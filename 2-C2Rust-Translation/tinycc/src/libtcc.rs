use ::libc;
use ::c2rust_bitfields;
use ::f128;
use ::num_traits;
use num_traits::ToPrimitive;
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn strtof(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_float;
    fn strtold(_: *const libc::c_char, _: *mut *mut libc::c_char) -> f128::f128;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn strtoul(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulong;
    fn strtoull(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_ulonglong;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
    fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fdopen(__fd: libc::c_int, __modes: *const libc::c_char) -> *mut FILE;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn vfprintf(
        _: *mut FILE,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> libc::c_int;
    fn snprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ...
    ) -> libc::c_int;
    fn vsnprintf(
        _: *mut libc::c_char,
        _: libc::c_ulong,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strncpy(
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> *mut libc::c_char;
    fn strcat(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strrchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn strerror(_: libc::c_int) -> *mut libc::c_char;
    fn __errno_location() -> *mut libc::c_int;
    fn ldexp(_: libc::c_double, _: libc::c_int) -> libc::c_double;
    fn open(__file: *const libc::c_char, __oflag: libc::c_int, _: ...) -> libc::c_int;
    fn _setjmp(_: *mut __jmp_buf_tag) -> libc::c_int;
    fn longjmp(_: *mut __jmp_buf_tag, _: libc::c_int) -> !;
    fn time(__timer: *mut time_t) -> time_t;
    fn localtime(__timer: *const time_t) -> *mut tm;
    fn lseek(__fd: libc::c_int, __offset: __off_t, __whence: libc::c_int) -> __off_t;
    fn close(__fd: libc::c_int) -> libc::c_int;
    fn read(__fd: libc::c_int, __buf: *mut libc::c_void, __nbytes: size_t) -> ssize_t;
    fn getcwd(__buf: *mut libc::c_char, __size: size_t) -> *mut libc::c_char;
    static mut environ: *mut *mut libc::c_char;
    fn sysconf(__name: libc::c_int) -> libc::c_long;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn dlopen(__file: *const libc::c_char, __mode: libc::c_int) -> *mut libc::c_void;
    fn dlclose(__handle: *mut libc::c_void) -> libc::c_int;
    fn dlsym(
        __handle: *mut libc::c_void,
        __name: *const libc::c_char,
    ) -> *mut libc::c_void;
    fn sem_init(
        __sem: *mut sem_t,
        __pshared: libc::c_int,
        __value: libc::c_uint,
    ) -> libc::c_int;
    fn sem_wait(__sem: *mut sem_t) -> libc::c_int;
    fn sem_post(__sem: *mut sem_t) -> libc::c_int;
    fn mprotect(
        __addr: *mut libc::c_void,
        __len: size_t,
        __prot: libc::c_int,
    ) -> libc::c_int;
    fn sigemptyset(__set: *mut sigset_t) -> libc::c_int;
    fn sigaddset(__set: *mut sigset_t, __signo: libc::c_int) -> libc::c_int;
    fn sigprocmask(
        __how: libc::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> libc::c_int;
    fn sigaction(
        __sig: libc::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> libc::c_int;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type va_list = __builtin_va_list;
pub type size_t = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __clock_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
pub type int8_t = __int8_t;
pub type int32_t = __int32_t;
pub type int64_t = __int64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16],
}
pub type sigset_t = __sigset_t;
pub type __compar_fn_t = Option::<
    unsafe extern "C" fn(*const libc::c_void, *const libc::c_void) -> libc::c_int,
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type __jmp_buf = [libc::c_long; 8];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
    pub __saved_mask: __sigset_t,
}
pub type jmp_buf = [__jmp_buf_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
pub type __sigval_t = sigval;
#[derive(Copy, Clone)]
#[repr(C)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
}
pub type C2RustUnnamed = libc::c_uint;
pub const _SC_SIGSTKSZ: C2RustUnnamed = 250;
pub const _SC_MINSIGSTKSZ: C2RustUnnamed = 249;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: C2RustUnnamed = 248;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: C2RustUnnamed = 247;
pub const _SC_XOPEN_STREAMS: C2RustUnnamed = 246;
pub const _SC_TRACE_USER_EVENT_MAX: C2RustUnnamed = 245;
pub const _SC_TRACE_SYS_MAX: C2RustUnnamed = 244;
pub const _SC_TRACE_NAME_MAX: C2RustUnnamed = 243;
pub const _SC_TRACE_EVENT_NAME_MAX: C2RustUnnamed = 242;
pub const _SC_SS_REPL_MAX: C2RustUnnamed = 241;
pub const _SC_V7_LPBIG_OFFBIG: C2RustUnnamed = 240;
pub const _SC_V7_LP64_OFF64: C2RustUnnamed = 239;
pub const _SC_V7_ILP32_OFFBIG: C2RustUnnamed = 238;
pub const _SC_V7_ILP32_OFF32: C2RustUnnamed = 237;
pub const _SC_RAW_SOCKETS: C2RustUnnamed = 236;
pub const _SC_IPV6: C2RustUnnamed = 235;
pub const _SC_LEVEL4_CACHE_LINESIZE: C2RustUnnamed = 199;
pub const _SC_LEVEL4_CACHE_ASSOC: C2RustUnnamed = 198;
pub const _SC_LEVEL4_CACHE_SIZE: C2RustUnnamed = 197;
pub const _SC_LEVEL3_CACHE_LINESIZE: C2RustUnnamed = 196;
pub const _SC_LEVEL3_CACHE_ASSOC: C2RustUnnamed = 195;
pub const _SC_LEVEL3_CACHE_SIZE: C2RustUnnamed = 194;
pub const _SC_LEVEL2_CACHE_LINESIZE: C2RustUnnamed = 193;
pub const _SC_LEVEL2_CACHE_ASSOC: C2RustUnnamed = 192;
pub const _SC_LEVEL2_CACHE_SIZE: C2RustUnnamed = 191;
pub const _SC_LEVEL1_DCACHE_LINESIZE: C2RustUnnamed = 190;
pub const _SC_LEVEL1_DCACHE_ASSOC: C2RustUnnamed = 189;
pub const _SC_LEVEL1_DCACHE_SIZE: C2RustUnnamed = 188;
pub const _SC_LEVEL1_ICACHE_LINESIZE: C2RustUnnamed = 187;
pub const _SC_LEVEL1_ICACHE_ASSOC: C2RustUnnamed = 186;
pub const _SC_LEVEL1_ICACHE_SIZE: C2RustUnnamed = 185;
pub const _SC_TRACE_LOG: C2RustUnnamed = 184;
pub const _SC_TRACE_INHERIT: C2RustUnnamed = 183;
pub const _SC_TRACE_EVENT_FILTER: C2RustUnnamed = 182;
pub const _SC_TRACE: C2RustUnnamed = 181;
pub const _SC_HOST_NAME_MAX: C2RustUnnamed = 180;
pub const _SC_V6_LPBIG_OFFBIG: C2RustUnnamed = 179;
pub const _SC_V6_LP64_OFF64: C2RustUnnamed = 178;
pub const _SC_V6_ILP32_OFFBIG: C2RustUnnamed = 177;
pub const _SC_V6_ILP32_OFF32: C2RustUnnamed = 176;
pub const _SC_2_PBS_CHECKPOINT: C2RustUnnamed = 175;
pub const _SC_STREAMS: C2RustUnnamed = 174;
pub const _SC_SYMLOOP_MAX: C2RustUnnamed = 173;
pub const _SC_2_PBS_TRACK: C2RustUnnamed = 172;
pub const _SC_2_PBS_MESSAGE: C2RustUnnamed = 171;
pub const _SC_2_PBS_LOCATE: C2RustUnnamed = 170;
pub const _SC_2_PBS_ACCOUNTING: C2RustUnnamed = 169;
pub const _SC_2_PBS: C2RustUnnamed = 168;
pub const _SC_USER_GROUPS_R: C2RustUnnamed = 167;
pub const _SC_USER_GROUPS: C2RustUnnamed = 166;
pub const _SC_TYPED_MEMORY_OBJECTS: C2RustUnnamed = 165;
pub const _SC_TIMEOUTS: C2RustUnnamed = 164;
pub const _SC_SYSTEM_DATABASE_R: C2RustUnnamed = 163;
pub const _SC_SYSTEM_DATABASE: C2RustUnnamed = 162;
pub const _SC_THREAD_SPORADIC_SERVER: C2RustUnnamed = 161;
pub const _SC_SPORADIC_SERVER: C2RustUnnamed = 160;
pub const _SC_SPAWN: C2RustUnnamed = 159;
pub const _SC_SIGNALS: C2RustUnnamed = 158;
pub const _SC_SHELL: C2RustUnnamed = 157;
pub const _SC_REGEX_VERSION: C2RustUnnamed = 156;
pub const _SC_REGEXP: C2RustUnnamed = 155;
pub const _SC_SPIN_LOCKS: C2RustUnnamed = 154;
pub const _SC_READER_WRITER_LOCKS: C2RustUnnamed = 153;
pub const _SC_NETWORKING: C2RustUnnamed = 152;
pub const _SC_SINGLE_PROCESS: C2RustUnnamed = 151;
pub const _SC_MULTI_PROCESS: C2RustUnnamed = 150;
pub const _SC_MONOTONIC_CLOCK: C2RustUnnamed = 149;
pub const _SC_FILE_SYSTEM: C2RustUnnamed = 148;
pub const _SC_FILE_LOCKING: C2RustUnnamed = 147;
pub const _SC_FILE_ATTRIBUTES: C2RustUnnamed = 146;
pub const _SC_PIPE: C2RustUnnamed = 145;
pub const _SC_FIFO: C2RustUnnamed = 144;
pub const _SC_FD_MGMT: C2RustUnnamed = 143;
pub const _SC_DEVICE_SPECIFIC_R: C2RustUnnamed = 142;
pub const _SC_DEVICE_SPECIFIC: C2RustUnnamed = 141;
pub const _SC_DEVICE_IO: C2RustUnnamed = 140;
pub const _SC_THREAD_CPUTIME: C2RustUnnamed = 139;
pub const _SC_CPUTIME: C2RustUnnamed = 138;
pub const _SC_CLOCK_SELECTION: C2RustUnnamed = 137;
pub const _SC_C_LANG_SUPPORT_R: C2RustUnnamed = 136;
pub const _SC_C_LANG_SUPPORT: C2RustUnnamed = 135;
pub const _SC_BASE: C2RustUnnamed = 134;
pub const _SC_BARRIERS: C2RustUnnamed = 133;
pub const _SC_ADVISORY_INFO: C2RustUnnamed = 132;
pub const _SC_XOPEN_REALTIME_THREADS: C2RustUnnamed = 131;
pub const _SC_XOPEN_REALTIME: C2RustUnnamed = 130;
pub const _SC_XOPEN_LEGACY: C2RustUnnamed = 129;
pub const _SC_XBS5_LPBIG_OFFBIG: C2RustUnnamed = 128;
pub const _SC_XBS5_LP64_OFF64: C2RustUnnamed = 127;
pub const _SC_XBS5_ILP32_OFFBIG: C2RustUnnamed = 126;
pub const _SC_XBS5_ILP32_OFF32: C2RustUnnamed = 125;
pub const _SC_NL_TEXTMAX: C2RustUnnamed = 124;
pub const _SC_NL_SETMAX: C2RustUnnamed = 123;
pub const _SC_NL_NMAX: C2RustUnnamed = 122;
pub const _SC_NL_MSGMAX: C2RustUnnamed = 121;
pub const _SC_NL_LANGMAX: C2RustUnnamed = 120;
pub const _SC_NL_ARGMAX: C2RustUnnamed = 119;
pub const _SC_USHRT_MAX: C2RustUnnamed = 118;
pub const _SC_ULONG_MAX: C2RustUnnamed = 117;
pub const _SC_UINT_MAX: C2RustUnnamed = 116;
pub const _SC_UCHAR_MAX: C2RustUnnamed = 115;
pub const _SC_SHRT_MIN: C2RustUnnamed = 114;
pub const _SC_SHRT_MAX: C2RustUnnamed = 113;
pub const _SC_SCHAR_MIN: C2RustUnnamed = 112;
pub const _SC_SCHAR_MAX: C2RustUnnamed = 111;
pub const _SC_SSIZE_MAX: C2RustUnnamed = 110;
pub const _SC_NZERO: C2RustUnnamed = 109;
pub const _SC_MB_LEN_MAX: C2RustUnnamed = 108;
pub const _SC_WORD_BIT: C2RustUnnamed = 107;
pub const _SC_LONG_BIT: C2RustUnnamed = 106;
pub const _SC_INT_MIN: C2RustUnnamed = 105;
pub const _SC_INT_MAX: C2RustUnnamed = 104;
pub const _SC_CHAR_MIN: C2RustUnnamed = 103;
pub const _SC_CHAR_MAX: C2RustUnnamed = 102;
pub const _SC_CHAR_BIT: C2RustUnnamed = 101;
pub const _SC_XOPEN_XPG4: C2RustUnnamed = 100;
pub const _SC_XOPEN_XPG3: C2RustUnnamed = 99;
pub const _SC_XOPEN_XPG2: C2RustUnnamed = 98;
pub const _SC_2_UPE: C2RustUnnamed = 97;
pub const _SC_2_C_VERSION: C2RustUnnamed = 96;
pub const _SC_2_CHAR_TERM: C2RustUnnamed = 95;
pub const _SC_XOPEN_SHM: C2RustUnnamed = 94;
pub const _SC_XOPEN_ENH_I18N: C2RustUnnamed = 93;
pub const _SC_XOPEN_CRYPT: C2RustUnnamed = 92;
pub const _SC_XOPEN_UNIX: C2RustUnnamed = 91;
pub const _SC_XOPEN_XCU_VERSION: C2RustUnnamed = 90;
pub const _SC_XOPEN_VERSION: C2RustUnnamed = 89;
pub const _SC_PASS_MAX: C2RustUnnamed = 88;
pub const _SC_ATEXIT_MAX: C2RustUnnamed = 87;
pub const _SC_AVPHYS_PAGES: C2RustUnnamed = 86;
pub const _SC_PHYS_PAGES: C2RustUnnamed = 85;
pub const _SC_NPROCESSORS_ONLN: C2RustUnnamed = 84;
pub const _SC_NPROCESSORS_CONF: C2RustUnnamed = 83;
pub const _SC_THREAD_PROCESS_SHARED: C2RustUnnamed = 82;
pub const _SC_THREAD_PRIO_PROTECT: C2RustUnnamed = 81;
pub const _SC_THREAD_PRIO_INHERIT: C2RustUnnamed = 80;
pub const _SC_THREAD_PRIORITY_SCHEDULING: C2RustUnnamed = 79;
pub const _SC_THREAD_ATTR_STACKSIZE: C2RustUnnamed = 78;
pub const _SC_THREAD_ATTR_STACKADDR: C2RustUnnamed = 77;
pub const _SC_THREAD_THREADS_MAX: C2RustUnnamed = 76;
pub const _SC_THREAD_STACK_MIN: C2RustUnnamed = 75;
pub const _SC_THREAD_KEYS_MAX: C2RustUnnamed = 74;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: C2RustUnnamed = 73;
pub const _SC_TTY_NAME_MAX: C2RustUnnamed = 72;
pub const _SC_LOGIN_NAME_MAX: C2RustUnnamed = 71;
pub const _SC_GETPW_R_SIZE_MAX: C2RustUnnamed = 70;
pub const _SC_GETGR_R_SIZE_MAX: C2RustUnnamed = 69;
pub const _SC_THREAD_SAFE_FUNCTIONS: C2RustUnnamed = 68;
pub const _SC_THREADS: C2RustUnnamed = 67;
pub const _SC_T_IOV_MAX: C2RustUnnamed = 66;
pub const _SC_PII_OSI_M: C2RustUnnamed = 65;
pub const _SC_PII_OSI_CLTS: C2RustUnnamed = 64;
pub const _SC_PII_OSI_COTS: C2RustUnnamed = 63;
pub const _SC_PII_INTERNET_DGRAM: C2RustUnnamed = 62;
pub const _SC_PII_INTERNET_STREAM: C2RustUnnamed = 61;
pub const _SC_IOV_MAX: C2RustUnnamed = 60;
pub const _SC_UIO_MAXIOV: C2RustUnnamed = 60;
pub const _SC_SELECT: C2RustUnnamed = 59;
pub const _SC_POLL: C2RustUnnamed = 58;
pub const _SC_PII_OSI: C2RustUnnamed = 57;
pub const _SC_PII_INTERNET: C2RustUnnamed = 56;
pub const _SC_PII_SOCKET: C2RustUnnamed = 55;
pub const _SC_PII_XTI: C2RustUnnamed = 54;
pub const _SC_PII: C2RustUnnamed = 53;
pub const _SC_2_LOCALEDEF: C2RustUnnamed = 52;
pub const _SC_2_SW_DEV: C2RustUnnamed = 51;
pub const _SC_2_FORT_RUN: C2RustUnnamed = 50;
pub const _SC_2_FORT_DEV: C2RustUnnamed = 49;
pub const _SC_2_C_DEV: C2RustUnnamed = 48;
pub const _SC_2_C_BIND: C2RustUnnamed = 47;
pub const _SC_2_VERSION: C2RustUnnamed = 46;
pub const _SC_CHARCLASS_NAME_MAX: C2RustUnnamed = 45;
pub const _SC_RE_DUP_MAX: C2RustUnnamed = 44;
pub const _SC_LINE_MAX: C2RustUnnamed = 43;
pub const _SC_EXPR_NEST_MAX: C2RustUnnamed = 42;
pub const _SC_EQUIV_CLASS_MAX: C2RustUnnamed = 41;
pub const _SC_COLL_WEIGHTS_MAX: C2RustUnnamed = 40;
pub const _SC_BC_STRING_MAX: C2RustUnnamed = 39;
pub const _SC_BC_SCALE_MAX: C2RustUnnamed = 38;
pub const _SC_BC_DIM_MAX: C2RustUnnamed = 37;
pub const _SC_BC_BASE_MAX: C2RustUnnamed = 36;
pub const _SC_TIMER_MAX: C2RustUnnamed = 35;
pub const _SC_SIGQUEUE_MAX: C2RustUnnamed = 34;
pub const _SC_SEM_VALUE_MAX: C2RustUnnamed = 33;
pub const _SC_SEM_NSEMS_MAX: C2RustUnnamed = 32;
pub const _SC_RTSIG_MAX: C2RustUnnamed = 31;
pub const _SC_PAGESIZE: C2RustUnnamed = 30;
pub const _SC_VERSION: C2RustUnnamed = 29;
pub const _SC_MQ_PRIO_MAX: C2RustUnnamed = 28;
pub const _SC_MQ_OPEN_MAX: C2RustUnnamed = 27;
pub const _SC_DELAYTIMER_MAX: C2RustUnnamed = 26;
pub const _SC_AIO_PRIO_DELTA_MAX: C2RustUnnamed = 25;
pub const _SC_AIO_MAX: C2RustUnnamed = 24;
pub const _SC_AIO_LISTIO_MAX: C2RustUnnamed = 23;
pub const _SC_SHARED_MEMORY_OBJECTS: C2RustUnnamed = 22;
pub const _SC_SEMAPHORES: C2RustUnnamed = 21;
pub const _SC_MESSAGE_PASSING: C2RustUnnamed = 20;
pub const _SC_MEMORY_PROTECTION: C2RustUnnamed = 19;
pub const _SC_MEMLOCK_RANGE: C2RustUnnamed = 18;
pub const _SC_MEMLOCK: C2RustUnnamed = 17;
pub const _SC_MAPPED_FILES: C2RustUnnamed = 16;
pub const _SC_FSYNC: C2RustUnnamed = 15;
pub const _SC_SYNCHRONIZED_IO: C2RustUnnamed = 14;
pub const _SC_PRIORITIZED_IO: C2RustUnnamed = 13;
pub const _SC_ASYNCHRONOUS_IO: C2RustUnnamed = 12;
pub const _SC_TIMERS: C2RustUnnamed = 11;
pub const _SC_PRIORITY_SCHEDULING: C2RustUnnamed = 10;
pub const _SC_REALTIME_SIGNALS: C2RustUnnamed = 9;
pub const _SC_SAVED_IDS: C2RustUnnamed = 8;
pub const _SC_JOB_CONTROL: C2RustUnnamed = 7;
pub const _SC_TZNAME_MAX: C2RustUnnamed = 6;
pub const _SC_STREAM_MAX: C2RustUnnamed = 5;
pub const _SC_OPEN_MAX: C2RustUnnamed = 4;
pub const _SC_NGROUPS_MAX: C2RustUnnamed = 3;
pub const _SC_CLK_TCK: C2RustUnnamed = 2;
pub const _SC_CHILD_MAX: C2RustUnnamed = 1;
pub const _SC_ARG_MAX: C2RustUnnamed = 0;
pub type TCCReallocFunc = unsafe extern "C" fn(
    *mut libc::c_void,
    libc::c_ulong,
) -> *mut libc::c_void;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TCCState {
    pub verbose: libc::c_uchar,
    pub nostdinc: libc::c_uchar,
    pub nostdlib: libc::c_uchar,
    pub nostdlib_paths: libc::c_uchar,
    pub nocommon: libc::c_uchar,
    pub static_link: libc::c_uchar,
    pub rdynamic: libc::c_uchar,
    pub symbolic: libc::c_uchar,
    pub filetype: libc::c_uchar,
    pub optimize: libc::c_uchar,
    pub option_pthread: libc::c_uchar,
    pub enable_new_dtags: libc::c_uchar,
    pub cversion: libc::c_uint,
    pub char_is_unsigned: libc::c_uchar,
    pub leading_underscore: libc::c_uchar,
    pub ms_extensions: libc::c_uchar,
    pub dollars_in_identifiers: libc::c_uchar,
    pub ms_bitfields: libc::c_uchar,
    pub reverse_funcargs: libc::c_uchar,
    pub gnu89_inline: libc::c_uchar,
    pub unwind_tables: libc::c_uchar,
    pub warn_none: libc::c_uchar,
    pub warn_all: libc::c_uchar,
    pub warn_error: libc::c_uchar,
    pub warn_write_strings: libc::c_uchar,
    pub warn_unsupported: libc::c_uchar,
    pub warn_implicit_function_declaration: libc::c_uchar,
    pub warn_discarded_qualifiers: libc::c_uchar,
    pub warn_num: libc::c_uchar,
    pub option_r: libc::c_uchar,
    pub do_bench: libc::c_uchar,
    pub just_deps: libc::c_uchar,
    pub gen_deps: libc::c_uchar,
    pub include_sys_deps: libc::c_uchar,
    pub gen_phony_deps: libc::c_uchar,
    pub do_debug: libc::c_uchar,
    pub dwarf: libc::c_uchar,
    pub do_backtrace: libc::c_uchar,
    pub do_bounds_check: libc::c_uchar,
    pub test_coverage: libc::c_uchar,
    pub gnu_ext: libc::c_uchar,
    pub tcc_ext: libc::c_uchar,
    pub dflag: libc::c_uchar,
    pub Pflag: libc::c_uchar,
    pub nosse: libc::c_uchar,
    pub has_text_addr: libc::c_uchar,
    pub text_addr: Elf64_Addr,
    pub section_align: libc::c_uint,
    pub tcc_lib_path: *mut libc::c_char,
    pub soname: *mut libc::c_char,
    pub rpath: *mut libc::c_char,
    pub elfint: *mut libc::c_char,
    pub elf_entryname: *mut libc::c_char,
    pub init_symbol: *mut libc::c_char,
    pub fini_symbol: *mut libc::c_char,
    pub mapfile: *mut libc::c_char,
    pub output_type: libc::c_int,
    pub output_format: libc::c_int,
    pub run_test: libc::c_int,
    pub loaded_dlls: *mut *mut DLLReference,
    pub nb_loaded_dlls: libc::c_int,
    pub include_paths: *mut *mut libc::c_char,
    pub nb_include_paths: libc::c_int,
    pub sysinclude_paths: *mut *mut libc::c_char,
    pub nb_sysinclude_paths: libc::c_int,
    pub library_paths: *mut *mut libc::c_char,
    pub nb_library_paths: libc::c_int,
    pub crt_paths: *mut *mut libc::c_char,
    pub nb_crt_paths: libc::c_int,
    pub cmdline_defs: CString,
    pub cmdline_incl: CString,
    pub error_opaque: *mut libc::c_void,
    pub error_func: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> (),
    >,
    pub error_set_jmp_enabled: libc::c_int,
    pub error_jmp_buf: jmp_buf,
    pub nb_errors: libc::c_int,
    pub ppfp: *mut FILE,
    pub target_deps: *mut *mut libc::c_char,
    pub nb_target_deps: libc::c_int,
    pub include_stack: [*mut BufferedFile; 32],
    pub include_stack_ptr: *mut *mut BufferedFile,
    pub ifdef_stack: [libc::c_int; 64],
    pub ifdef_stack_ptr: *mut libc::c_int,
    pub cached_includes_hash: [libc::c_int; 32],
    pub cached_includes: *mut *mut CachedInclude,
    pub nb_cached_includes: libc::c_int,
    pub pack_stack: [libc::c_int; 8],
    pub pack_stack_ptr: *mut libc::c_int,
    pub pragma_libs: *mut *mut libc::c_char,
    pub nb_pragma_libs: libc::c_int,
    pub inline_fns: *mut *mut InlineFunc,
    pub nb_inline_fns: libc::c_int,
    pub sections: *mut *mut Section,
    pub nb_sections: libc::c_int,
    pub priv_sections: *mut *mut Section,
    pub nb_priv_sections: libc::c_int,
    pub text_section: *mut Section,
    pub data_section: *mut Section,
    pub rodata_section: *mut Section,
    pub bss_section: *mut Section,
    pub common_section: *mut Section,
    pub cur_text_section: *mut Section,
    pub bounds_section: *mut Section,
    pub lbounds_section: *mut Section,
    pub c2rust_unnamed: C2RustUnnamed_11,
    pub dynsymtab_section: *mut Section,
    pub dynsym: *mut Section,
    pub got: *mut Section,
    pub plt: *mut Section,
    pub eh_frame_section: *mut Section,
    pub eh_frame_hdr_section: *mut Section,
    pub eh_start: libc::c_ulong,
    pub stab_section: *mut Section,
    pub dwarf_info_section: *mut Section,
    pub dwarf_abbrev_section: *mut Section,
    pub dwarf_line_section: *mut Section,
    pub dwarf_aranges_section: *mut Section,
    pub dwarf_str_section: *mut Section,
    pub dwarf_line_str_section: *mut Section,
    pub dwlo: libc::c_int,
    pub dwhi: libc::c_int,
    pub tcov_section: *mut Section,
    pub dState: *mut _tccdbg,
    pub sym_attrs: *mut sym_attr,
    pub nb_sym_attrs: libc::c_int,
    pub qrel: *mut Elf64_Rela,
    pub nb_sym_versions: libc::c_int,
    pub sym_versions: *mut sym_version,
    pub nb_sym_to_version: libc::c_int,
    pub sym_to_version: *mut libc::c_int,
    pub dt_verneednum: libc::c_int,
    pub versym_section: *mut Section,
    pub verneed_section: *mut Section,
    pub run_main: *const libc::c_char,
    pub run_ptr: *mut libc::c_void,
    pub run_size: libc::c_uint,
    pub next: *mut TCCState,
    pub rc: *mut rt_context,
    pub run_lj: *mut libc::c_void,
    pub run_jb: *mut libc::c_void,
    pub bt_func: Option::<TCCBtFunc>,
    pub bt_data: *mut libc::c_void,
    pub rt_num_callers: libc::c_int,
    pub total_idents: libc::c_int,
    pub total_lines: libc::c_int,
    pub total_bytes: libc::c_uint,
    pub total_output: [libc::c_uint; 4],
    pub ld_p: *mut libc::c_uchar,
    pub current_filename: *const libc::c_char,
    pub files: *mut *mut filespec,
    pub nb_files: libc::c_int,
    pub nb_libraries: libc::c_int,
    pub outfile: *mut libc::c_char,
    pub deps_outfile: *mut libc::c_char,
    pub argc: libc::c_int,
    pub argv: *mut *mut libc::c_char,
    pub link_argv: *mut *mut libc::c_char,
    pub link_argc: libc::c_int,
    pub link_optind: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct filespec {
    pub type_0: libc::c_char,
    pub name: [libc::c_char; 1],
}
pub type TCCBtFunc = unsafe extern "C" fn(
    *mut libc::c_void,
    *mut libc::c_void,
    *const libc::c_char,
    libc::c_int,
    *const libc::c_char,
    *const libc::c_char,
) -> libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rt_context {
    pub c2rust_unnamed: C2RustUnnamed_0,
    pub esym_start: *mut Elf64_Sym,
    pub esym_end: *mut Elf64_Sym,
    pub elf_str: *mut libc::c_char,
    pub prog_base: Elf64_Addr,
    pub bounds_start: *mut libc::c_void,
    pub top_func: *mut libc::c_void,
    pub next: *mut rt_context,
    pub num_callers: libc::c_int,
    pub dwarf: libc::c_int,
}
pub type Elf64_Addr = uint64_t;
pub type uint64_t = __uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Sym {
    pub st_name: Elf64_Word,
    pub st_info: libc::c_uchar,
    pub st_other: libc::c_uchar,
    pub st_shndx: Elf64_Section,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Xword = uint64_t;
pub type Elf64_Section = uint16_t;
pub type uint16_t = __uint16_t;
pub type Elf64_Word = uint32_t;
pub type uint32_t = __uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub c2rust_unnamed: C2RustUnnamed_2,
    pub c2rust_unnamed_0: C2RustUnnamed_1,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_1 {
    pub dwarf_line: *mut libc::c_uchar,
    pub dwarf_line_end: *mut libc::c_uchar,
    pub dwarf_line_str: *mut libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_2 {
    pub stab_sym: *mut Stab_Sym,
    pub stab_sym_end: *mut Stab_Sym,
    pub stab_str: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Stab_Sym {
    pub n_strx: libc::c_uint,
    pub n_type: libc::c_uchar,
    pub n_other: libc::c_uchar,
    pub n_desc: libc::c_ushort,
    pub n_value: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Section {
    pub data_offset: libc::c_ulong,
    pub data: *mut libc::c_uchar,
    pub data_allocated: libc::c_ulong,
    pub s1: *mut TCCState,
    pub sh_name: libc::c_int,
    pub sh_num: libc::c_int,
    pub sh_type: libc::c_int,
    pub sh_flags: libc::c_int,
    pub sh_info: libc::c_int,
    pub sh_addralign: libc::c_int,
    pub sh_entsize: libc::c_int,
    pub sh_size: libc::c_ulong,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: libc::c_ulong,
    pub nb_hashed_syms: libc::c_int,
    pub link: *mut Section,
    pub reloc: *mut Section,
    pub hash: *mut Section,
    pub prev: *mut Section,
    pub name: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sym_version {
    pub lib: *mut libc::c_char,
    pub version: *mut libc::c_char,
    pub out_index: libc::c_int,
    pub prev_same_lib: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Rela {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
    pub r_addend: Elf64_Sxword,
}
pub type Elf64_Sxword = int64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sym_attr {
    pub got_offset: libc::c_uint,
    pub plt_offset: libc::c_uint,
    pub plt_sym: libc::c_int,
    pub dyn_index: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _tccdbg {
    pub last_line_num: libc::c_int,
    pub new_file: libc::c_int,
    pub section_sym: libc::c_int,
    pub debug_next_type: libc::c_int,
    pub debug_hash: *mut _debug_hash,
    pub debug_anon_hash: *mut _debug_anon_hash,
    pub n_debug_hash: libc::c_int,
    pub n_debug_anon_hash: libc::c_int,
    pub debug_info: *mut _debug_info,
    pub debug_info_root: *mut _debug_info,
    pub dwarf_sym: C2RustUnnamed_10,
    pub dwarf_line: C2RustUnnamed_9,
    pub dwarf_info: C2RustUnnamed_4,
    pub tcov_data: C2RustUnnamed_3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_3 {
    pub offset: libc::c_ulong,
    pub last_file_name: libc::c_ulong,
    pub last_func_name: libc::c_ulong,
    pub ind: libc::c_int,
    pub line: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_4 {
    pub start: libc::c_int,
    pub func: *mut Sym,
    pub line: libc::c_int,
    pub base_type_used: [libc::c_int; 29],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Sym {
    pub v: libc::c_int,
    pub r: libc::c_ushort,
    pub a: SymAttr,
    pub c2rust_unnamed: C2RustUnnamed_6,
    pub type_0: CType,
    pub c2rust_unnamed_0: C2RustUnnamed_5,
    pub prev: *mut Sym,
    pub prev_tok: *mut Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub next: *mut Sym,
    pub e: *mut libc::c_int,
    pub asm_label: libc::c_int,
    pub cleanupstate: *mut Sym,
    pub vla_array_str: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CType {
    pub t: libc::c_int,
    pub ref_0: *mut Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub c2rust_unnamed: C2RustUnnamed_7,
    pub enum_val: libc::c_longlong,
    pub d: *mut libc::c_int,
    pub cleanup_func: *mut Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_7 {
    pub c: libc::c_int,
    pub c2rust_unnamed: C2RustUnnamed_8,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub sym_scope: libc::c_int,
    pub jnext: libc::c_int,
    pub jind: libc::c_int,
    pub f: FuncAttr,
    pub auxtype: libc::c_int,
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct FuncAttr {
    #[bitfield(name = "func_call", ty = "libc::c_uint", bits = "0..=2")]
    #[bitfield(name = "func_type", ty = "libc::c_uint", bits = "3..=4")]
    #[bitfield(name = "func_noreturn", ty = "libc::c_uint", bits = "5..=5")]
    #[bitfield(name = "func_ctor", ty = "libc::c_uint", bits = "6..=6")]
    #[bitfield(name = "func_dtor", ty = "libc::c_uint", bits = "7..=7")]
    #[bitfield(name = "func_args", ty = "libc::c_uint", bits = "8..=15")]
    #[bitfield(name = "func_alwinl", ty = "libc::c_uint", bits = "16..=16")]
    #[bitfield(name = "xxxx", ty = "libc::c_uint", bits = "17..=31")]
    pub func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [u8; 4],
}
#[derive(Copy, Clone, BitfieldStruct)]
#[repr(C)]
pub struct SymAttr {
    #[bitfield(name = "aligned", ty = "libc::c_ushort", bits = "0..=4")]
    #[bitfield(name = "packed", ty = "libc::c_ushort", bits = "5..=5")]
    #[bitfield(name = "weak", ty = "libc::c_ushort", bits = "6..=6")]
    #[bitfield(name = "visibility", ty = "libc::c_ushort", bits = "7..=8")]
    #[bitfield(name = "dllexport", ty = "libc::c_ushort", bits = "9..=9")]
    #[bitfield(name = "nodecorate", ty = "libc::c_ushort", bits = "10..=10")]
    #[bitfield(name = "dllimport", ty = "libc::c_ushort", bits = "11..=11")]
    #[bitfield(name = "addrtaken", ty = "libc::c_ushort", bits = "12..=12")]
    #[bitfield(name = "nodebug", ty = "libc::c_ushort", bits = "13..=13")]
    #[bitfield(name = "xxxx", ty = "libc::c_ushort", bits = "14..=15")]
    pub aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [u8; 2],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_9 {
    pub start: libc::c_int,
    pub dir_size: libc::c_int,
    pub dir_table: *mut *mut libc::c_char,
    pub filename_size: libc::c_int,
    pub filename_table: *mut dwarf_filename_struct,
    pub line_size: libc::c_int,
    pub line_max_size: libc::c_int,
    pub line_data: *mut libc::c_uchar,
    pub cur_file: libc::c_int,
    pub last_file: libc::c_int,
    pub last_pc: libc::c_int,
    pub last_line: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dwarf_filename_struct {
    pub dir_entry: libc::c_int,
    pub name: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_10 {
    pub info: libc::c_int,
    pub abbrev: libc::c_int,
    pub line: libc::c_int,
    pub str_0: libc::c_int,
    pub line_str: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _debug_info {
    pub start: libc::c_int,
    pub end: libc::c_int,
    pub n_sym: libc::c_int,
    pub sym: *mut debug_sym,
    pub child: *mut _debug_info,
    pub next: *mut _debug_info,
    pub last: *mut _debug_info,
    pub parent: *mut _debug_info,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct debug_sym {
    pub type_0: libc::c_int,
    pub value: libc::c_ulong,
    pub str_0: *mut libc::c_char,
    pub sec: *mut Section,
    pub sym_index: libc::c_int,
    pub info: libc::c_int,
    pub file: libc::c_int,
    pub line: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _debug_anon_hash {
    pub type_0: *mut Sym,
    pub n_debug_type: libc::c_int,
    pub debug_type: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _debug_hash {
    pub debug_type: libc::c_int,
    pub type_0: *mut Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub symtab_section: *mut Section,
    pub symtab: *mut Section,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct InlineFunc {
    pub func_str: *mut TokenString,
    pub sym: *mut Sym,
    pub filename: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TokenString {
    pub str_0: *mut libc::c_int,
    pub len: libc::c_int,
    pub need_spc: libc::c_int,
    pub allocated_len: libc::c_int,
    pub last_line_num: libc::c_int,
    pub save_line_num: libc::c_int,
    pub prev: *mut TokenString,
    pub prev_ptr: *const libc::c_int,
    pub alloc: libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CachedInclude {
    pub ifndef_macro: libc::c_int,
    pub once: libc::c_int,
    pub hash_next: libc::c_int,
    pub filename: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct BufferedFile {
    pub buf_ptr: *mut uint8_t,
    pub buf_end: *mut uint8_t,
    pub fd: libc::c_int,
    pub prev: *mut BufferedFile,
    pub line_num: libc::c_int,
    pub line_ref: libc::c_int,
    pub ifndef_macro: libc::c_int,
    pub ifndef_macro_saved: libc::c_int,
    pub ifdef_stack_ptr: *mut libc::c_int,
    pub include_next_index: libc::c_int,
    pub prev_tok_flags: libc::c_int,
    pub filename: [libc::c_char; 1024],
    pub true_filename: *mut libc::c_char,
    pub unget: [libc::c_uchar; 4],
    pub buffer: [libc::c_uchar; 1],
}
pub type uint8_t = __uint8_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct CString {
    pub size: libc::c_int,
    pub size_allocated: libc::c_int,
    pub data: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DLLReference {
    pub level: libc::c_int,
    pub handle: *mut libc::c_void,
    pub found: libc::c_uchar,
    pub index: libc::c_uchar,
    pub name: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TCCSem {
    pub init: libc::c_int,
    pub sem: sem_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union sem_t {
    pub __size: [libc::c_char; 32],
    pub __align: libc::c_long,
}
pub type TCCErrorFunc = unsafe extern "C" fn(
    *mut libc::c_void,
    *const libc::c_char,
) -> ();
pub const ERROR_NOABORT: C2RustUnnamed_54 = 1;
pub const ERROR_ERROR: C2RustUnnamed_54 = 2;
pub const ERROR_WARN: C2RustUnnamed_54 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union CValue {
    pub ld: f128::f128,
    pub d: libc::c_double,
    pub f: libc::c_float,
    pub i: uint64_t,
    pub str_0: C2RustUnnamed_12,
    pub tab: [libc::c_int; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_12 {
    pub data: *mut libc::c_char,
    pub size: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TokenSym {
    pub hash_next: *mut TokenSym,
    pub sym_define: *mut Sym,
    pub sym_label: *mut Sym,
    pub sym_struct: *mut Sym,
    pub sym_identifier: *mut Sym,
    pub tok: libc::c_int,
    pub len: libc::c_int,
    pub str_0: [libc::c_char; 1],
}
pub type nwchar_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TinyAlloc {
    pub limit: libc::c_uint,
    pub size: libc::c_uint,
    pub buffer: *mut uint8_t,
    pub p: *mut uint8_t,
    pub nb_allocs: libc::c_uint,
    pub next: *mut TinyAlloc,
    pub top: *mut TinyAlloc,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct tal_header_t {
    pub size: libc::c_uint,
}
pub const TOK___DATE__: tcc_token = 335;
pub const TOK___TIME__: tcc_token = 336;
pub const TOK___FILE__: tcc_token = 334;
pub const TOK___LINE__: tcc_token = 333;
pub const TOK___COUNTER__: tcc_token = 339;
pub const TOK_DEFINED: tcc_token = 327;
pub const TOK_option: tcc_token = 426;
pub const TOK_lib: tcc_token = 422;
pub const TOK_comment: tcc_token = 421;
pub const TOK_ASM_push: tcc_token = 732;
pub const TOK_ASM_pop: tcc_token = 736;
pub const TOK_pack: tcc_token = 420;
pub const TOK_PRAGMA: tcc_token = 332;
pub const TOK_once: tcc_token = 425;
pub const TOK_push_macro: tcc_token = 423;
pub const TOK_pop_macro: tcc_token = 424;
pub const TOK_ERROR: tcc_token = 329;
pub const TOK_WARNING: tcc_token = 330;
pub const TOK_LINE: tcc_token = 331;
pub const TOK_ENDIF: tcc_token = 326;
pub const TOK_IFNDEF: tcc_token = 324;
pub const TOK_IFDEF: tcc_token = 323;
pub const TOK_IF: tcc_token = 256;
pub const TOK_ELIF: tcc_token = 325;
pub const TOK_ELSE: tcc_token = 257;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SValue {
    pub type_0: CType,
    pub r: libc::c_ushort,
    pub r2: libc::c_ushort,
    pub c2rust_unnamed: C2RustUnnamed_15,
    pub c2rust_unnamed_0: C2RustUnnamed_13,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub c2rust_unnamed: C2RustUnnamed_14,
    pub sym: *mut Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub cmp_op: libc::c_ushort,
    pub cmp_r: libc::c_ushort,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub c2rust_unnamed: C2RustUnnamed_16,
    pub c: CValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub jtrue: libc::c_int,
    pub jfalse: libc::c_int,
}
pub const TREG_ST0: C2RustUnnamed_50 = 24;
pub const TREG_XMM7: C2RustUnnamed_50 = 23;
pub const TREG_XMM0: C2RustUnnamed_50 = 16;
pub const TREG_MEM: C2RustUnnamed_50 = 32;
pub const N_LCSYM: __stab_debug_code = 40;
pub const N_STSYM: __stab_debug_code = 38;
pub const N_SLINE: __stab_debug_code = 68;
pub const N_GSYM: __stab_debug_code = 32;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub type_0: libc::c_int,
    pub size: libc::c_int,
    pub encoding: libc::c_int,
    pub name: *const libc::c_char,
}
pub const DW_ATE_unsigned_char: C2RustUnnamed_43 = 8;
pub const DW_ATE_unsigned: C2RustUnnamed_43 = 7;
pub const DW_ATE_signed: C2RustUnnamed_43 = 5;
pub const DW_ATE_boolean: C2RustUnnamed_43 = 2;
pub const DW_ATE_float: C2RustUnnamed_43 = 4;
pub const DW_ATE_signed_char: C2RustUnnamed_43 = 6;
pub const N_LSYM: __stab_debug_code = 128;
pub const DW_OP_addr: C2RustUnnamed_42 = 3;
pub const N_SOL: __stab_debug_code = 132;
pub const TREG_R11: C2RustUnnamed_50 = 11;
pub const TREG_XMM1: C2RustUnnamed_50 = 17;
pub const TREG_RDX: C2RustUnnamed_50 = 2;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct temp_local_variable {
    pub location: libc::c_int,
    pub size: libc::c_short,
    pub align: libc::c_short,
}
pub const TREG_RAX: C2RustUnnamed_50 = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_18 {
    pub f: libc::c_float,
    pub u: libc::c_uint,
}
pub const TREG_R9: C2RustUnnamed_50 = 9;
pub const TREG_R8: C2RustUnnamed_50 = 8;
pub const TREG_RCX: C2RustUnnamed_50 = 1;
pub const TREG_RSI: C2RustUnnamed_50 = 6;
pub const TREG_RDI: C2RustUnnamed_50 = 7;
pub const x86_64_mode_integer: X86_64_Mode = 2;
pub type X86_64_Mode = libc::c_uint;
pub const x86_64_mode_x87: X86_64_Mode = 4;
pub const x86_64_mode_sse: X86_64_Mode = 3;
pub const x86_64_mode_memory: X86_64_Mode = 1;
pub const x86_64_mode_none: X86_64_Mode = 0;
pub const TOK___bound_ptr_indir16: tcc_token = 450;
pub const TOK___bound_ptr_indir12: tcc_token = 449;
pub const TOK___bound_ptr_indir8: tcc_token = 448;
pub const TOK___bound_ptr_indir4: tcc_token = 447;
pub const TOK___bound_ptr_indir2: tcc_token = 446;
pub const TOK___bound_ptr_indir1: tcc_token = 445;
pub const TOK___bound_ptr_add: tcc_token = 444;
pub const TOK_memmove: tcc_token = 428;
pub const TOK_alloca: tcc_token = 443;
pub const TOK___bound_setjmp: tcc_token = 454;
pub const TOK___sigsetjmp: tcc_token = 458;
pub const TOK_sigsetjmp: tcc_token = 457;
pub const TOK__setjmp: tcc_token = 461;
pub const TOK_setjmp: tcc_token = 460;
pub const TOK___fixunsdfdi: tcc_token = 442;
pub const TOK___fixunsxfdi: tcc_token = 440;
pub const TOK___fixunssfdi: tcc_token = 441;
pub const TOK___floatundidf: tcc_token = 438;
pub const TOK___floatundixf: tcc_token = 439;
pub const TOK___floatundisf: tcc_token = 437;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct init_params {
    pub sec: *mut Section,
    pub local_offset: libc::c_int,
    pub flex_array_ref: *mut Sym,
}
pub const TOK_DEFINE: tcc_token = 320;
pub const TOK___INF__: tcc_token = 345;
pub const TOK___SNAN__: tcc_token = 344;
pub const TOK___NAN__: tcc_token = 343;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AttributeDef {
    pub a: SymAttr,
    pub f: FuncAttr,
    pub section: *mut Section,
    pub cleanup_func: *mut Sym,
    pub alias_target: libc::c_int,
    pub asm_label: libc::c_int,
    pub attr_mode: libc::c_char,
}
pub const TOK_ATTRIBUTE2: tcc_token = 311;
pub const TOK_ATTRIBUTE1: tcc_token = 310;
pub const TOK_DLLIMPORT: tcc_token = 389;
pub const TOK_NODECORATE: tcc_token = 390;
pub const TOK_DLLEXPORT: tcc_token = 388;
pub const TOK_MODE_word: tcc_token = 387;
pub const TOK_MODE_SI: tcc_token = 386;
pub const TOK_MODE_HI: tcc_token = 385;
pub const TOK_MODE_QI: tcc_token = 383;
pub const TOK_MODE_DI: tcc_token = 384;
pub const TOK_MODE: tcc_token = 382;
pub const TOK_STDCALL3: tcc_token = 365;
pub const TOK_STDCALL2: tcc_token = 364;
pub const TOK_STDCALL1: tcc_token = 363;
pub const TOK_CDECL3: tcc_token = 362;
pub const TOK_CDECL2: tcc_token = 361;
pub const TOK_CDECL1: tcc_token = 360;
pub const TOK_NORETURN2: tcc_token = 392;
pub const TOK_NORETURN1: tcc_token = 391;
pub const TOK_UNUSED2: tcc_token = 357;
pub const TOK_UNUSED1: tcc_token = 356;
pub const TOK_NODEBUG2: tcc_token = 359;
pub const TOK_NODEBUG1: tcc_token = 358;
pub const TOK_WEAK2: tcc_token = 353;
pub const TOK_WEAK1: tcc_token = 352;
pub const TOK_PACKED2: tcc_token = 351;
pub const TOK_PACKED1: tcc_token = 350;
pub const TOK_ALIGNED2: tcc_token = 349;
pub const TOK_ALIGNED1: tcc_token = 348;
pub const TOK_VISIBILITY2: tcc_token = 395;
pub const TOK_VISIBILITY1: tcc_token = 394;
pub const TOK_ALIAS2: tcc_token = 355;
pub const TOK_ALIAS1: tcc_token = 354;
pub const TOK_SECTION2: tcc_token = 347;
pub const TOK_SECTION1: tcc_token = 346;
pub const TOK_ALWAYS_INLINE2: tcc_token = 381;
pub const TOK_ALWAYS_INLINE1: tcc_token = 380;
pub const TOK_DESTRUCTOR2: tcc_token = 379;
pub const TOK_DESTRUCTOR1: tcc_token = 378;
pub const TOK_CONSTRUCTOR2: tcc_token = 377;
pub const TOK_CONSTRUCTOR1: tcc_token = 376;
pub const TOK_CLEANUP2: tcc_token = 375;
pub const TOK_CLEANUP1: tcc_token = 374;
pub const TOK_STATIC: tcc_token = 272;
pub const TOK_VOLATILE1: tcc_token = 278;
pub const TOK_CONST1: tcc_token = 275;
pub const TOK_RESTRICT3: tcc_token = 291;
pub const TOK_RESTRICT2: tcc_token = 290;
pub const TOK_RESTRICT1: tcc_token = 289;
pub const TOK_THREAD_LOCAL: tcc_token = 293;
pub const TOK_TYPEOF3: tcc_token = 318;
pub const TOK_TYPEOF2: tcc_token = 317;
pub const TOK_TYPEOF1: tcc_token = 316;
pub const TOK_NORETURN3: tcc_token = 393;
pub const TOK_INLINE3: tcc_token = 288;
pub const TOK_INLINE2: tcc_token = 287;
pub const TOK_INLINE1: tcc_token = 286;
pub const TOK_TYPEDEF: tcc_token = 307;
pub const TOK_EXTERN: tcc_token = 271;
pub const TOK_UNSIGNED: tcc_token = 273;
pub const TOK_AUTO: tcc_token = 285;
pub const TOK_REGISTER: tcc_token = 281;
pub const TOK_SIGNED3: tcc_token = 284;
pub const TOK_SIGNED2: tcc_token = 283;
pub const TOK_SIGNED1: tcc_token = 282;
pub const TOK_VOLATILE3: tcc_token = 280;
pub const TOK_VOLATILE2: tcc_token = 279;
pub const TOK_CONST3: tcc_token = 277;
pub const TOK_CONST2: tcc_token = 276;
pub const TOK__Atomic: tcc_token = 274;
pub const TOK_STATIC_ASSERT: tcc_token = 295;
pub const TOK_UNION: tcc_token = 306;
pub const TOK_STRUCT: tcc_token = 305;
pub const TOK_ENUM: tcc_token = 308;
pub const TOK_DOUBLE: tcc_token = 300;
pub const TOK_FLOAT: tcc_token = 299;
pub const TOK_COMPLEX: tcc_token = 302;
pub const TOK_BOOL: tcc_token = 301;
pub const TOK_LONG: tcc_token = 304;
pub const TOK_ALIGNAS: tcc_token = 315;
pub const TOK_INT: tcc_token = 298;
pub const TOK_SHORT: tcc_token = 303;
pub const TOK_VOID: tcc_token = 296;
pub const TOK_CHAR: tcc_token = 297;
pub const TOK_EXTENSION: tcc_token = 292;
pub const TOK_DEFAULT: tcc_token = 267;
pub const TOK_GENERIC: tcc_token = 294;
pub const TOK___atomic_store: tcc_token = 404;
pub const TOK___atomic_compare_exchange: tcc_token = 407;
pub const TOK___atomic_nand_fetch: tcc_token = 419;
pub const TOK___atomic_and_fetch: tcc_token = 418;
pub const TOK___atomic_xor_fetch: tcc_token = 417;
pub const TOK___atomic_or_fetch: tcc_token = 416;
pub const TOK___atomic_sub_fetch: tcc_token = 415;
pub const TOK___atomic_add_fetch: tcc_token = 414;
pub const TOK___atomic_fetch_nand: tcc_token = 413;
pub const TOK___atomic_fetch_and: tcc_token = 412;
pub const TOK___atomic_fetch_xor: tcc_token = 411;
pub const TOK___atomic_fetch_or: tcc_token = 410;
pub const TOK___atomic_fetch_sub: tcc_token = 409;
pub const TOK___atomic_fetch_add: tcc_token = 408;
pub const TOK___atomic_exchange: tcc_token = 406;
pub const TOK___atomic_load: tcc_token = 405;
pub const __va_float_reg: __va_arg_type = 1;
pub const __va_gen_reg: __va_arg_type = 0;
pub const __va_stack: __va_arg_type = 2;
pub type __va_arg_type = libc::c_uint;
pub const TOK_builtin_va_arg_types: tcc_token = 403;
pub const TOK_builtin_return_address: tcc_token = 400;
pub const TOK_builtin_frame_address: tcc_token = 399;
pub const TOK_builtin_unreachable: tcc_token = 402;
pub const TOK_builtin_constant_p: tcc_token = 398;
pub const TOK_builtin_choose_expr: tcc_token = 397;
pub const TOK_builtin_types_compatible_p: tcc_token = 396;
pub const TOK_builtin_expect: tcc_token = 401;
pub const TOK_SIZEOF: tcc_token = 309;
pub const TOK_ALIGNOF3: tcc_token = 314;
pub const TOK_ALIGNOF2: tcc_token = 313;
pub const TOK_ALIGNOF1: tcc_token = 312;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub loc: libc::c_int,
    pub locorig: libc::c_int,
    pub num: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct scope {
    pub prev: *mut scope,
    pub vla: C2RustUnnamed_19,
    pub cl: C2RustUnnamed_20,
    pub bsym: *mut libc::c_int,
    pub csym: *mut libc::c_int,
    pub lstk: *mut Sym,
    pub llstk: *mut Sym,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub s: *mut Sym,
    pub n: libc::c_int,
}
pub const TREG_RSP: C2RustUnnamed_50 = 4;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ASMOperand {
    pub id: libc::c_int,
    pub constraint: [libc::c_char; 16],
    pub asm_str: [libc::c_char; 16],
    pub vt: *mut SValue,
    pub ref_index: libc::c_int,
    pub input_index: libc::c_int,
    pub priority: libc::c_int,
    pub reg: libc::c_int,
    pub is_llong: libc::c_int,
    pub is_memory: libc::c_int,
    pub is_rw: libc::c_int,
    pub is_label: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExprValue {
    pub v: uint64_t,
    pub sym: *mut Sym,
    pub pcrel: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Operand {
    pub type_0: uint32_t,
    pub reg: int8_t,
    pub reg2: int8_t,
    pub shift: uint8_t,
    pub e: ExprValue,
}
pub const OPT_DISP8: C2RustUnnamed_53 = 30;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ASMInstr {
    pub sym: uint16_t,
    pub opcode: uint16_t,
    pub instr_type: uint16_t,
    pub nb_ops: uint8_t,
    pub op_type: [uint8_t; 3],
}
pub const OPT_DISP: C2RustUnnamed_53 = 29;
pub const OPT_IM64: C2RustUnnamed_53 = 16;
pub const OPT_IM16: C2RustUnnamed_53 = 14;
pub const OPT_IM8S: C2RustUnnamed_53 = 13;
pub const OPT_IM8: C2RustUnnamed_53 = 12;
pub const OPT_IM32: C2RustUnnamed_53 = 15;
pub const OPT_ADDR: C2RustUnnamed_53 = 21;
pub const OPT_SSE: C2RustUnnamed_53 = 5;
pub const OPT_MMX: C2RustUnnamed_53 = 4;
pub const OPT_REG64: C2RustUnnamed_53 = 3;
pub const OPT_REG32: C2RustUnnamed_53 = 2;
pub const OPT_REG16: C2RustUnnamed_53 = 1;
pub const OPT_REG8: C2RustUnnamed_53 = 0;
pub const OPT_ST: C2RustUnnamed_53 = 10;
pub const OPT_REG8_LOW: C2RustUnnamed_53 = 11;
pub const OPT_CR: C2RustUnnamed_53 = 6;
pub const OPT_SEG: C2RustUnnamed_53 = 9;
pub const OPT_DB: C2RustUnnamed_53 = 8;
pub const OPT_TR: C2RustUnnamed_53 = 7;
pub const OPT_INDIR: C2RustUnnamed_53 = 22;
pub const TOK_ASM_sfence: tcc_token = 1317;
pub const TOK_ASM_lfence: tcc_token = 1315;
pub const TOK_ASM_endbr64: tcc_token = 1319;
pub const TOK_ASM_addb: tcc_token = 596;
pub const TOK_ASM_jmp: tcc_token = 767;
pub const TOK_ASM_call: tcc_token = 766;
pub const TOK_ASM_popq: tcc_token = 735;
pub const TOK_ASM_popl: tcc_token = 734;
pub const TOK_ASM_popw: tcc_token = 733;
pub const TOK_ASM_pushq: tcc_token = 731;
pub const TOK_ASM_pushl: tcc_token = 730;
pub const TOK_ASM_pushw: tcc_token = 729;
pub const OPT_DX: C2RustUnnamed_53 = 20;
pub const OPT_CL: C2RustUnnamed_53 = 19;
pub const OPT_EA: C2RustUnnamed_53 = 128;
pub const OPT_MMXSSE: C2RustUnnamed_53 = 28;
pub const OPT_IMW: C2RustUnnamed_53 = 27;
pub const OPT_REGW: C2RustUnnamed_53 = 26;
pub const OPT_REG: C2RustUnnamed_53 = 25;
pub const OPT_IM: C2RustUnnamed_53 = 24;
pub const TOK_ASM_clflush: tcc_token = 1318;
pub const TOK_ASM_mfence: tcc_token = 1316;
pub const TOK_ASM_prefetchw: tcc_token = 1314;
pub const TOK_ASM_prefetcht2: tcc_token = 1313;
pub const TOK_ASM_prefetcht1: tcc_token = 1312;
pub const TOK_ASM_prefetcht0: tcc_token = 1311;
pub const TOK_ASM_prefetchnta: tcc_token = 1310;
pub const TOK_ASM_movntiq: tcc_token = 1309;
pub const TOK_ASM_movntil: tcc_token = 1308;
pub const TOK_ASM_movnti: tcc_token = 1307;
pub const TOK_ASM_subps: tcc_token = 1306;
pub const TOK_ASM_sqrtps: tcc_token = 1305;
pub const TOK_ASM_rsqrtps: tcc_token = 1304;
pub const TOK_ASM_rcpss: tcc_token = 1303;
pub const TOK_ASM_pminub: tcc_token = 1302;
pub const TOK_ASM_pminsw: tcc_token = 1301;
pub const TOK_ASM_pmaxub: tcc_token = 1300;
pub const TOK_ASM_pmaxsw: tcc_token = 1299;
pub const TOK_ASM_pavgw: tcc_token = 1298;
pub const TOK_ASM_pavgb: tcc_token = 1297;
pub const TOK_ASM_mulps: tcc_token = 1296;
pub const TOK_ASM_minps: tcc_token = 1295;
pub const TOK_ASM_maxps: tcc_token = 1294;
pub const TOK_ASM_divps: tcc_token = 1293;
pub const TOK_ASM_cvttps2pi: tcc_token = 1292;
pub const TOK_ASM_cvtps2pi: tcc_token = 1291;
pub const TOK_ASM_cvtpi2ps: tcc_token = 1290;
pub const TOK_ASM_addps: tcc_token = 1289;
pub const TOK_ASM_movhps: tcc_token = 1288;
pub const TOK_ASM_movaps: tcc_token = 1287;
pub const TOK_ASM_movups: tcc_token = 1286;
pub const TOK_ASM_stmxcsr: tcc_token = 1285;
pub const TOK_ASM_ldmxcsr: tcc_token = 1284;
pub const TOK_ASM_pxor: tcc_token = 1283;
pub const TOK_ASM_punpckldq: tcc_token = 1282;
pub const TOK_ASM_punpcklwd: tcc_token = 1281;
pub const TOK_ASM_punpcklbw: tcc_token = 1280;
pub const TOK_ASM_punpckhdq: tcc_token = 1279;
pub const TOK_ASM_punpckhwd: tcc_token = 1278;
pub const TOK_ASM_punpckhbw: tcc_token = 1277;
pub const TOK_ASM_psubusw: tcc_token = 1276;
pub const TOK_ASM_psubusb: tcc_token = 1275;
pub const TOK_ASM_psubsw: tcc_token = 1274;
pub const TOK_ASM_psubsb: tcc_token = 1273;
pub const TOK_ASM_psubd: tcc_token = 1272;
pub const TOK_ASM_psubw: tcc_token = 1271;
pub const TOK_ASM_psubb: tcc_token = 1270;
pub const TOK_ASM_psrlq: tcc_token = 1269;
pub const TOK_ASM_psrld: tcc_token = 1268;
pub const TOK_ASM_psrlw: tcc_token = 1267;
pub const TOK_ASM_psrad: tcc_token = 1266;
pub const TOK_ASM_psraw: tcc_token = 1265;
pub const TOK_ASM_psllq: tcc_token = 1264;
pub const TOK_ASM_pslld: tcc_token = 1263;
pub const TOK_ASM_psllw: tcc_token = 1262;
pub const TOK_ASM_por: tcc_token = 1261;
pub const TOK_ASM_pmullw: tcc_token = 1260;
pub const TOK_ASM_pmulhw: tcc_token = 1259;
pub const TOK_ASM_pmaddwd: tcc_token = 1258;
pub const TOK_ASM_pcmpgtd: tcc_token = 1257;
pub const TOK_ASM_pcmpgtw: tcc_token = 1256;
pub const TOK_ASM_pcmpgtb: tcc_token = 1255;
pub const TOK_ASM_pcmpeqd: tcc_token = 1254;
pub const TOK_ASM_pcmpeqw: tcc_token = 1253;
pub const TOK_ASM_pcmpeqb: tcc_token = 1252;
pub const TOK_ASM_pandn: tcc_token = 1251;
pub const TOK_ASM_pand: tcc_token = 1250;
pub const TOK_ASM_paddusw: tcc_token = 1249;
pub const TOK_ASM_paddusb: tcc_token = 1248;
pub const TOK_ASM_paddsw: tcc_token = 1247;
pub const TOK_ASM_paddsb: tcc_token = 1246;
pub const TOK_ASM_paddd: tcc_token = 1245;
pub const TOK_ASM_paddw: tcc_token = 1244;
pub const TOK_ASM_paddb: tcc_token = 1243;
pub const TOK_ASM_packuswb: tcc_token = 1242;
pub const TOK_ASM_packsswb: tcc_token = 1241;
pub const TOK_ASM_packssdw: tcc_token = 1240;
pub const TOK_ASM_movq: tcc_token = 594;
pub const TOK_ASM_movd: tcc_token = 1239;
pub const OPT_ST0: C2RustUnnamed_53 = 18;
pub const TOK_ASM_fcomip: tcc_token = 1238;
pub const TOK_ASM_fucomip: tcc_token = 1237;
pub const TOK_ASM_fcomi: tcc_token = 1236;
pub const TOK_ASM_fucomi: tcc_token = 1235;
pub const TOK_ASM_fcmovnu: tcc_token = 1234;
pub const TOK_ASM_fcmovnbe: tcc_token = 1233;
pub const TOK_ASM_fcmovne: tcc_token = 1232;
pub const TOK_ASM_fcmovnb: tcc_token = 1231;
pub const TOK_ASM_fcmovu: tcc_token = 1230;
pub const TOK_ASM_fcmovbe: tcc_token = 1229;
pub const TOK_ASM_fcmove: tcc_token = 1228;
pub const TOK_ASM_fcmovb: tcc_token = 1227;
pub const TOK_ASM_cmovo: tcc_token = 860;
pub const TOK_ASM_cmpxchg16b: tcc_token = 1226;
pub const TOK_ASM_cmpxchg8b: tcc_token = 1225;
pub const TOK_ASM_invlpg: tcc_token = 1224;
pub const TOK_ASM_cmpxchgb: tcc_token = 987;
pub const TOK_ASM_xaddb: tcc_token = 982;
pub const TOK_ASM_bswapq: tcc_token = 1223;
pub const TOK_ASM_bswapl: tcc_token = 1222;
pub const TOK_ASM_bswap: tcc_token = 1221;
pub const TOK_ASM_swapgs: tcc_token = 1220;
pub const TOK_ASM_verw: tcc_token = 1219;
pub const TOK_ASM_verr: tcc_token = 1218;
pub const TOK_ASM_str: tcc_token = 1217;
pub const TOK_ASM_smsw: tcc_token = 1216;
pub const TOK_ASM_sldt: tcc_token = 1215;
pub const TOK_ASM_sidtq: tcc_token = 1214;
pub const TOK_ASM_sidt: tcc_token = 1213;
pub const TOK_ASM_sgdtq: tcc_token = 1212;
pub const TOK_ASM_sgdt: tcc_token = 1211;
pub const TOK_ASM_ltr: tcc_token = 1210;
pub const TOK_ASM_lslw: tcc_token = 930;
pub const TOK_ASM_lmsw: tcc_token = 1209;
pub const TOK_ASM_lldt: tcc_token = 1208;
pub const TOK_ASM_lidtq: tcc_token = 1207;
pub const TOK_ASM_lidt: tcc_token = 1206;
pub const TOK_ASM_lgdtq: tcc_token = 1205;
pub const TOK_ASM_lgdt: tcc_token = 1204;
pub const TOK_ASM_larw: tcc_token = 926;
pub const TOK_ASM_arpl: tcc_token = 1203;
pub const TOK_ASM_fxrstorq: tcc_token = 1202;
pub const TOK_ASM_fxsaveq: tcc_token = 1201;
pub const TOK_ASM_fxrstor: tcc_token = 1200;
pub const TOK_ASM_fxsave: tcc_token = 1199;
pub const TOK_ASM_ffreep: tcc_token = 1198;
pub const TOK_ASM_ffree: tcc_token = 1197;
pub const TOK_ASM_frstor: tcc_token = 1196;
pub const TOK_ASM_fsave: tcc_token = 1195;
pub const TOK_ASM_fnsave: tcc_token = 1194;
pub const TOK_ASM_fldenv: tcc_token = 1193;
pub const TOK_ASM_fstenv: tcc_token = 1192;
pub const TOK_ASM_fnstenv: tcc_token = 1191;
pub const TOK_ASM_fclex: tcc_token = 1190;
pub const TOK_ASM_fstsw: tcc_token = 1189;
pub const OPT_EAX: C2RustUnnamed_53 = 17;
pub const TOK_ASM_fnstsw: tcc_token = 1144;
pub const TOK_ASM_fstcw: tcc_token = 1188;
pub const TOK_ASM_fnstcw: tcc_token = 1187;
pub const TOK_ASM_fldcw: tcc_token = 1186;
pub const TOK_ASM_finit: tcc_token = 1185;
pub const TOK_ASM_fucomp: tcc_token = 1184;
pub const TOK_ASM_fucom: tcc_token = 1183;
pub const TOK_ASM_fxch: tcc_token = 1143;
pub const TOK_ASM_fbstp: tcc_token = 1182;
pub const TOK_ASM_fstpt: tcc_token = 1181;
pub const TOK_ASM_fistpll: tcc_token = 1180;
pub const TOK_ASM_fistpq: tcc_token = 1179;
pub const TOK_ASM_fstp: tcc_token = 1178;
pub const TOK_ASM_fistpl: tcc_token = 1177;
pub const TOK_ASM_fistl: tcc_token = 1176;
pub const TOK_ASM_fistp: tcc_token = 1175;
pub const TOK_ASM_fist: tcc_token = 1174;
pub const TOK_ASM_fstpl: tcc_token = 1173;
pub const TOK_ASM_fstl: tcc_token = 1170;
pub const TOK_ASM_fstps: tcc_token = 1172;
pub const TOK_ASM_fsts: tcc_token = 1171;
pub const TOK_ASM_fst: tcc_token = 1169;
pub const TOK_ASM_fbld: tcc_token = 1168;
pub const TOK_ASM_fldt: tcc_token = 1167;
pub const TOK_ASM_fildll: tcc_token = 1166;
pub const TOK_ASM_fildq: tcc_token = 1165;
pub const TOK_ASM_fildl: tcc_token = 1164;
pub const TOK_ASM_fldl: tcc_token = 1162;
pub const TOK_ASM_flds: tcc_token = 1163;
pub const TOK_ASM_fld: tcc_token = 1161;
pub const TOK_ASM_fiadds: tcc_token = 939;
pub const TOK_ASM_faddl: tcc_token = 938;
pub const TOK_ASM_fiaddl: tcc_token = 937;
pub const TOK_ASM_fadds: tcc_token = 936;
pub const TOK_ASM_faddp: tcc_token = 935;
pub const TOK_ASM_fadd: tcc_token = 934;
pub const TOK_ASM_fmul: tcc_token = 940;
pub const TOK_ASM_fcomp: tcc_token = 952;
pub const TOK_ASM_jecxz: tcc_token = 1160;
pub const TOK_ASM_loop: tcc_token = 1159;
pub const TOK_ASM_loopz: tcc_token = 1158;
pub const TOK_ASM_loope: tcc_token = 1157;
pub const TOK_ASM_loopnz: tcc_token = 1156;
pub const TOK_ASM_loopne: tcc_token = 1155;
pub const TOK_ASM_jo: tcc_token = 770;
pub const TOK_ASM_lret: tcc_token = 1110;
pub const TOK_ASM_ret: tcc_token = 1108;
pub const TOK_ASM_retq: tcc_token = 1109;
pub const TOK_ASM_enter: tcc_token = 1154;
pub const TOK_ASM_setob: tcc_token = 830;
pub const TOK_ASM_seto: tcc_token = 800;
pub const TOK_ASM_ljmpl: tcc_token = 1153;
pub const TOK_ASM_ljmpw: tcc_token = 1152;
pub const TOK_ASM_ljmp: tcc_token = 769;
pub const TOK_ASM_lcall: tcc_token = 768;
pub const TOK_ASM_callq: tcc_token = 1151;
pub const TOK_ASM_shrdw: tcc_token = 725;
pub const TOK_ASM_shldw: tcc_token = 721;
pub const TOK_ASM_rolb: tcc_token = 686;
pub const TOK_ASM_idivb: tcc_token = 671;
pub const TOK_ASM_divb: tcc_token = 666;
pub const TOK_ASM_imulw: tcc_token = 662;
pub const TOK_ASM_imulb: tcc_token = 661;
pub const TOK_ASM_mulb: tcc_token = 656;
pub const TOK_ASM_negb: tcc_token = 651;
pub const TOK_ASM_notb: tcc_token = 646;
pub const TOK_ASM_decb: tcc_token = 641;
pub const TOK_ASM_incb: tcc_token = 636;
pub const TOK_ASM_testb: tcc_token = 681;
pub const TOK_ASM_addw: tcc_token = 597;
pub const TOK_ASM_lgs: tcc_token = 765;
pub const TOK_ASM_lfs: tcc_token = 764;
pub const TOK_ASM_lss: tcc_token = 763;
pub const TOK_ASM_lds: tcc_token = 762;
pub const TOK_ASM_les: tcc_token = 761;
pub const TOK_ASM_leaw: tcc_token = 757;
pub const TOK_ASM_outb: tcc_token = 741;
pub const TOK_ASM_inb: tcc_token = 737;
pub const TOK_ASM_xchgb: tcc_token = 676;
pub const TOK_ASM_xchgw: tcc_token = 677;
pub const TOK_ASM_movzwq: tcc_token = 755;
pub const TOK_ASM_movzwl: tcc_token = 749;
pub const TOK_ASM_movzbw: tcc_token = 745;
pub const TOK_ASM_movslq: tcc_token = 756;
pub const TOK_ASM_movswq: tcc_token = 754;
pub const TOK_ASM_movswl: tcc_token = 752;
pub const TOK_ASM_movsbq: tcc_token = 753;
pub const TOK_ASM_movsbl: tcc_token = 751;
pub const TOK_ASM_movsbw: tcc_token = 750;
pub const TOK_ASM_movw: tcc_token = 592;
pub const TOK_ASM_movb: tcc_token = 591;
pub const TOK_ASM_mov: tcc_token = 595;
pub const TOK_ASM_sysretq: tcc_token = 1150;
pub const TOK_ASM_lzcntw: tcc_token = 922;
pub const TOK_ASM_tzcntw: tcc_token = 918;
pub const TOK_ASM_popcntw: tcc_token = 914;
pub const TOK_ASM_btcw: tcc_token = 910;
pub const TOK_ASM_btrw: tcc_token = 906;
pub const TOK_ASM_btsw: tcc_token = 902;
pub const TOK_ASM_btw: tcc_token = 898;
pub const TOK_ASM_bsrw: tcc_token = 894;
pub const TOK_ASM_bsfw: tcc_token = 890;
pub const TOK_ASM_sstob: tcc_token = 1045;
pub const TOK_ASM_stosb: tcc_token = 1040;
pub const TOK_ASM_sscab: tcc_token = 1035;
pub const TOK_ASM_scasb: tcc_token = 1030;
pub const TOK_ASM_smovb: tcc_token = 1025;
pub const TOK_ASM_movsb: tcc_token = 1020;
pub const TOK_ASM_slodb: tcc_token = 1015;
pub const TOK_ASM_lodsb: tcc_token = 1010;
pub const TOK_ASM_outsb: tcc_token = 1006;
pub const TOK_ASM_insb: tcc_token = 1002;
pub const TOK_ASM_scmpb: tcc_token = 997;
pub const TOK_ASM_cmpsb: tcc_token = 992;
pub const TOK_ASM_vmxoff: tcc_token = 1149;
pub const TOK_ASM_vmresume: tcc_token = 1148;
pub const TOK_ASM_vmlaunch: tcc_token = 1147;
pub const TOK_ASM_vmcall: tcc_token = 1146;
pub const TOK_ASM_clc: tcc_token = 1050;
pub const TOK_ASM_emms: tcc_token = 1145;
pub const TOK_ASM_rip: tcc_token = 586;
pub const TOK_ASM_rax: tcc_token = 523;
pub const TOK_ASM_rdi: tcc_token = 530;
pub const TOK_ASM_eax: tcc_token = 515;
pub const TOK_ASM_edi: tcc_token = 522;
pub const TOK_ASM_spl: tcc_token = 587;
pub const TOK_ASM_dil: tcc_token = 590;
pub const TOK_ASM_st: tcc_token = 585;
pub const TOK_ASM_es: tcc_token = 579;
pub const TOK_ASM_gs: tcc_token = 584;
pub const TOK_ASM_dr0: tcc_token = 571;
pub const TOK_ASM_dr7: tcc_token = 578;
pub const TOK_ASM_al: tcc_token = 499;
pub const TOK_ASM_db7: tcc_token = 570;
pub const TOK_ASM_repnz: tcc_token = 1096;
pub const TOK_ASM_wait: tcc_token = 1087;
pub const TOK_ASMDIR_symver: tcc_token = 497;
pub const TOK_ASMDIR_code64: tcc_token = 493;
pub const TOK_ASMDIR_popsection: tcc_token = 487;
pub const TOK_ASMDIR_previous: tcc_token = 485;
pub const TOK_ASMDIR_section: tcc_token = 498;
pub const TOK_ASMDIR_pushsection: tcc_token = 486;
pub const TOK_ASMDIR_type: tcc_token = 481;
pub const TOK_ASMDIR_size: tcc_token = 480;
pub const TOK_ASMDIR_ident: tcc_token = 479;
pub const TOK_ASMDIR_file: tcc_token = 474;
pub const TOK_ASMDIR_bss: tcc_token = 484;
pub const TOK_ASMDIR_data: tcc_token = 483;
pub const TOK_ASMDIR_text: tcc_token = 482;
pub const TOK_ASMDIR_ascii: tcc_token = 473;
pub const TOK_ASMDIR_asciz: tcc_token = 472;
pub const TOK_ASMDIR_string: tcc_token = 471;
pub const TOK_ASMDIR_hidden: tcc_token = 478;
pub const TOK_ASMDIR_weak: tcc_token = 477;
pub const TOK_ASMDIR_global: tcc_token = 476;
pub const TOK_ASMDIR_globl: tcc_token = 475;
pub const TOK_ASMDIR_set: tcc_token = 468;
pub const TOK_ASMDIR_org: tcc_token = 491;
pub const TOK_ASMDIR_endr: tcc_token = 490;
pub const TOK_ASMDIR_rept: tcc_token = 489;
pub const TOK_ASMDIR_fill: tcc_token = 488;
pub const TOK_ASMDIR_int: tcc_token = 496;
pub const TOK_ASMDIR_long: tcc_token = 495;
pub const TOK_ASMDIR_short: tcc_token = 494;
pub const TOK_ASMDIR_word: tcc_token = 464;
pub const TOK_ASMDIR_byte: tcc_token = 463;
pub const TOK_ASMDIR_quad: tcc_token = 492;
pub const TOK_ASMDIR_balign: tcc_token = 466;
pub const TOK_ASMDIR_align: tcc_token = 465;
pub const TOK_ASMDIR_p2align: tcc_token = 467;
pub const TOK_ASMDIR_space: tcc_token = 470;
pub const TOK_ASMDIR_skip: tcc_token = 469;
pub const DW_LNS_advance_line: C2RustUnnamed_46 = 3;
pub const DW_LNS_advance_pc: C2RustUnnamed_46 = 2;
pub const DW_LNS_set_file: C2RustUnnamed_46 = 4;
pub const TOK_ASM_ax: tcc_token = 507;
pub const TOK_ASM_ah: tcc_token = 503;
pub const TOK_ASM_di: tcc_token = 514;
pub const TOK_GOTO: tcc_token = 264;
pub const TOK_ASM3: tcc_token = 270;
pub const TOK_ASM2: tcc_token = 269;
pub const TOK_ASM1: tcc_token = 268;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct switch_t {
    pub p: *mut *mut case_t,
    pub n: libc::c_int,
    pub def_sym: libc::c_int,
    pub nocode_wanted: libc::c_int,
    pub bsym: *mut libc::c_int,
    pub scope: *mut scope,
    pub prev: *mut switch_t,
    pub sv: SValue,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct case_t {
    pub v1: int64_t,
    pub v2: int64_t,
    pub ind: libc::c_int,
    pub line: libc::c_int,
}
pub const TOK_CASE: tcc_token = 266;
pub const TOK_SWITCH: tcc_token = 265;
pub const TOK_WHILE: tcc_token = 258;
pub const TOK_DO: tcc_token = 260;
pub const N_PSYM: __stab_debug_code = 160;
pub const TOK_memset: tcc_token = 429;
pub const N_RBRAC: __stab_debug_code = 224;
pub const N_LBRAC: __stab_debug_code = 192;
pub const DW_OP_fbreg: C2RustUnnamed_42 = 145;
pub const DW_OP_reg6: C2RustUnnamed_42 = 86;
pub const DW_CFA_nop: C2RustUnnamed_48 = 0;
pub const DW_CFA_def_cfa: C2RustUnnamed_48 = 12;
pub const DW_CFA_advance_loc4: C2RustUnnamed_48 = 4;
pub const DW_CFA_def_cfa_register: C2RustUnnamed_48 = 13;
pub const DW_CFA_advance_loc: C2RustUnnamed_48 = 64;
pub const DW_CFA_offset: C2RustUnnamed_48 = 128;
pub const DW_CFA_def_cfa_offset: C2RustUnnamed_48 = 14;
pub const TOK___bound_local_delete: tcc_token = 453;
pub const TOK___bound_local_new: tcc_token = 452;
pub const DW_LNS_set_epilogue_begin: C2RustUnnamed_46 = 11;
pub const DW_LNS_set_prologue_end: C2RustUnnamed_46 = 10;
pub const N_FUN: __stab_debug_code = 36;
pub const DW_LNE_hi_user: C2RustUnnamed_47 = 255;
pub const TOK_FOR: tcc_token = 259;
pub const TOK_CONTINUE: tcc_token = 261;
pub const TOK_BREAK: tcc_token = 262;
pub const TOK_RETURN: tcc_token = 263;
pub const TOK_LABEL: tcc_token = 319;
pub const TOK___FUNC__: tcc_token = 342;
pub const TOK___FUNCTION__: tcc_token = 337;
pub const TOK___HAS_INCLUDE: tcc_token = 340;
pub const N_BINCL: __stab_debug_code = 130;
pub const TOK___HAS_INCLUDE_NEXT: tcc_token = 341;
pub const TOK_INCLUDE: tcc_token = 321;
pub const TOK_INCLUDE_NEXT: tcc_token = 322;
pub const TOK_UNDEF: tcc_token = 328;
pub const TOK___VA_ARGS__: tcc_token = 338;
pub const N_EINCL: __stab_debug_code = 162;
pub const TCC_OPTION_ar: C2RustUnnamed_55 = 50;
pub const TCC_OPTION_impdef: C2RustUnnamed_55 = 51;
pub const TCC_OPTION_print_search_dirs: C2RustUnnamed_55 = 37;
pub const TCC_OPTION_HELP2: C2RustUnnamed_55 = 2;
pub const TCC_OPTION_HELP: C2RustUnnamed_55 = 1;
pub const TCC_OPTION_O: C2RustUnnamed_55 = 28;
pub const TCC_OPTION_x: C2RustUnnamed_55 = 49;
pub const TCC_OPTION_dumpversion: C2RustUnnamed_55 = 17;
pub const TCC_OPTION_dumpmachine: C2RustUnnamed_55 = 16;
pub const TCC_OPTION_MP: C2RustUnnamed_55 = 48;
pub const TCC_OPTION_MF: C2RustUnnamed_55 = 45;
pub const TCC_OPTION_MD: C2RustUnnamed_55 = 44;
pub const TCC_OPTION_MMD: C2RustUnnamed_55 = 47;
pub const TCC_OPTION_MM: C2RustUnnamed_55 = 46;
pub const TCC_OPTION_M: C2RustUnnamed_55 = 43;
pub const TCC_OPTION_P: C2RustUnnamed_55 = 7;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct TCCOption {
    pub name: *const libc::c_char,
    pub index: uint16_t,
    pub flags: uint16_t,
}
pub const TCC_OPTION_E: C2RustUnnamed_55 = 42;
pub const TCC_OPTION_Wp: C2RustUnnamed_55 = 26;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct lopt {
    pub s: *mut TCCState,
    pub opt: *const libc::c_char,
    pub arg: *const libc::c_char,
    pub match_0: libc::c_int,
}
pub const TCC_OPTION_Wl: C2RustUnnamed_55 = 25;
pub const TCC_OPTION_rdynamic: C2RustUnnamed_55 = 38;
pub const TCC_OPTION_w: C2RustUnnamed_55 = 41;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FlagDef {
    pub offset: uint16_t,
    pub flags: uint16_t,
    pub name: *const libc::c_char,
}
pub const TCC_OPTION_W: C2RustUnnamed_55 = 27;
pub const TCC_OPTION_m: C2RustUnnamed_55 = 30;
pub const TCC_OPTION_f: C2RustUnnamed_55 = 31;
pub const TCC_OPTION_v: C2RustUnnamed_55 = 3;
pub const TCC_OPTION_run: C2RustUnnamed_55 = 40;
pub const TCC_OPTION_nostdlib: C2RustUnnamed_55 = 36;
pub const TCC_OPTION_nostdinc: C2RustUnnamed_55 = 35;
pub const TCC_OPTION_include: C2RustUnnamed_55 = 34;
pub const TCC_OPTION_isystem: C2RustUnnamed_55 = 32;
pub const TCC_OPTION_r: C2RustUnnamed_55 = 24;
pub const TCC_OPTION_o: C2RustUnnamed_55 = 23;
pub const TCC_OPTION_soname: C2RustUnnamed_55 = 22;
pub const TCC_OPTION_shared: C2RustUnnamed_55 = 21;
pub const TCC_OPTION_std: C2RustUnnamed_55 = 20;
pub const TCC_OPTION_static: C2RustUnnamed_55 = 19;
pub const TCC_OPTION_d: C2RustUnnamed_55 = 18;
pub const TCC_OPTION_c: C2RustUnnamed_55 = 15;
pub const TCC_OPTION_g: C2RustUnnamed_55 = 14;
pub const TCC_OPTION_b: C2RustUnnamed_55 = 13;
pub const TCC_OPTION_bt: C2RustUnnamed_55 = 12;
pub const TCC_OPTION_bench: C2RustUnnamed_55 = 11;
pub const TCC_OPTION_pthread: C2RustUnnamed_55 = 39;
pub const TCC_OPTION_l: C2RustUnnamed_55 = 10;
pub const TCC_OPTION_B: C2RustUnnamed_55 = 9;
pub const TCC_OPTION_L: C2RustUnnamed_55 = 8;
pub const TCC_OPTION_U: C2RustUnnamed_55 = 6;
pub const TCC_OPTION_D: C2RustUnnamed_55 = 5;
pub const TCC_OPTION_I: C2RustUnnamed_55 = 4;
pub const N_SO: __stab_debug_code = 100;
pub const DW_LNE_end_sequence: C2RustUnnamed_47 = 1;
pub const DW_FORM_udata: C2RustUnnamed_41 = 15;
pub const DW_LNCT_directory_index: C2RustUnnamed_45 = 2;
pub const DW_FORM_line_strp: C2RustUnnamed_41 = 31;
pub const DW_LNCT_path: C2RustUnnamed_45 = 1;
pub const DW_LNE_set_address: C2RustUnnamed_47 = 2;
pub const DW_LANG_C99: C2RustUnnamed_44 = 12;
pub const DW_LANG_C11: C2RustUnnamed_44 = 29;
pub const DW_UT_compile: C2RustUnnamed_38 = 1;
pub const DW_FORM_block1: C2RustUnnamed_41 = 10;
pub const DW_FORM_exprloc: C2RustUnnamed_41 = 24;
pub const DW_FORM_data4: C2RustUnnamed_41 = 6;
pub const DW_FORM_sec_offset: C2RustUnnamed_41 = 23;
pub const DW_FORM_strp: C2RustUnnamed_41 = 14;
pub const DW_FORM_ref4: C2RustUnnamed_41 = 19;
pub const DW_AT_type: C2RustUnnamed_40 = 73;
pub const DW_TAG_formal_parameter: C2RustUnnamed_39 = 5;
pub const DW_TAG_subroutine_type: C2RustUnnamed_39 = 21;
pub const DW_AT_sibling: C2RustUnnamed_40 = 1;
pub const DW_FORM_data8: C2RustUnnamed_41 = 7;
pub const DW_AT_high_pc: C2RustUnnamed_40 = 18;
pub const DW_FORM_addr: C2RustUnnamed_41 = 1;
pub const DW_AT_low_pc: C2RustUnnamed_40 = 17;
pub const DW_TAG_lexical_block: C2RustUnnamed_39 = 11;
pub const DW_AT_frame_base: C2RustUnnamed_40 = 64;
pub const DW_AT_decl_line: C2RustUnnamed_40 = 59;
pub const DW_AT_decl_file: C2RustUnnamed_40 = 58;
pub const DW_AT_name: C2RustUnnamed_40 = 3;
pub const DW_TAG_subprogram: C2RustUnnamed_39 = 46;
pub const DW_FORM_flag: C2RustUnnamed_41 = 12;
pub const DW_AT_external: C2RustUnnamed_40 = 63;
pub const DW_AT_byte_size: C2RustUnnamed_40 = 11;
pub const DW_TAG_union_type: C2RustUnnamed_39 = 23;
pub const DW_TAG_structure_type: C2RustUnnamed_39 = 19;
pub const DW_AT_data_bit_offset: C2RustUnnamed_40 = 107;
pub const DW_AT_bit_size: C2RustUnnamed_40 = 13;
pub const DW_TAG_member: C2RustUnnamed_39 = 13;
pub const DW_AT_data_member_location: C2RustUnnamed_40 = 56;
pub const DW_FORM_data1: C2RustUnnamed_41 = 11;
pub const DW_AT_encoding: C2RustUnnamed_40 = 62;
pub const DW_TAG_enumeration_type: C2RustUnnamed_39 = 4;
pub const DW_AT_const_value: C2RustUnnamed_40 = 28;
pub const DW_TAG_enumerator: C2RustUnnamed_39 = 40;
pub const DW_FORM_sdata: C2RustUnnamed_41 = 13;
pub const DW_TAG_typedef: C2RustUnnamed_39 = 22;
pub const DW_AT_upper_bound: C2RustUnnamed_40 = 47;
pub const DW_TAG_subrange_type: C2RustUnnamed_39 = 33;
pub const DW_TAG_array_type: C2RustUnnamed_39 = 1;
pub const DW_TAG_pointer_type: C2RustUnnamed_39 = 15;
pub const DW_AT_location: C2RustUnnamed_40 = 2;
pub const DW_TAG_variable: C2RustUnnamed_39 = 52;
pub const DW_TAG_base_type: C2RustUnnamed_39 = 36;
pub const DW_AT_stmt_list: C2RustUnnamed_40 = 16;
pub const DW_AT_comp_dir: C2RustUnnamed_40 = 27;
pub const DW_AT_language: C2RustUnnamed_40 = 19;
pub const DW_AT_producer: C2RustUnnamed_40 = 37;
pub const DW_TAG_compile_unit: C2RustUnnamed_39 = 17;
pub const LINE_MACRO_OUTPUT_FORMAT_STD: line_macro_output_format = 2;
pub const LINE_MACRO_OUTPUT_FORMAT_NONE: line_macro_output_format = 1;
pub const LINE_MACRO_OUTPUT_FORMAT_P10: line_macro_output_format = 11;
pub type Elf64_Half = uint16_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct versym_info {
    pub nb_versyms: libc::c_int,
    pub verdef: *mut Elf64_Verdef,
    pub verneed: *mut Elf64_Verneed,
    pub versym: *mut Elf64_Half,
    pub nb_local_ver: libc::c_int,
    pub local_ver: *mut libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Verneed {
    pub vn_version: Elf64_Half,
    pub vn_cnt: Elf64_Half,
    pub vn_file: Elf64_Word,
    pub vn_aux: Elf64_Word,
    pub vn_next: Elf64_Word,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Verdef {
    pub vd_version: Elf64_Half,
    pub vd_flags: Elf64_Half,
    pub vd_ndx: Elf64_Half,
    pub vd_cnt: Elf64_Half,
    pub vd_hash: Elf64_Word,
    pub vd_aux: Elf64_Word,
    pub vd_next: Elf64_Word,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
pub type Elf64_Off = uint64_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Dyn {
    pub d_tag: Elf64_Sxword,
    pub d_un: C2RustUnnamed_21,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_21 {
    pub d_val: Elf64_Xword,
    pub d_ptr: Elf64_Addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Vernaux {
    pub vna_hash: Elf64_Word,
    pub vna_flags: Elf64_Half,
    pub vna_other: Elf64_Half,
    pub vna_name: Elf64_Word,
    pub vna_next: Elf64_Word,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Verdaux {
    pub vda_name: Elf64_Word,
    pub vda_next: Elf64_Word,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Ehdr {
    pub e_ident: [libc::c_uchar; 16],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SectionMergeInfo {
    pub s: *mut Section,
    pub offset: libc::c_ulong,
    pub new_section: uint8_t,
    pub link_once: uint8_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArchiveHeader {
    pub ar_name: [libc::c_char; 16],
    pub ar_date: [libc::c_char; 12],
    pub ar_uid: [libc::c_char; 6],
    pub ar_gid: [libc::c_char; 6],
    pub ar_mode: [libc::c_char; 8],
    pub ar_size: [libc::c_char; 10],
    pub ar_fmag: [libc::c_char; 2],
}
pub const DW_EH_PE_pcrel: C2RustUnnamed_49 = 16;
pub const DW_EH_PE_signed: C2RustUnnamed_49 = 8;
pub const DW_EH_PE_udata4: C2RustUnnamed_49 = 3;
pub type uintptr_t = libc::c_ulong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Elf64_Phdr {
    pub p_type: Elf64_Word,
    pub p_flags: Elf64_Word,
    pub p_offset: Elf64_Off,
    pub p_vaddr: Elf64_Addr,
    pub p_paddr: Elf64_Addr,
    pub p_filesz: Elf64_Xword,
    pub p_memsz: Elf64_Xword,
    pub p_align: Elf64_Xword,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dyn_inf {
    pub dynamic: *mut Section,
    pub dynstr: *mut Section,
    pub c2rust_unnamed: C2RustUnnamed_22,
    pub phdr: *mut Elf64_Phdr,
    pub phnum: libc::c_int,
    pub shnum: libc::c_int,
    pub interp: *mut Section,
    pub note: *mut Section,
    pub gnu_hash: *mut Section,
    pub _roinf: Section,
    pub roinf: *mut Section,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
    pub data_offset: libc::c_ulong,
    pub rel_addr: Elf64_Addr,
    pub rel_size: Elf64_Addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct eh_search_table {
    pub pc_offset: uint32_t,
    pub fde_offset: uint32_t,
}
pub const DW_EH_PE_datarel: C2RustUnnamed_49 = 48;
pub const DW_EH_PE_sdata4: C2RustUnnamed_49 = 11;
pub const DW_EH_PE_absptr: C2RustUnnamed_49 = 0;
pub type Elf32_Word = uint32_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub first: libc::c_int,
    pub last: libc::c_int,
}
pub const BUILD_GOT_ONLY: gotplt_entry = 1;
pub const AUTO_GOTPLT_ENTRY: gotplt_entry = 2;
pub const NO_GOTPLT_ENTRY: gotplt_entry = 0;
pub const ALWAYS_GOTPLT_ENTRY: gotplt_entry = 3;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sigaction {
    pub __sigaction_handler: C2RustUnnamed_24,
    pub sa_mask: __sigset_t,
    pub sa_flags: libc::c_int,
    pub sa_restorer: Option::<unsafe extern "C" fn() -> ()>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_24 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: Option::<
        unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct siginfo_t {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub __pad0: libc::c_int,
    pub _sifields: C2RustUnnamed_25,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_25 {
    pub _pad: [libc::c_int; 28],
    pub _kill: C2RustUnnamed_34,
    pub _timer: C2RustUnnamed_33,
    pub _rt: C2RustUnnamed_32,
    pub _sigchld: C2RustUnnamed_31,
    pub _sigfault: C2RustUnnamed_28,
    pub _sigpoll: C2RustUnnamed_27,
    pub _sigsys: C2RustUnnamed_26,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_26 {
    pub _call_addr: *mut libc::c_void,
    pub _syscall: libc::c_int,
    pub _arch: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_27 {
    pub si_band: libc::c_long,
    pub si_fd: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_28 {
    pub si_addr: *mut libc::c_void,
    pub si_addr_lsb: libc::c_short,
    pub _bounds: C2RustUnnamed_29,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_29 {
    pub _addr_bnd: C2RustUnnamed_30,
    pub _pkey: __uint32_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_30 {
    pub _lower: *mut libc::c_void,
    pub _upper: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_31 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: libc::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_32 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_33 {
    pub si_tid: libc::c_int,
    pub si_overrun: libc::c_int,
    pub si_sigval: __sigval_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_34 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rt_frame {
    pub ip: Elf64_Addr,
    pub fp: Elf64_Addr,
    pub sp: Elf64_Addr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct bt_info {
    pub file: [libc::c_char; 100],
    pub line: libc::c_int,
    pub func: [libc::c_char; 100],
    pub func_pc: Elf64_Addr,
}
pub const DW_LNS_fixed_advance_pc: C2RustUnnamed_46 = 9;
pub const DW_LNS_const_add_pc: C2RustUnnamed_46 = 8;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_35 {
    pub dir_entry: libc::c_uint,
    pub name: *mut libc::c_char,
}
pub const DW_LNE_define_file: C2RustUnnamed_47 = 3;
pub const DW_FORM_data16: C2RustUnnamed_41 = 30;
pub const DW_FORM_data2: C2RustUnnamed_41 = 5;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_36 {
    pub type_0: libc::c_uint,
    pub form: libc::c_uint,
}
pub const FPE_FLTDIV: C2RustUnnamed_51 = 3;
pub const FPE_INTDIV: C2RustUnnamed_51 = 1;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ucontext_t {
    pub uc_flags: libc::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [libc::c_ulonglong; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8],
    pub _xmm: [_libc_xmmreg; 16],
    pub __glibc_reserved1: [__uint32_t; 24],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _libc_fpxreg {
    pub significand: [libc::c_ushort; 4],
    pub exponent: libc::c_ushort,
    pub __glibc_reserved1: [libc::c_ushort; 3],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [libc::c_ulonglong; 8],
}
pub type fpregset_t = *mut _libc_fpstate;
pub type gregset_t = [greg_t; 23];
pub type greg_t = libc::c_longlong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stack_t {
    pub ss_sp: *mut libc::c_void,
    pub ss_flags: libc::c_int,
    pub ss_size: size_t,
}
pub const REG_RBP: C2RustUnnamed_52 = 10;
pub const REG_RIP: C2RustUnnamed_52 = 16;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_37 {
    pub secs: *mut *mut Section,
    pub nb_secs: libc::c_int,
}
pub type __stab_debug_code = libc::c_uint;
pub const LAST_UNUSED_STAB_CODE: __stab_debug_code = 255;
pub const N_LENG: __stab_debug_code = 254;
pub const N_NBLCS: __stab_debug_code = 248;
pub const N_NBSTS: __stab_debug_code = 246;
pub const N_NBBSS: __stab_debug_code = 244;
pub const N_NBDATA: __stab_debug_code = 242;
pub const N_NBTEXT: __stab_debug_code = 240;
pub const N_ECOML: __stab_debug_code = 232;
pub const N_ECOMM: __stab_debug_code = 228;
pub const N_BCOMM: __stab_debug_code = 226;
pub const N_SCOPE: __stab_debug_code = 196;
pub const N_EXCL: __stab_debug_code = 194;
pub const N_ENTRY: __stab_debug_code = 164;
pub const N_SSYM: __stab_debug_code = 96;
pub const N_CATCH: __stab_debug_code = 84;
pub const N_MOD2: __stab_debug_code = 80;
pub const N_EHDECL: __stab_debug_code = 80;
pub const N_DEFD: __stab_debug_code = 74;
pub const N_BROWS: __stab_debug_code = 72;
pub const N_BSLINE: __stab_debug_code = 72;
pub const N_DSLINE: __stab_debug_code = 70;
pub const N_M2C: __stab_debug_code = 66;
pub const N_RSYM: __stab_debug_code = 64;
pub const N_OPT: __stab_debug_code = 60;
pub const N_OBJ: __stab_debug_code = 56;
pub const N_NOMAP: __stab_debug_code = 52;
pub const N_NSYMS: __stab_debug_code = 50;
pub const N_PC: __stab_debug_code = 48;
pub const N_MAIN: __stab_debug_code = 42;
pub const N_FNAME: __stab_debug_code = 34;
pub type C2RustUnnamed_38 = libc::c_uint;
pub const DW_UT_hi_user: C2RustUnnamed_38 = 255;
pub const DW_UT_lo_user: C2RustUnnamed_38 = 128;
pub const DW_UT_split_type: C2RustUnnamed_38 = 6;
pub const DW_UT_split_compile: C2RustUnnamed_38 = 5;
pub const DW_UT_skeleton: C2RustUnnamed_38 = 4;
pub const DW_UT_partial: C2RustUnnamed_38 = 3;
pub const DW_UT_type: C2RustUnnamed_38 = 2;
pub type C2RustUnnamed_39 = libc::c_uint;
pub const DW_TAG_hi_user: C2RustUnnamed_39 = 65535;
pub const DW_TAG_GNU_call_site_parameter: C2RustUnnamed_39 = 16650;
pub const DW_TAG_GNU_call_site: C2RustUnnamed_39 = 16649;
pub const DW_TAG_GNU_formal_parameter_pack: C2RustUnnamed_39 = 16648;
pub const DW_TAG_GNU_template_parameter_pack: C2RustUnnamed_39 = 16647;
pub const DW_TAG_GNU_template_template_param: C2RustUnnamed_39 = 16646;
pub const DW_TAG_GNU_EINCL: C2RustUnnamed_39 = 16645;
pub const DW_TAG_GNU_BINCL: C2RustUnnamed_39 = 16644;
pub const DW_TAG_class_template: C2RustUnnamed_39 = 16643;
pub const DW_TAG_function_template: C2RustUnnamed_39 = 16642;
pub const DW_TAG_format_label: C2RustUnnamed_39 = 16641;
pub const DW_TAG_MIPS_loop: C2RustUnnamed_39 = 16513;
pub const DW_TAG_lo_user: C2RustUnnamed_39 = 16512;
pub const DW_TAG_immutable_type: C2RustUnnamed_39 = 75;
pub const DW_TAG_skeleton_unit: C2RustUnnamed_39 = 74;
pub const DW_TAG_call_site_parameter: C2RustUnnamed_39 = 73;
pub const DW_TAG_call_site: C2RustUnnamed_39 = 72;
pub const DW_TAG_atomic_type: C2RustUnnamed_39 = 71;
pub const DW_TAG_dynamic_type: C2RustUnnamed_39 = 70;
pub const DW_TAG_generic_subrange: C2RustUnnamed_39 = 69;
pub const DW_TAG_coarray_type: C2RustUnnamed_39 = 68;
pub const DW_TAG_template_alias: C2RustUnnamed_39 = 67;
pub const DW_TAG_rvalue_reference_type: C2RustUnnamed_39 = 66;
pub const DW_TAG_type_unit: C2RustUnnamed_39 = 65;
pub const DW_TAG_shared_type: C2RustUnnamed_39 = 64;
pub const DW_TAG_condition: C2RustUnnamed_39 = 63;
pub const DW_TAG_imported_unit: C2RustUnnamed_39 = 61;
pub const DW_TAG_partial_unit: C2RustUnnamed_39 = 60;
pub const DW_TAG_unspecified_type: C2RustUnnamed_39 = 59;
pub const DW_TAG_imported_module: C2RustUnnamed_39 = 58;
pub const DW_TAG_namespace: C2RustUnnamed_39 = 57;
pub const DW_TAG_interface_type: C2RustUnnamed_39 = 56;
pub const DW_TAG_restrict_type: C2RustUnnamed_39 = 55;
pub const DW_TAG_dwarf_procedure: C2RustUnnamed_39 = 54;
pub const DW_TAG_volatile_type: C2RustUnnamed_39 = 53;
pub const DW_TAG_variant_part: C2RustUnnamed_39 = 51;
pub const DW_TAG_try_block: C2RustUnnamed_39 = 50;
pub const DW_TAG_thrown_type: C2RustUnnamed_39 = 49;
pub const DW_TAG_template_value_parameter: C2RustUnnamed_39 = 48;
pub const DW_TAG_template_type_parameter: C2RustUnnamed_39 = 47;
pub const DW_TAG_packed_type: C2RustUnnamed_39 = 45;
pub const DW_TAG_namelist_item: C2RustUnnamed_39 = 44;
pub const DW_TAG_namelist: C2RustUnnamed_39 = 43;
pub const DW_TAG_friend: C2RustUnnamed_39 = 42;
pub const DW_TAG_file_type: C2RustUnnamed_39 = 41;
pub const DW_TAG_constant: C2RustUnnamed_39 = 39;
pub const DW_TAG_const_type: C2RustUnnamed_39 = 38;
pub const DW_TAG_catch_block: C2RustUnnamed_39 = 37;
pub const DW_TAG_access_declaration: C2RustUnnamed_39 = 35;
pub const DW_TAG_with_stmt: C2RustUnnamed_39 = 34;
pub const DW_TAG_set_type: C2RustUnnamed_39 = 32;
pub const DW_TAG_ptr_to_member_type: C2RustUnnamed_39 = 31;
pub const DW_TAG_module: C2RustUnnamed_39 = 30;
pub const DW_TAG_inlined_subroutine: C2RustUnnamed_39 = 29;
pub const DW_TAG_inheritance: C2RustUnnamed_39 = 28;
pub const DW_TAG_common_inclusion: C2RustUnnamed_39 = 27;
pub const DW_TAG_common_block: C2RustUnnamed_39 = 26;
pub const DW_TAG_variant: C2RustUnnamed_39 = 25;
pub const DW_TAG_unspecified_parameters: C2RustUnnamed_39 = 24;
pub const DW_TAG_string_type: C2RustUnnamed_39 = 18;
pub const DW_TAG_reference_type: C2RustUnnamed_39 = 16;
pub const DW_TAG_label: C2RustUnnamed_39 = 10;
pub const DW_TAG_imported_declaration: C2RustUnnamed_39 = 8;
pub const DW_TAG_entry_point: C2RustUnnamed_39 = 3;
pub const DW_TAG_class_type: C2RustUnnamed_39 = 2;
pub type C2RustUnnamed_40 = libc::c_uint;
pub const DW_AT_hi_user: C2RustUnnamed_40 = 16383;
pub const DW_AT_GNU_bias: C2RustUnnamed_40 = 8965;
pub const DW_AT_GNU_denominator: C2RustUnnamed_40 = 8964;
pub const DW_AT_GNU_numerator: C2RustUnnamed_40 = 8963;
pub const DW_AT_GNU_pubtypes: C2RustUnnamed_40 = 8501;
pub const DW_AT_GNU_pubnames: C2RustUnnamed_40 = 8500;
pub const DW_AT_GNU_addr_base: C2RustUnnamed_40 = 8499;
pub const DW_AT_GNU_ranges_base: C2RustUnnamed_40 = 8498;
pub const DW_AT_GNU_dwo_id: C2RustUnnamed_40 = 8497;
pub const DW_AT_GNU_dwo_name: C2RustUnnamed_40 = 8496;
pub const DW_AT_GNU_deleted: C2RustUnnamed_40 = 8474;
pub const DW_AT_GNU_macros: C2RustUnnamed_40 = 8473;
pub const DW_AT_GNU_entry_view: C2RustUnnamed_40 = 8504;
pub const DW_AT_GNU_locviews: C2RustUnnamed_40 = 8503;
pub const DW_AT_GNU_all_source_call_sites: C2RustUnnamed_40 = 8472;
pub const DW_AT_GNU_all_call_sites: C2RustUnnamed_40 = 8471;
pub const DW_AT_GNU_all_tail_call_sites: C2RustUnnamed_40 = 8470;
pub const DW_AT_GNU_tail_call: C2RustUnnamed_40 = 8469;
pub const DW_AT_GNU_call_site_target_clobbered: C2RustUnnamed_40 = 8468;
pub const DW_AT_GNU_call_site_target: C2RustUnnamed_40 = 8467;
pub const DW_AT_GNU_call_site_data_value: C2RustUnnamed_40 = 8466;
pub const DW_AT_GNU_call_site_value: C2RustUnnamed_40 = 8465;
pub const DW_AT_GNU_template_name: C2RustUnnamed_40 = 8464;
pub const DW_AT_GNU_odr_signature: C2RustUnnamed_40 = 8463;
pub const DW_AT_GNU_shared_locks_required: C2RustUnnamed_40 = 8462;
pub const DW_AT_GNU_exclusive_locks_required: C2RustUnnamed_40 = 8461;
pub const DW_AT_GNU_locks_excluded: C2RustUnnamed_40 = 8460;
pub const DW_AT_GNU_pt_guarded: C2RustUnnamed_40 = 8459;
pub const DW_AT_GNU_guarded: C2RustUnnamed_40 = 8458;
pub const DW_AT_GNU_pt_guarded_by: C2RustUnnamed_40 = 8457;
pub const DW_AT_GNU_guarded_by: C2RustUnnamed_40 = 8456;
pub const DW_AT_GNU_vector: C2RustUnnamed_40 = 8455;
pub const DW_AT_body_end: C2RustUnnamed_40 = 8454;
pub const DW_AT_body_begin: C2RustUnnamed_40 = 8453;
pub const DW_AT_src_coords: C2RustUnnamed_40 = 8452;
pub const DW_AT_mac_info: C2RustUnnamed_40 = 8451;
pub const DW_AT_src_info: C2RustUnnamed_40 = 8450;
pub const DW_AT_sf_names: C2RustUnnamed_40 = 8449;
pub const DW_AT_MIPS_assumed_size: C2RustUnnamed_40 = 8209;
pub const DW_AT_MIPS_assumed_shape_dopetype: C2RustUnnamed_40 = 8208;
pub const DW_AT_MIPS_allocatable_dopetype: C2RustUnnamed_40 = 8207;
pub const DW_AT_MIPS_ptr_dopetype: C2RustUnnamed_40 = 8206;
pub const DW_AT_MIPS_stride_elem: C2RustUnnamed_40 = 8205;
pub const DW_AT_MIPS_stride_byte: C2RustUnnamed_40 = 8204;
pub const DW_AT_MIPS_has_inlines: C2RustUnnamed_40 = 8203;
pub const DW_AT_MIPS_clone_origin: C2RustUnnamed_40 = 8202;
pub const DW_AT_MIPS_abstract_name: C2RustUnnamed_40 = 8201;
pub const DW_AT_MIPS_stride: C2RustUnnamed_40 = 8200;
pub const DW_AT_MIPS_linkage_name: C2RustUnnamed_40 = 8199;
pub const DW_AT_MIPS_software_pipeline_depth: C2RustUnnamed_40 = 8198;
pub const DW_AT_MIPS_loop_unroll_factor: C2RustUnnamed_40 = 8197;
pub const DW_AT_MIPS_epilog_begin: C2RustUnnamed_40 = 8196;
pub const DW_AT_MIPS_tail_loop_begin: C2RustUnnamed_40 = 8195;
pub const DW_AT_MIPS_loop_begin: C2RustUnnamed_40 = 8194;
pub const DW_AT_MIPS_fde: C2RustUnnamed_40 = 8193;
pub const DW_AT_lo_user: C2RustUnnamed_40 = 8192;
pub const DW_AT_loclists_base: C2RustUnnamed_40 = 140;
pub const DW_AT_defaulted: C2RustUnnamed_40 = 139;
pub const DW_AT_deleted: C2RustUnnamed_40 = 138;
pub const DW_AT_export_symbols: C2RustUnnamed_40 = 137;
pub const DW_AT_alignment: C2RustUnnamed_40 = 136;
pub const DW_AT_noreturn: C2RustUnnamed_40 = 135;
pub const DW_AT_call_data_value: C2RustUnnamed_40 = 134;
pub const DW_AT_call_data_location: C2RustUnnamed_40 = 133;
pub const DW_AT_call_target_clobbered: C2RustUnnamed_40 = 132;
pub const DW_AT_call_target: C2RustUnnamed_40 = 131;
pub const DW_AT_call_tail_call: C2RustUnnamed_40 = 130;
pub const DW_AT_call_pc: C2RustUnnamed_40 = 129;
pub const DW_AT_call_parameter: C2RustUnnamed_40 = 128;
pub const DW_AT_call_origin: C2RustUnnamed_40 = 127;
pub const DW_AT_call_value: C2RustUnnamed_40 = 126;
pub const DW_AT_call_return_pc: C2RustUnnamed_40 = 125;
pub const DW_AT_call_all_tail_calls: C2RustUnnamed_40 = 124;
pub const DW_AT_call_all_source_calls: C2RustUnnamed_40 = 123;
pub const DW_AT_call_all_calls: C2RustUnnamed_40 = 122;
pub const DW_AT_macros: C2RustUnnamed_40 = 121;
pub const DW_AT_rvalue_reference: C2RustUnnamed_40 = 120;
pub const DW_AT_reference: C2RustUnnamed_40 = 119;
pub const DW_AT_dwo_name: C2RustUnnamed_40 = 118;
pub const DW_AT_rnglists_base: C2RustUnnamed_40 = 116;
pub const DW_AT_addr_base: C2RustUnnamed_40 = 115;
pub const DW_AT_str_offsets_base: C2RustUnnamed_40 = 114;
pub const DW_AT_rank: C2RustUnnamed_40 = 113;
pub const DW_AT_string_length_byte_size: C2RustUnnamed_40 = 112;
pub const DW_AT_string_length_bit_size: C2RustUnnamed_40 = 111;
pub const DW_AT_linkage_name: C2RustUnnamed_40 = 110;
pub const DW_AT_enum_class: C2RustUnnamed_40 = 109;
pub const DW_AT_const_expr: C2RustUnnamed_40 = 108;
pub const DW_AT_main_subprogram: C2RustUnnamed_40 = 106;
pub const DW_AT_signature: C2RustUnnamed_40 = 105;
pub const DW_AT_recursive: C2RustUnnamed_40 = 104;
pub const DW_AT_pure: C2RustUnnamed_40 = 103;
pub const DW_AT_elemental: C2RustUnnamed_40 = 102;
pub const DW_AT_endianity: C2RustUnnamed_40 = 101;
pub const DW_AT_object_pointer: C2RustUnnamed_40 = 100;
pub const DW_AT_explicit: C2RustUnnamed_40 = 99;
pub const DW_AT_threads_scaled: C2RustUnnamed_40 = 98;
pub const DW_AT_mutable: C2RustUnnamed_40 = 97;
pub const DW_AT_picture_string: C2RustUnnamed_40 = 96;
pub const DW_AT_digit_count: C2RustUnnamed_40 = 95;
pub const DW_AT_decimal_sign: C2RustUnnamed_40 = 94;
pub const DW_AT_small: C2RustUnnamed_40 = 93;
pub const DW_AT_decimal_scale: C2RustUnnamed_40 = 92;
pub const DW_AT_binary_scale: C2RustUnnamed_40 = 91;
pub const DW_AT_description: C2RustUnnamed_40 = 90;
pub const DW_AT_call_line: C2RustUnnamed_40 = 89;
pub const DW_AT_call_file: C2RustUnnamed_40 = 88;
pub const DW_AT_call_column: C2RustUnnamed_40 = 87;
pub const DW_AT_trampoline: C2RustUnnamed_40 = 86;
pub const DW_AT_ranges: C2RustUnnamed_40 = 85;
pub const DW_AT_extension: C2RustUnnamed_40 = 84;
pub const DW_AT_use_UTF8: C2RustUnnamed_40 = 83;
pub const DW_AT_entry_pc: C2RustUnnamed_40 = 82;
pub const DW_AT_byte_stride: C2RustUnnamed_40 = 81;
pub const DW_AT_data_location: C2RustUnnamed_40 = 80;
pub const DW_AT_associated: C2RustUnnamed_40 = 79;
pub const DW_AT_allocated: C2RustUnnamed_40 = 78;
pub const DW_AT_vtable_elem_location: C2RustUnnamed_40 = 77;
pub const DW_AT_virtuality: C2RustUnnamed_40 = 76;
pub const DW_AT_variable_parameter: C2RustUnnamed_40 = 75;
pub const DW_AT_use_location: C2RustUnnamed_40 = 74;
pub const DW_AT_static_link: C2RustUnnamed_40 = 72;
pub const DW_AT_specification: C2RustUnnamed_40 = 71;
pub const DW_AT_segment: C2RustUnnamed_40 = 70;
pub const DW_AT_priority: C2RustUnnamed_40 = 69;
pub const DW_AT_namelist_item: C2RustUnnamed_40 = 68;
pub const DW_AT_macro_info: C2RustUnnamed_40 = 67;
pub const DW_AT_identifier_case: C2RustUnnamed_40 = 66;
pub const DW_AT_friend: C2RustUnnamed_40 = 65;
pub const DW_AT_discr_list: C2RustUnnamed_40 = 61;
pub const DW_AT_declaration: C2RustUnnamed_40 = 60;
pub const DW_AT_decl_column: C2RustUnnamed_40 = 57;
pub const DW_AT_count: C2RustUnnamed_40 = 55;
pub const DW_AT_calling_convention: C2RustUnnamed_40 = 54;
pub const DW_AT_base_types: C2RustUnnamed_40 = 53;
pub const DW_AT_artificial: C2RustUnnamed_40 = 52;
pub const DW_AT_address_class: C2RustUnnamed_40 = 51;
pub const DW_AT_accessibility: C2RustUnnamed_40 = 50;
pub const DW_AT_abstract_origin: C2RustUnnamed_40 = 49;
pub const DW_AT_bit_stride: C2RustUnnamed_40 = 46;
pub const DW_AT_start_scope: C2RustUnnamed_40 = 44;
pub const DW_AT_return_addr: C2RustUnnamed_40 = 42;
pub const DW_AT_prototyped: C2RustUnnamed_40 = 39;
pub const DW_AT_lower_bound: C2RustUnnamed_40 = 34;
pub const DW_AT_is_optional: C2RustUnnamed_40 = 33;
pub const DW_AT_inline: C2RustUnnamed_40 = 32;
pub const DW_AT_default_value: C2RustUnnamed_40 = 30;
pub const DW_AT_containing_type: C2RustUnnamed_40 = 29;
pub const DW_AT_common_reference: C2RustUnnamed_40 = 26;
pub const DW_AT_string_length: C2RustUnnamed_40 = 25;
pub const DW_AT_import: C2RustUnnamed_40 = 24;
pub const DW_AT_visibility: C2RustUnnamed_40 = 23;
pub const DW_AT_discr_value: C2RustUnnamed_40 = 22;
pub const DW_AT_discr: C2RustUnnamed_40 = 21;
pub const DW_AT_bit_offset: C2RustUnnamed_40 = 12;
pub const DW_AT_ordering: C2RustUnnamed_40 = 9;
pub type C2RustUnnamed_41 = libc::c_uint;
pub const DW_FORM_GNU_strp_alt: C2RustUnnamed_41 = 7969;
pub const DW_FORM_GNU_ref_alt: C2RustUnnamed_41 = 7968;
pub const DW_FORM_GNU_str_index: C2RustUnnamed_41 = 7938;
pub const DW_FORM_GNU_addr_index: C2RustUnnamed_41 = 7937;
pub const DW_FORM_addrx4: C2RustUnnamed_41 = 44;
pub const DW_FORM_addrx3: C2RustUnnamed_41 = 43;
pub const DW_FORM_addrx2: C2RustUnnamed_41 = 42;
pub const DW_FORM_addrx1: C2RustUnnamed_41 = 41;
pub const DW_FORM_strx4: C2RustUnnamed_41 = 40;
pub const DW_FORM_strx3: C2RustUnnamed_41 = 39;
pub const DW_FORM_strx2: C2RustUnnamed_41 = 38;
pub const DW_FORM_strx1: C2RustUnnamed_41 = 37;
pub const DW_FORM_ref_sup8: C2RustUnnamed_41 = 36;
pub const DW_FORM_rnglistx: C2RustUnnamed_41 = 35;
pub const DW_FORM_loclistx: C2RustUnnamed_41 = 34;
pub const DW_FORM_implicit_const: C2RustUnnamed_41 = 33;
pub const DW_FORM_ref_sig8: C2RustUnnamed_41 = 32;
pub const DW_FORM_strp_sup: C2RustUnnamed_41 = 29;
pub const DW_FORM_ref_sup4: C2RustUnnamed_41 = 28;
pub const DW_FORM_addrx: C2RustUnnamed_41 = 27;
pub const DW_FORM_strx: C2RustUnnamed_41 = 26;
pub const DW_FORM_flag_present: C2RustUnnamed_41 = 25;
pub const DW_FORM_indirect: C2RustUnnamed_41 = 22;
pub const DW_FORM_ref_udata: C2RustUnnamed_41 = 21;
pub const DW_FORM_ref8: C2RustUnnamed_41 = 20;
pub const DW_FORM_ref2: C2RustUnnamed_41 = 18;
pub const DW_FORM_ref1: C2RustUnnamed_41 = 17;
pub const DW_FORM_ref_addr: C2RustUnnamed_41 = 16;
pub const DW_FORM_block: C2RustUnnamed_41 = 9;
pub const DW_FORM_string: C2RustUnnamed_41 = 8;
pub const DW_FORM_block4: C2RustUnnamed_41 = 4;
pub const DW_FORM_block2: C2RustUnnamed_41 = 3;
pub type C2RustUnnamed_42 = libc::c_uint;
pub const DW_OP_hi_user: C2RustUnnamed_42 = 255;
pub const DW_OP_lo_user: C2RustUnnamed_42 = 224;
pub const DW_OP_GNU_variable_value: C2RustUnnamed_42 = 253;
pub const DW_OP_GNU_const_index: C2RustUnnamed_42 = 252;
pub const DW_OP_GNU_addr_index: C2RustUnnamed_42 = 251;
pub const DW_OP_GNU_parameter_ref: C2RustUnnamed_42 = 250;
pub const DW_OP_GNU_reinterpret: C2RustUnnamed_42 = 249;
pub const DW_OP_GNU_convert: C2RustUnnamed_42 = 247;
pub const DW_OP_GNU_deref_type: C2RustUnnamed_42 = 246;
pub const DW_OP_GNU_regval_type: C2RustUnnamed_42 = 245;
pub const DW_OP_GNU_const_type: C2RustUnnamed_42 = 244;
pub const DW_OP_GNU_entry_value: C2RustUnnamed_42 = 243;
pub const DW_OP_GNU_implicit_pointer: C2RustUnnamed_42 = 242;
pub const DW_OP_GNU_encoded_addr: C2RustUnnamed_42 = 241;
pub const DW_OP_GNU_uninit: C2RustUnnamed_42 = 240;
pub const DW_OP_GNU_push_tls_address: C2RustUnnamed_42 = 224;
pub const DW_OP_reinterpret: C2RustUnnamed_42 = 169;
pub const DW_OP_convert: C2RustUnnamed_42 = 168;
pub const DW_OP_xderef_type: C2RustUnnamed_42 = 167;
pub const DW_OP_deref_type: C2RustUnnamed_42 = 166;
pub const DW_OP_regval_type: C2RustUnnamed_42 = 165;
pub const DW_OP_const_type: C2RustUnnamed_42 = 164;
pub const DW_OP_entry_value: C2RustUnnamed_42 = 163;
pub const DW_OP_constx: C2RustUnnamed_42 = 162;
pub const DW_OP_addrx: C2RustUnnamed_42 = 161;
pub const DW_OP_implicit_pointer: C2RustUnnamed_42 = 160;
pub const DW_OP_stack_value: C2RustUnnamed_42 = 159;
pub const DW_OP_implicit_value: C2RustUnnamed_42 = 158;
pub const DW_OP_bit_piece: C2RustUnnamed_42 = 157;
pub const DW_OP_call_frame_cfa: C2RustUnnamed_42 = 156;
pub const DW_OP_form_tls_address: C2RustUnnamed_42 = 155;
pub const DW_OP_call_ref: C2RustUnnamed_42 = 154;
pub const DW_OP_call4: C2RustUnnamed_42 = 153;
pub const DW_OP_call2: C2RustUnnamed_42 = 152;
pub const DW_OP_push_object_address: C2RustUnnamed_42 = 151;
pub const DW_OP_nop: C2RustUnnamed_42 = 150;
pub const DW_OP_xderef_size: C2RustUnnamed_42 = 149;
pub const DW_OP_deref_size: C2RustUnnamed_42 = 148;
pub const DW_OP_piece: C2RustUnnamed_42 = 147;
pub const DW_OP_bregx: C2RustUnnamed_42 = 146;
pub const DW_OP_regx: C2RustUnnamed_42 = 144;
pub const DW_OP_breg31: C2RustUnnamed_42 = 143;
pub const DW_OP_breg30: C2RustUnnamed_42 = 142;
pub const DW_OP_breg29: C2RustUnnamed_42 = 141;
pub const DW_OP_breg28: C2RustUnnamed_42 = 140;
pub const DW_OP_breg27: C2RustUnnamed_42 = 139;
pub const DW_OP_breg26: C2RustUnnamed_42 = 138;
pub const DW_OP_breg25: C2RustUnnamed_42 = 137;
pub const DW_OP_breg24: C2RustUnnamed_42 = 136;
pub const DW_OP_breg23: C2RustUnnamed_42 = 135;
pub const DW_OP_breg22: C2RustUnnamed_42 = 134;
pub const DW_OP_breg21: C2RustUnnamed_42 = 133;
pub const DW_OP_breg20: C2RustUnnamed_42 = 132;
pub const DW_OP_breg19: C2RustUnnamed_42 = 131;
pub const DW_OP_breg18: C2RustUnnamed_42 = 130;
pub const DW_OP_breg17: C2RustUnnamed_42 = 129;
pub const DW_OP_breg16: C2RustUnnamed_42 = 128;
pub const DW_OP_breg15: C2RustUnnamed_42 = 127;
pub const DW_OP_breg14: C2RustUnnamed_42 = 126;
pub const DW_OP_breg13: C2RustUnnamed_42 = 125;
pub const DW_OP_breg12: C2RustUnnamed_42 = 124;
pub const DW_OP_breg11: C2RustUnnamed_42 = 123;
pub const DW_OP_breg10: C2RustUnnamed_42 = 122;
pub const DW_OP_breg9: C2RustUnnamed_42 = 121;
pub const DW_OP_breg8: C2RustUnnamed_42 = 120;
pub const DW_OP_breg7: C2RustUnnamed_42 = 119;
pub const DW_OP_breg6: C2RustUnnamed_42 = 118;
pub const DW_OP_breg5: C2RustUnnamed_42 = 117;
pub const DW_OP_breg4: C2RustUnnamed_42 = 116;
pub const DW_OP_breg3: C2RustUnnamed_42 = 115;
pub const DW_OP_breg2: C2RustUnnamed_42 = 114;
pub const DW_OP_breg1: C2RustUnnamed_42 = 113;
pub const DW_OP_breg0: C2RustUnnamed_42 = 112;
pub const DW_OP_reg31: C2RustUnnamed_42 = 111;
pub const DW_OP_reg30: C2RustUnnamed_42 = 110;
pub const DW_OP_reg29: C2RustUnnamed_42 = 109;
pub const DW_OP_reg28: C2RustUnnamed_42 = 108;
pub const DW_OP_reg27: C2RustUnnamed_42 = 107;
pub const DW_OP_reg26: C2RustUnnamed_42 = 106;
pub const DW_OP_reg25: C2RustUnnamed_42 = 105;
pub const DW_OP_reg24: C2RustUnnamed_42 = 104;
pub const DW_OP_reg23: C2RustUnnamed_42 = 103;
pub const DW_OP_reg22: C2RustUnnamed_42 = 102;
pub const DW_OP_reg21: C2RustUnnamed_42 = 101;
pub const DW_OP_reg20: C2RustUnnamed_42 = 100;
pub const DW_OP_reg19: C2RustUnnamed_42 = 99;
pub const DW_OP_reg18: C2RustUnnamed_42 = 98;
pub const DW_OP_reg17: C2RustUnnamed_42 = 97;
pub const DW_OP_reg16: C2RustUnnamed_42 = 96;
pub const DW_OP_reg15: C2RustUnnamed_42 = 95;
pub const DW_OP_reg14: C2RustUnnamed_42 = 94;
pub const DW_OP_reg13: C2RustUnnamed_42 = 93;
pub const DW_OP_reg12: C2RustUnnamed_42 = 92;
pub const DW_OP_reg11: C2RustUnnamed_42 = 91;
pub const DW_OP_reg10: C2RustUnnamed_42 = 90;
pub const DW_OP_reg9: C2RustUnnamed_42 = 89;
pub const DW_OP_reg8: C2RustUnnamed_42 = 88;
pub const DW_OP_reg7: C2RustUnnamed_42 = 87;
pub const DW_OP_reg5: C2RustUnnamed_42 = 85;
pub const DW_OP_reg4: C2RustUnnamed_42 = 84;
pub const DW_OP_reg3: C2RustUnnamed_42 = 83;
pub const DW_OP_reg2: C2RustUnnamed_42 = 82;
pub const DW_OP_reg1: C2RustUnnamed_42 = 81;
pub const DW_OP_reg0: C2RustUnnamed_42 = 80;
pub const DW_OP_lit31: C2RustUnnamed_42 = 79;
pub const DW_OP_lit30: C2RustUnnamed_42 = 78;
pub const DW_OP_lit29: C2RustUnnamed_42 = 77;
pub const DW_OP_lit28: C2RustUnnamed_42 = 76;
pub const DW_OP_lit27: C2RustUnnamed_42 = 75;
pub const DW_OP_lit26: C2RustUnnamed_42 = 74;
pub const DW_OP_lit25: C2RustUnnamed_42 = 73;
pub const DW_OP_lit24: C2RustUnnamed_42 = 72;
pub const DW_OP_lit23: C2RustUnnamed_42 = 71;
pub const DW_OP_lit22: C2RustUnnamed_42 = 70;
pub const DW_OP_lit21: C2RustUnnamed_42 = 69;
pub const DW_OP_lit20: C2RustUnnamed_42 = 68;
pub const DW_OP_lit19: C2RustUnnamed_42 = 67;
pub const DW_OP_lit18: C2RustUnnamed_42 = 66;
pub const DW_OP_lit17: C2RustUnnamed_42 = 65;
pub const DW_OP_lit16: C2RustUnnamed_42 = 64;
pub const DW_OP_lit15: C2RustUnnamed_42 = 63;
pub const DW_OP_lit14: C2RustUnnamed_42 = 62;
pub const DW_OP_lit13: C2RustUnnamed_42 = 61;
pub const DW_OP_lit12: C2RustUnnamed_42 = 60;
pub const DW_OP_lit11: C2RustUnnamed_42 = 59;
pub const DW_OP_lit10: C2RustUnnamed_42 = 58;
pub const DW_OP_lit9: C2RustUnnamed_42 = 57;
pub const DW_OP_lit8: C2RustUnnamed_42 = 56;
pub const DW_OP_lit7: C2RustUnnamed_42 = 55;
pub const DW_OP_lit6: C2RustUnnamed_42 = 54;
pub const DW_OP_lit5: C2RustUnnamed_42 = 53;
pub const DW_OP_lit4: C2RustUnnamed_42 = 52;
pub const DW_OP_lit3: C2RustUnnamed_42 = 51;
pub const DW_OP_lit2: C2RustUnnamed_42 = 50;
pub const DW_OP_lit1: C2RustUnnamed_42 = 49;
pub const DW_OP_lit0: C2RustUnnamed_42 = 48;
pub const DW_OP_skip: C2RustUnnamed_42 = 47;
pub const DW_OP_ne: C2RustUnnamed_42 = 46;
pub const DW_OP_lt: C2RustUnnamed_42 = 45;
pub const DW_OP_le: C2RustUnnamed_42 = 44;
pub const DW_OP_gt: C2RustUnnamed_42 = 43;
pub const DW_OP_ge: C2RustUnnamed_42 = 42;
pub const DW_OP_eq: C2RustUnnamed_42 = 41;
pub const DW_OP_bra: C2RustUnnamed_42 = 40;
pub const DW_OP_xor: C2RustUnnamed_42 = 39;
pub const DW_OP_shra: C2RustUnnamed_42 = 38;
pub const DW_OP_shr: C2RustUnnamed_42 = 37;
pub const DW_OP_shl: C2RustUnnamed_42 = 36;
pub const DW_OP_plus_uconst: C2RustUnnamed_42 = 35;
pub const DW_OP_plus: C2RustUnnamed_42 = 34;
pub const DW_OP_or: C2RustUnnamed_42 = 33;
pub const DW_OP_not: C2RustUnnamed_42 = 32;
pub const DW_OP_neg: C2RustUnnamed_42 = 31;
pub const DW_OP_mul: C2RustUnnamed_42 = 30;
pub const DW_OP_mod: C2RustUnnamed_42 = 29;
pub const DW_OP_minus: C2RustUnnamed_42 = 28;
pub const DW_OP_div: C2RustUnnamed_42 = 27;
pub const DW_OP_and: C2RustUnnamed_42 = 26;
pub const DW_OP_abs: C2RustUnnamed_42 = 25;
pub const DW_OP_xderef: C2RustUnnamed_42 = 24;
pub const DW_OP_rot: C2RustUnnamed_42 = 23;
pub const DW_OP_swap: C2RustUnnamed_42 = 22;
pub const DW_OP_pick: C2RustUnnamed_42 = 21;
pub const DW_OP_over: C2RustUnnamed_42 = 20;
pub const DW_OP_drop: C2RustUnnamed_42 = 19;
pub const DW_OP_dup: C2RustUnnamed_42 = 18;
pub const DW_OP_consts: C2RustUnnamed_42 = 17;
pub const DW_OP_constu: C2RustUnnamed_42 = 16;
pub const DW_OP_const8s: C2RustUnnamed_42 = 15;
pub const DW_OP_const8u: C2RustUnnamed_42 = 14;
pub const DW_OP_const4s: C2RustUnnamed_42 = 13;
pub const DW_OP_const4u: C2RustUnnamed_42 = 12;
pub const DW_OP_const2s: C2RustUnnamed_42 = 11;
pub const DW_OP_const2u: C2RustUnnamed_42 = 10;
pub const DW_OP_const1s: C2RustUnnamed_42 = 9;
pub const DW_OP_const1u: C2RustUnnamed_42 = 8;
pub const DW_OP_deref: C2RustUnnamed_42 = 6;
pub type C2RustUnnamed_43 = libc::c_uint;
pub const DW_ATE_hi_user: C2RustUnnamed_43 = 255;
pub const DW_ATE_lo_user: C2RustUnnamed_43 = 128;
pub const DW_ATE_ASCII: C2RustUnnamed_43 = 18;
pub const DW_ATE_UCS: C2RustUnnamed_43 = 17;
pub const DW_ATE_UTF: C2RustUnnamed_43 = 16;
pub const DW_ATE_decimal_float: C2RustUnnamed_43 = 15;
pub const DW_ATE_unsigned_fixed: C2RustUnnamed_43 = 14;
pub const DW_ATE_signed_fixed: C2RustUnnamed_43 = 13;
pub const DW_ATE_edited: C2RustUnnamed_43 = 12;
pub const DW_ATE_numeric_string: C2RustUnnamed_43 = 11;
pub const DW_ATE_packed_decimal: C2RustUnnamed_43 = 10;
pub const DW_ATE_imaginary_float: C2RustUnnamed_43 = 9;
pub const DW_ATE_complex_float: C2RustUnnamed_43 = 3;
pub const DW_ATE_address: C2RustUnnamed_43 = 1;
pub const DW_ATE_void: C2RustUnnamed_43 = 0;
pub type C2RustUnnamed_44 = libc::c_uint;
pub const DW_LANG_hi_user: C2RustUnnamed_44 = 65535;
pub const DW_LANG_Mips_Assembler: C2RustUnnamed_44 = 32769;
pub const DW_LANG_lo_user: C2RustUnnamed_44 = 32768;
pub const DW_LANG_BLISS: C2RustUnnamed_44 = 37;
pub const DW_LANG_RenderScript: C2RustUnnamed_44 = 36;
pub const DW_LANG_Fortran08: C2RustUnnamed_44 = 35;
pub const DW_LANG_Fortran03: C2RustUnnamed_44 = 34;
pub const DW_LANG_C_plus_plus_14: C2RustUnnamed_44 = 33;
pub const DW_LANG_Dylan: C2RustUnnamed_44 = 32;
pub const DW_LANG_Julia: C2RustUnnamed_44 = 31;
pub const DW_LANG_Swift: C2RustUnnamed_44 = 30;
pub const DW_LANG_Rust: C2RustUnnamed_44 = 28;
pub const DW_LANG_OCaml: C2RustUnnamed_44 = 27;
pub const DW_LANG_C_plus_plus_11: C2RustUnnamed_44 = 26;
pub const DW_LANG_C_plus_plus_03: C2RustUnnamed_44 = 25;
pub const DW_LANG_Haskell: C2RustUnnamed_44 = 24;
pub const DW_LANG_Modula3: C2RustUnnamed_44 = 23;
pub const DW_LANG_Go: C2RustUnnamed_44 = 22;
pub const DW_LANG_OpenCL: C2RustUnnamed_44 = 21;
pub const DW_LANG_Python: C2RustUnnamed_44 = 20;
pub const DW_LANG_D: C2RustUnnamed_44 = 19;
pub const DW_LANG_UPC: C2RustUnnamed_44 = 18;
pub const DW_LANG_ObjC_plus_plus: C2RustUnnamed_44 = 17;
pub const DW_LANG_ObjC: C2RustUnnamed_44 = 16;
pub const DW_LANG_PLI: C2RustUnnamed_44 = 15;
pub const DW_LANG_Fortran95: C2RustUnnamed_44 = 14;
pub const DW_LANG_Ada95: C2RustUnnamed_44 = 13;
pub const DW_LANG_Java: C2RustUnnamed_44 = 11;
pub const DW_LANG_Modula2: C2RustUnnamed_44 = 10;
pub const DW_LANG_Pascal83: C2RustUnnamed_44 = 9;
pub const DW_LANG_Fortran90: C2RustUnnamed_44 = 8;
pub const DW_LANG_Fortran77: C2RustUnnamed_44 = 7;
pub const DW_LANG_Cobol85: C2RustUnnamed_44 = 6;
pub const DW_LANG_Cobol74: C2RustUnnamed_44 = 5;
pub const DW_LANG_C_plus_plus: C2RustUnnamed_44 = 4;
pub const DW_LANG_Ada83: C2RustUnnamed_44 = 3;
pub const DW_LANG_C: C2RustUnnamed_44 = 2;
pub const DW_LANG_C89: C2RustUnnamed_44 = 1;
pub type C2RustUnnamed_45 = libc::c_uint;
pub const DW_LNCT_hi_user: C2RustUnnamed_45 = 16383;
pub const DW_LNCT_lo_user: C2RustUnnamed_45 = 8192;
pub const DW_LNCT_MD5: C2RustUnnamed_45 = 5;
pub const DW_LNCT_size: C2RustUnnamed_45 = 4;
pub const DW_LNCT_timestamp: C2RustUnnamed_45 = 3;
pub type C2RustUnnamed_46 = libc::c_uint;
pub const DW_LNS_set_isa: C2RustUnnamed_46 = 12;
pub const DW_LNS_set_basic_block: C2RustUnnamed_46 = 7;
pub const DW_LNS_negate_stmt: C2RustUnnamed_46 = 6;
pub const DW_LNS_set_column: C2RustUnnamed_46 = 5;
pub const DW_LNS_copy: C2RustUnnamed_46 = 1;
pub type C2RustUnnamed_47 = libc::c_uint;
pub const DW_LNE_NVIDIA_set_function_name: C2RustUnnamed_47 = 145;
pub const DW_LNE_NVIDIA_inlined_call: C2RustUnnamed_47 = 144;
pub const DW_LNE_lo_user: C2RustUnnamed_47 = 128;
pub const DW_LNE_set_discriminator: C2RustUnnamed_47 = 4;
pub type C2RustUnnamed_48 = libc::c_uint;
pub const DW_CFA_high_user: C2RustUnnamed_48 = 63;
pub const DW_CFA_GNU_negative_offset_extended: C2RustUnnamed_48 = 47;
pub const DW_CFA_GNU_args_size: C2RustUnnamed_48 = 46;
pub const DW_CFA_AARCH64_negate_ra_state: C2RustUnnamed_48 = 45;
pub const DW_CFA_GNU_window_save: C2RustUnnamed_48 = 45;
pub const DW_CFA_MIPS_advance_loc8: C2RustUnnamed_48 = 29;
pub const DW_CFA_low_user: C2RustUnnamed_48 = 28;
pub const DW_CFA_val_expression: C2RustUnnamed_48 = 22;
pub const DW_CFA_val_offset_sf: C2RustUnnamed_48 = 21;
pub const DW_CFA_val_offset: C2RustUnnamed_48 = 20;
pub const DW_CFA_def_cfa_offset_sf: C2RustUnnamed_48 = 19;
pub const DW_CFA_def_cfa_sf: C2RustUnnamed_48 = 18;
pub const DW_CFA_offset_extended_sf: C2RustUnnamed_48 = 17;
pub const DW_CFA_expression: C2RustUnnamed_48 = 16;
pub const DW_CFA_def_cfa_expression: C2RustUnnamed_48 = 15;
pub const DW_CFA_restore_state: C2RustUnnamed_48 = 11;
pub const DW_CFA_remember_state: C2RustUnnamed_48 = 10;
pub const DW_CFA_register: C2RustUnnamed_48 = 9;
pub const DW_CFA_same_value: C2RustUnnamed_48 = 8;
pub const DW_CFA_undefined: C2RustUnnamed_48 = 7;
pub const DW_CFA_restore_extended: C2RustUnnamed_48 = 6;
pub const DW_CFA_offset_extended: C2RustUnnamed_48 = 5;
pub const DW_CFA_advance_loc2: C2RustUnnamed_48 = 3;
pub const DW_CFA_advance_loc1: C2RustUnnamed_48 = 2;
pub const DW_CFA_set_loc: C2RustUnnamed_48 = 1;
pub const DW_CFA_extended: C2RustUnnamed_48 = 0;
pub const DW_CFA_restore: C2RustUnnamed_48 = 192;
pub type C2RustUnnamed_49 = libc::c_uint;
pub const DW_EH_PE_indirect: C2RustUnnamed_49 = 128;
pub const DW_EH_PE_aligned: C2RustUnnamed_49 = 80;
pub const DW_EH_PE_funcrel: C2RustUnnamed_49 = 64;
pub const DW_EH_PE_textrel: C2RustUnnamed_49 = 32;
pub const DW_EH_PE_sdata8: C2RustUnnamed_49 = 12;
pub const DW_EH_PE_sdata2: C2RustUnnamed_49 = 10;
pub const DW_EH_PE_sleb128: C2RustUnnamed_49 = 9;
pub const DW_EH_PE_udata8: C2RustUnnamed_49 = 4;
pub const DW_EH_PE_udata2: C2RustUnnamed_49 = 2;
pub const DW_EH_PE_uleb128: C2RustUnnamed_49 = 1;
pub const DW_EH_PE_omit: C2RustUnnamed_49 = 255;
pub type C2RustUnnamed_50 = libc::c_uint;
pub const TREG_XMM6: C2RustUnnamed_50 = 22;
pub const TREG_XMM5: C2RustUnnamed_50 = 21;
pub const TREG_XMM4: C2RustUnnamed_50 = 20;
pub const TREG_XMM3: C2RustUnnamed_50 = 19;
pub const TREG_XMM2: C2RustUnnamed_50 = 18;
pub const TREG_R10: C2RustUnnamed_50 = 10;
pub type tcc_token = libc::c_uint;
pub const TOK_ASM_fwait: tcc_token = 1142;
pub const TOK_ASM_fnop: tcc_token = 1141;
pub const TOK_ASM_fnclex: tcc_token = 1140;
pub const TOK_ASM_fninit: tcc_token = 1139;
pub const TOK_ASM_fabs: tcc_token = 1138;
pub const TOK_ASM_fchs: tcc_token = 1137;
pub const TOK_ASM_fcos: tcc_token = 1136;
pub const TOK_ASM_fsin: tcc_token = 1135;
pub const TOK_ASM_fscale: tcc_token = 1134;
pub const TOK_ASM_frndint: tcc_token = 1133;
pub const TOK_ASM_fsincos: tcc_token = 1132;
pub const TOK_ASM_fsqrt: tcc_token = 1131;
pub const TOK_ASM_fyl2xp1: tcc_token = 1130;
pub const TOK_ASM_fprem: tcc_token = 1129;
pub const TOK_ASM_fincstp: tcc_token = 1128;
pub const TOK_ASM_fdecstp: tcc_token = 1127;
pub const TOK_ASM_fprem1: tcc_token = 1126;
pub const TOK_ASM_fxtract: tcc_token = 1125;
pub const TOK_ASM_fpatan: tcc_token = 1124;
pub const TOK_ASM_fptan: tcc_token = 1123;
pub const TOK_ASM_fyl2x: tcc_token = 1122;
pub const TOK_ASM_f2xm1: tcc_token = 1121;
pub const TOK_ASM_fldz: tcc_token = 1120;
pub const TOK_ASM_fldln2: tcc_token = 1119;
pub const TOK_ASM_fldlg2: tcc_token = 1118;
pub const TOK_ASM_fldpi: tcc_token = 1117;
pub const TOK_ASM_fldl2e: tcc_token = 1116;
pub const TOK_ASM_fldl2t: tcc_token = 1115;
pub const TOK_ASM_fld1: tcc_token = 1114;
pub const TOK_ASM_fxam: tcc_token = 1113;
pub const TOK_ASM_ftst: tcc_token = 1112;
pub const TOK_ASM_fucompp: tcc_token = 1111;
pub const TOK_ASM_leave: tcc_token = 1107;
pub const TOK_ASM_ud2: tcc_token = 1106;
pub const TOK_ASM_sysret: tcc_token = 1105;
pub const TOK_ASM_syscall: tcc_token = 1104;
pub const TOK_ASM_rdpmc: tcc_token = 1103;
pub const TOK_ASM_rdmsr: tcc_token = 1102;
pub const TOK_ASM_rdtsc: tcc_token = 1101;
pub const TOK_ASM_wrmsr: tcc_token = 1100;
pub const TOK_ASM_cpuid: tcc_token = 1099;
pub const TOK_ASM_wbinvd: tcc_token = 1098;
pub const TOK_ASM_invd: tcc_token = 1097;
pub const TOK_ASM_repne: tcc_token = 1095;
pub const TOK_ASM_repz: tcc_token = 1094;
pub const TOK_ASM_repe: tcc_token = 1093;
pub const TOK_ASM_rep: tcc_token = 1092;
pub const TOK_ASM_lock: tcc_token = 1091;
pub const TOK_ASM_xlat: tcc_token = 1090;
pub const TOK_ASM_pause: tcc_token = 1089;
pub const TOK_ASM_nop: tcc_token = 1088;
pub const TOK_ASM_hlt: tcc_token = 1086;
pub const TOK_ASM_rsm: tcc_token = 1085;
pub const TOK_ASM_iretq: tcc_token = 1084;
pub const TOK_ASM_iretl: tcc_token = 1083;
pub const TOK_ASM_iretw: tcc_token = 1082;
pub const TOK_ASM_iret: tcc_token = 1081;
pub const TOK_ASM_into: tcc_token = 1080;
pub const TOK_ASM_int3: tcc_token = 1079;
pub const TOK_ASM_cqto: tcc_token = 1078;
pub const TOK_ASM_cltd: tcc_token = 1077;
pub const TOK_ASM_cwtd: tcc_token = 1076;
pub const TOK_ASM_cwtl: tcc_token = 1075;
pub const TOK_ASM_cbtw: tcc_token = 1074;
pub const TOK_ASM_cdq: tcc_token = 1073;
pub const TOK_ASM_cwde: tcc_token = 1072;
pub const TOK_ASM_cwd: tcc_token = 1071;
pub const TOK_ASM_cbw: tcc_token = 1070;
pub const TOK_ASM_aam: tcc_token = 1069;
pub const TOK_ASM_aad: tcc_token = 1068;
pub const TOK_ASM_das: tcc_token = 1067;
pub const TOK_ASM_daa: tcc_token = 1066;
pub const TOK_ASM_aas: tcc_token = 1065;
pub const TOK_ASM_aaa: tcc_token = 1064;
pub const TOK_ASM_sti: tcc_token = 1063;
pub const TOK_ASM_std: tcc_token = 1062;
pub const TOK_ASM_stc: tcc_token = 1061;
pub const TOK_ASM_popf: tcc_token = 1060;
pub const TOK_ASM_pushf: tcc_token = 1059;
pub const TOK_ASM_popfq: tcc_token = 1058;
pub const TOK_ASM_pushfq: tcc_token = 1057;
pub const TOK_ASM_sahf: tcc_token = 1056;
pub const TOK_ASM_lahf: tcc_token = 1055;
pub const TOK_ASM_cmc: tcc_token = 1054;
pub const TOK_ASM_clts: tcc_token = 1053;
pub const TOK_ASM_cli: tcc_token = 1052;
pub const TOK_ASM_cld: tcc_token = 1051;
pub const TOK_ASM_ssto: tcc_token = 1049;
pub const TOK_ASM_sstoq: tcc_token = 1048;
pub const TOK_ASM_sstol: tcc_token = 1047;
pub const TOK_ASM_sstow: tcc_token = 1046;
pub const TOK_ASM_stos: tcc_token = 1044;
pub const TOK_ASM_stosq: tcc_token = 1043;
pub const TOK_ASM_stosl: tcc_token = 1042;
pub const TOK_ASM_stosw: tcc_token = 1041;
pub const TOK_ASM_ssca: tcc_token = 1039;
pub const TOK_ASM_sscaq: tcc_token = 1038;
pub const TOK_ASM_sscal: tcc_token = 1037;
pub const TOK_ASM_sscaw: tcc_token = 1036;
pub const TOK_ASM_scas: tcc_token = 1034;
pub const TOK_ASM_scasq: tcc_token = 1033;
pub const TOK_ASM_scasl: tcc_token = 1032;
pub const TOK_ASM_scasw: tcc_token = 1031;
pub const TOK_ASM_smov: tcc_token = 1029;
pub const TOK_ASM_smovq: tcc_token = 1028;
pub const TOK_ASM_smovl: tcc_token = 1027;
pub const TOK_ASM_smovw: tcc_token = 1026;
pub const TOK_ASM_movs: tcc_token = 1024;
pub const TOK_ASM_movsq: tcc_token = 1023;
pub const TOK_ASM_movsl: tcc_token = 1022;
pub const TOK_ASM_movsw: tcc_token = 1021;
pub const TOK_ASM_slod: tcc_token = 1019;
pub const TOK_ASM_slodq: tcc_token = 1018;
pub const TOK_ASM_slodl: tcc_token = 1017;
pub const TOK_ASM_slodw: tcc_token = 1016;
pub const TOK_ASM_lods: tcc_token = 1014;
pub const TOK_ASM_lodsq: tcc_token = 1013;
pub const TOK_ASM_lodsl: tcc_token = 1012;
pub const TOK_ASM_lodsw: tcc_token = 1011;
pub const TOK_ASM_outs: tcc_token = 1009;
pub const TOK_ASM_outsl: tcc_token = 1008;
pub const TOK_ASM_outsw: tcc_token = 1007;
pub const TOK_ASM_ins: tcc_token = 1005;
pub const TOK_ASM_insl: tcc_token = 1004;
pub const TOK_ASM_insw: tcc_token = 1003;
pub const TOK_ASM_scmp: tcc_token = 1001;
pub const TOK_ASM_scmpq: tcc_token = 1000;
pub const TOK_ASM_scmpl: tcc_token = 999;
pub const TOK_ASM_scmpw: tcc_token = 998;
pub const TOK_ASM_cmps: tcc_token = 996;
pub const TOK_ASM_cmpsq: tcc_token = 995;
pub const TOK_ASM_cmpsl: tcc_token = 994;
pub const TOK_ASM_cmpsw: tcc_token = 993;
pub const TOK_ASM_cmpxchg: tcc_token = 991;
pub const TOK_ASM_cmpxchgq: tcc_token = 990;
pub const TOK_ASM_cmpxchgl: tcc_token = 989;
pub const TOK_ASM_cmpxchgw: tcc_token = 988;
pub const TOK_ASM_xadd: tcc_token = 986;
pub const TOK_ASM_xaddq: tcc_token = 985;
pub const TOK_ASM_xaddl: tcc_token = 984;
pub const TOK_ASM_xaddw: tcc_token = 983;
pub const TOK_ASM_fidivrs: tcc_token = 981;
pub const TOK_ASM_fdivrl: tcc_token = 980;
pub const TOK_ASM_fidivrl: tcc_token = 979;
pub const TOK_ASM_fdivrs: tcc_token = 978;
pub const TOK_ASM_fdivrp: tcc_token = 977;
pub const TOK_ASM_fdivr: tcc_token = 976;
pub const TOK_ASM_fidivs: tcc_token = 975;
pub const TOK_ASM_fdivl: tcc_token = 974;
pub const TOK_ASM_fidivl: tcc_token = 973;
pub const TOK_ASM_fdivs: tcc_token = 972;
pub const TOK_ASM_fdivp: tcc_token = 971;
pub const TOK_ASM_fdiv: tcc_token = 970;
pub const TOK_ASM_fisubrs: tcc_token = 969;
pub const TOK_ASM_fsubrl: tcc_token = 968;
pub const TOK_ASM_fisubrl: tcc_token = 967;
pub const TOK_ASM_fsubrs: tcc_token = 966;
pub const TOK_ASM_fsubrp: tcc_token = 965;
pub const TOK_ASM_fsubr: tcc_token = 964;
pub const TOK_ASM_fisubs: tcc_token = 963;
pub const TOK_ASM_fsubl: tcc_token = 962;
pub const TOK_ASM_fisubl: tcc_token = 961;
pub const TOK_ASM_fsubs: tcc_token = 960;
pub const TOK_ASM_fsubp: tcc_token = 959;
pub const TOK_ASM_fsub: tcc_token = 958;
pub const TOK_ASM_ficomps: tcc_token = 957;
pub const TOK_ASM_fcompl: tcc_token = 956;
pub const TOK_ASM_ficompl: tcc_token = 955;
pub const TOK_ASM_fcomps: tcc_token = 954;
pub const TOK_ASM_fcompp: tcc_token = 953;
pub const TOK_ASM_ficoms: tcc_token = 951;
pub const TOK_ASM_fcoml: tcc_token = 950;
pub const TOK_ASM_ficoml: tcc_token = 949;
pub const TOK_ASM_fcoms: tcc_token = 948;
pub const TOK_ASM_fcom_1: tcc_token = 947;
pub const TOK_ASM_fcom: tcc_token = 946;
pub const TOK_ASM_fimuls: tcc_token = 945;
pub const TOK_ASM_fmull: tcc_token = 944;
pub const TOK_ASM_fimull: tcc_token = 943;
pub const TOK_ASM_fmuls: tcc_token = 942;
pub const TOK_ASM_fmulp: tcc_token = 941;
pub const TOK_ASM_lsl: tcc_token = 933;
pub const TOK_ASM_lslq: tcc_token = 932;
pub const TOK_ASM_lsll: tcc_token = 931;
pub const TOK_ASM_lar: tcc_token = 929;
pub const TOK_ASM_larq: tcc_token = 928;
pub const TOK_ASM_larl: tcc_token = 927;
pub const TOK_ASM_lzcnt: tcc_token = 925;
pub const TOK_ASM_lzcntq: tcc_token = 924;
pub const TOK_ASM_lzcntl: tcc_token = 923;
pub const TOK_ASM_tzcnt: tcc_token = 921;
pub const TOK_ASM_tzcntq: tcc_token = 920;
pub const TOK_ASM_tzcntl: tcc_token = 919;
pub const TOK_ASM_popcnt: tcc_token = 917;
pub const TOK_ASM_popcntq: tcc_token = 916;
pub const TOK_ASM_popcntl: tcc_token = 915;
pub const TOK_ASM_btc: tcc_token = 913;
pub const TOK_ASM_btcq: tcc_token = 912;
pub const TOK_ASM_btcl: tcc_token = 911;
pub const TOK_ASM_btr: tcc_token = 909;
pub const TOK_ASM_btrq: tcc_token = 908;
pub const TOK_ASM_btrl: tcc_token = 907;
pub const TOK_ASM_bts: tcc_token = 905;
pub const TOK_ASM_btsq: tcc_token = 904;
pub const TOK_ASM_btsl: tcc_token = 903;
pub const TOK_ASM_bt: tcc_token = 901;
pub const TOK_ASM_btq: tcc_token = 900;
pub const TOK_ASM_btl: tcc_token = 899;
pub const TOK_ASM_bsr: tcc_token = 897;
pub const TOK_ASM_bsrq: tcc_token = 896;
pub const TOK_ASM_bsrl: tcc_token = 895;
pub const TOK_ASM_bsf: tcc_token = 893;
pub const TOK_ASM_bsfq: tcc_token = 892;
pub const TOK_ASM_bsfl: tcc_token = 891;
pub const TOK_ASM_cmovg: tcc_token = 889;
pub const TOK_ASM_cmovnle: tcc_token = 888;
pub const TOK_ASM_cmovng: tcc_token = 887;
pub const TOK_ASM_cmovle: tcc_token = 886;
pub const TOK_ASM_cmovge: tcc_token = 885;
pub const TOK_ASM_cmovnl: tcc_token = 884;
pub const TOK_ASM_cmovnge: tcc_token = 883;
pub const TOK_ASM_cmovl: tcc_token = 882;
pub const TOK_ASM_cmovpo: tcc_token = 881;
pub const TOK_ASM_cmovnp: tcc_token = 880;
pub const TOK_ASM_cmovpe: tcc_token = 879;
pub const TOK_ASM_cmovp: tcc_token = 878;
pub const TOK_ASM_cmovns: tcc_token = 877;
pub const TOK_ASM_cmovs: tcc_token = 876;
pub const TOK_ASM_cmova: tcc_token = 875;
pub const TOK_ASM_cmovnbe: tcc_token = 874;
pub const TOK_ASM_cmovna: tcc_token = 873;
pub const TOK_ASM_cmovbe: tcc_token = 872;
pub const TOK_ASM_cmovnz: tcc_token = 871;
pub const TOK_ASM_cmovne: tcc_token = 870;
pub const TOK_ASM_cmovz: tcc_token = 869;
pub const TOK_ASM_cmove: tcc_token = 868;
pub const TOK_ASM_cmovae: tcc_token = 867;
pub const TOK_ASM_cmovnc: tcc_token = 866;
pub const TOK_ASM_cmovnb: tcc_token = 865;
pub const TOK_ASM_cmovnae: tcc_token = 864;
pub const TOK_ASM_cmovc: tcc_token = 863;
pub const TOK_ASM_cmovb: tcc_token = 862;
pub const TOK_ASM_cmovno: tcc_token = 861;
pub const TOK_ASM_setgb: tcc_token = 859;
pub const TOK_ASM_setnleb: tcc_token = 858;
pub const TOK_ASM_setngb: tcc_token = 857;
pub const TOK_ASM_setleb: tcc_token = 856;
pub const TOK_ASM_setgeb: tcc_token = 855;
pub const TOK_ASM_setnlb: tcc_token = 854;
pub const TOK_ASM_setngeb: tcc_token = 853;
pub const TOK_ASM_setlb: tcc_token = 852;
pub const TOK_ASM_setpob: tcc_token = 851;
pub const TOK_ASM_setnpb: tcc_token = 850;
pub const TOK_ASM_setpeb: tcc_token = 849;
pub const TOK_ASM_setpb: tcc_token = 848;
pub const TOK_ASM_setnsb: tcc_token = 847;
pub const TOK_ASM_setsb: tcc_token = 846;
pub const TOK_ASM_setab: tcc_token = 845;
pub const TOK_ASM_setnbeb: tcc_token = 844;
pub const TOK_ASM_setnab: tcc_token = 843;
pub const TOK_ASM_setbeb: tcc_token = 842;
pub const TOK_ASM_setnzb: tcc_token = 841;
pub const TOK_ASM_setneb: tcc_token = 840;
pub const TOK_ASM_setzb: tcc_token = 839;
pub const TOK_ASM_seteb: tcc_token = 838;
pub const TOK_ASM_setaeb: tcc_token = 837;
pub const TOK_ASM_setncb: tcc_token = 836;
pub const TOK_ASM_setnbb: tcc_token = 835;
pub const TOK_ASM_setnaeb: tcc_token = 834;
pub const TOK_ASM_setcb: tcc_token = 833;
pub const TOK_ASM_setbb: tcc_token = 832;
pub const TOK_ASM_setnob: tcc_token = 831;
pub const TOK_ASM_setg: tcc_token = 829;
pub const TOK_ASM_setnle: tcc_token = 828;
pub const TOK_ASM_setng: tcc_token = 827;
pub const TOK_ASM_setle: tcc_token = 826;
pub const TOK_ASM_setge: tcc_token = 825;
pub const TOK_ASM_setnl: tcc_token = 824;
pub const TOK_ASM_setnge: tcc_token = 823;
pub const TOK_ASM_setl: tcc_token = 822;
pub const TOK_ASM_setpo: tcc_token = 821;
pub const TOK_ASM_setnp: tcc_token = 820;
pub const TOK_ASM_setpe: tcc_token = 819;
pub const TOK_ASM_setp: tcc_token = 818;
pub const TOK_ASM_setns: tcc_token = 817;
pub const TOK_ASM_sets: tcc_token = 816;
pub const TOK_ASM_seta: tcc_token = 815;
pub const TOK_ASM_setnbe: tcc_token = 814;
pub const TOK_ASM_setna: tcc_token = 813;
pub const TOK_ASM_setbe: tcc_token = 812;
pub const TOK_ASM_setnz: tcc_token = 811;
pub const TOK_ASM_setne: tcc_token = 810;
pub const TOK_ASM_setz: tcc_token = 809;
pub const TOK_ASM_sete: tcc_token = 808;
pub const TOK_ASM_setae: tcc_token = 807;
pub const TOK_ASM_setnc: tcc_token = 806;
pub const TOK_ASM_setnb: tcc_token = 805;
pub const TOK_ASM_setnae: tcc_token = 804;
pub const TOK_ASM_setc: tcc_token = 803;
pub const TOK_ASM_setb: tcc_token = 802;
pub const TOK_ASM_setno: tcc_token = 801;
pub const TOK_ASM_jg: tcc_token = 799;
pub const TOK_ASM_jnle: tcc_token = 798;
pub const TOK_ASM_jng: tcc_token = 797;
pub const TOK_ASM_jle: tcc_token = 796;
pub const TOK_ASM_jge: tcc_token = 795;
pub const TOK_ASM_jnl: tcc_token = 794;
pub const TOK_ASM_jnge: tcc_token = 793;
pub const TOK_ASM_jl: tcc_token = 792;
pub const TOK_ASM_jpo: tcc_token = 791;
pub const TOK_ASM_jnp: tcc_token = 790;
pub const TOK_ASM_jpe: tcc_token = 789;
pub const TOK_ASM_jp: tcc_token = 788;
pub const TOK_ASM_jns: tcc_token = 787;
pub const TOK_ASM_js: tcc_token = 786;
pub const TOK_ASM_ja: tcc_token = 785;
pub const TOK_ASM_jnbe: tcc_token = 784;
pub const TOK_ASM_jna: tcc_token = 783;
pub const TOK_ASM_jbe: tcc_token = 782;
pub const TOK_ASM_jnz: tcc_token = 781;
pub const TOK_ASM_jne: tcc_token = 780;
pub const TOK_ASM_jz: tcc_token = 779;
pub const TOK_ASM_je: tcc_token = 778;
pub const TOK_ASM_jae: tcc_token = 777;
pub const TOK_ASM_jnc: tcc_token = 776;
pub const TOK_ASM_jnb: tcc_token = 775;
pub const TOK_ASM_jnae: tcc_token = 774;
pub const TOK_ASM_jc: tcc_token = 773;
pub const TOK_ASM_jb: tcc_token = 772;
pub const TOK_ASM_jno: tcc_token = 771;
pub const TOK_ASM_lea: tcc_token = 760;
pub const TOK_ASM_leaq: tcc_token = 759;
pub const TOK_ASM_leal: tcc_token = 758;
pub const TOK_ASM_movzb: tcc_token = 748;
pub const TOK_ASM_movzbq: tcc_token = 747;
pub const TOK_ASM_movzbl: tcc_token = 746;
pub const TOK_ASM_out: tcc_token = 744;
pub const TOK_ASM_outl: tcc_token = 743;
pub const TOK_ASM_outw: tcc_token = 742;
pub const TOK_ASM_in: tcc_token = 740;
pub const TOK_ASM_inl: tcc_token = 739;
pub const TOK_ASM_inw: tcc_token = 738;
pub const TOK_ASM_shrd: tcc_token = 728;
pub const TOK_ASM_shrdq: tcc_token = 727;
pub const TOK_ASM_shrdl: tcc_token = 726;
pub const TOK_ASM_shld: tcc_token = 724;
pub const TOK_ASM_shldq: tcc_token = 723;
pub const TOK_ASM_shldl: tcc_token = 722;
pub const TOK_ASM_sar: tcc_token = 720;
pub const TOK_ASM_sarq: tcc_token = 719;
pub const TOK_ASM_sarl: tcc_token = 718;
pub const TOK_ASM_sarw: tcc_token = 717;
pub const TOK_ASM_sarb: tcc_token = 716;
pub const TOK_ASM_shr: tcc_token = 715;
pub const TOK_ASM_shrq: tcc_token = 714;
pub const TOK_ASM_shrl: tcc_token = 713;
pub const TOK_ASM_shrw: tcc_token = 712;
pub const TOK_ASM_shrb: tcc_token = 711;
pub const TOK_ASM_shl: tcc_token = 710;
pub const TOK_ASM_shlq: tcc_token = 709;
pub const TOK_ASM_shll: tcc_token = 708;
pub const TOK_ASM_shlw: tcc_token = 707;
pub const TOK_ASM_shlb: tcc_token = 706;
pub const TOK_ASM_rcr: tcc_token = 705;
pub const TOK_ASM_rcrq: tcc_token = 704;
pub const TOK_ASM_rcrl: tcc_token = 703;
pub const TOK_ASM_rcrw: tcc_token = 702;
pub const TOK_ASM_rcrb: tcc_token = 701;
pub const TOK_ASM_rcl: tcc_token = 700;
pub const TOK_ASM_rclq: tcc_token = 699;
pub const TOK_ASM_rcll: tcc_token = 698;
pub const TOK_ASM_rclw: tcc_token = 697;
pub const TOK_ASM_rclb: tcc_token = 696;
pub const TOK_ASM_ror: tcc_token = 695;
pub const TOK_ASM_rorq: tcc_token = 694;
pub const TOK_ASM_rorl: tcc_token = 693;
pub const TOK_ASM_rorw: tcc_token = 692;
pub const TOK_ASM_rorb: tcc_token = 691;
pub const TOK_ASM_rol: tcc_token = 690;
pub const TOK_ASM_rolq: tcc_token = 689;
pub const TOK_ASM_roll: tcc_token = 688;
pub const TOK_ASM_rolw: tcc_token = 687;
pub const TOK_ASM_test: tcc_token = 685;
pub const TOK_ASM_testq: tcc_token = 684;
pub const TOK_ASM_testl: tcc_token = 683;
pub const TOK_ASM_testw: tcc_token = 682;
pub const TOK_ASM_xchg: tcc_token = 680;
pub const TOK_ASM_xchgq: tcc_token = 679;
pub const TOK_ASM_xchgl: tcc_token = 678;
pub const TOK_ASM_idiv: tcc_token = 675;
pub const TOK_ASM_idivq: tcc_token = 674;
pub const TOK_ASM_idivl: tcc_token = 673;
pub const TOK_ASM_idivw: tcc_token = 672;
pub const TOK_ASM_div: tcc_token = 670;
pub const TOK_ASM_divq: tcc_token = 669;
pub const TOK_ASM_divl: tcc_token = 668;
pub const TOK_ASM_divw: tcc_token = 667;
pub const TOK_ASM_imul: tcc_token = 665;
pub const TOK_ASM_imulq: tcc_token = 664;
pub const TOK_ASM_imull: tcc_token = 663;
pub const TOK_ASM_mul: tcc_token = 660;
pub const TOK_ASM_mulq: tcc_token = 659;
pub const TOK_ASM_mull: tcc_token = 658;
pub const TOK_ASM_mulw: tcc_token = 657;
pub const TOK_ASM_neg: tcc_token = 655;
pub const TOK_ASM_negq: tcc_token = 654;
pub const TOK_ASM_negl: tcc_token = 653;
pub const TOK_ASM_negw: tcc_token = 652;
pub const TOK_ASM_not: tcc_token = 650;
pub const TOK_ASM_notq: tcc_token = 649;
pub const TOK_ASM_notl: tcc_token = 648;
pub const TOK_ASM_notw: tcc_token = 647;
pub const TOK_ASM_dec: tcc_token = 645;
pub const TOK_ASM_decq: tcc_token = 644;
pub const TOK_ASM_decl: tcc_token = 643;
pub const TOK_ASM_decw: tcc_token = 642;
pub const TOK_ASM_inc: tcc_token = 640;
pub const TOK_ASM_incq: tcc_token = 639;
pub const TOK_ASM_incl: tcc_token = 638;
pub const TOK_ASM_incw: tcc_token = 637;
pub const TOK_ASM_cmp: tcc_token = 635;
pub const TOK_ASM_cmpq: tcc_token = 634;
pub const TOK_ASM_cmpl: tcc_token = 633;
pub const TOK_ASM_cmpw: tcc_token = 632;
pub const TOK_ASM_cmpb: tcc_token = 631;
pub const TOK_ASM_xor: tcc_token = 630;
pub const TOK_ASM_xorq: tcc_token = 629;
pub const TOK_ASM_xorl: tcc_token = 628;
pub const TOK_ASM_xorw: tcc_token = 627;
pub const TOK_ASM_xorb: tcc_token = 626;
pub const TOK_ASM_sub: tcc_token = 625;
pub const TOK_ASM_subq: tcc_token = 624;
pub const TOK_ASM_subl: tcc_token = 623;
pub const TOK_ASM_subw: tcc_token = 622;
pub const TOK_ASM_subb: tcc_token = 621;
pub const TOK_ASM_and: tcc_token = 620;
pub const TOK_ASM_andq: tcc_token = 619;
pub const TOK_ASM_andl: tcc_token = 618;
pub const TOK_ASM_andw: tcc_token = 617;
pub const TOK_ASM_andb: tcc_token = 616;
pub const TOK_ASM_sbb: tcc_token = 615;
pub const TOK_ASM_sbbq: tcc_token = 614;
pub const TOK_ASM_sbbl: tcc_token = 613;
pub const TOK_ASM_sbbw: tcc_token = 612;
pub const TOK_ASM_sbbb: tcc_token = 611;
pub const TOK_ASM_adc: tcc_token = 610;
pub const TOK_ASM_adcq: tcc_token = 609;
pub const TOK_ASM_adcl: tcc_token = 608;
pub const TOK_ASM_adcw: tcc_token = 607;
pub const TOK_ASM_adcb: tcc_token = 606;
pub const TOK_ASM_or: tcc_token = 605;
pub const TOK_ASM_orq: tcc_token = 604;
pub const TOK_ASM_orl: tcc_token = 603;
pub const TOK_ASM_orw: tcc_token = 602;
pub const TOK_ASM_orb: tcc_token = 601;
pub const TOK_ASM_add: tcc_token = 600;
pub const TOK_ASM_addq: tcc_token = 599;
pub const TOK_ASM_addl: tcc_token = 598;
pub const TOK_ASM_movl: tcc_token = 593;
pub const TOK_ASM_sil: tcc_token = 589;
pub const TOK_ASM_bpl: tcc_token = 588;
pub const TOK_ASM_fs: tcc_token = 583;
pub const TOK_ASM_ds: tcc_token = 582;
pub const TOK_ASM_ss: tcc_token = 581;
pub const TOK_ASM_cs: tcc_token = 580;
pub const TOK_ASM_dr6: tcc_token = 577;
pub const TOK_ASM_dr5: tcc_token = 576;
pub const TOK_ASM_dr4: tcc_token = 575;
pub const TOK_ASM_dr3: tcc_token = 574;
pub const TOK_ASM_dr2: tcc_token = 573;
pub const TOK_ASM_dr1: tcc_token = 572;
pub const TOK_ASM_db6: tcc_token = 569;
pub const TOK_ASM_db5: tcc_token = 568;
pub const TOK_ASM_db4: tcc_token = 567;
pub const TOK_ASM_db3: tcc_token = 566;
pub const TOK_ASM_db2: tcc_token = 565;
pub const TOK_ASM_db1: tcc_token = 564;
pub const TOK_ASM_db0: tcc_token = 563;
pub const TOK_ASM_tr7: tcc_token = 562;
pub const TOK_ASM_tr6: tcc_token = 561;
pub const TOK_ASM_tr5: tcc_token = 560;
pub const TOK_ASM_tr4: tcc_token = 559;
pub const TOK_ASM_tr3: tcc_token = 558;
pub const TOK_ASM_tr2: tcc_token = 557;
pub const TOK_ASM_tr1: tcc_token = 556;
pub const TOK_ASM_tr0: tcc_token = 555;
pub const TOK_ASM_cr7: tcc_token = 554;
pub const TOK_ASM_cr6: tcc_token = 553;
pub const TOK_ASM_cr5: tcc_token = 552;
pub const TOK_ASM_cr4: tcc_token = 551;
pub const TOK_ASM_cr3: tcc_token = 550;
pub const TOK_ASM_cr2: tcc_token = 549;
pub const TOK_ASM_cr1: tcc_token = 548;
pub const TOK_ASM_cr0: tcc_token = 547;
pub const TOK_ASM_xmm7: tcc_token = 546;
pub const TOK_ASM_xmm6: tcc_token = 545;
pub const TOK_ASM_xmm5: tcc_token = 544;
pub const TOK_ASM_xmm4: tcc_token = 543;
pub const TOK_ASM_xmm3: tcc_token = 542;
pub const TOK_ASM_xmm2: tcc_token = 541;
pub const TOK_ASM_xmm1: tcc_token = 540;
pub const TOK_ASM_xmm0: tcc_token = 539;
pub const TOK_ASM_mm7: tcc_token = 538;
pub const TOK_ASM_mm6: tcc_token = 537;
pub const TOK_ASM_mm5: tcc_token = 536;
pub const TOK_ASM_mm4: tcc_token = 535;
pub const TOK_ASM_mm3: tcc_token = 534;
pub const TOK_ASM_mm2: tcc_token = 533;
pub const TOK_ASM_mm1: tcc_token = 532;
pub const TOK_ASM_mm0: tcc_token = 531;
pub const TOK_ASM_rsi: tcc_token = 529;
pub const TOK_ASM_rbp: tcc_token = 528;
pub const TOK_ASM_rsp: tcc_token = 527;
pub const TOK_ASM_rbx: tcc_token = 526;
pub const TOK_ASM_rdx: tcc_token = 525;
pub const TOK_ASM_rcx: tcc_token = 524;
pub const TOK_ASM_esi: tcc_token = 521;
pub const TOK_ASM_ebp: tcc_token = 520;
pub const TOK_ASM_esp: tcc_token = 519;
pub const TOK_ASM_ebx: tcc_token = 518;
pub const TOK_ASM_edx: tcc_token = 517;
pub const TOK_ASM_ecx: tcc_token = 516;
pub const TOK_ASM_si: tcc_token = 513;
pub const TOK_ASM_bp: tcc_token = 512;
pub const TOK_ASM_sp: tcc_token = 511;
pub const TOK_ASM_bx: tcc_token = 510;
pub const TOK_ASM_dx: tcc_token = 509;
pub const TOK_ASM_cx: tcc_token = 508;
pub const TOK_ASM_bh: tcc_token = 506;
pub const TOK_ASM_dh: tcc_token = 505;
pub const TOK_ASM_ch: tcc_token = 504;
pub const TOK_ASM_bl: tcc_token = 502;
pub const TOK_ASM_dl: tcc_token = 501;
pub const TOK_ASM_cl: tcc_token = 500;
pub const TOK_longjmp: tcc_token = 462;
pub const TOK_siglongjmp: tcc_token = 459;
pub const TOK___bound_new_region: tcc_token = 456;
pub const TOK___bound_longjmp: tcc_token = 455;
pub const TOK___bound_main_arg: tcc_token = 451;
pub const TOK___ashldi3: tcc_token = 436;
pub const TOK___lshrdi3: tcc_token = 435;
pub const TOK___ashrdi3: tcc_token = 434;
pub const TOK___umoddi3: tcc_token = 433;
pub const TOK___udivdi3: tcc_token = 432;
pub const TOK___moddi3: tcc_token = 431;
pub const TOK___divdi3: tcc_token = 430;
pub const TOK_memcpy: tcc_token = 427;
pub const TOK_REGPARM2: tcc_token = 373;
pub const TOK_REGPARM1: tcc_token = 372;
pub const TOK_THISCALL3: tcc_token = 371;
pub const TOK_THISCALL2: tcc_token = 370;
pub const TOK_THISCALL1: tcc_token = 369;
pub const TOK_FASTCALL3: tcc_token = 368;
pub const TOK_FASTCALL2: tcc_token = 367;
pub const TOK_FASTCALL1: tcc_token = 366;
pub const TOK_LAST: tcc_token = 255;
pub type line_macro_output_format = libc::c_uint;
pub const LINE_MACRO_OUTPUT_FORMAT_GCC: line_macro_output_format = 0;
pub type gotplt_entry = libc::c_uint;
pub type C2RustUnnamed_51 = libc::c_uint;
pub const FPE_CONDTRAP: C2RustUnnamed_51 = 15;
pub const FPE_FLTUNK: C2RustUnnamed_51 = 14;
pub const FPE_FLTSUB: C2RustUnnamed_51 = 8;
pub const FPE_FLTINV: C2RustUnnamed_51 = 7;
pub const FPE_FLTRES: C2RustUnnamed_51 = 6;
pub const FPE_FLTUND: C2RustUnnamed_51 = 5;
pub const FPE_FLTOVF: C2RustUnnamed_51 = 4;
pub const FPE_INTOVF: C2RustUnnamed_51 = 2;
pub type C2RustUnnamed_52 = libc::c_uint;
pub const REG_CR2: C2RustUnnamed_52 = 22;
pub const REG_OLDMASK: C2RustUnnamed_52 = 21;
pub const REG_TRAPNO: C2RustUnnamed_52 = 20;
pub const REG_ERR: C2RustUnnamed_52 = 19;
pub const REG_CSGSFS: C2RustUnnamed_52 = 18;
pub const REG_EFL: C2RustUnnamed_52 = 17;
pub const REG_RSP: C2RustUnnamed_52 = 15;
pub const REG_RCX: C2RustUnnamed_52 = 14;
pub const REG_RAX: C2RustUnnamed_52 = 13;
pub const REG_RDX: C2RustUnnamed_52 = 12;
pub const REG_RBX: C2RustUnnamed_52 = 11;
pub const REG_RSI: C2RustUnnamed_52 = 9;
pub const REG_RDI: C2RustUnnamed_52 = 8;
pub const REG_R15: C2RustUnnamed_52 = 7;
pub const REG_R14: C2RustUnnamed_52 = 6;
pub const REG_R13: C2RustUnnamed_52 = 5;
pub const REG_R12: C2RustUnnamed_52 = 4;
pub const REG_R11: C2RustUnnamed_52 = 3;
pub const REG_R10: C2RustUnnamed_52 = 2;
pub const REG_R9: C2RustUnnamed_52 = 1;
pub const REG_R8: C2RustUnnamed_52 = 0;
pub type C2RustUnnamed_53 = libc::c_uint;
pub const OPT_COMPOSITE_FIRST: C2RustUnnamed_53 = 23;
pub type C2RustUnnamed_54 = libc::c_uint;
pub type C2RustUnnamed_55 = libc::c_uint;
pub const TCC_OPTION_current_version: C2RustUnnamed_55 = 58;
pub const TCC_OPTION_compatibility_version: C2RustUnnamed_55 = 57;
pub const TCC_OPTION_install_name: C2RustUnnamed_55 = 56;
pub const TCC_OPTION_undefined: C2RustUnnamed_55 = 55;
pub const TCC_OPTION_two_levelnamespace: C2RustUnnamed_55 = 54;
pub const TCC_OPTION_flat_namespace: C2RustUnnamed_55 = 53;
pub const TCC_OPTION_dynamiclib: C2RustUnnamed_55 = 52;
pub const TCC_OPTION_iwithprefix: C2RustUnnamed_55 = 33;
pub const TCC_OPTION_mfloat_abi: C2RustUnnamed_55 = 29;
pub const TCC_OPTION_ignored: C2RustUnnamed_55 = 0;
#[inline]
unsafe extern "C" fn is_space(mut ch: libc::c_int) -> libc::c_int {
    return (ch == ' ' as i32 || ch == '\t' as i32 || ch == '\u{b}' as i32
        || ch == '\u{c}' as i32 || ch == '\r' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn isid(mut c: libc::c_int) -> libc::c_int {
    return (c >= 'a' as i32 && c <= 'z' as i32 || c >= 'A' as i32 && c <= 'Z' as i32
        || c == '_' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn isnum(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn isoct(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '7' as i32) as libc::c_int;
}
#[inline]
unsafe extern "C" fn toup(mut c: libc::c_int) -> libc::c_int {
    return if c >= 'a' as i32 && c <= 'z' as i32 {
        c - 'a' as i32 + 'A' as i32
    } else {
        c
    };
}
#[inline]
unsafe extern "C" fn read16le(mut p: *mut libc::c_uchar) -> uint16_t {
    return (*p.offset(0 as libc::c_int as isize) as libc::c_int
        | (*p.offset(1 as libc::c_int as isize) as uint16_t as libc::c_int)
            << 8 as libc::c_int) as uint16_t;
}
#[inline]
unsafe extern "C" fn write16le(mut p: *mut libc::c_uchar, mut x: uint16_t) {
    *p
        .offset(
            0 as libc::c_int as isize,
        ) = (x as libc::c_int & 255 as libc::c_int) as libc::c_uchar;
    *p
        .offset(
            1 as libc::c_int as isize,
        ) = (x as libc::c_int >> 8 as libc::c_int & 255 as libc::c_int) as libc::c_uchar;
}
#[inline]
unsafe extern "C" fn read32le(mut p: *mut libc::c_uchar) -> uint32_t {
    return read16le(p) as uint32_t
        | (read16le(p.offset(2 as libc::c_int as isize)) as uint32_t)
            << 16 as libc::c_int;
}
#[inline]
unsafe extern "C" fn write32le(mut p: *mut libc::c_uchar, mut x: uint32_t) {
    write16le(p, x as uint16_t);
    write16le(p.offset(2 as libc::c_int as isize), (x >> 16 as libc::c_int) as uint16_t);
}
#[inline]
unsafe extern "C" fn add32le(mut p: *mut libc::c_uchar, mut x: int32_t) {
    write32le(p, (read32le(p)).wrapping_add(x as uint32_t));
}
#[inline]
unsafe extern "C" fn read64le(mut p: *mut libc::c_uchar) -> uint64_t {
    return read32le(p) as uint64_t
        | (read32le(p.offset(4 as libc::c_int as isize)) as uint64_t)
            << 32 as libc::c_int;
}
#[inline]
unsafe extern "C" fn write64le(mut p: *mut libc::c_uchar, mut x: uint64_t) {
    write32le(p, x as uint32_t);
    write32le(p.offset(4 as libc::c_int as isize), (x >> 32 as libc::c_int) as uint32_t);
}
#[inline]
unsafe extern "C" fn add64le(mut p: *mut libc::c_uchar, mut x: int64_t) {
    write64le(p, (read64le(p)).wrapping_add(x as uint64_t));
}
#[inline]
unsafe extern "C" fn dwarf_read_uleb128(
    mut ln: *mut *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
) -> uint64_t {
    let mut cp: *mut libc::c_uchar = *ln;
    let mut retval: uint64_t = 0 as libc::c_int as uint64_t;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while (i as libc::c_ulong)
        < (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<int64_t>() as libc::c_ulong)
            .wrapping_add(6 as libc::c_int as libc::c_ulong)
            .wrapping_div(7 as libc::c_int as libc::c_ulong)
    {
        let mut byte: uint64_t = (if cp < end {
            let fresh0 = cp;
            cp = cp.offset(1);
            *fresh0 as libc::c_int
        } else {
            0 as libc::c_int
        }) as uint64_t;
        retval |= (byte & 0x7f as libc::c_int as uint64_t) << i * 7 as libc::c_int;
        if byte & 0x80 as libc::c_int as uint64_t == 0 as libc::c_int as uint64_t {
            break;
        }
        i += 1;
        i;
    }
    *ln = cp;
    return retval;
}
#[inline]
unsafe extern "C" fn dwarf_read_sleb128(
    mut ln: *mut *mut libc::c_uchar,
    mut end: *mut libc::c_uchar,
) -> int64_t {
    let mut cp: *mut libc::c_uchar = *ln;
    let mut retval: int64_t = 0 as libc::c_int as int64_t;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while (i as libc::c_ulong)
        < (8 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<int64_t>() as libc::c_ulong)
            .wrapping_add(6 as libc::c_int as libc::c_ulong)
            .wrapping_div(7 as libc::c_int as libc::c_ulong)
    {
        let mut byte: uint64_t = (if cp < end {
            let fresh1 = cp;
            cp = cp.offset(1);
            *fresh1 as libc::c_int
        } else {
            0 as libc::c_int
        }) as uint64_t;
        retval = (retval as uint64_t
            | (byte & 0x7f as libc::c_int as uint64_t) << i * 7 as libc::c_int)
            as int64_t;
        if byte & 0x80 as libc::c_int as uint64_t == 0 as libc::c_int as uint64_t {
            if byte & 0x40 as libc::c_int as uint64_t != 0
                && ((i + 1 as libc::c_int) * 7 as libc::c_int) < 64 as libc::c_int
            {
                retval = (retval as libc::c_longlong
                    | -(1 as libc::c_longlong)
                        << (i + 1 as libc::c_int) * 7 as libc::c_int) as int64_t;
            }
            break;
        } else {
            i += 1;
            i;
        }
    }
    *ln = cp;
    return retval;
}
#[inline]
unsafe extern "C" fn wait_sem(mut p: *mut TCCSem) {
    if (*p).init == 0 {
        sem_init(&mut (*p).sem, 0 as libc::c_int, 1 as libc::c_int as libc::c_uint);
        (*p).init = 1 as libc::c_int;
    }
    while sem_wait(&mut (*p).sem) < 0 as libc::c_int
        && *__errno_location() == 4 as libc::c_int
    {}
}
#[inline]
unsafe extern "C" fn post_sem(mut p: *mut TCCSem) {
    sem_post(&mut (*p).sem);
}
static mut default_debug: [C2RustUnnamed_17; 29] = [
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 3 as libc::c_int,
            size: 4 as libc::c_int,
            encoding: DW_ATE_signed as libc::c_int,
            name: b"int:t1=r1;-2147483648;2147483647;\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 1 as libc::c_int,
            size: 1 as libc::c_int,
            encoding: DW_ATE_signed_char as libc::c_int,
            name: b"char:t2=r2;0;127;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 4 as libc::c_int | 0x800 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_signed as libc::c_int,
            name: b"long int:t3=r3;-9223372036854775808;9223372036854775807;\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 3 as libc::c_int | 0x10 as libc::c_int,
            size: 4 as libc::c_int,
            encoding: DW_ATE_unsigned as libc::c_int,
            name: b"unsigned int:t4=r4;0;037777777777;\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 4 as libc::c_int | 0x800 as libc::c_int | 0x10 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_unsigned as libc::c_int,
            name: b"long unsigned int:t5=r5;0;01777777777777777777777;\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 13 as libc::c_int,
            size: 16 as libc::c_int,
            encoding: DW_ATE_signed as libc::c_int,
            name: b"__int128:t6=r6;0;-1;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 13 as libc::c_int | 0x10 as libc::c_int,
            size: 16 as libc::c_int,
            encoding: DW_ATE_unsigned as libc::c_int,
            name: b"__int128 unsigned:t7=r7;0;-1;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 4 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_signed as libc::c_int,
            name: b"long long int:t8=r8;-9223372036854775808;9223372036854775807;\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 4 as libc::c_int | 0x10 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_unsigned as libc::c_int,
            name: b"long long unsigned int:t9=r9;0;01777777777777777777777;\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 2 as libc::c_int,
            size: 2 as libc::c_int,
            encoding: DW_ATE_signed as libc::c_int,
            name: b"short int:t10=r10;-32768;32767;\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 2 as libc::c_int | 0x10 as libc::c_int,
            size: 2 as libc::c_int,
            encoding: DW_ATE_unsigned as libc::c_int,
            name: b"short unsigned int:t11=r11;0;65535;\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 1 as libc::c_int | 0x20 as libc::c_int,
            size: 1 as libc::c_int,
            encoding: DW_ATE_signed_char as libc::c_int,
            name: b"signed char:t12=r12;-128;127;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 1 as libc::c_int | 0x20 as libc::c_int | 0x10 as libc::c_int,
            size: 1 as libc::c_int,
            encoding: DW_ATE_unsigned_char as libc::c_int,
            name: b"unsigned char:t13=r13;0;255;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 8 as libc::c_int,
            size: 4 as libc::c_int,
            encoding: DW_ATE_float as libc::c_int,
            name: b"float:t14=r1;4;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 9 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_float as libc::c_int,
            name: b"double:t15=r1;8;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 10 as libc::c_int,
            size: 16 as libc::c_int,
            encoding: DW_ATE_float as libc::c_int,
            name: b"long double:t16=r1;16;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Float32:t17=r1;4;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Float64:t18=r1;8;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Float128:t19=r1;16;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Float32x:t20=r1;8;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Float64x:t21=r1;16;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Decimal32:t22=r1;4;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Decimal64:t23=r1;8;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: -(1 as libc::c_int),
            size: -(1 as libc::c_int),
            encoding: -(1 as libc::c_int),
            name: b"_Decimal128:t24=r1;16;0;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 1 as libc::c_int | 0x10 as libc::c_int,
            size: 1 as libc::c_int,
            encoding: DW_ATE_unsigned_char as libc::c_int,
            name: b"unsigned char:t25=r25;0;255;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 11 as libc::c_int,
            size: 1 as libc::c_int,
            encoding: DW_ATE_boolean as libc::c_int,
            name: b"bool:t26=r26;0;255;\0" as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 0x800 as libc::c_int | 3 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_signed as libc::c_int,
            name: b"long int:t27=r27;-9223372036854775808;9223372036854775807;\0"
                as *const u8 as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 0x800 as libc::c_int | 3 as libc::c_int | 0x10 as libc::c_int,
            size: 8 as libc::c_int,
            encoding: DW_ATE_unsigned as libc::c_int,
            name: b"long unsigned int:t28=r28;0;01777777777777777777777;\0" as *const u8
                as *const libc::c_char,
        };
        init
    },
    {
        let mut init = C2RustUnnamed_17 {
            type_0: 0 as libc::c_int,
            size: 1 as libc::c_int,
            encoding: DW_ATE_unsigned_char as libc::c_int,
            name: b"void:t29=29\0" as *const u8 as *const libc::c_char,
        };
        init
    },
];
static mut dwarf_abbrev_init: [libc::c_uchar; 335] = [
    1 as libc::c_int as libc::c_uchar,
    DW_TAG_compile_unit as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_producer as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_language as libc::c_int as libc::c_uchar,
    DW_FORM_data1 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_line_strp as libc::c_int as libc::c_uchar,
    DW_AT_comp_dir as libc::c_int as libc::c_uchar,
    DW_FORM_line_strp as libc::c_int as libc::c_uchar,
    DW_AT_low_pc as libc::c_int as libc::c_uchar,
    DW_FORM_addr as libc::c_int as libc::c_uchar,
    DW_AT_high_pc as libc::c_int as libc::c_uchar,
    DW_FORM_data8 as libc::c_int as libc::c_uchar,
    DW_AT_stmt_list as libc::c_int as libc::c_uchar,
    DW_FORM_sec_offset as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    2 as libc::c_int as libc::c_uchar,
    DW_TAG_base_type as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_encoding as libc::c_int as libc::c_uchar,
    DW_FORM_data1 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    3 as libc::c_int as libc::c_uchar,
    DW_TAG_variable as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_external as libc::c_int as libc::c_uchar,
    DW_FORM_flag as libc::c_int as libc::c_uchar,
    DW_AT_location as libc::c_int as libc::c_uchar,
    DW_FORM_exprloc as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    4 as libc::c_int as libc::c_uchar,
    DW_TAG_variable as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_location as libc::c_int as libc::c_uchar,
    DW_FORM_exprloc as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    5 as libc::c_int as libc::c_uchar,
    DW_TAG_variable as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_location as libc::c_int as libc::c_uchar,
    DW_FORM_exprloc as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    6 as libc::c_int as libc::c_uchar,
    DW_TAG_formal_parameter as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_location as libc::c_int as libc::c_uchar,
    DW_FORM_exprloc as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    7 as libc::c_int as libc::c_uchar,
    DW_TAG_pointer_type as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_data1 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    8 as libc::c_int as libc::c_uchar,
    DW_TAG_array_type as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    9 as libc::c_int as libc::c_uchar,
    DW_TAG_subrange_type as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_upper_bound as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    10 as libc::c_int as libc::c_uchar,
    DW_TAG_typedef as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    11 as libc::c_int as libc::c_uchar,
    DW_TAG_enumerator as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_const_value as libc::c_int as libc::c_uchar,
    DW_FORM_sdata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    12 as libc::c_int as libc::c_uchar,
    DW_TAG_enumerator as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_const_value as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    13 as libc::c_int as libc::c_uchar,
    DW_TAG_enumeration_type as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_encoding as libc::c_int as libc::c_uchar,
    DW_FORM_data1 as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_data1 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    14 as libc::c_int as libc::c_uchar,
    DW_TAG_member as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_data_member_location as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    15 as libc::c_int as libc::c_uchar,
    DW_TAG_member as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_bit_size as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_data_bit_offset as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    16 as libc::c_int as libc::c_uchar,
    DW_TAG_structure_type as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    17 as libc::c_int as libc::c_uchar,
    DW_TAG_structure_type as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    18 as libc::c_int as libc::c_uchar,
    DW_TAG_union_type as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    19 as libc::c_int as libc::c_uchar,
    DW_TAG_union_type as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_byte_size as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    20 as libc::c_int as libc::c_uchar,
    DW_TAG_subprogram as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_external as libc::c_int as libc::c_uchar,
    DW_FORM_flag as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_low_pc as libc::c_int as libc::c_uchar,
    DW_FORM_addr as libc::c_int as libc::c_uchar,
    DW_AT_high_pc as libc::c_int as libc::c_uchar,
    DW_FORM_data8 as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_frame_base as libc::c_int as libc::c_uchar,
    DW_FORM_exprloc as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    21 as libc::c_int as libc::c_uchar,
    DW_TAG_subprogram as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_name as libc::c_int as libc::c_uchar,
    DW_FORM_strp as libc::c_int as libc::c_uchar,
    DW_AT_decl_file as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_decl_line as libc::c_int as libc::c_uchar,
    DW_FORM_udata as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_low_pc as libc::c_int as libc::c_uchar,
    DW_FORM_addr as libc::c_int as libc::c_uchar,
    DW_AT_high_pc as libc::c_int as libc::c_uchar,
    DW_FORM_data8 as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_frame_base as libc::c_int as libc::c_uchar,
    DW_FORM_exprloc as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    22 as libc::c_int as libc::c_uchar,
    DW_TAG_lexical_block as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_low_pc as libc::c_int as libc::c_uchar,
    DW_FORM_addr as libc::c_int as libc::c_uchar,
    DW_AT_high_pc as libc::c_int as libc::c_uchar,
    DW_FORM_data8 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    23 as libc::c_int as libc::c_uchar,
    DW_TAG_lexical_block as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_low_pc as libc::c_int as libc::c_uchar,
    DW_FORM_addr as libc::c_int as libc::c_uchar,
    DW_AT_high_pc as libc::c_int as libc::c_uchar,
    DW_FORM_data8 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    24 as libc::c_int as libc::c_uchar,
    DW_TAG_subroutine_type as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    DW_AT_sibling as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    25 as libc::c_int as libc::c_uchar,
    DW_TAG_subroutine_type as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    26 as libc::c_int as libc::c_uchar,
    DW_TAG_formal_parameter as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    DW_AT_type as libc::c_int as libc::c_uchar,
    DW_FORM_ref4 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
];
static mut dwarf_line_opcodes: [libc::c_uchar; 12] = [
    0 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
    1 as libc::c_int as libc::c_uchar,
];
unsafe extern "C" fn tcc_debug_new(mut s1: *mut TCCState) {
    let mut shf: libc::c_int = 0 as libc::c_int;
    if ((*s1).dState).is_null() {
        (*s1)
            .dState = tcc_mallocz(::core::mem::size_of::<_tccdbg>() as libc::c_ulong)
            as *mut _tccdbg;
    }
    if (*s1).do_debug as libc::c_int != 0 && (*s1).output_type == 1 as libc::c_int {
        (*s1).do_backtrace = 1 as libc::c_int as libc::c_uchar;
    }
    if (*s1).do_backtrace != 0 {
        shf = (1 as libc::c_int) << 1 as libc::c_int;
    }
    if (*s1).dwarf != 0 {
        (*s1).dwlo = (*s1).nb_sections;
        (*s1)
            .dwarf_info_section = new_section(
            s1,
            b".debug_info\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            shf,
        );
        (*s1)
            .dwarf_abbrev_section = new_section(
            s1,
            b".debug_abbrev\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            shf,
        );
        (*s1)
            .dwarf_line_section = new_section(
            s1,
            b".debug_line\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            shf,
        );
        (*s1)
            .dwarf_aranges_section = new_section(
            s1,
            b".debug_aranges\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            shf,
        );
        shf
            |= (1 as libc::c_int) << 4 as libc::c_int
                | (1 as libc::c_int) << 5 as libc::c_int;
        (*s1)
            .dwarf_str_section = new_section(
            s1,
            b".debug_str\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            shf,
        );
        (*(*s1).dwarf_str_section).sh_entsize = 1 as libc::c_int;
        (*(*s1).dwarf_str_section).sh_addralign = 1 as libc::c_int;
        (*(*s1).dwarf_aranges_section)
            .sh_addralign = (*(*s1).dwarf_str_section).sh_addralign;
        (*(*s1).dwarf_line_section)
            .sh_addralign = (*(*s1).dwarf_aranges_section).sh_addralign;
        (*(*s1).dwarf_abbrev_section)
            .sh_addralign = (*(*s1).dwarf_line_section).sh_addralign;
        (*(*s1).dwarf_info_section)
            .sh_addralign = (*(*s1).dwarf_abbrev_section).sh_addralign;
        if (*s1).dwarf as libc::c_int >= 5 as libc::c_int {
            (*s1)
                .dwarf_line_str_section = new_section(
                s1,
                b".debug_line_str\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                shf,
            );
            (*(*s1).dwarf_line_str_section).sh_entsize = 1 as libc::c_int;
            (*(*s1).dwarf_line_str_section).sh_addralign = 1 as libc::c_int;
        }
        (*s1).dwhi = (*s1).nb_sections;
    } else {
        (*s1)
            .stab_section = new_section(
            s1,
            b".stab\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            shf,
        );
        (*(*s1).stab_section)
            .sh_entsize = ::core::mem::size_of::<Stab_Sym>() as libc::c_ulong
            as libc::c_int;
        (*(*s1).stab_section)
            .sh_addralign = ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
            as libc::c_int;
        (*(*s1).stab_section)
            .link = new_section(
            s1,
            b".stabstr\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            shf,
        );
        put_stabs(
            s1,
            b"\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int as libc::c_ulong,
        );
    };
}
unsafe extern "C" fn put_stabs(
    mut s1: *mut TCCState,
    mut str: *const libc::c_char,
    mut type_0: libc::c_int,
    mut other: libc::c_int,
    mut desc: libc::c_int,
    mut value: libc::c_ulong,
) {
    let mut sym: *mut Stab_Sym = 0 as *mut Stab_Sym;
    let mut offset: libc::c_uint = 0;
    if type_0 == N_SLINE as libc::c_int
        && {
            offset = (*(*s1).stab_section).data_offset as libc::c_uint;
            offset != 0
        }
        && {
            sym = (((*(*s1).stab_section).data).offset(offset as isize) as *mut Stab_Sym)
                .offset(-(1 as libc::c_int as isize));
            !sym.is_null()
        } && (*sym).n_type as libc::c_int == type_0
        && (*sym).n_value as libc::c_ulong == value
    {
        (*sym).n_desc = desc as libc::c_ushort;
        return;
    }
    sym = section_ptr_add(
        (*s1).stab_section,
        ::core::mem::size_of::<Stab_Sym>() as libc::c_ulong,
    ) as *mut Stab_Sym;
    if !str.is_null() {
        (*sym).n_strx = put_elf_str((*(*s1).stab_section).link, str) as libc::c_uint;
    } else {
        (*sym).n_strx = 0 as libc::c_int as libc::c_uint;
    }
    (*sym).n_type = type_0 as libc::c_uchar;
    (*sym).n_other = other as libc::c_uchar;
    (*sym).n_desc = desc as libc::c_ushort;
    (*sym).n_value = value as libc::c_uint;
}
unsafe extern "C" fn put_stabs_r(
    mut s1: *mut TCCState,
    mut str: *const libc::c_char,
    mut type_0: libc::c_int,
    mut other: libc::c_int,
    mut desc: libc::c_int,
    mut value: libc::c_ulong,
    mut sec: *mut Section,
    mut sym_index: libc::c_int,
) {
    put_elf_reloc(
        (*s1).c2rust_unnamed.symtab_section,
        (*s1).stab_section,
        ((*(*s1).stab_section).data_offset)
            .wrapping_add(8 as libc::c_int as libc::c_ulong),
        if ::core::mem::size_of::<libc::c_uint>() as libc::c_ulong
            == 8 as libc::c_int as libc::c_ulong
        {
            1 as libc::c_int
        } else {
            11 as libc::c_int
        },
        sym_index,
    );
    put_stabs(s1, str, type_0, other, desc, value);
}
unsafe extern "C" fn put_stabn(
    mut s1: *mut TCCState,
    mut type_0: libc::c_int,
    mut other: libc::c_int,
    mut desc: libc::c_int,
    mut value: libc::c_int,
) {
    put_stabs(s1, 0 as *const libc::c_char, type_0, other, desc, value as libc::c_ulong);
}
unsafe extern "C" fn dwarf_get_section_sym(mut s: *mut Section) -> libc::c_int {
    let mut s1: *mut TCCState = (*s).s1;
    return put_elf_sym(
        (*s1).c2rust_unnamed.symtab_section,
        0 as libc::c_int as Elf64_Addr,
        0 as libc::c_int as libc::c_ulong,
        ((0 as libc::c_int) << 4 as libc::c_int)
            + (3 as libc::c_int & 0xf as libc::c_int),
        0 as libc::c_int,
        (*s).sh_num,
        0 as *const libc::c_char,
    );
}
unsafe extern "C" fn dwarf_reloc(
    mut s: *mut Section,
    mut sym: libc::c_int,
    mut rel: libc::c_int,
) {
    let mut s1: *mut TCCState = (*s).s1;
    put_elf_reloca(
        (*s1).c2rust_unnamed.symtab_section,
        s,
        (*s).data_offset,
        rel,
        sym,
        0 as libc::c_int as Elf64_Addr,
    );
}
unsafe extern "C" fn dwarf_string(
    mut s: *mut Section,
    mut dw: *mut Section,
    mut sym: libc::c_int,
    mut str: *const libc::c_char,
) {
    let mut s1: *mut TCCState = (*s).s1;
    let mut offset: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    len = (strlen(str)).wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    offset = (*dw).data_offset as libc::c_int;
    ptr = section_ptr_add(dw, len as Elf64_Addr) as *mut libc::c_char;
    memmove(ptr as *mut libc::c_void, str as *const libc::c_void, len as libc::c_ulong);
    put_elf_reloca(
        (*s1).c2rust_unnamed.symtab_section,
        s,
        (*s).data_offset,
        10 as libc::c_int,
        sym,
        (if 8 as libc::c_int == 4 as libc::c_int { 0 as libc::c_int } else { offset })
            as Elf64_Addr,
    );
    write32le(
        section_ptr_add(s, 4 as libc::c_int as Elf64_Addr) as *mut libc::c_uchar,
        (if 8 as libc::c_int == 4 as libc::c_int { offset } else { 0 as libc::c_int })
            as uint32_t,
    );
}
unsafe extern "C" fn dwarf_strp(mut s: *mut Section, mut str: *const libc::c_char) {
    let mut s1: *mut TCCState = (*s).s1;
    dwarf_string(s, (*s1).dwarf_str_section, (*(*s1).dState).dwarf_sym.str_0, str);
}
unsafe extern "C" fn dwarf_line_strp(mut s: *mut Section, mut str: *const libc::c_char) {
    let mut s1: *mut TCCState = (*s).s1;
    dwarf_string(
        s,
        (*s1).dwarf_line_str_section,
        (*(*s1).dState).dwarf_sym.line_str,
        str,
    );
}
unsafe extern "C" fn dwarf_line_op(mut s1: *mut TCCState, mut op: libc::c_uchar) {
    if (*(*s1).dState).dwarf_line.line_size >= (*(*s1).dState).dwarf_line.line_max_size {
        (*(*s1).dState).dwarf_line.line_max_size += 1024 as libc::c_int;
        (*(*s1).dState)
            .dwarf_line
            .line_data = tcc_realloc(
            (*(*s1).dState).dwarf_line.line_data as *mut libc::c_void,
            (*(*s1).dState).dwarf_line.line_max_size as libc::c_ulong,
        ) as *mut libc::c_uchar;
    }
    let fresh2 = (*(*s1).dState).dwarf_line.line_size;
    (*(*s1).dState).dwarf_line.line_size = (*(*s1).dState).dwarf_line.line_size + 1;
    *((*(*s1).dState).dwarf_line.line_data).offset(fresh2 as isize) = op;
}
unsafe extern "C" fn dwarf_file(mut s1: *mut TCCState) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut filename: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut index_offset: libc::c_int = (((*s1).dwarf as libc::c_int) < 5 as libc::c_int)
        as libc::c_int;
    if strcmp(
        ((*file).filename).as_mut_ptr(),
        b"<command line>\0" as *const u8 as *const libc::c_char,
    ) == 0
    {
        (*(*s1).dState).dwarf_line.cur_file = 1 as libc::c_int;
        return;
    }
    filename = strrchr(((*file).filename).as_mut_ptr(), '/' as i32);
    if filename.is_null() {
        i = 1 as libc::c_int;
        while i < (*(*s1).dState).dwarf_line.filename_size {
            if (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                .dir_entry == 0 as libc::c_int
                && strcmp(
                    (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                        .name,
                    ((*file).filename).as_mut_ptr(),
                ) == 0 as libc::c_int
            {
                (*(*s1).dState).dwarf_line.cur_file = i + index_offset;
                return;
            }
            i += 1;
            i;
        }
        i = -index_offset;
        filename = ((*file).filename).as_mut_ptr();
    } else {
        let mut undo: *mut libc::c_char = filename;
        let mut dir: *mut libc::c_char = ((*file).filename).as_mut_ptr();
        let fresh3 = filename;
        filename = filename.offset(1);
        *fresh3 = '\0' as i32 as libc::c_char;
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).dwarf_line.dir_size {
            if strcmp(*((*(*s1).dState).dwarf_line.dir_table).offset(i as isize), dir)
                == 0 as libc::c_int
            {
                j = 1 as libc::c_int;
                while j < (*(*s1).dState).dwarf_line.filename_size {
                    if (*((*(*s1).dState).dwarf_line.filename_table).offset(j as isize))
                        .dir_entry - index_offset == i
                        && strcmp(
                            (*((*(*s1).dState).dwarf_line.filename_table)
                                .offset(j as isize))
                                .name,
                            filename,
                        ) == 0 as libc::c_int
                    {
                        *undo = '/' as i32 as libc::c_char;
                        (*(*s1).dState).dwarf_line.cur_file = j + index_offset;
                        return;
                    }
                    j += 1;
                    j;
                }
                break;
            } else {
                i += 1;
                i;
            }
        }
        if i == (*(*s1).dState).dwarf_line.dir_size {
            (*(*s1).dState).dwarf_line.dir_size += 1;
            (*(*s1).dState).dwarf_line.dir_size;
            (*(*s1).dState)
                .dwarf_line
                .dir_table = tcc_realloc(
                (*(*s1).dState).dwarf_line.dir_table as *mut libc::c_void,
                ((*(*s1).dState).dwarf_line.dir_size as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                    ),
            ) as *mut *mut libc::c_char;
            let ref mut fresh4 = *((*(*s1).dState).dwarf_line.dir_table)
                .offset(i as isize);
            *fresh4 = tcc_strdup(dir);
        }
        *undo = '/' as i32 as libc::c_char;
    }
    (*(*s1).dState)
        .dwarf_line
        .filename_table = tcc_realloc(
        (*(*s1).dState).dwarf_line.filename_table as *mut libc::c_void,
        (((*(*s1).dState).dwarf_line.filename_size + 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(
                ::core::mem::size_of::<dwarf_filename_struct>() as libc::c_ulong,
            ),
    ) as *mut dwarf_filename_struct;
    (*((*(*s1).dState).dwarf_line.filename_table)
        .offset((*(*s1).dState).dwarf_line.filename_size as isize))
        .dir_entry = i + index_offset;
    let ref mut fresh5 = (*((*(*s1).dState).dwarf_line.filename_table)
        .offset((*(*s1).dState).dwarf_line.filename_size as isize))
        .name;
    *fresh5 = tcc_strdup(filename);
    let fresh6 = (*(*s1).dState).dwarf_line.filename_size;
    (*(*s1).dState)
        .dwarf_line
        .filename_size = (*(*s1).dState).dwarf_line.filename_size + 1;
    (*(*s1).dState).dwarf_line.cur_file = fresh6 + index_offset;
}
unsafe extern "C" fn dwarf_sleb128_size(mut value: libc::c_longlong) -> libc::c_int {
    let mut size: libc::c_int = 0 as libc::c_int;
    let mut end: libc::c_longlong = value >> 63 as libc::c_int;
    let mut last: libc::c_uchar = (end & 0x40 as libc::c_int as libc::c_longlong)
        as libc::c_uchar;
    let mut byte: libc::c_uchar = 0;
    loop {
        byte = (value & 0x7f as libc::c_int as libc::c_longlong) as libc::c_uchar;
        value >>= 7 as libc::c_int;
        size += 1;
        size;
        if !(value != end
            || byte as libc::c_int & 0x40 as libc::c_int != last as libc::c_int)
        {
            break;
        }
    }
    return size;
}
unsafe extern "C" fn dwarf_uleb128(mut s: *mut Section, mut value: libc::c_ulonglong) {
    loop {
        let mut byte: libc::c_uchar = (value & 0x7f as libc::c_int as libc::c_ulonglong)
            as libc::c_uchar;
        value >>= 7 as libc::c_int;
        *(section_ptr_add(s, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = (byte as libc::c_int
            | (if value != 0 { 0x80 as libc::c_int } else { 0 as libc::c_int }))
            as uint8_t;
        if !(value != 0 as libc::c_int as libc::c_ulonglong) {
            break;
        }
    };
}
unsafe extern "C" fn dwarf_sleb128(mut s: *mut Section, mut value: libc::c_longlong) {
    let mut more: libc::c_int = 0;
    let mut end: libc::c_longlong = value >> 63 as libc::c_int;
    let mut last: libc::c_uchar = (end & 0x40 as libc::c_int as libc::c_longlong)
        as libc::c_uchar;
    loop {
        let mut byte: libc::c_uchar = (value & 0x7f as libc::c_int as libc::c_longlong)
            as libc::c_uchar;
        value >>= 7 as libc::c_int;
        more = (value != end
            || byte as libc::c_int & 0x40 as libc::c_int != last as libc::c_int)
            as libc::c_int;
        *(section_ptr_add(s, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = (byte as libc::c_int | 0x80 as libc::c_int * more)
            as uint8_t;
        if !(more != 0) {
            break;
        }
    };
}
unsafe extern "C" fn dwarf_uleb128_op(
    mut s1: *mut TCCState,
    mut value: libc::c_ulonglong,
) {
    loop {
        let mut byte: libc::c_uchar = (value & 0x7f as libc::c_int as libc::c_ulonglong)
            as libc::c_uchar;
        value >>= 7 as libc::c_int;
        dwarf_line_op(
            s1,
            (byte as libc::c_int
                | (if value != 0 { 0x80 as libc::c_int } else { 0 as libc::c_int }))
                as libc::c_uchar,
        );
        if !(value != 0 as libc::c_int as libc::c_ulonglong) {
            break;
        }
    };
}
unsafe extern "C" fn dwarf_sleb128_op(
    mut s1: *mut TCCState,
    mut value: libc::c_longlong,
) {
    let mut more: libc::c_int = 0;
    let mut end: libc::c_longlong = value >> 63 as libc::c_int;
    let mut last: libc::c_uchar = (end & 0x40 as libc::c_int as libc::c_longlong)
        as libc::c_uchar;
    loop {
        let mut byte: libc::c_uchar = (value & 0x7f as libc::c_int as libc::c_longlong)
            as libc::c_uchar;
        value >>= 7 as libc::c_int;
        more = (value != end
            || byte as libc::c_int & 0x40 as libc::c_int != last as libc::c_int)
            as libc::c_int;
        dwarf_line_op(
            s1,
            (byte as libc::c_int | 0x80 as libc::c_int * more) as libc::c_uchar,
        );
        if !(more != 0) {
            break;
        }
    };
}
unsafe extern "C" fn tcc_eh_frame_start(mut s1: *mut TCCState) {
    if (*s1).unwind_tables == 0 {
        return;
    }
    (*s1)
        .eh_frame_section = new_section(
        s1,
        b".eh_frame\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
    (*s1).eh_start = (*(*s1).eh_frame_section).data_offset;
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        0 as libc::c_int as uint32_t,
    );
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        0 as libc::c_int as uint32_t,
    );
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = 1 as libc::c_int as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = 'z' as i32 as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = 'R' as i32 as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = 0 as libc::c_int as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 1 as libc::c_int as libc::c_ulonglong);
    dwarf_sleb128((*s1).eh_frame_section, -(8 as libc::c_int) as libc::c_longlong);
    dwarf_uleb128((*s1).eh_frame_section, 16 as libc::c_int as libc::c_ulonglong);
    dwarf_uleb128((*s1).eh_frame_section, 1 as libc::c_int as libc::c_ulonglong);
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_EH_PE_udata4 as libc::c_int
        | DW_EH_PE_signed as libc::c_int | DW_EH_PE_pcrel as libc::c_int) as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = DW_CFA_def_cfa as libc::c_int as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 7 as libc::c_int as libc::c_ulonglong);
    dwarf_uleb128((*s1).eh_frame_section, 8 as libc::c_int as libc::c_ulonglong);
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_CFA_offset as libc::c_int + 16 as libc::c_int) as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 1 as libc::c_int as libc::c_ulonglong);
    while ((*(*s1).eh_frame_section).data_offset).wrapping_sub((*s1).eh_start)
        & 3 as libc::c_int as libc::c_ulong != 0
    {
        *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = DW_CFA_nop as libc::c_int as uint8_t;
    }
    write32le(
        ((*(*s1).eh_frame_section).data).offset((*s1).eh_start as isize),
        ((*(*s1).eh_frame_section).data_offset)
            .wrapping_sub((*s1).eh_start)
            .wrapping_sub(4 as libc::c_int as libc::c_ulong) as uint32_t,
    );
}
unsafe extern "C" fn tcc_debug_frame_end(mut s1: *mut TCCState, mut size: libc::c_int) {
    let mut eh_section_sym: libc::c_int = 0;
    let mut fde_start: libc::c_ulong = 0;
    if ((*s1).eh_frame_section).is_null() {
        return;
    }
    eh_section_sym = dwarf_get_section_sym((*s1).text_section);
    fde_start = (*(*s1).eh_frame_section).data_offset;
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        0 as libc::c_int as uint32_t,
    );
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        fde_start
            .wrapping_sub((*s1).eh_start)
            .wrapping_add(4 as libc::c_int as libc::c_ulong) as uint32_t,
    );
    dwarf_reloc((*s1).eh_frame_section, eh_section_sym, 2 as libc::c_int);
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        func_ind as uint32_t,
    );
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        size as uint32_t,
    );
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = 0 as libc::c_int as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_CFA_advance_loc as libc::c_int + 1 as libc::c_int)
        as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = DW_CFA_def_cfa_offset as libc::c_int as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 16 as libc::c_int as libc::c_ulonglong);
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_CFA_offset as libc::c_int + 6 as libc::c_int) as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 2 as libc::c_int as libc::c_ulonglong);
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_CFA_advance_loc as libc::c_int + 3 as libc::c_int)
        as uint8_t;
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = DW_CFA_def_cfa_register as libc::c_int as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 6 as libc::c_int as libc::c_ulonglong);
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = DW_CFA_advance_loc4 as libc::c_int as uint8_t;
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        (size - 5 as libc::c_int) as uint32_t,
    );
    *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = DW_CFA_def_cfa as libc::c_int as uint8_t;
    dwarf_uleb128((*s1).eh_frame_section, 7 as libc::c_int as libc::c_ulonglong);
    dwarf_uleb128((*s1).eh_frame_section, 8 as libc::c_int as libc::c_ulonglong);
    while ((*(*s1).eh_frame_section).data_offset).wrapping_sub(fde_start)
        & 3 as libc::c_int as libc::c_ulong != 0
    {
        *(section_ptr_add((*s1).eh_frame_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = DW_CFA_nop as libc::c_int as uint8_t;
    }
    write32le(
        ((*(*s1).eh_frame_section).data).offset(fde_start as isize),
        ((*(*s1).eh_frame_section).data_offset)
            .wrapping_sub(fde_start)
            .wrapping_sub(4 as libc::c_int as libc::c_ulong) as uint32_t,
    );
}
unsafe extern "C" fn tcc_eh_frame_end(mut s1: *mut TCCState) {
    if ((*s1).eh_frame_section).is_null() {
        return;
    }
    write32le(
        section_ptr_add((*s1).eh_frame_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        0 as libc::c_int as uint32_t,
    );
}
unsafe extern "C" fn sort_eh_table(
    mut a: *const libc::c_void,
    mut b: *const libc::c_void,
) -> libc::c_int {
    let mut pc1: uint32_t = (*(a as *const eh_search_table)).pc_offset;
    let mut pc2: uint32_t = (*(b as *const eh_search_table)).pc_offset;
    return if pc1 < pc2 {
        -(1 as libc::c_int)
    } else if pc1 > pc2 {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
}
unsafe extern "C" fn tcc_eh_frame_hdr(mut s1: *mut TCCState, mut final_0: libc::c_int) {
    let mut current_block: u64;
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut offset: libc::c_int = 0;
    let mut count_offset: libc::c_ulong = 0;
    let mut tab_offset: libc::c_ulong = 0;
    let mut ln: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut last_cie_offset: libc::c_uint = 0xffffffff as libc::c_uint;
    if ((*s1).eh_frame_section).is_null() || (*(*s1).eh_frame_section).data_offset == 0 {
        return;
    }
    if final_0 != 0 && ((*s1).eh_frame_hdr_section).is_null() {
        return;
    }
    if final_0 == 0 as libc::c_int {
        (*s1)
            .eh_frame_hdr_section = new_section(
            s1,
            b".eh_frame_hdr\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int,
        );
    }
    (*(*s1).eh_frame_hdr_section).data_offset = 0 as libc::c_int as libc::c_ulong;
    *(section_ptr_add((*s1).eh_frame_hdr_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = 1 as libc::c_int as uint8_t;
    *(section_ptr_add((*s1).eh_frame_hdr_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_EH_PE_sdata4 as libc::c_int
        | DW_EH_PE_pcrel as libc::c_int) as uint8_t;
    *(section_ptr_add((*s1).eh_frame_hdr_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_EH_PE_udata4 as libc::c_int
        | DW_EH_PE_absptr as libc::c_int) as uint8_t;
    *(section_ptr_add((*s1).eh_frame_hdr_section, 1 as libc::c_int as Elf64_Addr)
        as *mut uint8_t) = (DW_EH_PE_sdata4 as libc::c_int
        | DW_EH_PE_datarel as libc::c_int) as uint8_t;
    offset = ((*(*s1).eh_frame_section).sh_addr)
        .wrapping_sub((*(*s1).eh_frame_hdr_section).sh_addr)
        .wrapping_sub((*(*s1).eh_frame_hdr_section).data_offset) as libc::c_int;
    write32le(
        section_ptr_add((*s1).eh_frame_hdr_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        offset as uint32_t,
    );
    count_offset = (*(*s1).eh_frame_hdr_section).data_offset;
    write32le(
        section_ptr_add((*s1).eh_frame_hdr_section, 4 as libc::c_int as Elf64_Addr)
            as *mut libc::c_uchar,
        0 as libc::c_int as uint32_t,
    );
    tab_offset = (*(*s1).eh_frame_hdr_section).data_offset;
    ln = (*(*s1).eh_frame_section).data;
    end = ((*(*s1).eh_frame_section).data)
        .offset((*(*s1).eh_frame_section).data_offset as isize);
    while ln < end {
        let mut fde: *mut libc::c_uchar = ln;
        let mut rd: *mut libc::c_uchar = ln;
        let mut cie_offset: libc::c_uint = 0;
        let mut version: libc::c_uint = 0;
        let mut length: libc::c_uint = if rd.offset(3 as libc::c_int as isize) < end {
            rd = rd.offset(4 as libc::c_int as isize);
            read32le(rd.offset(-(4 as libc::c_int as isize)))
        } else {
            0 as libc::c_int as uint32_t
        };
        let mut pc_offset: libc::c_uint = 0;
        let mut fde_offset: libc::c_uint = 0;
        if !(length == 0 as libc::c_int as libc::c_uint) {
            cie_offset = if rd.offset(3 as libc::c_int as isize) < end {
                rd = rd.offset(4 as libc::c_int as isize);
                read32le(rd.offset(-(4 as libc::c_int as isize)))
            } else {
                0 as libc::c_int as uint32_t
            };
            if !(cie_offset == 0 as libc::c_int as libc::c_uint) {
                if cie_offset != last_cie_offset {
                    let mut cie: *mut libc::c_uchar = rd
                        .offset(-(cie_offset as isize))
                        .offset(4 as libc::c_int as isize);
                    if cie < (*(*s1).eh_frame_section).data {
                        current_block = 15396267755452377945;
                    } else {
                        version = (if cie < end {
                            let fresh7 = cie;
                            cie = cie.offset(1);
                            *fresh7 as libc::c_int
                        } else {
                            0 as libc::c_int
                        }) as libc::c_uint;
                        if (version == 1 as libc::c_int as libc::c_uint
                            || version == 3 as libc::c_int as libc::c_uint)
                            && (if cie < end {
                                let fresh8 = cie;
                                cie = cie.offset(1);
                                *fresh8 as libc::c_int
                            } else {
                                0 as libc::c_int
                            }) == 'z' as i32
                            && (if cie < end {
                                let fresh9 = cie;
                                cie = cie.offset(1);
                                *fresh9 as libc::c_int
                            } else {
                                0 as libc::c_int
                            }) == 'R' as i32
                            && (if cie < end {
                                let fresh10 = cie;
                                cie = cie.offset(1);
                                *fresh10 as libc::c_int
                            } else {
                                0 as libc::c_int
                            }) == 0 as libc::c_int
                        {
                            dwarf_read_uleb128(&mut cie, end);
                            dwarf_read_sleb128(&mut cie, end);
                            if cie < end {
                                let fresh11 = cie;
                                cie = cie.offset(1);
                                *fresh11;
                            } else {};
                            if dwarf_read_uleb128(&mut cie, end)
                                == 1 as libc::c_int as uint64_t
                                && (if cie < end {
                                    let fresh12 = cie;
                                    cie = cie.offset(1);
                                    *fresh12 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                })
                                    == DW_EH_PE_udata4 as libc::c_int
                                        | DW_EH_PE_signed as libc::c_int
                                        | DW_EH_PE_pcrel as libc::c_int
                            {
                                last_cie_offset = cie_offset;
                                current_block = 14818589718467733107;
                            } else {
                                current_block = 15396267755452377945;
                            }
                        } else {
                            current_block = 15396267755452377945;
                        }
                    }
                } else {
                    current_block = 14818589718467733107;
                }
                match current_block {
                    15396267755452377945 => {}
                    _ => {
                        count += 1;
                        count;
                        fde_offset = ((*(*s1).eh_frame_section).sh_addr)
                            .wrapping_add(
                                fde.offset_from((*(*s1).eh_frame_section).data)
                                    as libc::c_long as Elf64_Addr,
                            )
                            .wrapping_sub((*(*s1).eh_frame_hdr_section).sh_addr)
                            as libc::c_uint;
                        pc_offset = (if rd.offset(3 as libc::c_int as isize) < end {
                            rd = rd.offset(4 as libc::c_int as isize);
                            read32le(rd.offset(-(4 as libc::c_int as isize)))
                        } else {
                            0 as libc::c_int as uint32_t
                        })
                            .wrapping_add(fde_offset)
                            .wrapping_add(8 as libc::c_int as libc::c_uint);
                        write32le(
                            section_ptr_add(
                                (*s1).eh_frame_hdr_section,
                                4 as libc::c_int as Elf64_Addr,
                            ) as *mut libc::c_uchar,
                            pc_offset,
                        );
                        write32le(
                            section_ptr_add(
                                (*s1).eh_frame_hdr_section,
                                4 as libc::c_int as Elf64_Addr,
                            ) as *mut libc::c_uchar,
                            fde_offset,
                        );
                    }
                }
            }
        }
        ln = ln.offset(length.wrapping_add(4 as libc::c_int as libc::c_uint) as isize);
    }
    add32le(((*(*s1).eh_frame_hdr_section).data).offset(count_offset as isize), count);
    qsort(
        ((*(*s1).eh_frame_hdr_section).data).offset(tab_offset as isize)
            as *mut libc::c_void,
        count as size_t,
        ::core::mem::size_of::<eh_search_table>() as libc::c_ulong,
        Some(
            sort_eh_table
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
}
unsafe extern "C" fn tcc_debug_start(mut s1: *mut TCCState) {
    let mut i: libc::c_int = 0;
    let mut buf: [libc::c_char; 512] = [0; 512];
    let mut filename: *mut libc::c_char = 0 as *mut libc::c_char;
    filename = if !((*file).prev).is_null() {
        ((*(*file).prev).filename).as_mut_ptr()
    } else {
        ((*file).filename).as_mut_ptr()
    };
    put_elf_sym(
        (*s1).c2rust_unnamed.symtab_section,
        0 as libc::c_int as Elf64_Addr,
        0 as libc::c_int as libc::c_ulong,
        ((0 as libc::c_int) << 4 as libc::c_int)
            + (4 as libc::c_int & 0xf as libc::c_int),
        0 as libc::c_int,
        0xfff1 as libc::c_int,
        filename,
    );
    if (*s1).do_debug != 0 {
        put_elf_sym(
            (*s1).c2rust_unnamed.symtab_section,
            (*(*s1).text_section).data_offset,
            0 as libc::c_int as libc::c_ulong,
            ((0 as libc::c_int) << 4 as libc::c_int)
                + (0 as libc::c_int & 0xf as libc::c_int),
            0 as libc::c_int,
            (*(*s1).text_section).sh_num,
            b"$a\0" as *const u8 as *const libc::c_char,
        );
        (*(*s1).dState).last_line_num = 0 as libc::c_int;
        (*(*s1).dState).new_file = (*(*s1).dState).last_line_num;
        (*(*s1).dState)
            .debug_next_type = (::core::mem::size_of::<[C2RustUnnamed_17; 29]>()
            as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong)
            as libc::c_int;
        (*(*s1).dState).debug_hash = 0 as *mut _debug_hash;
        (*(*s1).dState).debug_anon_hash = 0 as *mut _debug_anon_hash;
        (*(*s1).dState).n_debug_hash = 0 as libc::c_int;
        (*(*s1).dState).n_debug_anon_hash = 0 as libc::c_int;
        getcwd(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
        );
        if (*s1).dwarf != 0 {
            let mut start_abbrev: libc::c_int = 0;
            let mut ptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut undo: *mut libc::c_char = 0 as *mut libc::c_char;
            start_abbrev = (*(*s1).dwarf_abbrev_section).data_offset as libc::c_int;
            ptr = section_ptr_add(
                (*s1).dwarf_abbrev_section,
                ::core::mem::size_of::<[libc::c_uchar; 335]>() as libc::c_ulong,
            ) as *mut libc::c_uchar;
            memcpy(
                ptr as *mut libc::c_void,
                dwarf_abbrev_init.as_ptr() as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_uchar; 335]>() as libc::c_ulong,
            );
            if ((*s1).dwarf as libc::c_int) < 5 as libc::c_int {
                while *ptr != 0 {
                    ptr = ptr.offset(3 as libc::c_int as isize);
                    while *ptr != 0 {
                        if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                            == DW_FORM_line_strp as libc::c_int
                        {
                            *ptr
                                .offset(
                                    1 as libc::c_int as isize,
                                ) = DW_FORM_strp as libc::c_int as libc::c_uchar;
                        }
                        if ((*s1).dwarf as libc::c_int) < 4 as libc::c_int {
                            if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == DW_FORM_sec_offset as libc::c_int
                            {
                                *ptr
                                    .offset(
                                        1 as libc::c_int as isize,
                                    ) = DW_FORM_data4 as libc::c_int as libc::c_uchar;
                            }
                            if *ptr.offset(1 as libc::c_int as isize) as libc::c_int
                                == DW_FORM_exprloc as libc::c_int
                            {
                                *ptr
                                    .offset(
                                        1 as libc::c_int as isize,
                                    ) = DW_FORM_block1 as libc::c_int as libc::c_uchar;
                            }
                        }
                        ptr = ptr.offset(2 as libc::c_int as isize);
                    }
                    ptr = ptr.offset(2 as libc::c_int as isize);
                }
            }
            (*(*s1).dState)
                .dwarf_sym
                .info = dwarf_get_section_sym((*s1).dwarf_info_section);
            (*(*s1).dState)
                .dwarf_sym
                .abbrev = dwarf_get_section_sym((*s1).dwarf_abbrev_section);
            (*(*s1).dState)
                .dwarf_sym
                .line = dwarf_get_section_sym((*s1).dwarf_line_section);
            (*(*s1).dState)
                .dwarf_sym
                .str_0 = dwarf_get_section_sym((*s1).dwarf_str_section);
            if (*tcc_state).dwarf as libc::c_int >= 5 as libc::c_int {
                (*(*s1).dState)
                    .dwarf_sym
                    .line_str = dwarf_get_section_sym((*s1).dwarf_line_str_section);
            } else {
                (*s1).dwarf_line_str_section = (*s1).dwarf_str_section;
                (*(*s1).dState).dwarf_sym.line_str = (*(*s1).dState).dwarf_sym.str_0;
            }
            (*(*s1).dState).section_sym = dwarf_get_section_sym((*s1).text_section);
            (*(*s1).dState)
                .dwarf_info
                .start = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            write16le(
                section_ptr_add((*s1).dwarf_info_section, 2 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                (*s1).dwarf as uint16_t,
            );
            if (*s1).dwarf as libc::c_int >= 5 as libc::c_int {
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = DW_UT_compile as libc::c_int as uint8_t;
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 8 as libc::c_int as uint8_t;
                dwarf_reloc(
                    (*s1).dwarf_info_section,
                    (*(*s1).dState).dwarf_sym.abbrev,
                    10 as libc::c_int,
                );
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    start_abbrev as uint32_t,
                );
            } else {
                dwarf_reloc(
                    (*s1).dwarf_info_section,
                    (*(*s1).dState).dwarf_sym.abbrev,
                    10 as libc::c_int,
                );
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    start_abbrev as uint32_t,
                );
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 8 as libc::c_int as uint8_t;
            }
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 1 as libc::c_int as uint8_t;
            dwarf_strp(
                (*s1).dwarf_info_section,
                b"tcc 0.9.28rc\0" as *const u8 as *const libc::c_char,
            );
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = (if (*s1).cversion
                == 201112 as libc::c_int as libc::c_uint
            {
                DW_LANG_C11 as libc::c_int
            } else {
                DW_LANG_C99 as libc::c_int
            }) as uint8_t;
            dwarf_line_strp((*s1).dwarf_info_section, filename);
            dwarf_line_strp((*s1).dwarf_info_section, buf.as_mut_ptr());
            dwarf_reloc(
                (*s1).dwarf_info_section,
                (*(*s1).dState).section_sym,
                1 as libc::c_int,
            );
            write64le(
                section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                ind as uint64_t,
            );
            write64le(
                section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint64_t,
            );
            dwarf_reloc(
                (*s1).dwarf_info_section,
                (*(*s1).dState).dwarf_sym.line,
                10 as libc::c_int,
            );
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                (*(*s1).dwarf_line_section).data_offset as uint32_t,
            );
            (*(*s1).dState)
                .dwarf_line
                .start = (*(*s1).dwarf_line_section).data_offset as libc::c_int;
            write32le(
                section_ptr_add((*s1).dwarf_line_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            write16le(
                section_ptr_add((*s1).dwarf_line_section, 2 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                (*s1).dwarf as uint16_t,
            );
            if (*s1).dwarf as libc::c_int >= 5 as libc::c_int {
                *(section_ptr_add(
                    (*s1).dwarf_line_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 8 as libc::c_int as uint8_t;
                *(section_ptr_add(
                    (*s1).dwarf_line_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 0 as libc::c_int as uint8_t;
            }
            write32le(
                section_ptr_add((*s1).dwarf_line_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 1 as libc::c_int as uint8_t;
            if (*s1).dwarf as libc::c_int >= 4 as libc::c_int {
                *(section_ptr_add(
                    (*s1).dwarf_line_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 1 as libc::c_int as uint8_t;
            }
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 1 as libc::c_int as uint8_t;
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = -(5 as libc::c_int) as uint8_t;
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 14 as libc::c_int as uint8_t;
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 13 as libc::c_int as uint8_t;
            ptr = section_ptr_add(
                (*s1).dwarf_line_section,
                ::core::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong,
            ) as *mut libc::c_uchar;
            memcpy(
                ptr as *mut libc::c_void,
                dwarf_line_opcodes.as_ptr() as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong,
            );
            undo = strrchr(filename, '/' as i32);
            if !undo.is_null() {
                *undo = 0 as libc::c_int as libc::c_char;
            }
            (*(*s1).dState)
                .dwarf_line
                .dir_size = 1 as libc::c_int
                + (undo != 0 as *mut libc::c_void as *mut libc::c_char) as libc::c_int;
            (*(*s1).dState)
                .dwarf_line
                .dir_table = tcc_malloc(
                (::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                    .wrapping_mul((*(*s1).dState).dwarf_line.dir_size as libc::c_ulong),
            ) as *mut *mut libc::c_char;
            let ref mut fresh13 = *((*(*s1).dState).dwarf_line.dir_table)
                .offset(0 as libc::c_int as isize);
            *fresh13 = tcc_strdup(buf.as_mut_ptr());
            if !undo.is_null() {
                let ref mut fresh14 = *((*(*s1).dState).dwarf_line.dir_table)
                    .offset(1 as libc::c_int as isize);
                *fresh14 = tcc_strdup(filename);
            }
            (*(*s1).dState).dwarf_line.filename_size = 2 as libc::c_int;
            (*(*s1).dState)
                .dwarf_line
                .filename_table = tcc_malloc(
                (2 as libc::c_int as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<dwarf_filename_struct>() as libc::c_ulong,
                    ),
            ) as *mut dwarf_filename_struct;
            (*((*(*s1).dState).dwarf_line.filename_table)
                .offset(0 as libc::c_int as isize))
                .dir_entry = 0 as libc::c_int;
            if !undo.is_null() {
                let ref mut fresh15 = (*((*(*s1).dState).dwarf_line.filename_table)
                    .offset(0 as libc::c_int as isize))
                    .name;
                *fresh15 = tcc_strdup(undo.offset(1 as libc::c_int as isize));
                (*((*(*s1).dState).dwarf_line.filename_table)
                    .offset(1 as libc::c_int as isize))
                    .dir_entry = 1 as libc::c_int;
                let ref mut fresh16 = (*((*(*s1).dState).dwarf_line.filename_table)
                    .offset(1 as libc::c_int as isize))
                    .name;
                *fresh16 = tcc_strdup(undo.offset(1 as libc::c_int as isize));
                *undo = '/' as i32 as libc::c_char;
            } else {
                let ref mut fresh17 = (*((*(*s1).dState).dwarf_line.filename_table)
                    .offset(0 as libc::c_int as isize))
                    .name;
                *fresh17 = tcc_strdup(filename);
                (*((*(*s1).dState).dwarf_line.filename_table)
                    .offset(1 as libc::c_int as isize))
                    .dir_entry = 0 as libc::c_int;
                let ref mut fresh18 = (*((*(*s1).dState).dwarf_line.filename_table)
                    .offset(1 as libc::c_int as isize))
                    .name;
                *fresh18 = tcc_strdup(filename);
            }
            (*(*s1).dState).dwarf_line.line_max_size = 0 as libc::c_int;
            (*(*s1).dState)
                .dwarf_line
                .line_size = (*(*s1).dState).dwarf_line.line_max_size;
            (*(*s1).dState).dwarf_line.line_data = 0 as *mut libc::c_uchar;
            (*(*s1).dState).dwarf_line.cur_file = 1 as libc::c_int;
            (*(*s1).dState).dwarf_line.last_file = 0 as libc::c_int;
            (*(*s1).dState).dwarf_line.last_pc = 0 as libc::c_int;
            (*(*s1).dState).dwarf_line.last_line = 1 as libc::c_int;
            dwarf_line_op(s1, 0 as libc::c_int as libc::c_uchar);
            dwarf_uleb128_op(
                s1,
                (1 as libc::c_int + 8 as libc::c_int) as libc::c_ulonglong,
            );
            dwarf_line_op(s1, DW_LNE_set_address as libc::c_int as libc::c_uchar);
            i = 0 as libc::c_int;
            while i < 8 as libc::c_int {
                dwarf_line_op(s1, 0 as libc::c_int as libc::c_uchar);
                i += 1;
                i;
            }
            memset(
                &mut (*(*s1).dState).dwarf_info.base_type_used as *mut [libc::c_int; 29]
                    as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<[libc::c_int; 29]>() as libc::c_ulong,
            );
        } else {
            pstrcat(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 512]>() as libc::c_ulong,
                b"/\0" as *const u8 as *const libc::c_char,
            );
            (*(*s1).dState)
                .section_sym = put_elf_sym(
                (*s1).c2rust_unnamed.symtab_section,
                0 as libc::c_int as Elf64_Addr,
                0 as libc::c_int as libc::c_ulong,
                ((0 as libc::c_int) << 4 as libc::c_int)
                    + (3 as libc::c_int & 0xf as libc::c_int),
                0 as libc::c_int,
                (*(*s1).text_section).sh_num,
                0 as *const libc::c_char,
            );
            put_stabs_r(
                s1,
                buf.as_mut_ptr(),
                N_SO as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (*(*s1).text_section).data_offset,
                (*s1).text_section,
                (*(*s1).dState).section_sym,
            );
            put_stabs_r(
                s1,
                filename,
                N_SO as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (*(*s1).text_section).data_offset,
                (*s1).text_section,
                (*(*s1).dState).section_sym,
            );
            i = 0 as libc::c_int;
            while (i as libc::c_ulong)
                < (::core::mem::size_of::<[C2RustUnnamed_17; 29]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong,
                    )
            {
                put_stabs(
                    s1,
                    default_debug[i as usize].name,
                    N_LSYM as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int,
                    0 as libc::c_int as libc::c_ulong,
                );
                i += 1;
                i;
            }
        }
        tcc_debug_bincl(s1);
    }
}
unsafe extern "C" fn tcc_debug_end(mut s1: *mut TCCState) {
    if (*s1).do_debug == 0 || (*(*s1).dState).debug_next_type == 0 as libc::c_int {
        return;
    }
    if !((*(*s1).dState).debug_info_root).is_null() {
        tcc_debug_funcend(s1, 0 as libc::c_int);
    }
    if (*s1).dwarf != 0 {
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut start_aranges: libc::c_int = 0;
        let mut ptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
        let mut text_size: libc::c_int = (*(*s1).text_section).data_offset
            as libc::c_int;
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).n_debug_anon_hash {
            let mut t: *mut Sym = (*((*(*s1).dState).debug_anon_hash).offset(i as isize))
                .type_0;
            let mut pos: libc::c_int = (*(*s1).dwarf_info_section).data_offset
                as libc::c_int;
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = (if (*t).type_0.t as libc::c_uint
                & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint
                    | 0xf as libc::c_int as libc::c_uint)
                == ((1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int)
                    as libc::c_uint
            {
                19 as libc::c_int
            } else {
                17 as libc::c_int
            }) as uint8_t;
            dwarf_strp(
                (*s1).dwarf_info_section,
                if (*t).v & !(0x40000000 as libc::c_int) >= 0x10000000 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    get_tok_str((*t).v, 0 as *mut CValue)
                },
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                0 as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*file).line_num as libc::c_ulonglong,
            );
            j = 0 as libc::c_int;
            while j
                < (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).n_debug_type
            {
                write32le(
                    ((*(*s1).dwarf_info_section).data)
                        .offset(
                            *((*((*(*s1).dState).debug_anon_hash).offset(i as isize))
                                .debug_type)
                                .offset(j as isize) as isize,
                        ),
                    (pos - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
                j += 1;
                j;
            }
            tcc_free(
                (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).debug_type
                    as *mut libc::c_void,
            );
            i += 1;
            i;
        }
        tcc_free((*(*s1).dState).debug_anon_hash as *mut libc::c_void);
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = 0 as libc::c_int as uint8_t;
        ptr = ((*(*s1).dwarf_info_section).data)
            .offset((*(*s1).dState).dwarf_info.start as isize);
        write32le(
            ptr,
            ((*(*s1).dwarf_info_section).data_offset)
                .wrapping_sub((*(*s1).dState).dwarf_info.start as libc::c_ulong)
                .wrapping_sub(4 as libc::c_int as libc::c_ulong) as uint32_t,
        );
        write32le(
            ptr
                .offset(25 as libc::c_int as isize)
                .offset(
                    ((*s1).dwarf as libc::c_int >= 5 as libc::c_int) as libc::c_int
                        as isize,
                )
                .offset(8 as libc::c_int as isize),
            text_size as uint32_t,
        );
        start_aranges = (*(*s1).dwarf_aranges_section).data_offset as libc::c_int;
        write32le(
            section_ptr_add((*s1).dwarf_aranges_section, 4 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint32_t,
        );
        write16le(
            section_ptr_add((*s1).dwarf_aranges_section, 2 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            2 as libc::c_int as uint16_t,
        );
        dwarf_reloc(
            (*s1).dwarf_aranges_section,
            (*(*s1).dState).dwarf_sym.info,
            10 as libc::c_int,
        );
        write32le(
            section_ptr_add((*s1).dwarf_aranges_section, 4 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint32_t,
        );
        *(section_ptr_add((*s1).dwarf_aranges_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = 8 as libc::c_int as uint8_t;
        *(section_ptr_add((*s1).dwarf_aranges_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = 0 as libc::c_int as uint8_t;
        write32le(
            section_ptr_add((*s1).dwarf_aranges_section, 4 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint32_t,
        );
        dwarf_reloc(
            (*s1).dwarf_aranges_section,
            (*(*s1).dState).section_sym,
            1 as libc::c_int,
        );
        write64le(
            section_ptr_add((*s1).dwarf_aranges_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint64_t,
        );
        write64le(
            section_ptr_add((*s1).dwarf_aranges_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            text_size as uint64_t,
        );
        write64le(
            section_ptr_add((*s1).dwarf_aranges_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint64_t,
        );
        write64le(
            section_ptr_add((*s1).dwarf_aranges_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint64_t,
        );
        ptr = ((*(*s1).dwarf_aranges_section).data).offset(start_aranges as isize);
        write32le(
            ptr,
            ((*(*s1).dwarf_aranges_section).data_offset)
                .wrapping_sub(start_aranges as libc::c_ulong)
                .wrapping_sub(4 as libc::c_int as libc::c_ulong) as uint32_t,
        );
        if (*s1).dwarf as libc::c_int >= 5 as libc::c_int {
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 1 as libc::c_int as uint8_t;
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                DW_LNCT_path as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                DW_FORM_line_strp as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                (*(*s1).dState).dwarf_line.dir_size as libc::c_ulonglong,
            );
            i = 0 as libc::c_int;
            while i < (*(*s1).dState).dwarf_line.dir_size {
                dwarf_line_strp(
                    (*s1).dwarf_line_section,
                    *((*(*s1).dState).dwarf_line.dir_table).offset(i as isize),
                );
                i += 1;
                i;
            }
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 2 as libc::c_int as uint8_t;
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                DW_LNCT_path as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                DW_FORM_line_strp as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                DW_LNCT_directory_index as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                DW_FORM_udata as libc::c_int as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_line_section,
                (*(*s1).dState).dwarf_line.filename_size as libc::c_ulonglong,
            );
            i = 0 as libc::c_int;
            while i < (*(*s1).dState).dwarf_line.filename_size {
                dwarf_line_strp(
                    (*s1).dwarf_line_section,
                    (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                        .name,
                );
                dwarf_uleb128(
                    (*s1).dwarf_line_section,
                    (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                        .dir_entry as libc::c_ulonglong,
                );
                i += 1;
                i;
            }
        } else {
            let mut len: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i < (*(*s1).dState).dwarf_line.dir_size {
                len = (strlen(
                    *((*(*s1).dState).dwarf_line.dir_table).offset(i as isize),
                ))
                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                ptr = section_ptr_add((*s1).dwarf_line_section, len as Elf64_Addr)
                    as *mut libc::c_uchar;
                memmove(
                    ptr as *mut libc::c_void,
                    *((*(*s1).dState).dwarf_line.dir_table).offset(i as isize)
                        as *const libc::c_void,
                    len as libc::c_ulong,
                );
                i += 1;
                i;
            }
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 0 as libc::c_int as uint8_t;
            i = 0 as libc::c_int;
            while i < (*(*s1).dState).dwarf_line.filename_size {
                len = (strlen(
                    (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                        .name,
                ))
                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                ptr = section_ptr_add((*s1).dwarf_line_section, len as Elf64_Addr)
                    as *mut libc::c_uchar;
                memmove(
                    ptr as *mut libc::c_void,
                    (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                        .name as *const libc::c_void,
                    len as libc::c_ulong,
                );
                dwarf_uleb128(
                    (*s1).dwarf_line_section,
                    (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize))
                        .dir_entry as libc::c_ulonglong,
                );
                dwarf_uleb128(
                    (*s1).dwarf_line_section,
                    0 as libc::c_int as libc::c_ulonglong,
                );
                dwarf_uleb128(
                    (*s1).dwarf_line_section,
                    0 as libc::c_int as libc::c_ulonglong,
                );
                i += 1;
                i;
            }
            *(section_ptr_add((*s1).dwarf_line_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 0 as libc::c_int as uint8_t;
        }
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).dwarf_line.dir_size {
            tcc_free(
                *((*(*s1).dState).dwarf_line.dir_table).offset(i as isize)
                    as *mut libc::c_void,
            );
            i += 1;
            i;
        }
        tcc_free((*(*s1).dState).dwarf_line.dir_table as *mut libc::c_void);
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).dwarf_line.filename_size {
            tcc_free(
                (*((*(*s1).dState).dwarf_line.filename_table).offset(i as isize)).name
                    as *mut libc::c_void,
            );
            i += 1;
            i;
        }
        tcc_free((*(*s1).dState).dwarf_line.filename_table as *mut libc::c_void);
        dwarf_line_op(s1, 0 as libc::c_int as libc::c_uchar);
        dwarf_uleb128_op(s1, 1 as libc::c_int as libc::c_ulonglong);
        dwarf_line_op(s1, DW_LNE_end_sequence as libc::c_int as libc::c_uchar);
        i = ((*s1).dwarf as libc::c_int >= 5 as libc::c_int) as libc::c_int
            * 2 as libc::c_int;
        write32le(
            &mut *((*(*s1).dwarf_line_section).data)
                .offset(
                    ((*(*s1).dState).dwarf_line.start + 6 as libc::c_int + i) as isize,
                ),
            ((*(*s1).dwarf_line_section).data_offset)
                .wrapping_sub((*(*s1).dState).dwarf_line.start as libc::c_ulong)
                .wrapping_sub((10 as libc::c_int + i) as libc::c_ulong) as uint32_t,
        );
        section_ptr_add((*s1).dwarf_line_section, 3 as libc::c_int as Elf64_Addr);
        dwarf_reloc(
            (*s1).dwarf_line_section,
            (*(*s1).dState).section_sym,
            1 as libc::c_int,
        );
        ptr = section_ptr_add(
            (*s1).dwarf_line_section,
            ((*(*s1).dState).dwarf_line.line_size - 3 as libc::c_int) as Elf64_Addr,
        ) as *mut libc::c_uchar;
        memmove(
            ptr.offset(-(3 as libc::c_int as isize)) as *mut libc::c_void,
            (*(*s1).dState).dwarf_line.line_data as *const libc::c_void,
            (*(*s1).dState).dwarf_line.line_size as libc::c_ulong,
        );
        tcc_free((*(*s1).dState).dwarf_line.line_data as *mut libc::c_void);
        write32le(
            ((*(*s1).dwarf_line_section).data)
                .offset((*(*s1).dState).dwarf_line.start as isize),
            ((*(*s1).dwarf_line_section).data_offset)
                .wrapping_sub((*(*s1).dState).dwarf_line.start as libc::c_ulong)
                .wrapping_sub(4 as libc::c_int as libc::c_ulong) as uint32_t,
        );
    } else {
        put_stabs_r(
            s1,
            0 as *const libc::c_char,
            N_SO as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            (*(*s1).text_section).data_offset,
            (*s1).text_section,
            (*(*s1).dState).section_sym,
        );
    }
    tcc_free((*(*s1).dState).debug_hash as *mut libc::c_void);
    (*(*s1).dState).debug_next_type = 0 as libc::c_int;
}
unsafe extern "C" fn put_new_file(mut s1: *mut TCCState) -> *mut BufferedFile {
    let mut f: *mut BufferedFile = file;
    if (*f).filename[0 as libc::c_int as usize] as libc::c_int == ':' as i32 {
        f = (*f).prev;
    }
    if !f.is_null() && (*(*s1).dState).new_file != 0 {
        (*(*s1).dState).last_line_num = 0 as libc::c_int;
        (*(*s1).dState).new_file = (*(*s1).dState).last_line_num;
        if (*s1).dwarf != 0 {
            dwarf_file(s1);
        } else {
            put_stabs_r(
                s1,
                ((*f).filename).as_mut_ptr(),
                N_SOL as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                ind as libc::c_ulong,
                (*s1).text_section,
                (*(*s1).dState).section_sym,
            );
        }
    }
    return f;
}
unsafe extern "C" fn tcc_debug_newfile(mut s1: *mut TCCState) {
    if (*s1).do_debug == 0 {
        return;
    }
    if (*s1).dwarf != 0 {
        dwarf_file(s1);
    }
    (*(*s1).dState).new_file = 1 as libc::c_int;
}
unsafe extern "C" fn tcc_debug_bincl(mut s1: *mut TCCState) {
    if (*s1).do_debug == 0 {
        return;
    }
    if (*s1).dwarf != 0 {
        dwarf_file(s1);
    } else {
        put_stabs(
            s1,
            ((*file).filename).as_mut_ptr(),
            N_BINCL as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int as libc::c_ulong,
        );
    }
    (*(*s1).dState).new_file = 1 as libc::c_int;
}
unsafe extern "C" fn tcc_debug_eincl(mut s1: *mut TCCState) {
    if (*s1).do_debug == 0 {
        return;
    }
    if (*s1).dwarf != 0 {
        dwarf_file(s1);
    } else {
        put_stabn(
            s1,
            N_EINCL as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
            0 as libc::c_int,
        );
    }
    (*(*s1).dState).new_file = 1 as libc::c_int;
}
unsafe extern "C" fn tcc_debug_line(mut s1: *mut TCCState) {
    let mut f: *mut BufferedFile = 0 as *mut BufferedFile;
    if (*s1).do_debug == 0 {
        return;
    }
    if (*s1).cur_text_section != (*s1).text_section || nocode_wanted != 0 {
        return;
    }
    f = put_new_file(s1);
    if f.is_null() {
        return;
    }
    if (*(*s1).dState).last_line_num == (*f).line_num {
        return;
    }
    (*(*s1).dState).last_line_num = (*f).line_num;
    if (*s1).dwarf != 0 {
        let mut len_pc: libc::c_int = (ind - (*(*s1).dState).dwarf_line.last_pc)
            / 1 as libc::c_int;
        let mut len_line: libc::c_int = (*f).line_num
            - (*(*s1).dState).dwarf_line.last_line;
        let mut n: libc::c_int = len_pc * 14 as libc::c_int + len_line
            + 13 as libc::c_int - -(5 as libc::c_int);
        if (*(*s1).dState).dwarf_line.cur_file != (*(*s1).dState).dwarf_line.last_file {
            (*(*s1).dState).dwarf_line.last_file = (*(*s1).dState).dwarf_line.cur_file;
            dwarf_line_op(s1, DW_LNS_set_file as libc::c_int as libc::c_uchar);
            dwarf_uleb128_op(
                s1,
                (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
            );
        }
        if len_pc != 0 && len_line >= -(5 as libc::c_int)
            && len_line <= 13 as libc::c_int + -(5 as libc::c_int)
            && n >= 13 as libc::c_int && n <= 255 as libc::c_int
        {
            dwarf_line_op(s1, n as libc::c_uchar);
        } else {
            if len_pc != 0 {
                n = len_pc * 14 as libc::c_int + 0 as libc::c_int + 13 as libc::c_int
                    - -(5 as libc::c_int);
                if n >= 13 as libc::c_int && n <= 255 as libc::c_int {
                    dwarf_line_op(s1, n as libc::c_uchar);
                } else {
                    dwarf_line_op(s1, DW_LNS_advance_pc as libc::c_int as libc::c_uchar);
                    dwarf_uleb128_op(s1, len_pc as libc::c_ulonglong);
                }
            }
            if len_line != 0 {
                n = 0 as libc::c_int * 14 as libc::c_int + len_line + 13 as libc::c_int
                    - -(5 as libc::c_int);
                if len_line >= -(5 as libc::c_int)
                    && len_line <= 13 as libc::c_int + -(5 as libc::c_int)
                    && n >= 13 as libc::c_int && n <= 255 as libc::c_int
                {
                    dwarf_line_op(s1, n as libc::c_uchar);
                } else {
                    dwarf_line_op(
                        s1,
                        DW_LNS_advance_line as libc::c_int as libc::c_uchar,
                    );
                    dwarf_sleb128_op(s1, len_line as libc::c_longlong);
                }
            }
        }
        (*(*s1).dState).dwarf_line.last_pc = ind;
        (*(*s1).dState).dwarf_line.last_line = (*f).line_num;
    } else if func_ind != -(1 as libc::c_int) {
        put_stabn(
            s1,
            N_SLINE as libc::c_int,
            0 as libc::c_int,
            (*f).line_num,
            ind - func_ind,
        );
    } else {
        put_stabs_r(
            s1,
            0 as *const libc::c_char,
            N_SLINE as libc::c_int,
            0 as libc::c_int,
            (*f).line_num,
            ind as libc::c_ulong,
            (*s1).text_section,
            (*(*s1).dState).section_sym,
        );
    };
}
unsafe extern "C" fn tcc_debug_stabs(
    mut s1: *mut TCCState,
    mut str: *const libc::c_char,
    mut type_0: libc::c_int,
    mut value: libc::c_ulong,
    mut sec: *mut Section,
    mut sym_index: libc::c_int,
    mut info: libc::c_int,
) {
    let mut s: *mut debug_sym = 0 as *mut debug_sym;
    if !((*(*s1).dState).debug_info).is_null() {
        (*(*(*s1).dState).debug_info)
            .sym = tcc_realloc(
            (*(*(*s1).dState).debug_info).sym as *mut libc::c_void,
            (::core::mem::size_of::<debug_sym>() as libc::c_ulong)
                .wrapping_mul(
                    ((*(*(*s1).dState).debug_info).n_sym + 1 as libc::c_int)
                        as libc::c_ulong,
                ),
        ) as *mut debug_sym;
        let fresh19 = (*(*(*s1).dState).debug_info).n_sym;
        (*(*(*s1).dState).debug_info).n_sym = (*(*(*s1).dState).debug_info).n_sym + 1;
        s = ((*(*(*s1).dState).debug_info).sym).offset(fresh19 as isize);
        (*s).type_0 = type_0;
        (*s).value = value;
        (*s).str_0 = tcc_strdup(str);
        (*s).sec = sec;
        (*s).sym_index = sym_index;
        (*s).info = info;
        (*s).file = (*(*s1).dState).dwarf_line.cur_file;
        (*s).line = (*file).line_num;
    } else if !sec.is_null() {
        put_stabs_r(
            s1,
            str,
            type_0,
            0 as libc::c_int,
            0 as libc::c_int,
            value,
            sec,
            sym_index,
        );
    } else {
        put_stabs(s1, str, type_0, 0 as libc::c_int, 0 as libc::c_int, value);
    };
}
unsafe extern "C" fn tcc_debug_stabn(
    mut s1: *mut TCCState,
    mut type_0: libc::c_int,
    mut value: libc::c_int,
) {
    if (*s1).do_debug == 0 {
        return;
    }
    if type_0 == N_LBRAC as libc::c_int {
        let mut info: *mut _debug_info = tcc_mallocz(
            ::core::mem::size_of::<_debug_info>() as libc::c_ulong,
        ) as *mut _debug_info;
        (*info).start = value;
        (*info).parent = (*(*s1).dState).debug_info;
        if !((*(*s1).dState).debug_info).is_null() {
            if !((*(*(*s1).dState).debug_info).child).is_null() {
                if !((*(*(*(*s1).dState).debug_info).child).last).is_null() {
                    (*(*(*(*(*s1).dState).debug_info).child).last).next = info;
                } else {
                    (*(*(*(*s1).dState).debug_info).child).next = info;
                }
                (*(*(*(*s1).dState).debug_info).child).last = info;
            } else {
                (*(*(*s1).dState).debug_info).child = info;
            }
        } else {
            (*(*s1).dState).debug_info_root = info;
        }
        (*(*s1).dState).debug_info = info;
    } else {
        (*(*(*s1).dState).debug_info).end = value;
        (*(*s1).dState).debug_info = (*(*(*s1).dState).debug_info).parent;
    };
}
unsafe extern "C" fn tcc_debug_find(
    mut s1: *mut TCCState,
    mut t: *mut Sym,
    mut dwarf: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if ((*(*s1).dState).debug_info).is_null() && dwarf != 0
        && (*t).type_0.t & 0xf as libc::c_int == 7 as libc::c_int
        && (*t).c2rust_unnamed.c2rust_unnamed.c == -(1 as libc::c_int)
    {
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).n_debug_anon_hash {
            if t == (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).type_0 {
                return 0 as libc::c_int;
            }
            i += 1;
            i;
        }
        (*(*s1).dState)
            .debug_anon_hash = tcc_realloc(
            (*(*s1).dState).debug_anon_hash as *mut libc::c_void,
            (((*(*s1).dState).n_debug_anon_hash + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<_debug_anon_hash>() as libc::c_ulong,
                ),
        ) as *mut _debug_anon_hash;
        (*((*(*s1).dState).debug_anon_hash)
            .offset((*(*s1).dState).n_debug_anon_hash as isize))
            .n_debug_type = 0 as libc::c_int;
        let ref mut fresh20 = (*((*(*s1).dState).debug_anon_hash)
            .offset((*(*s1).dState).n_debug_anon_hash as isize))
            .debug_type;
        *fresh20 = 0 as *mut libc::c_int;
        let fresh21 = (*(*s1).dState).n_debug_anon_hash;
        (*(*s1).dState).n_debug_anon_hash = (*(*s1).dState).n_debug_anon_hash + 1;
        let ref mut fresh22 = (*((*(*s1).dState).debug_anon_hash)
            .offset(fresh21 as isize))
            .type_0;
        *fresh22 = t;
        return 0 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while i < (*(*s1).dState).n_debug_hash {
        if t == (*((*(*s1).dState).debug_hash).offset(i as isize)).type_0 {
            return (*((*(*s1).dState).debug_hash).offset(i as isize)).debug_type;
        }
        i += 1;
        i;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn tcc_debug_check_anon(
    mut s1: *mut TCCState,
    mut t: *mut Sym,
    mut debug_type: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    if ((*(*s1).dState).debug_info).is_null()
        && (*t).type_0.t & 0xf as libc::c_int == 7 as libc::c_int
        && (*(*t).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c == -(1 as libc::c_int)
    {
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).n_debug_anon_hash {
            if (*t).type_0.ref_0
                == (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).type_0
            {
                let ref mut fresh23 = (*((*(*s1).dState).debug_anon_hash)
                    .offset(i as isize))
                    .debug_type;
                *fresh23 = tcc_realloc(
                    (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).debug_type
                        as *mut libc::c_void,
                    (((*((*(*s1).dState).debug_anon_hash).offset(i as isize))
                        .n_debug_type + 1 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ),
                ) as *mut libc::c_int;
                let ref mut fresh24 = (*((*(*s1).dState).debug_anon_hash)
                    .offset(i as isize))
                    .n_debug_type;
                let fresh25 = *fresh24;
                *fresh24 = *fresh24 + 1;
                *((*((*(*s1).dState).debug_anon_hash).offset(i as isize)).debug_type)
                    .offset(fresh25 as isize) = debug_type;
            }
            i += 1;
            i;
        }
    }
}
unsafe extern "C" fn tcc_debug_fix_anon(mut s1: *mut TCCState, mut t: *mut CType) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut debug_type: libc::c_int = 0;
    if (*s1).do_debug as libc::c_int & 2 as libc::c_int == 0 || (*s1).dwarf == 0
        || !((*(*s1).dState).debug_info).is_null()
    {
        return;
    }
    if (*t).t & 0xf as libc::c_int == 7 as libc::c_int
        && (*(*t).ref_0).c2rust_unnamed.c2rust_unnamed.c != -(1 as libc::c_int)
    {
        i = 0 as libc::c_int;
        while i < (*(*s1).dState).n_debug_anon_hash {
            if (*t).ref_0
                == (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).type_0
            {
                let mut sym: Sym = {
                    let mut init = Sym {
                        v: 0 as libc::c_int,
                        r: 0,
                        a: SymAttr {
                            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                        },
                        c2rust_unnamed: C2RustUnnamed_6 {
                            c2rust_unnamed: C2RustUnnamed_7 {
                                c: 0,
                                c2rust_unnamed: C2RustUnnamed_8 { sym_scope: 0 },
                            },
                        },
                        type_0: CType {
                            t: 0,
                            ref_0: 0 as *mut Sym,
                        },
                        c2rust_unnamed_0: C2RustUnnamed_5 {
                            next: 0 as *mut Sym,
                        },
                        prev: 0 as *mut Sym,
                        prev_tok: 0 as *mut Sym,
                    };
                    init
                };
                sym.type_0 = *t;
                (*(*s1).dState).debug_info = t as *mut _debug_info;
                debug_type = tcc_get_dwarf_info(s1, &mut sym);
                (*(*s1).dState).debug_info = 0 as *mut _debug_info;
                j = 0 as libc::c_int;
                while j
                    < (*((*(*s1).dState).debug_anon_hash).offset(i as isize))
                        .n_debug_type
                {
                    write32le(
                        ((*(*s1).dwarf_info_section).data)
                            .offset(
                                *((*((*(*s1).dState).debug_anon_hash).offset(i as isize))
                                    .debug_type)
                                    .offset(j as isize) as isize,
                            ),
                        (debug_type - (*(*s1).dState).dwarf_info.start) as uint32_t,
                    );
                    j += 1;
                    j;
                }
                tcc_free(
                    (*((*(*s1).dState).debug_anon_hash).offset(i as isize)).debug_type
                        as *mut libc::c_void,
                );
                (*(*s1).dState).n_debug_anon_hash -= 1;
                (*(*s1).dState).n_debug_anon_hash;
                while i < (*(*s1).dState).n_debug_anon_hash {
                    *((*(*s1).dState).debug_anon_hash)
                        .offset(
                            i as isize,
                        ) = *((*(*s1).dState).debug_anon_hash)
                        .offset((i + 1 as libc::c_int) as isize);
                    i += 1;
                    i;
                }
            }
            i += 1;
            i;
        }
    }
}
unsafe extern "C" fn tcc_debug_add(
    mut s1: *mut TCCState,
    mut t: *mut Sym,
    mut dwarf: libc::c_int,
) -> libc::c_int {
    let mut offset: libc::c_int = (if dwarf != 0 {
        (*(*s1).dwarf_info_section).data_offset
    } else {
        (*(*s1).dState).debug_next_type += 1;
        (*(*s1).dState).debug_next_type as libc::c_ulong
    }) as libc::c_int;
    (*(*s1).dState)
        .debug_hash = tcc_realloc(
        (*(*s1).dState).debug_hash as *mut libc::c_void,
        (((*(*s1).dState).n_debug_hash + 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<_debug_hash>() as libc::c_ulong),
    ) as *mut _debug_hash;
    (*((*(*s1).dState).debug_hash).offset((*(*s1).dState).n_debug_hash as isize))
        .debug_type = offset;
    let fresh26 = (*(*s1).dState).n_debug_hash;
    (*(*s1).dState).n_debug_hash = (*(*s1).dState).n_debug_hash + 1;
    let ref mut fresh27 = (*((*(*s1).dState).debug_hash).offset(fresh26 as isize))
        .type_0;
    *fresh27 = t;
    return offset;
}
unsafe extern "C" fn tcc_debug_remove(mut s1: *mut TCCState, mut t: *mut Sym) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*(*s1).dState).n_debug_hash {
        if t == (*((*(*s1).dState).debug_hash).offset(i as isize)).type_0 {
            (*(*s1).dState).n_debug_hash -= 1;
            (*(*s1).dState).n_debug_hash;
            while i < (*(*s1).dState).n_debug_hash {
                *((*(*s1).dState).debug_hash)
                    .offset(
                        i as isize,
                    ) = *((*(*s1).dState).debug_hash)
                    .offset((i + 1 as libc::c_int) as isize);
                i += 1;
                i;
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn tcc_get_debug_info(
    mut s1: *mut TCCState,
    mut s: *mut Sym,
    mut result: *mut CString,
) {
    let mut type_0: libc::c_int = 0;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut debug_type: libc::c_int = -(1 as libc::c_int);
    let mut t: *mut Sym = s;
    let mut str: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    loop {
        type_0 = (*t).type_0.t
            & !(0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int
                | 0x400 as libc::c_int);
        if type_0 & 0xf as libc::c_int != 1 as libc::c_int {
            type_0 &= !(0x20 as libc::c_int);
        }
        if !(type_0 == 5 as libc::c_int
            || type_0 == 5 as libc::c_int | 0x40 as libc::c_int)
        {
            break;
        }
        n += 1;
        n;
        t = (*t).type_0.ref_0;
    }
    if type_0 & 0xf as libc::c_int == 7 as libc::c_int {
        let mut e: *mut Sym = t;
        t = (*t).type_0.ref_0;
        debug_type = tcc_debug_find(s1, t, 0 as libc::c_int);
        if debug_type == -(1 as libc::c_int) {
            debug_type = tcc_debug_add(s1, t, 0 as libc::c_int);
            cstr_new(&mut str);
            cstr_printf(
                &mut str as *mut CString,
                b"%s:T%d=%c%d\0" as *const u8 as *const libc::c_char,
                if (*t).v & !(0x40000000 as libc::c_int) >= 0x10000000 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    get_tok_str((*t).v, 0 as *mut CValue)
                },
                debug_type,
                if (*t).type_0.t as libc::c_uint
                    & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint
                        | 0xf as libc::c_int as libc::c_uint)
                    == ((1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int)
                        as libc::c_uint
                {
                    'u' as i32
                } else {
                    's' as i32
                },
                (*t).c2rust_unnamed.c2rust_unnamed.c,
            );
            while !((*t).c2rust_unnamed_0.next).is_null() {
                let mut pos: libc::c_int = 0;
                let mut size: libc::c_int = 0;
                let mut align: libc::c_int = 0;
                t = (*t).c2rust_unnamed_0.next;
                if ((*t).a).nodebug() as libc::c_int != 0
                    || (*t).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int
                        && ((*t).type_0.t & 0xf as libc::c_int == 1 as libc::c_int
                            || (*t).type_0.t & 0xf as libc::c_int == 11 as libc::c_int
                            || (*t).type_0.t & 0xf as libc::c_int == 2 as libc::c_int
                            || (*t).type_0.t & 0xf as libc::c_int == 3 as libc::c_int
                            || (*t).type_0.t & 0xf as libc::c_int == 4 as libc::c_int)
                {
                    continue;
                }
                cstr_printf(
                    &mut str as *mut CString,
                    b"%s:\0" as *const u8 as *const libc::c_char,
                    get_tok_str((*t).v, 0 as *mut CValue),
                );
                tcc_get_debug_info(s1, t, &mut str);
                if (*t).type_0.t & 0x80 as libc::c_int != 0 {
                    pos = (*t).c2rust_unnamed.c2rust_unnamed.c * 8 as libc::c_int
                        + ((*t).type_0.t >> 20 as libc::c_int & 0x3f as libc::c_int);
                    size = (*t).type_0.t >> 20 as libc::c_int + 6 as libc::c_int
                        & 0x3f as libc::c_int;
                } else {
                    pos = (*t).c2rust_unnamed.c2rust_unnamed.c * 8 as libc::c_int;
                    size = type_size(&mut (*t).type_0, &mut align) * 8 as libc::c_int;
                }
                cstr_printf(
                    &mut str as *mut CString,
                    b",%d,%d;\0" as *const u8 as *const libc::c_char,
                    pos,
                    size,
                );
            }
            cstr_printf(
                &mut str as *mut CString,
                b";\0" as *const u8 as *const libc::c_char,
            );
            tcc_debug_stabs(
                s1,
                str.data,
                N_LSYM as libc::c_int,
                0 as libc::c_int as libc::c_ulong,
                0 as *mut Section,
                0 as libc::c_int,
                0 as libc::c_int,
            );
            cstr_free(&mut str);
            if !((*(*s1).dState).debug_info).is_null() {
                tcc_debug_remove(s1, e);
            }
        }
    } else if type_0 as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
    {
        t = (*t).type_0.ref_0;
        let mut e_0: *mut Sym = t;
        debug_type = tcc_debug_find(s1, t, 0 as libc::c_int);
        if debug_type == -(1 as libc::c_int) {
            debug_type = tcc_debug_add(s1, t, 0 as libc::c_int);
            cstr_new(&mut str);
            cstr_printf(
                &mut str as *mut CString,
                b"%s:T%d=e\0" as *const u8 as *const libc::c_char,
                if (*t).v & !(0x40000000 as libc::c_int) >= 0x10000000 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    get_tok_str((*t).v, 0 as *mut CValue)
                },
                debug_type,
            );
            while !((*t).c2rust_unnamed_0.next).is_null() {
                t = (*t).c2rust_unnamed_0.next;
                cstr_printf(
                    &mut str as *mut CString,
                    b"%s:\0" as *const u8 as *const libc::c_char,
                    if (*t).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int
                    {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        get_tok_str((*t).v, 0 as *mut CValue)
                    },
                );
                cstr_printf(
                    &mut str as *mut CString,
                    if (*e_0).type_0.t & 0x10 as libc::c_int != 0 {
                        b"%u,\0" as *const u8 as *const libc::c_char
                    } else {
                        b"%d,\0" as *const u8 as *const libc::c_char
                    },
                    (*t).c2rust_unnamed.enum_val as libc::c_int,
                );
            }
            cstr_printf(
                &mut str as *mut CString,
                b";\0" as *const u8 as *const libc::c_char,
            );
            tcc_debug_stabs(
                s1,
                str.data,
                N_LSYM as libc::c_int,
                0 as libc::c_int as libc::c_ulong,
                0 as *mut Section,
                0 as libc::c_int,
                0 as libc::c_int,
            );
            cstr_free(&mut str);
            if !((*(*s1).dState).debug_info).is_null() {
                tcc_debug_remove(s1, e_0);
            }
        }
    } else if type_0 & 0xf as libc::c_int != 6 as libc::c_int {
        type_0 = (type_0 as libc::c_uint
            & !(((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint)) as libc::c_int;
        debug_type = 1 as libc::c_int;
        while debug_type as libc::c_ulong
            <= (::core::mem::size_of::<[C2RustUnnamed_17; 29]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong,
                )
        {
            if default_debug[(debug_type - 1 as libc::c_int) as usize].type_0 == type_0 {
                break;
            }
            debug_type += 1;
            debug_type;
        }
        if debug_type as libc::c_ulong
            > (::core::mem::size_of::<[C2RustUnnamed_17; 29]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong,
                )
        {
            return;
        }
    }
    if n > 0 as libc::c_int {
        (*(*s1).dState).debug_next_type += 1;
        cstr_printf(
            result,
            b"%d=\0" as *const u8 as *const libc::c_char,
            (*(*s1).dState).debug_next_type,
        );
    }
    t = s;
    loop {
        type_0 = (*t).type_0.t
            & !(0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int
                | 0x400 as libc::c_int);
        if type_0 & 0xf as libc::c_int != 1 as libc::c_int {
            type_0 &= !(0x20 as libc::c_int);
        }
        if type_0 == 5 as libc::c_int {
            (*(*s1).dState).debug_next_type += 1;
            cstr_printf(
                result,
                b"%d=*\0" as *const u8 as *const libc::c_char,
                (*(*s1).dState).debug_next_type,
            );
        } else if type_0 == 5 as libc::c_int | 0x40 as libc::c_int {
            (*(*s1).dState).debug_next_type += 1;
            cstr_printf(
                result,
                b"%d=ar1;0;%d;\0" as *const u8 as *const libc::c_char,
                (*(*s1).dState).debug_next_type,
                (*(*t).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c - 1 as libc::c_int,
            );
        } else {
            if !(type_0 == 6 as libc::c_int) {
                break;
            }
            (*(*s1).dState).debug_next_type += 1;
            cstr_printf(
                result,
                b"%d=f\0" as *const u8 as *const libc::c_char,
                (*(*s1).dState).debug_next_type,
            );
            tcc_get_debug_info(s1, (*t).type_0.ref_0, result);
            return;
        }
        t = (*t).type_0.ref_0;
    }
    cstr_printf(result, b"%d\0" as *const u8 as *const libc::c_char, debug_type);
}
unsafe extern "C" fn tcc_get_dwarf_info(
    mut s1: *mut TCCState,
    mut s: *mut Sym,
) -> libc::c_int {
    let mut type_0: libc::c_int = 0;
    let mut debug_type: libc::c_int = -(1 as libc::c_int);
    let mut e: *mut Sym = 0 as *mut Sym;
    let mut t: *mut Sym = s;
    let mut i: libc::c_int = 0;
    let mut last_pos: libc::c_int = -(1 as libc::c_int);
    let mut retval: libc::c_int = 0;
    if (*(*s1).dState).new_file != 0 {
        put_new_file(s1);
    }
    loop {
        type_0 = (*t).type_0.t
            & !(0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int
                | 0x400 as libc::c_int);
        if type_0 & 0xf as libc::c_int != 1 as libc::c_int {
            type_0 &= !(0x20 as libc::c_int);
        }
        if !(type_0 == 5 as libc::c_int
            || type_0 == 5 as libc::c_int | 0x40 as libc::c_int)
        {
            break;
        }
        t = (*t).type_0.ref_0;
    }
    if type_0 & 0xf as libc::c_int == 7 as libc::c_int {
        t = (*t).type_0.ref_0;
        debug_type = tcc_debug_find(s1, t, 1 as libc::c_int);
        if debug_type == -(1 as libc::c_int) {
            let mut pos_sib: libc::c_int = 0 as libc::c_int;
            let mut i_0: libc::c_int = 0;
            let mut pos_type: *mut libc::c_int = 0 as *mut libc::c_int;
            debug_type = tcc_debug_add(s1, t, 1 as libc::c_int);
            e = t;
            i_0 = 0 as libc::c_int;
            while !((*e).c2rust_unnamed_0.next).is_null() {
                e = (*e).c2rust_unnamed_0.next;
                if ((*e).a).nodebug() as libc::c_int != 0
                    || (*e).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int
                        && ((*e).type_0.t & 0xf as libc::c_int == 1 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 11 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 2 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 3 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 4 as libc::c_int)
                {
                    continue;
                }
                i_0 += 1;
                i_0;
            }
            pos_type = tcc_malloc(
                (i_0 as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
            ) as *mut libc::c_int;
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = (if (*t).type_0.t as libc::c_uint
                & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint
                    | 0xf as libc::c_int as libc::c_uint)
                == ((1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int)
                    as libc::c_uint
            {
                if !((*t).c2rust_unnamed_0.next).is_null() {
                    18 as libc::c_int
                } else {
                    19 as libc::c_int
                }
            } else if !((*t).c2rust_unnamed_0.next).is_null() {
                16 as libc::c_int
            } else {
                17 as libc::c_int
            }) as uint8_t;
            dwarf_strp(
                (*s1).dwarf_info_section,
                if (*t).v & !(0x40000000 as libc::c_int) >= 0x10000000 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    get_tok_str((*t).v, 0 as *mut CValue)
                },
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*t).c2rust_unnamed.c2rust_unnamed.c as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*file).line_num as libc::c_ulonglong,
            );
            if !((*t).c2rust_unnamed_0.next).is_null() {
                pos_sib = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    0 as libc::c_int as uint32_t,
                );
            }
            e = t;
            i_0 = 0 as libc::c_int;
            while !((*e).c2rust_unnamed_0.next).is_null() {
                e = (*e).c2rust_unnamed_0.next;
                if ((*e).a).nodebug() as libc::c_int != 0
                    || (*e).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int
                        && ((*e).type_0.t & 0xf as libc::c_int == 1 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 11 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 2 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 3 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 4 as libc::c_int)
                {
                    continue;
                }
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                )
                    as *mut uint8_t) = (if (*e).type_0.t & 0x80 as libc::c_int != 0 {
                    15 as libc::c_int
                } else {
                    14 as libc::c_int
                }) as uint8_t;
                dwarf_strp(
                    (*s1).dwarf_info_section,
                    get_tok_str((*e).v, 0 as *mut CValue),
                );
                dwarf_uleb128(
                    (*s1).dwarf_info_section,
                    (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
                );
                dwarf_uleb128(
                    (*s1).dwarf_info_section,
                    (*file).line_num as libc::c_ulonglong,
                );
                let fresh28 = i_0;
                i_0 = i_0 + 1;
                *pos_type
                    .offset(
                        fresh28 as isize,
                    ) = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    0 as libc::c_int as uint32_t,
                );
                if (*e).type_0.t & 0x80 as libc::c_int != 0 {
                    let mut pos: libc::c_int = (*e).c2rust_unnamed.c2rust_unnamed.c
                        * 8 as libc::c_int
                        + ((*e).type_0.t >> 20 as libc::c_int & 0x3f as libc::c_int);
                    let mut size: libc::c_int = (*e).type_0.t
                        >> 20 as libc::c_int + 6 as libc::c_int & 0x3f as libc::c_int;
                    dwarf_uleb128((*s1).dwarf_info_section, size as libc::c_ulonglong);
                    dwarf_uleb128((*s1).dwarf_info_section, pos as libc::c_ulonglong);
                } else {
                    dwarf_uleb128(
                        (*s1).dwarf_info_section,
                        (*e).c2rust_unnamed.c2rust_unnamed.c as libc::c_ulonglong,
                    );
                }
            }
            if !((*t).c2rust_unnamed_0.next).is_null() {
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 0 as libc::c_int as uint8_t;
                write32le(
                    ((*(*s1).dwarf_info_section).data).offset(pos_sib as isize),
                    ((*(*s1).dwarf_info_section).data_offset)
                        .wrapping_sub((*(*s1).dState).dwarf_info.start as libc::c_ulong)
                        as uint32_t,
                );
            }
            e = t;
            i_0 = 0 as libc::c_int;
            while !((*e).c2rust_unnamed_0.next).is_null() {
                e = (*e).c2rust_unnamed_0.next;
                if ((*e).a).nodebug() as libc::c_int != 0
                    || (*e).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int
                        && ((*e).type_0.t & 0xf as libc::c_int == 1 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 11 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 2 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 3 as libc::c_int
                            || (*e).type_0.t & 0xf as libc::c_int == 4 as libc::c_int)
                {
                    continue;
                }
                type_0 = tcc_get_dwarf_info(s1, e);
                tcc_debug_check_anon(s1, e, *pos_type.offset(i_0 as isize));
                let fresh29 = i_0;
                i_0 = i_0 + 1;
                write32le(
                    ((*(*s1).dwarf_info_section).data)
                        .offset(*pos_type.offset(fresh29 as isize) as isize),
                    (type_0 - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
            }
            tcc_free(pos_type as *mut libc::c_void);
            if !((*(*s1).dState).debug_info).is_null() {
                tcc_debug_remove(s1, t);
            }
        }
    } else if type_0 as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
    {
        t = (*t).type_0.ref_0;
        debug_type = tcc_debug_find(s1, t, 1 as libc::c_int);
        if debug_type == -(1 as libc::c_int) {
            let mut pos_sib_0: libc::c_int = 0;
            let mut pos_type_0: libc::c_int = 0;
            let mut sym: Sym = {
                let mut init = Sym {
                    v: 0 as libc::c_int,
                    r: 0,
                    a: SymAttr {
                        aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                    },
                    c2rust_unnamed: C2RustUnnamed_6 {
                        c2rust_unnamed: C2RustUnnamed_7 {
                            c: 0,
                            c2rust_unnamed: C2RustUnnamed_8 { sym_scope: 0 },
                        },
                    },
                    type_0: CType {
                        t: 0,
                        ref_0: 0 as *mut Sym,
                    },
                    c2rust_unnamed_0: C2RustUnnamed_5 {
                        next: 0 as *mut Sym,
                    },
                    prev: 0 as *mut Sym,
                    prev_tok: 0 as *mut Sym,
                };
                init
            };
            sym.type_0.t = 3 as libc::c_int | type_0 & 0x10 as libc::c_int;
            pos_type_0 = tcc_get_dwarf_info(s1, &mut sym);
            debug_type = tcc_debug_add(s1, t, 1 as libc::c_int);
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 13 as libc::c_int as uint8_t;
            dwarf_strp(
                (*s1).dwarf_info_section,
                if (*t).v & !(0x40000000 as libc::c_int) >= 0x10000000 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else {
                    get_tok_str((*t).v, 0 as *mut CValue)
                },
            );
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = (if type_0 & 0x10 as libc::c_int != 0 {
                DW_ATE_unsigned as libc::c_int
            } else {
                DW_ATE_signed as libc::c_int
            }) as uint8_t;
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 4 as libc::c_int as uint8_t;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                (pos_type_0 - (*(*s1).dState).dwarf_info.start) as uint32_t,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*file).line_num as libc::c_ulonglong,
            );
            pos_sib_0 = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            e = t;
            while !((*e).c2rust_unnamed_0.next).is_null() {
                e = (*e).c2rust_unnamed_0.next;
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                )
                    as *mut uint8_t) = (if type_0 & 0x10 as libc::c_int != 0 {
                    12 as libc::c_int
                } else {
                    11 as libc::c_int
                }) as uint8_t;
                dwarf_strp(
                    (*s1).dwarf_info_section,
                    if (*e).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int
                    {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        get_tok_str((*e).v, 0 as *mut CValue)
                    },
                );
                if type_0 & 0x10 as libc::c_int != 0 {
                    dwarf_uleb128(
                        (*s1).dwarf_info_section,
                        (*e).c2rust_unnamed.enum_val as libc::c_ulonglong,
                    );
                } else {
                    dwarf_sleb128(
                        (*s1).dwarf_info_section,
                        (*e).c2rust_unnamed.enum_val,
                    );
                }
            }
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 0 as libc::c_int as uint8_t;
            write32le(
                ((*(*s1).dwarf_info_section).data).offset(pos_sib_0 as isize),
                ((*(*s1).dwarf_info_section).data_offset)
                    .wrapping_sub((*(*s1).dState).dwarf_info.start as libc::c_ulong)
                    as uint32_t,
            );
            if !((*(*s1).dState).debug_info).is_null() {
                tcc_debug_remove(s1, t);
            }
        }
    } else if type_0 & 0xf as libc::c_int != 6 as libc::c_int {
        type_0 = (type_0 as libc::c_uint
            & !(((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint)) as libc::c_int;
        i = 1 as libc::c_int;
        while i as libc::c_ulong
            <= (::core::mem::size_of::<[C2RustUnnamed_17; 29]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong,
                )
        {
            if default_debug[(i - 1 as libc::c_int) as usize].type_0 == type_0 {
                break;
            }
            i += 1;
            i;
        }
        if i as libc::c_ulong
            > (::core::mem::size_of::<[C2RustUnnamed_17; 29]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong,
                )
        {
            return 0 as libc::c_int;
        }
        debug_type = (*(*s1).dState)
            .dwarf_info
            .base_type_used[(i - 1 as libc::c_int) as usize];
        if debug_type == 0 as libc::c_int {
            let mut name: [libc::c_char; 100] = [0; 100];
            debug_type = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 2 as libc::c_int as uint8_t;
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                default_debug[(i - 1 as libc::c_int) as usize].size as libc::c_ulonglong,
            );
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = default_debug[(i - 1 as libc::c_int) as usize]
                .encoding as uint8_t;
            strncpy(
                name.as_mut_ptr(),
                default_debug[(i - 1 as libc::c_int) as usize].name,
                (::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            );
            *strchr(name.as_mut_ptr(), ':' as i32) = 0 as libc::c_int as libc::c_char;
            dwarf_strp((*s1).dwarf_info_section, name.as_mut_ptr());
            (*(*s1).dState)
                .dwarf_info
                .base_type_used[(i - 1 as libc::c_int) as usize] = debug_type;
        }
    }
    retval = debug_type;
    e = 0 as *mut Sym;
    t = s;
    loop {
        type_0 = (*t).type_0.t
            & !(0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int
                | 0x400 as libc::c_int);
        if type_0 & 0xf as libc::c_int != 1 as libc::c_int {
            type_0 &= !(0x20 as libc::c_int);
        }
        if type_0 == 5 as libc::c_int {
            i = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            if retval == debug_type {
                retval = i;
            }
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 7 as libc::c_int as uint8_t;
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 8 as libc::c_int as uint8_t;
            if last_pos != -(1 as libc::c_int) {
                tcc_debug_check_anon(s1, e, last_pos);
                write32le(
                    ((*(*s1).dwarf_info_section).data).offset(last_pos as isize),
                    (i - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
            }
            last_pos = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            e = (*t).type_0.ref_0;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
        } else if type_0 == 5 as libc::c_int | 0x40 as libc::c_int {
            let mut sib_pos: libc::c_int = 0;
            let mut sub_type: libc::c_int = 0;
            let mut sym_0: Sym = {
                let mut init = Sym {
                    v: 0 as libc::c_int,
                    r: 0,
                    a: SymAttr {
                        aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                    },
                    c2rust_unnamed: C2RustUnnamed_6 {
                        c2rust_unnamed: C2RustUnnamed_7 {
                            c: 0,
                            c2rust_unnamed: C2RustUnnamed_8 { sym_scope: 0 },
                        },
                    },
                    type_0: CType {
                        t: 0,
                        ref_0: 0 as *mut Sym,
                    },
                    c2rust_unnamed_0: C2RustUnnamed_5 {
                        next: 0 as *mut Sym,
                    },
                    prev: 0 as *mut Sym,
                    prev_tok: 0 as *mut Sym,
                };
                init
            };
            sym_0
                .type_0
                .t = 4 as libc::c_int | 0x800 as libc::c_int | 0x10 as libc::c_int;
            sub_type = tcc_get_dwarf_info(s1, &mut sym_0);
            i = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            if retval == debug_type {
                retval = i;
            }
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 8 as libc::c_int as uint8_t;
            if last_pos != -(1 as libc::c_int) {
                tcc_debug_check_anon(s1, e, last_pos);
                write32le(
                    ((*(*s1).dwarf_info_section).data).offset(last_pos as isize),
                    (i - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
            }
            last_pos = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            e = (*t).type_0.ref_0;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            sib_pos = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            loop {
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 9 as libc::c_int as uint8_t;
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    (sub_type - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
                dwarf_uleb128(
                    (*s1).dwarf_info_section,
                    ((*(*t).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c
                        - 1 as libc::c_int) as libc::c_ulonglong,
                );
                s = (*t).type_0.ref_0;
                type_0 = (*s).type_0.t
                    & !(0x1000 as libc::c_int | 0x2000 as libc::c_int
                        | 0x4000 as libc::c_int | 0x8000 as libc::c_int
                        | 0x100 as libc::c_int | 0x200 as libc::c_int);
                if type_0 != 5 as libc::c_int | 0x40 as libc::c_int {
                    break;
                }
                t = s;
            }
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 0 as libc::c_int as uint8_t;
            write32le(
                ((*(*s1).dwarf_info_section).data).offset(sib_pos as isize),
                ((*(*s1).dwarf_info_section).data_offset)
                    .wrapping_sub((*(*s1).dState).dwarf_info.start as libc::c_ulong)
                    as uint32_t,
            );
        } else if type_0 == 6 as libc::c_int {
            let mut sib_pos_0: libc::c_int = 0 as libc::c_int;
            let mut pos_type_1: *mut libc::c_int = 0 as *mut libc::c_int;
            let mut f: *mut Sym = 0 as *mut Sym;
            i = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            debug_type = tcc_get_dwarf_info(s1, (*t).type_0.ref_0);
            if retval == debug_type {
                retval = i;
            }
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = (if !((*(*t).type_0.ref_0).c2rust_unnamed_0.next)
                .is_null()
            {
                24 as libc::c_int
            } else {
                25 as libc::c_int
            }) as uint8_t;
            if last_pos != -(1 as libc::c_int) {
                tcc_debug_check_anon(s1, e, last_pos);
                write32le(
                    ((*(*s1).dwarf_info_section).data).offset(last_pos as isize),
                    (i - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
            }
            last_pos = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
            e = (*t).type_0.ref_0;
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                0 as libc::c_int as uint32_t,
            );
            if !((*(*t).type_0.ref_0).c2rust_unnamed_0.next).is_null() {
                sib_pos_0 = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    0 as libc::c_int as uint32_t,
                );
            }
            f = (*t).type_0.ref_0;
            i = 0 as libc::c_int;
            while !((*f).c2rust_unnamed_0.next).is_null() {
                f = (*f).c2rust_unnamed_0.next;
                i += 1;
                i;
            }
            pos_type_1 = tcc_malloc(
                (i as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
            ) as *mut libc::c_int;
            f = (*t).type_0.ref_0;
            i = 0 as libc::c_int;
            while !((*f).c2rust_unnamed_0.next).is_null() {
                f = (*f).c2rust_unnamed_0.next;
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 26 as libc::c_int as uint8_t;
                let fresh30 = i;
                i = i + 1;
                *pos_type_1
                    .offset(
                        fresh30 as isize,
                    ) = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    0 as libc::c_int as uint32_t,
                );
            }
            if !((*(*t).type_0.ref_0).c2rust_unnamed_0.next).is_null() {
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 0 as libc::c_int as uint8_t;
                write32le(
                    ((*(*s1).dwarf_info_section).data).offset(sib_pos_0 as isize),
                    ((*(*s1).dwarf_info_section).data_offset)
                        .wrapping_sub((*(*s1).dState).dwarf_info.start as libc::c_ulong)
                        as uint32_t,
                );
            }
            f = (*t).type_0.ref_0;
            i = 0 as libc::c_int;
            while !((*f).c2rust_unnamed_0.next).is_null() {
                f = (*f).c2rust_unnamed_0.next;
                type_0 = tcc_get_dwarf_info(s1, f);
                tcc_debug_check_anon(s1, f, *pos_type_1.offset(i as isize));
                let fresh31 = i;
                i = i + 1;
                write32le(
                    ((*(*s1).dwarf_info_section).data)
                        .offset(*pos_type_1.offset(fresh31 as isize) as isize),
                    (type_0 - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
            }
            tcc_free(pos_type_1 as *mut libc::c_void);
        } else {
            if last_pos != -(1 as libc::c_int) {
                tcc_debug_check_anon(s1, e, last_pos);
                write32le(
                    ((*(*s1).dwarf_info_section).data).offset(last_pos as isize),
                    (debug_type - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
            }
            break;
        }
        t = (*t).type_0.ref_0;
    }
    return retval;
}
unsafe extern "C" fn tcc_debug_finish(mut s1: *mut TCCState, mut cur: *mut _debug_info) {
    while !cur.is_null() {
        let mut next_0: *mut _debug_info = (*cur).next;
        let mut i: libc::c_int = 0;
        if (*s1).dwarf != 0 {
            i = (*cur).n_sym - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let mut s: *mut debug_sym = &mut *((*cur).sym).offset(i as isize)
                    as *mut debug_sym;
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                )
                    as *mut uint8_t) = (if (*s).type_0 == N_PSYM as libc::c_int {
                    6 as libc::c_int
                } else if (*s).type_0 == N_GSYM as libc::c_int {
                    3 as libc::c_int
                } else if (*s).type_0 == N_STSYM as libc::c_int {
                    4 as libc::c_int
                } else {
                    5 as libc::c_int
                }) as uint8_t;
                dwarf_strp((*s1).dwarf_info_section, (*s).str_0);
                if (*s).type_0 == N_GSYM as libc::c_int
                    || (*s).type_0 == N_STSYM as libc::c_int
                {
                    dwarf_uleb128(
                        (*s1).dwarf_info_section,
                        (*s).file as libc::c_ulonglong,
                    );
                    dwarf_uleb128(
                        (*s1).dwarf_info_section,
                        (*s).line as libc::c_ulonglong,
                    );
                }
                write32le(
                    section_ptr_add(
                        (*s1).dwarf_info_section,
                        4 as libc::c_int as Elf64_Addr,
                    ) as *mut libc::c_uchar,
                    ((*s).info - (*(*s1).dState).dwarf_info.start) as uint32_t,
                );
                if (*s).type_0 == N_GSYM as libc::c_int
                    || (*s).type_0 == N_STSYM as libc::c_int
                {
                    if (*s).type_0 == N_GSYM as libc::c_int {
                        *(section_ptr_add(
                            (*s1).dwarf_info_section,
                            1 as libc::c_int as Elf64_Addr,
                        ) as *mut uint8_t) = 1 as libc::c_int as uint8_t;
                    }
                    *(section_ptr_add(
                        (*s1).dwarf_info_section,
                        1 as libc::c_int as Elf64_Addr,
                    )
                        as *mut uint8_t) = (8 as libc::c_int + 1 as libc::c_int)
                        as uint8_t;
                    *(section_ptr_add(
                        (*s1).dwarf_info_section,
                        1 as libc::c_int as Elf64_Addr,
                    ) as *mut uint8_t) = DW_OP_addr as libc::c_int as uint8_t;
                    if (*s).type_0 == N_STSYM as libc::c_int {
                        dwarf_reloc(
                            (*s1).dwarf_info_section,
                            (*(*s1).dState).section_sym,
                            1 as libc::c_int,
                        );
                    }
                    write64le(
                        section_ptr_add(
                            (*s1).dwarf_info_section,
                            8 as libc::c_int as Elf64_Addr,
                        ) as *mut libc::c_uchar,
                        (*s).value,
                    );
                } else {
                    *(section_ptr_add(
                        (*s1).dwarf_info_section,
                        1 as libc::c_int as Elf64_Addr,
                    )
                        as *mut uint8_t) = (dwarf_sleb128_size(
                        (*s).value as libc::c_longlong,
                    ) + 1 as libc::c_int) as uint8_t;
                    *(section_ptr_add(
                        (*s1).dwarf_info_section,
                        1 as libc::c_int as Elf64_Addr,
                    ) as *mut uint8_t) = DW_OP_fbreg as libc::c_int as uint8_t;
                    dwarf_sleb128(
                        (*s1).dwarf_info_section,
                        (*s).value as libc::c_longlong,
                    );
                }
                tcc_free((*s).str_0 as *mut libc::c_void);
                i -= 1;
                i;
            }
            tcc_free((*cur).sym as *mut libc::c_void);
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = (if !((*cur).child).is_null() {
                22 as libc::c_int
            } else {
                23 as libc::c_int
            }) as uint8_t;
            dwarf_reloc(
                (*s1).dwarf_info_section,
                (*(*s1).dState).section_sym,
                1 as libc::c_int,
            );
            write64le(
                section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                (func_ind + (*cur).start) as uint64_t,
            );
            write64le(
                section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                ((*cur).end - (*cur).start) as uint64_t,
            );
            tcc_debug_finish(s1, (*cur).child);
            if !((*cur).child).is_null() {
                *(section_ptr_add(
                    (*s1).dwarf_info_section,
                    1 as libc::c_int as Elf64_Addr,
                ) as *mut uint8_t) = 0 as libc::c_int as uint8_t;
            }
        } else {
            i = 0 as libc::c_int;
            while i < (*cur).n_sym {
                let mut s_0: *mut debug_sym = &mut *((*cur).sym).offset(i as isize)
                    as *mut debug_sym;
                if !((*s_0).sec).is_null() {
                    put_stabs_r(
                        s1,
                        (*s_0).str_0,
                        (*s_0).type_0,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (*s_0).value,
                        (*s_0).sec,
                        (*s_0).sym_index,
                    );
                } else {
                    put_stabs(
                        s1,
                        (*s_0).str_0,
                        (*s_0).type_0,
                        0 as libc::c_int,
                        0 as libc::c_int,
                        (*s_0).value,
                    );
                }
                tcc_free((*s_0).str_0 as *mut libc::c_void);
                i += 1;
                i;
            }
            tcc_free((*cur).sym as *mut libc::c_void);
            put_stabn(
                s1,
                N_LBRAC as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (*cur).start,
            );
            tcc_debug_finish(s1, (*cur).child);
            put_stabn(
                s1,
                N_RBRAC as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
                (*cur).end,
            );
        }
        tcc_free(cur as *mut libc::c_void);
        cur = next_0;
    }
}
unsafe extern "C" fn tcc_add_debug_info(
    mut s1: *mut TCCState,
    mut param: libc::c_int,
    mut s: *mut Sym,
    mut e: *mut Sym,
) {
    let mut debug_str: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    if (*s1).do_debug as libc::c_int & 2 as libc::c_int == 0 {
        return;
    }
    cstr_new(&mut debug_str);
    while s != e {
        if !((*s).v == 0
            || (*s).r as libc::c_int & 0x3f as libc::c_int != 0x32 as libc::c_int)
        {
            if (*s1).dwarf != 0 {
                tcc_debug_stabs(
                    s1,
                    get_tok_str((*s).v, 0 as *mut CValue),
                    if param != 0 {
                        N_PSYM as libc::c_int
                    } else {
                        N_LSYM as libc::c_int
                    },
                    (*s).c2rust_unnamed.c2rust_unnamed.c as libc::c_ulong,
                    0 as *mut Section,
                    0 as libc::c_int,
                    tcc_get_dwarf_info(s1, s),
                );
            } else {
                cstr_reset(&mut debug_str);
                cstr_printf(
                    &mut debug_str as *mut CString,
                    b"%s:%s\0" as *const u8 as *const libc::c_char,
                    get_tok_str((*s).v, 0 as *mut CValue),
                    if param != 0 {
                        b"p\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                tcc_get_debug_info(s1, s, &mut debug_str);
                tcc_debug_stabs(
                    s1,
                    debug_str.data,
                    if param != 0 {
                        N_PSYM as libc::c_int
                    } else {
                        N_LSYM as libc::c_int
                    },
                    (*s).c2rust_unnamed.c2rust_unnamed.c as libc::c_ulong,
                    0 as *mut Section,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
            }
        }
        s = (*s).prev;
    }
    cstr_free(&mut debug_str);
}
unsafe extern "C" fn tcc_debug_funcstart(mut s1: *mut TCCState, mut sym: *mut Sym) {
    let mut debug_str: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    let mut f: *mut BufferedFile = 0 as *mut BufferedFile;
    if (*s1).do_debug == 0 {
        return;
    }
    (*(*s1).dState).debug_info_root = 0 as *mut _debug_info;
    (*(*s1).dState).debug_info = 0 as *mut _debug_info;
    tcc_debug_stabn(s1, N_LBRAC as libc::c_int, ind - func_ind);
    f = put_new_file(s1);
    if f.is_null() {
        return;
    }
    if (*s1).dwarf != 0 {
        tcc_debug_line(s1);
        (*(*s1).dState).dwarf_info.func = sym;
        (*(*s1).dState).dwarf_info.line = (*file).line_num;
        if (*s1).do_backtrace != 0 {
            let mut i: libc::c_int = 0;
            let mut len: libc::c_int = 0;
            dwarf_line_op(s1, 0 as libc::c_int as libc::c_uchar);
            dwarf_uleb128_op(
                s1,
                (strlen(funcname)).wrapping_add(2 as libc::c_int as libc::c_ulong)
                    as libc::c_ulonglong,
            );
            dwarf_line_op(
                s1,
                (DW_LNE_hi_user as libc::c_int - 1 as libc::c_int) as libc::c_uchar,
            );
            len = (strlen(funcname)).wrapping_add(1 as libc::c_int as libc::c_ulong)
                as libc::c_int;
            i = 0 as libc::c_int;
            while i < len {
                dwarf_line_op(s1, *funcname.offset(i as isize) as libc::c_uchar);
                i += 1;
                i;
            }
        }
    } else {
        cstr_new(&mut debug_str);
        cstr_printf(
            &mut debug_str as *mut CString,
            b"%s:%c\0" as *const u8 as *const libc::c_char,
            funcname,
            if (*sym).type_0.t & 0x2000 as libc::c_int != 0 {
                'f' as i32
            } else {
                'F' as i32
            },
        );
        tcc_get_debug_info(s1, (*sym).type_0.ref_0, &mut debug_str);
        put_stabs_r(
            s1,
            debug_str.data,
            N_FUN as libc::c_int,
            0 as libc::c_int,
            (*f).line_num,
            0 as libc::c_int as libc::c_ulong,
            (*s1).cur_text_section,
            (*sym).c2rust_unnamed.c2rust_unnamed.c,
        );
        cstr_free(&mut debug_str);
        tcc_debug_line(s1);
    };
}
unsafe extern "C" fn tcc_debug_prolog_epilog(
    mut s1: *mut TCCState,
    mut value: libc::c_int,
) {
    if (*s1).do_debug == 0 {
        return;
    }
    if (*s1).dwarf != 0 {
        dwarf_line_op(
            s1,
            (if value == 0 as libc::c_int {
                DW_LNS_set_prologue_end as libc::c_int
            } else {
                DW_LNS_set_epilogue_begin as libc::c_int
            }) as libc::c_uchar,
        );
    }
}
unsafe extern "C" fn tcc_debug_funcend(mut s1: *mut TCCState, mut size: libc::c_int) {
    let mut min_instr_len: libc::c_int = 0;
    tcc_debug_frame_end(s1, size);
    if (*s1).do_debug == 0 {
        return;
    }
    min_instr_len = if (*(*s1).dState).dwarf_line.last_pc == ind {
        0 as libc::c_int
    } else {
        1 as libc::c_int
    };
    ind -= min_instr_len;
    tcc_debug_line(s1);
    ind += min_instr_len;
    tcc_debug_stabn(s1, N_RBRAC as libc::c_int, size);
    if (*s1).dwarf != 0 {
        let mut func_sib: libc::c_int = 0 as libc::c_int;
        let mut sym: *mut Sym = (*(*s1).dState).dwarf_info.func;
        let mut n_debug_info: libc::c_int = tcc_get_dwarf_info(s1, (*sym).type_0.ref_0);
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = (if (*sym).type_0.t & 0x2000 as libc::c_int != 0 {
            21 as libc::c_int
        } else {
            20 as libc::c_int
        }) as uint8_t;
        if (*sym).type_0.t & 0x2000 as libc::c_int == 0 as libc::c_int {
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 1 as libc::c_int as uint8_t;
        }
        dwarf_strp((*s1).dwarf_info_section, funcname);
        dwarf_uleb128(
            (*s1).dwarf_info_section,
            (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
        );
        dwarf_uleb128(
            (*s1).dwarf_info_section,
            (*(*s1).dState).dwarf_info.line as libc::c_ulonglong,
        );
        tcc_debug_check_anon(
            s1,
            (*sym).type_0.ref_0,
            (*(*s1).dwarf_info_section).data_offset as libc::c_int,
        );
        write32le(
            section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            (n_debug_info - (*(*s1).dState).dwarf_info.start) as uint32_t,
        );
        dwarf_reloc(
            (*s1).dwarf_info_section,
            (*(*s1).dState).section_sym,
            1 as libc::c_int,
        );
        write64le(
            section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            func_ind as uint64_t,
        );
        write64le(
            section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            size as uint64_t,
        );
        func_sib = (*(*s1).dwarf_info_section).data_offset as libc::c_int;
        write32le(
            section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint32_t,
        );
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = 1 as libc::c_int as uint8_t;
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = DW_OP_reg6 as libc::c_int as uint8_t;
        tcc_debug_finish(s1, (*(*s1).dState).debug_info_root);
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = 0 as libc::c_int as uint8_t;
        write32le(
            ((*(*s1).dwarf_info_section).data).offset(func_sib as isize),
            ((*(*s1).dwarf_info_section).data_offset)
                .wrapping_sub((*(*s1).dState).dwarf_info.start as libc::c_ulong)
                as uint32_t,
        );
    } else {
        tcc_debug_finish(s1, (*(*s1).dState).debug_info_root);
    }
    (*(*s1).dState).debug_info_root = 0 as *mut _debug_info;
}
unsafe extern "C" fn tcc_debug_extern_sym(
    mut s1: *mut TCCState,
    mut sym: *mut Sym,
    mut sh_num: libc::c_int,
    mut sym_bind: libc::c_int,
    mut sym_type: libc::c_int,
) {
    if (*s1).do_debug as libc::c_int & 2 as libc::c_int == 0 {
        return;
    }
    if sym_type == 2 as libc::c_int || (*sym).v >= 0x10000000 as libc::c_int {
        return;
    }
    if (*s1).dwarf != 0 {
        let mut debug_type: libc::c_int = 0;
        debug_type = tcc_get_dwarf_info(s1, sym);
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = (if sym_bind == 1 as libc::c_int {
            3 as libc::c_int
        } else {
            4 as libc::c_int
        }) as uint8_t;
        dwarf_strp((*s1).dwarf_info_section, get_tok_str((*sym).v, 0 as *mut CValue));
        dwarf_uleb128(
            (*s1).dwarf_info_section,
            (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
        );
        dwarf_uleb128((*s1).dwarf_info_section, (*file).line_num as libc::c_ulonglong);
        tcc_debug_check_anon(
            s1,
            sym,
            (*(*s1).dwarf_info_section).data_offset as libc::c_int,
        );
        write32le(
            section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            (debug_type - (*(*s1).dState).dwarf_info.start) as uint32_t,
        );
        if sym_bind == 1 as libc::c_int {
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 1 as libc::c_int as uint8_t;
        }
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = (8 as libc::c_int + 1 as libc::c_int) as uint8_t;
        *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
            as *mut uint8_t) = DW_OP_addr as libc::c_int as uint8_t;
        greloca(
            (*s1).dwarf_info_section,
            sym,
            (*(*s1).dwarf_info_section).data_offset,
            1 as libc::c_int,
            0 as libc::c_int as Elf64_Addr,
        );
        write64le(
            section_ptr_add((*s1).dwarf_info_section, 8 as libc::c_int as Elf64_Addr)
                as *mut libc::c_uchar,
            0 as libc::c_int as uint64_t,
        );
    } else {
        let mut s: *mut Section = if sh_num == 0xfff2 as libc::c_int {
            (*s1).common_section
        } else {
            *((*s1).sections).offset(sh_num as isize)
        };
        let mut str: CString = CString {
            size: 0,
            size_allocated: 0,
            data: 0 as *mut libc::c_char,
        };
        cstr_new(&mut str);
        cstr_printf(
            &mut str as *mut CString,
            b"%s:%c\0" as *const u8 as *const libc::c_char,
            get_tok_str((*sym).v, 0 as *mut CValue),
            if sym_bind == 1 as libc::c_int {
                'G' as i32
            } else if func_ind != -(1 as libc::c_int) {
                'V' as i32
            } else {
                'S' as i32
            },
        );
        tcc_get_debug_info(s1, sym, &mut str);
        if sym_bind == 1 as libc::c_int {
            tcc_debug_stabs(
                s1,
                str.data,
                N_GSYM as libc::c_int,
                0 as libc::c_int as libc::c_ulong,
                0 as *mut Section,
                0 as libc::c_int,
                0 as libc::c_int,
            );
        } else {
            tcc_debug_stabs(
                s1,
                str.data,
                if (*sym).type_0.t & 0x2000 as libc::c_int != 0
                    && (*s1).data_section == s
                {
                    N_STSYM as libc::c_int
                } else {
                    N_LCSYM as libc::c_int
                },
                0 as libc::c_int as libc::c_ulong,
                s,
                (*sym).c2rust_unnamed.c2rust_unnamed.c,
                0 as libc::c_int,
            );
        }
        cstr_free(&mut str);
    };
}
unsafe extern "C" fn tcc_debug_typedef(mut s1: *mut TCCState, mut sym: *mut Sym) {
    if (*s1).do_debug as libc::c_int & 2 as libc::c_int == 0 {
        return;
    }
    if (*s1).dwarf != 0 {
        let mut debug_type: libc::c_int = 0;
        debug_type = tcc_get_dwarf_info(s1, sym);
        if debug_type != -(1 as libc::c_int) {
            *(section_ptr_add((*s1).dwarf_info_section, 1 as libc::c_int as Elf64_Addr)
                as *mut uint8_t) = 10 as libc::c_int as uint8_t;
            dwarf_strp(
                (*s1).dwarf_info_section,
                get_tok_str((*sym).v, 0 as *mut CValue),
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*(*s1).dState).dwarf_line.cur_file as libc::c_ulonglong,
            );
            dwarf_uleb128(
                (*s1).dwarf_info_section,
                (*file).line_num as libc::c_ulonglong,
            );
            tcc_debug_check_anon(
                s1,
                sym,
                (*(*s1).dwarf_info_section).data_offset as libc::c_int,
            );
            write32le(
                section_ptr_add((*s1).dwarf_info_section, 4 as libc::c_int as Elf64_Addr)
                    as *mut libc::c_uchar,
                (debug_type - (*(*s1).dState).dwarf_info.start) as uint32_t,
            );
        }
    } else {
        let mut str: CString = CString {
            size: 0,
            size_allocated: 0,
            data: 0 as *mut libc::c_char,
        };
        cstr_new(&mut str);
        cstr_printf(
            &mut str as *mut CString,
            b"%s:t\0" as *const u8 as *const libc::c_char,
            if (*sym).v & !(0x20000000 as libc::c_int) >= 0x10000000 as libc::c_int {
                b"\0" as *const u8 as *const libc::c_char
            } else {
                get_tok_str((*sym).v, 0 as *mut CValue)
            },
        );
        tcc_get_debug_info(s1, sym, &mut str);
        tcc_debug_stabs(
            s1,
            str.data,
            N_LSYM as libc::c_int,
            0 as libc::c_int as libc::c_ulong,
            0 as *mut Section,
            0 as libc::c_int,
            0 as libc::c_int,
        );
        cstr_free(&mut str);
    };
}
unsafe extern "C" fn tcc_tcov_block_begin(mut s1: *mut TCCState) {
    let mut sv: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut last_offset: libc::c_ulong = (*(*s1).dState).tcov_data.offset;
    tcc_tcov_block_end(tcc_state, 0 as libc::c_int);
    if (*s1).test_coverage as libc::c_int == 0 as libc::c_int || nocode_wanted != 0 {
        return;
    }
    if (*(*s1).dState).tcov_data.last_file_name == 0 as libc::c_int as libc::c_ulong
        || strcmp(
            ((*(*s1).tcov_section).data)
                .offset((*(*s1).dState).tcov_data.last_file_name as isize)
                as *const libc::c_char,
            (*file).true_filename,
        ) != 0 as libc::c_int
    {
        let mut wd: [libc::c_char; 1024] = [0; 1024];
        let mut cstr: CString = CString {
            size: 0,
            size_allocated: 0,
            data: 0 as *mut libc::c_char,
        };
        if (*(*s1).dState).tcov_data.last_func_name != 0 {
            section_ptr_add((*s1).tcov_section, 1 as libc::c_int as Elf64_Addr);
        }
        if (*(*s1).dState).tcov_data.last_file_name != 0 {
            section_ptr_add((*s1).tcov_section, 1 as libc::c_int as Elf64_Addr);
        }
        (*(*s1).dState).tcov_data.last_func_name = 0 as libc::c_int as libc::c_ulong;
        cstr_new(&mut cstr);
        if *((*file).true_filename).offset(0 as libc::c_int as isize) as libc::c_int
            == '/' as i32
        {
            (*(*s1).dState).tcov_data.last_file_name = (*(*s1).tcov_section).data_offset;
            cstr_printf(
                &mut cstr as *mut CString,
                b"%s\0" as *const u8 as *const libc::c_char,
                (*file).true_filename,
            );
        } else {
            getcwd(
                wd.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            );
            (*(*s1).dState)
                .tcov_data
                .last_file_name = ((*(*s1).tcov_section).data_offset)
                .wrapping_add(strlen(wd.as_mut_ptr()))
                .wrapping_add(1 as libc::c_int as libc::c_ulong);
            cstr_printf(
                &mut cstr as *mut CString,
                b"%s/%s\0" as *const u8 as *const libc::c_char,
                wd.as_mut_ptr(),
                (*file).true_filename,
            );
        }
        ptr = section_ptr_add(
            (*s1).tcov_section,
            (cstr.size + 1 as libc::c_int) as Elf64_Addr,
        );
        strcpy(ptr as *mut libc::c_char, cstr.data);
        cstr_free(&mut cstr);
    }
    if (*(*s1).dState).tcov_data.last_func_name == 0 as libc::c_int as libc::c_ulong
        || strcmp(
            ((*(*s1).tcov_section).data)
                .offset((*(*s1).dState).tcov_data.last_func_name as isize)
                as *const libc::c_char,
            funcname,
        ) != 0 as libc::c_int
    {
        let mut len: size_t = 0;
        if (*(*s1).dState).tcov_data.last_func_name != 0 {
            section_ptr_add((*s1).tcov_section, 1 as libc::c_int as Elf64_Addr);
        }
        (*(*s1).dState).tcov_data.last_func_name = (*(*s1).tcov_section).data_offset;
        len = strlen(funcname);
        ptr = section_ptr_add(
            (*s1).tcov_section,
            len.wrapping_add(1 as libc::c_int as size_t),
        );
        strcpy(ptr as *mut libc::c_char, funcname);
        section_ptr_add(
            (*s1).tcov_section,
            ((*(*s1).tcov_section).data_offset).wrapping_neg()
                & 7 as libc::c_int as libc::c_ulong,
        );
        ptr = section_ptr_add((*s1).tcov_section, 8 as libc::c_int as Elf64_Addr);
        write64le(ptr as *mut libc::c_uchar, (*file).line_num as uint64_t);
    }
    if ind == (*(*s1).dState).tcov_data.ind
        && (*(*s1).dState).tcov_data.line == (*file).line_num
    {
        (*(*s1).dState).tcov_data.offset = last_offset;
    } else {
        let mut label: Sym = {
            let mut init = Sym {
                v: 0 as libc::c_int,
                r: 0,
                a: SymAttr {
                    aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                },
                c2rust_unnamed: C2RustUnnamed_6 {
                    c2rust_unnamed: C2RustUnnamed_7 {
                        c: 0,
                        c2rust_unnamed: C2RustUnnamed_8 { sym_scope: 0 },
                    },
                },
                type_0: CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                },
                c2rust_unnamed_0: C2RustUnnamed_5 {
                    next: 0 as *mut Sym,
                },
                prev: 0 as *mut Sym,
                prev_tok: 0 as *mut Sym,
            };
            init
        };
        label.type_0.t = 4 as libc::c_int | 0x2000 as libc::c_int;
        ptr = section_ptr_add((*s1).tcov_section, 16 as libc::c_int as Elf64_Addr);
        (*(*s1).dState).tcov_data.line = (*file).line_num;
        write64le(
            ptr as *mut libc::c_uchar,
            ((*(*s1).dState).tcov_data.line << 8 as libc::c_int | 0xff as libc::c_int)
                as uint64_t,
        );
        put_extern_sym(
            &mut label,
            (*s1).tcov_section,
            ((ptr as *mut libc::c_uchar).offset_from((*(*s1).tcov_section).data)
                as libc::c_long + 8 as libc::c_int as libc::c_long) as Elf64_Addr,
            0 as libc::c_int as libc::c_ulong,
        );
        sv.type_0 = label.type_0;
        sv
            .r = (0x200 as libc::c_int | 0x100 as libc::c_int | 0x30 as libc::c_int)
            as libc::c_ushort;
        sv.r2 = 0x30 as libc::c_int as libc::c_ushort;
        sv.c2rust_unnamed.c.i = 0 as libc::c_int as uint64_t;
        sv.c2rust_unnamed_0.sym = &mut label;
        gen_increment_tcov(&mut sv);
        (*(*s1).dState)
            .tcov_data
            .offset = (ptr as *mut libc::c_uchar).offset_from((*(*s1).tcov_section).data)
            as libc::c_long as libc::c_ulong;
        (*(*s1).dState).tcov_data.ind = ind;
    };
}
unsafe extern "C" fn tcc_tcov_block_end(mut s1: *mut TCCState, mut line: libc::c_int) {
    if (*s1).test_coverage as libc::c_int == 0 as libc::c_int {
        return;
    }
    if line == -(1 as libc::c_int) {
        line = (*(*s1).dState).tcov_data.line;
    }
    if (*(*s1).dState).tcov_data.offset != 0 {
        let mut ptr: *mut libc::c_void = ((*(*s1).tcov_section).data)
            .offset((*(*s1).dState).tcov_data.offset as isize) as *mut libc::c_void;
        let mut nline: libc::c_ulonglong = (if line != 0 {
            line
        } else {
            (*file).line_num
        }) as libc::c_ulonglong;
        write64le(
            ptr as *mut libc::c_uchar,
            (read64le(ptr as *mut libc::c_uchar) as libc::c_ulonglong
                & 0xfffffffff as libc::c_ulonglong | nline << 36 as libc::c_int)
                as uint64_t,
        );
        (*(*s1).dState).tcov_data.offset = 0 as libc::c_int as libc::c_ulong;
    }
}
unsafe extern "C" fn tcc_tcov_check_line(mut s1: *mut TCCState, mut start: libc::c_int) {
    if (*s1).test_coverage as libc::c_int == 0 as libc::c_int {
        return;
    }
    if (*(*s1).dState).tcov_data.line != (*file).line_num {
        if (*(*s1).dState).tcov_data.line + 1 as libc::c_int != (*file).line_num {
            tcc_tcov_block_end(s1, -(1 as libc::c_int));
            if start != 0 {
                tcc_tcov_block_begin(s1);
            }
        } else {
            (*(*s1).dState).tcov_data.line = (*file).line_num;
        }
    }
}
unsafe extern "C" fn tcc_tcov_start(mut s1: *mut TCCState) {
    if (*s1).test_coverage as libc::c_int == 0 as libc::c_int {
        return;
    }
    if ((*s1).dState).is_null() {
        (*s1)
            .dState = tcc_mallocz(::core::mem::size_of::<_tccdbg>() as libc::c_ulong)
            as *mut _tccdbg;
    }
    memset(
        &mut (*(*s1).dState).tcov_data as *mut C2RustUnnamed_3 as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<C2RustUnnamed_3>() as libc::c_ulong,
    );
    if ((*s1).tcov_section).is_null() {
        (*s1)
            .tcov_section = new_section(
            tcc_state,
            b".tcov\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
        section_ptr_add((*s1).tcov_section, 4 as libc::c_int as Elf64_Addr);
    }
}
unsafe extern "C" fn tcc_tcov_end(mut s1: *mut TCCState) {
    if (*s1).test_coverage as libc::c_int == 0 as libc::c_int {
        return;
    }
    if (*(*s1).dState).tcov_data.last_func_name != 0 {
        section_ptr_add((*s1).tcov_section, 1 as libc::c_int as Elf64_Addr);
    }
    if (*(*s1).dState).tcov_data.last_file_name != 0 {
        section_ptr_add((*s1).tcov_section, 1 as libc::c_int as Elf64_Addr);
    }
}
unsafe extern "C" fn tcc_tcov_reset_ind(mut s1: *mut TCCState) {
    (*(*s1).dState).tcov_data.ind = 0 as libc::c_int;
}
static mut rdata: [libc::c_char; 9] = unsafe {
    *::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b".data.ro\0")
};
unsafe extern "C" fn tccelf_new(mut s: *mut TCCState) {
    let mut s1: *mut TCCState = s;
    dynarray_add(
        &mut (*s).sections as *mut *mut *mut Section as *mut libc::c_void,
        &mut (*s).nb_sections,
        0 as *mut libc::c_void,
    );
    (*s1)
        .text_section = new_section(
        s,
        b".text\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 2 as libc::c_int,
    );
    (*s1)
        .data_section = new_section(
        s,
        b".data\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    (*s1)
        .rodata_section = new_section(
        s,
        rdata.as_ptr(),
        1 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
    (*s1)
        .bss_section = new_section(
        s,
        b".bss\0" as *const u8 as *const libc::c_char,
        8 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    (*s1)
        .common_section = new_section(
        s,
        b".common\0" as *const u8 as *const libc::c_char,
        8 as libc::c_int,
        0x80000000 as libc::c_uint as libc::c_int,
    );
    (*(*s1).common_section).sh_num = 0xfff2 as libc::c_int;
    (*s1)
        .c2rust_unnamed
        .symtab_section = new_symtab(
        s,
        b".symtab\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        0 as libc::c_int,
        b".strtab\0" as *const u8 as *const libc::c_char,
        b".hashtab\0" as *const u8 as *const libc::c_char,
        0x80000000 as libc::c_uint as libc::c_int,
    );
    (*s)
        .dynsymtab_section = new_symtab(
        s,
        b".dynsymtab\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        (0x80000000 as libc::c_uint | 0x40000000 as libc::c_int as libc::c_uint)
            as libc::c_int,
        b".dynstrtab\0" as *const u8 as *const libc::c_char,
        b".dynhashtab\0" as *const u8 as *const libc::c_char,
        0x80000000 as libc::c_uint as libc::c_int,
    );
    get_sym_attr(s, 0 as libc::c_int, 1 as libc::c_int);
    if (*s).do_debug != 0 {
        tcc_debug_new(s);
    }
    if (*s).output_format != 0 as libc::c_int {
        (*s).unwind_tables = 0 as libc::c_int as libc::c_uchar;
    }
    tcc_eh_frame_start(s);
    if (*s).do_bounds_check != 0 {
        (*s1)
            .bounds_section = new_section(
            s,
            b".bounds\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int,
        );
        (*s1)
            .lbounds_section = new_section(
            s,
            b".lbounds\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int,
        );
    }
}
unsafe extern "C" fn free_section(mut s: *mut Section) {
    if s.is_null() {
        return;
    }
    tcc_free((*s).data as *mut libc::c_void);
    (*s).data = 0 as *mut libc::c_uchar;
    (*s).data_offset = 0 as libc::c_int as libc::c_ulong;
    (*s).data_allocated = (*s).data_offset;
}
unsafe extern "C" fn tccelf_delete(mut s1: *mut TCCState) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s1).nb_sym_versions {
        tcc_free(
            (*((*s1).sym_versions).offset(i as isize)).version as *mut libc::c_void,
        );
        tcc_free((*((*s1).sym_versions).offset(i as isize)).lib as *mut libc::c_void);
        i += 1;
        i;
    }
    tcc_free((*s1).sym_versions as *mut libc::c_void);
    tcc_free((*s1).sym_to_version as *mut libc::c_void);
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        free_section(*((*s1).sections).offset(i as isize));
        i += 1;
        i;
    }
    dynarray_reset(
        &mut (*s1).sections as *mut *mut *mut Section as *mut libc::c_void,
        &mut (*s1).nb_sections,
    );
    i = 0 as libc::c_int;
    while i < (*s1).nb_priv_sections {
        free_section(*((*s1).priv_sections).offset(i as isize));
        i += 1;
        i;
    }
    dynarray_reset(
        &mut (*s1).priv_sections as *mut *mut *mut Section as *mut libc::c_void,
        &mut (*s1).nb_priv_sections,
    );
    tcc_free((*s1).sym_attrs as *mut libc::c_void);
    (*s1).c2rust_unnamed.symtab_section = 0 as *mut Section;
}
unsafe extern "C" fn tccelf_begin_file(mut s1: *mut TCCState) {
    let mut s: *mut Section = 0 as *mut Section;
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        (*s).sh_offset = (*s).data_offset;
        i += 1;
        i;
    }
    s = (*s1).c2rust_unnamed.symtab;
    (*s).reloc = (*s).hash;
    (*s).hash = 0 as *mut Section;
}
unsafe extern "C" fn tccelf_end_file(mut s1: *mut TCCState) {
    let mut s: *mut Section = (*s1).c2rust_unnamed.symtab;
    let mut first_sym: libc::c_int = 0;
    let mut nb_syms: libc::c_int = 0;
    let mut tr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut i: libc::c_int = 0;
    first_sym = ((*s).sh_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    nb_syms = ((*s).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        .wrapping_sub(first_sym as libc::c_ulong) as libc::c_int;
    (*s).data_offset = (*s).sh_offset;
    (*(*s).link).data_offset = (*(*s).link).sh_offset;
    (*s).hash = (*s).reloc;
    (*s).reloc = 0 as *mut Section;
    tr = tcc_mallocz(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    i = 0 as libc::c_int;
    while i < nb_syms {
        let mut sym: *mut Elf64_Sym = ((*s).data as *mut Elf64_Sym)
            .offset(first_sym as isize)
            .offset(i as isize);
        if (*sym).st_shndx as libc::c_int == 0 as libc::c_int {
            let mut sym_bind: libc::c_int = (*sym).st_info as libc::c_int
                >> 4 as libc::c_int;
            let mut sym_type: libc::c_int = (*sym).st_info as libc::c_int
                & 0xf as libc::c_int;
            if sym_bind == 0 as libc::c_int {
                sym_bind = 1 as libc::c_int;
            }
            if sym_bind == 1 as libc::c_int && (*s1).output_type == 3 as libc::c_int {
                sym_type = 0 as libc::c_int;
            }
            (*sym)
                .st_info = ((sym_bind << 4 as libc::c_int)
                + (sym_type & 0xf as libc::c_int)) as libc::c_uchar;
        }
        *tr
            .offset(
                i as isize,
            ) = set_elf_sym(
            s,
            (*sym).st_value,
            (*sym).st_size,
            (*sym).st_info as libc::c_int,
            (*sym).st_other as libc::c_int,
            (*sym).st_shndx as libc::c_int,
            ((*(*s).link).data as *mut libc::c_char).offset((*sym).st_name as isize),
        );
        i += 1;
        i;
    }
    update_relocs(s1, s, tr, first_sym);
    tcc_free(tr as *mut libc::c_void);
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        s = *((*s1).sections).offset((i + 1 as libc::c_int) as isize);
        (*s1)
            .total_output[i
            as usize] = ((*s1).total_output[i as usize] as libc::c_ulong)
            .wrapping_add(((*s).data_offset).wrapping_sub((*s).sh_offset))
            as libc::c_uint as libc::c_uint;
        i += 1;
        i;
    }
}
unsafe extern "C" fn new_section(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
    mut sh_type: libc::c_int,
    mut sh_flags: libc::c_int,
) -> *mut Section {
    let mut sec: *mut Section = 0 as *mut Section;
    sec = tcc_mallocz(
        (::core::mem::size_of::<Section>() as libc::c_ulong).wrapping_add(strlen(name)),
    ) as *mut Section;
    (*sec).s1 = s1;
    strcpy(((*sec).name).as_mut_ptr(), name);
    (*sec).sh_type = sh_type;
    (*sec).sh_flags = sh_flags;
    match sh_type {
        1879048191 => {
            (*sec).sh_addralign = 2 as libc::c_int;
        }
        5 | 1879048182 | 9 | 4 | 11 | 2 | 6 | 1879048190 | 1879048189 => {
            (*sec).sh_addralign = 8 as libc::c_int;
        }
        3 => {
            (*sec).sh_addralign = 1 as libc::c_int;
        }
        _ => {
            (*sec).sh_addralign = 8 as libc::c_int;
        }
    }
    if sh_flags as libc::c_uint & 0x80000000 as libc::c_uint != 0 {
        dynarray_add(
            &mut (*s1).priv_sections as *mut *mut *mut Section as *mut libc::c_void,
            &mut (*s1).nb_priv_sections,
            sec as *mut libc::c_void,
        );
    } else {
        (*sec).sh_num = (*s1).nb_sections;
        dynarray_add(
            &mut (*s1).sections as *mut *mut *mut Section as *mut libc::c_void,
            &mut (*s1).nb_sections,
            sec as *mut libc::c_void,
        );
    }
    return sec;
}
unsafe extern "C" fn init_symtab(mut s: *mut Section) {
    let mut ptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nb_buckets: libc::c_int = 1 as libc::c_int;
    put_elf_str((*s).link, b"\0" as *const u8 as *const libc::c_char);
    section_ptr_add(s, ::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong);
    ptr = section_ptr_add(
        (*s).hash,
        ((2 as libc::c_int + nb_buckets + 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    *ptr.offset(0 as libc::c_int as isize) = nb_buckets;
    *ptr.offset(1 as libc::c_int as isize) = 1 as libc::c_int;
    memset(
        ptr.offset(2 as libc::c_int as isize) as *mut libc::c_void,
        0 as libc::c_int,
        ((nb_buckets + 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
}
unsafe extern "C" fn new_symtab(
    mut s1: *mut TCCState,
    mut symtab_name: *const libc::c_char,
    mut sh_type: libc::c_int,
    mut sh_flags: libc::c_int,
    mut strtab_name: *const libc::c_char,
    mut hash_name: *const libc::c_char,
    mut hash_sh_flags: libc::c_int,
) -> *mut Section {
    let mut symtab: *mut Section = 0 as *mut Section;
    let mut strtab: *mut Section = 0 as *mut Section;
    let mut hash: *mut Section = 0 as *mut Section;
    symtab = new_section(s1, symtab_name, sh_type, sh_flags);
    (*symtab)
        .sh_entsize = ::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong
        as libc::c_int;
    strtab = new_section(s1, strtab_name, 3 as libc::c_int, sh_flags);
    (*symtab).link = strtab;
    hash = new_section(s1, hash_name, 5 as libc::c_int, hash_sh_flags);
    (*hash)
        .sh_entsize = ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
        as libc::c_int;
    (*symtab).hash = hash;
    (*hash).link = symtab;
    init_symtab(symtab);
    return symtab;
}
unsafe extern "C" fn section_realloc(
    mut sec: *mut Section,
    mut new_size: libc::c_ulong,
) {
    let mut size: libc::c_ulong = 0;
    let mut data: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    size = (*sec).data_allocated;
    if size == 0 as libc::c_int as libc::c_ulong {
        size = 1 as libc::c_int as libc::c_ulong;
    }
    while size < new_size {
        size = size.wrapping_mul(2 as libc::c_int as libc::c_ulong);
    }
    data = tcc_realloc((*sec).data as *mut libc::c_void, size) as *mut libc::c_uchar;
    memset(
        data.offset((*sec).data_allocated as isize) as *mut libc::c_void,
        0 as libc::c_int,
        size.wrapping_sub((*sec).data_allocated),
    );
    (*sec).data = data;
    (*sec).data_allocated = size;
}
unsafe extern "C" fn section_add(
    mut sec: *mut Section,
    mut size: Elf64_Addr,
    mut align: libc::c_int,
) -> size_t {
    let mut offset: size_t = 0;
    let mut offset1: size_t = 0;
    offset = ((*sec).data_offset)
        .wrapping_add(align as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) & -align as libc::c_ulong;
    offset1 = offset.wrapping_add(size);
    if (*sec).sh_type != 8 as libc::c_int && offset1 > (*sec).data_allocated {
        section_realloc(sec, offset1);
    }
    (*sec).data_offset = offset1;
    if align > (*sec).sh_addralign {
        (*sec).sh_addralign = align;
    }
    return offset;
}
unsafe extern "C" fn section_ptr_add(
    mut sec: *mut Section,
    mut size: Elf64_Addr,
) -> *mut libc::c_void {
    let mut offset: size_t = section_add(sec, size, 1 as libc::c_int);
    return ((*sec).data).offset(offset as isize) as *mut libc::c_void;
}
unsafe extern "C" fn section_reserve(mut sec: *mut Section, mut size: libc::c_ulong) {
    if size > (*sec).data_allocated {
        section_realloc(sec, size);
    }
    if size > (*sec).data_offset {
        (*sec).data_offset = size;
    }
}
unsafe extern "C" fn have_section(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
) -> *mut Section {
    let mut sec: *mut Section = 0 as *mut Section;
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        sec = *((*s1).sections).offset(i as isize);
        if strcmp(name, ((*sec).name).as_mut_ptr()) == 0 {
            return sec;
        }
        i += 1;
        i;
    }
    return 0 as *mut Section;
}
unsafe extern "C" fn find_section(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
) -> *mut Section {
    let mut sec: *mut Section = have_section(s1, name);
    if !sec.is_null() {
        return sec;
    }
    return new_section(
        s1,
        name,
        1 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
}
unsafe extern "C" fn put_elf_str(
    mut s: *mut Section,
    mut sym: *const libc::c_char,
) -> libc::c_int {
    let mut offset: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    len = (strlen(sym)).wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    offset = (*s).data_offset as libc::c_int;
    ptr = section_ptr_add(s, len as Elf64_Addr) as *mut libc::c_char;
    memmove(ptr as *mut libc::c_void, sym as *const libc::c_void, len as libc::c_ulong);
    return offset;
}
unsafe extern "C" fn elf_hash(mut name: *const libc::c_uchar) -> Elf64_Word {
    let mut h: Elf64_Word = 0 as libc::c_int as Elf64_Word;
    let mut g_0: Elf64_Word = 0;
    while *name != 0 {
        let fresh32 = name;
        name = name.offset(1);
        h = (h << 4 as libc::c_int).wrapping_add(*fresh32 as Elf64_Word);
        g_0 = h & 0xf0000000 as libc::c_uint;
        if g_0 != 0 {
            h ^= g_0 >> 24 as libc::c_int;
        }
        h &= !g_0;
    }
    return h;
}
unsafe extern "C" fn rebuild_hash(mut s: *mut Section, mut nb_buckets: libc::c_uint) {
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut ptr: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut hash: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nb_syms: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut strtab: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    strtab = (*(*s).link).data;
    nb_syms = ((*s).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    if nb_buckets == 0 {
        nb_buckets = *((*(*s).hash).data as *mut libc::c_int)
            .offset(0 as libc::c_int as isize) as libc::c_uint;
    }
    (*(*s).hash).data_offset = 0 as libc::c_int as libc::c_ulong;
    ptr = section_ptr_add(
        (*s).hash,
        ((2 as libc::c_int as libc::c_uint)
            .wrapping_add(nb_buckets)
            .wrapping_add(nb_syms as libc::c_uint) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    *ptr.offset(0 as libc::c_int as isize) = nb_buckets as libc::c_int;
    *ptr.offset(1 as libc::c_int as isize) = nb_syms;
    ptr = ptr.offset(2 as libc::c_int as isize);
    hash = ptr;
    memset(
        hash as *mut libc::c_void,
        0 as libc::c_int,
        (nb_buckets.wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    ptr = ptr.offset(nb_buckets.wrapping_add(1 as libc::c_int as libc::c_uint) as isize);
    sym = ((*s).data as *mut Elf64_Sym).offset(1 as libc::c_int as isize);
    sym_index = 1 as libc::c_int;
    while sym_index < nb_syms {
        if (*sym).st_info as libc::c_int >> 4 as libc::c_int != 0 as libc::c_int {
            h = (elf_hash(strtab.offset((*sym).st_name as isize)))
                .wrapping_rem(nb_buckets) as libc::c_int;
            *ptr = *hash.offset(h as isize);
            *hash.offset(h as isize) = sym_index;
        } else {
            *ptr = 0 as libc::c_int;
        }
        ptr = ptr.offset(1);
        ptr;
        sym = sym.offset(1);
        sym;
        sym_index += 1;
        sym_index;
    }
}
unsafe extern "C" fn put_elf_sym(
    mut s: *mut Section,
    mut value: Elf64_Addr,
    mut size: libc::c_ulong,
    mut info: libc::c_int,
    mut other: libc::c_int,
    mut shndx: libc::c_int,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut name_offset: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut nbuckets: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut hs: *mut Section = 0 as *mut Section;
    sym = section_ptr_add(s, ::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as *mut Elf64_Sym;
    if !name.is_null() && *name.offset(0 as libc::c_int as isize) as libc::c_int != 0 {
        name_offset = put_elf_str((*s).link, name);
    } else {
        name_offset = 0 as libc::c_int;
    }
    (*sym).st_name = name_offset as Elf64_Word;
    (*sym).st_value = value;
    (*sym).st_size = size;
    (*sym).st_info = info as libc::c_uchar;
    (*sym).st_other = other as libc::c_uchar;
    (*sym).st_shndx = shndx as Elf64_Section;
    sym_index = sym.offset_from((*s).data as *mut Elf64_Sym) as libc::c_long
        as libc::c_int;
    hs = (*s).hash;
    if !hs.is_null() {
        let mut ptr: *mut libc::c_int = 0 as *mut libc::c_int;
        let mut base: *mut libc::c_int = 0 as *mut libc::c_int;
        ptr = section_ptr_add(hs, ::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as *mut libc::c_int;
        base = (*hs).data as *mut libc::c_int;
        if info as libc::c_uchar as libc::c_int >> 4 as libc::c_int != 0 as libc::c_int {
            nbuckets = *base.offset(0 as libc::c_int as isize);
            h = (elf_hash(((*(*s).link).data).offset(name_offset as isize))
                % nbuckets as Elf64_Word) as libc::c_int;
            *ptr = *base.offset((2 as libc::c_int + h) as isize);
            *base.offset((2 as libc::c_int + h) as isize) = sym_index;
            let ref mut fresh33 = *base.offset(1 as libc::c_int as isize);
            *fresh33 += 1;
            *fresh33;
            (*hs).nb_hashed_syms += 1;
            (*hs).nb_hashed_syms;
            if (*hs).nb_hashed_syms > 2 as libc::c_int * nbuckets {
                rebuild_hash(s, (2 as libc::c_int * nbuckets) as libc::c_uint);
            }
        } else {
            *ptr = 0 as libc::c_int;
            let ref mut fresh34 = *base.offset(1 as libc::c_int as isize);
            *fresh34 += 1;
            *fresh34;
        }
    }
    return sym_index;
}
unsafe extern "C" fn find_elf_sym(
    mut s: *mut Section,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut hs: *mut Section = 0 as *mut Section;
    let mut nbuckets: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut h: libc::c_int = 0;
    let mut name1: *const libc::c_char = 0 as *const libc::c_char;
    hs = (*s).hash;
    if hs.is_null() {
        return 0 as libc::c_int;
    }
    nbuckets = *((*hs).data as *mut libc::c_int).offset(0 as libc::c_int as isize);
    h = (elf_hash(name as *mut libc::c_uchar) % nbuckets as Elf64_Word) as libc::c_int;
    sym_index = *((*hs).data as *mut libc::c_int)
        .offset((2 as libc::c_int + h) as isize);
    while sym_index != 0 as libc::c_int {
        sym = &mut *((*s).data as *mut Elf64_Sym).offset(sym_index as isize)
            as *mut Elf64_Sym;
        name1 = ((*(*s).link).data as *mut libc::c_char).offset((*sym).st_name as isize);
        if strcmp(name, name1) == 0 {
            return sym_index;
        }
        sym_index = *((*hs).data as *mut libc::c_int)
            .offset((2 as libc::c_int + nbuckets + sym_index) as isize);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_sym_addr(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
    mut err: libc::c_int,
    mut forc: libc::c_int,
) -> Elf64_Addr {
    let mut sym_index: libc::c_int = 0;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut buf: [libc::c_char; 256] = [0; 256];
    if forc != 0 && (*s1).leading_underscore as libc::c_int != 0 {
        buf[0 as libc::c_int as usize] = '_' as i32 as libc::c_char;
        pstrcpy(
            buf.as_mut_ptr().offset(1 as libc::c_int as isize),
            (::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            name,
        );
        name = buf.as_mut_ptr();
    }
    sym_index = find_elf_sym((*s1).c2rust_unnamed.symtab, name);
    sym = &mut *((*(*s1).c2rust_unnamed.symtab).data as *mut Elf64_Sym)
        .offset(sym_index as isize) as *mut Elf64_Sym;
    if sym_index == 0 || (*sym).st_shndx as libc::c_int == 0 as libc::c_int {
        if err != 0 {
            tcc_enter_state(s1);
            (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(b"%s not defined\0" as *const u8 as *const libc::c_char, name);
        }
        return -(1 as libc::c_int) as Elf64_Addr;
    }
    return (*sym).st_value;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_get_symbol(
    mut s: *mut TCCState,
    mut name: *const libc::c_char,
) -> *mut libc::c_void {
    let mut addr: Elf64_Addr = get_sym_addr(s, name, 0 as libc::c_int, 1 as libc::c_int);
    return if addr == -(1 as libc::c_int) as Elf64_Addr {
        0 as *mut libc::c_void
    } else {
        addr as *mut libc::c_void
    };
}
#[no_mangle]
pub unsafe extern "C" fn tcc_add_symbol(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
    mut val: *const libc::c_void,
) -> libc::c_int {
    let mut buf: [libc::c_char; 256] = [0; 256];
    if (*s1).leading_underscore != 0 {
        buf[0 as libc::c_int as usize] = '_' as i32 as libc::c_char;
        pstrcpy(
            buf.as_mut_ptr().offset(1 as libc::c_int as isize),
            (::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                .wrapping_sub(1 as libc::c_int as libc::c_ulong),
            name,
        );
        name = buf.as_mut_ptr();
    }
    set_global_sym(s1, name, 0 as *mut Section, val as uintptr_t);
    return 0 as libc::c_int;
}
unsafe extern "C" fn list_elf_symbols(
    mut s: *mut TCCState,
    mut ctx: *mut libc::c_void,
    mut symbol_cb: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_void,
        ) -> (),
    >,
) {
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut symtab: *mut Section = 0 as *mut Section;
    let mut sym_index: libc::c_int = 0;
    let mut end_sym: libc::c_int = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym_vis: libc::c_uchar = 0;
    let mut sym_bind: libc::c_uchar = 0;
    symtab = (*s).c2rust_unnamed.symtab;
    end_sym = ((*symtab).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    sym_index = 0 as libc::c_int;
    while sym_index < end_sym {
        sym = &mut *((*symtab).data as *mut Elf64_Sym).offset(sym_index as isize)
            as *mut Elf64_Sym;
        if (*sym).st_value != 0 {
            name = ((*(*symtab).link).data as *mut libc::c_char)
                .offset((*sym).st_name as isize);
            sym_bind = ((*sym).st_info as libc::c_int >> 4 as libc::c_int)
                as libc::c_uchar;
            sym_vis = ((*sym).st_other as libc::c_int & 0x3 as libc::c_int)
                as libc::c_uchar;
            if sym_bind as libc::c_int == 1 as libc::c_int
                && sym_vis as libc::c_int == 0 as libc::c_int
            {
                symbol_cb
                    .expect(
                        "non-null function pointer",
                    )(ctx, name, (*sym).st_value as *mut libc::c_void);
            }
        }
        sym_index += 1;
        sym_index;
    }
}
#[no_mangle]
pub unsafe extern "C" fn tcc_list_symbols(
    mut s: *mut TCCState,
    mut ctx: *mut libc::c_void,
    mut symbol_cb: Option::<
        unsafe extern "C" fn(
            *mut libc::c_void,
            *const libc::c_char,
            *const libc::c_void,
        ) -> (),
    >,
) {
    list_elf_symbols(s, ctx, symbol_cb);
}
unsafe extern "C" fn version_add(mut s1: *mut TCCState) {
    let mut i: libc::c_int = 0;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut vn: *mut Elf64_Verneed = 0 as *mut Elf64_Verneed;
    let mut symtab: *mut Section = 0 as *mut Section;
    let mut sym_index: libc::c_int = 0;
    let mut end_sym: libc::c_int = 0;
    let mut nb_versions: libc::c_int = 2 as libc::c_int;
    let mut nb_entries: libc::c_int = 0 as libc::c_int;
    let mut versym: *mut Elf64_Half = 0 as *mut Elf64_Half;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    if 0 as libc::c_int == (*s1).nb_sym_versions {
        return;
    }
    (*s1)
        .versym_section = new_section(
        s1,
        b".gnu.version\0" as *const u8 as *const libc::c_char,
        0x6fffffff as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
    (*(*s1).versym_section)
        .sh_entsize = ::core::mem::size_of::<Elf64_Half>() as libc::c_ulong
        as libc::c_int;
    (*(*s1).versym_section).link = (*s1).dynsym;
    symtab = (*s1).dynsym;
    end_sym = ((*symtab).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    versym = section_ptr_add(
        (*s1).versym_section,
        (end_sym as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Half>() as libc::c_ulong),
    ) as *mut Elf64_Half;
    sym_index = 1 as libc::c_int;
    while sym_index < end_sym {
        let mut dllindex: libc::c_int = 0;
        let mut verndx: libc::c_int = 0;
        sym = &mut *((*symtab).data as *mut Elf64_Sym).offset(sym_index as isize)
            as *mut Elf64_Sym;
        name = ((*(*symtab).link).data as *mut libc::c_char)
            .offset((*sym).st_name as isize);
        dllindex = find_elf_sym((*s1).dynsymtab_section, name);
        verndx = if dllindex != 0 && dllindex < (*s1).nb_sym_to_version {
            *((*s1).sym_to_version).offset(dllindex as isize)
        } else {
            -(1 as libc::c_int)
        };
        if verndx >= 0 as libc::c_int
            && ((*sym).st_shndx as libc::c_int == 0 as libc::c_int
                || (*s1).output_type & 2 as libc::c_int != 0)
        {
            if (*((*s1).sym_versions).offset(verndx as isize)).out_index == 0 {
                let fresh35 = nb_versions;
                nb_versions = nb_versions + 1;
                (*((*s1).sym_versions).offset(verndx as isize)).out_index = fresh35;
            }
            *versym
                .offset(
                    sym_index as isize,
                ) = (*((*s1).sym_versions).offset(verndx as isize)).out_index
                as Elf64_Half;
        } else {
            *versym.offset(sym_index as isize) = 1 as libc::c_int as Elf64_Half;
        }
        sym_index += 1;
        sym_index;
    }
    if nb_versions > 2 as libc::c_int {
        (*s1)
            .verneed_section = new_section(
            s1,
            b".gnu.version_r\0" as *const u8 as *const libc::c_char,
            0x6ffffffe as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int,
        );
        (*(*s1).verneed_section).link = (*(*s1).dynsym).link;
        i = (*s1).nb_sym_versions;
        loop {
            let fresh36 = i;
            i = i - 1;
            if !(fresh36 > 0 as libc::c_int) {
                break;
            }
            let mut sv: *mut sym_version = &mut *((*s1).sym_versions).offset(i as isize)
                as *mut sym_version;
            let mut n_same_libs: libc::c_int = 0 as libc::c_int;
            let mut prev: libc::c_int = 0;
            let mut vnofs: size_t = 0;
            let mut vna: *mut Elf64_Vernaux = 0 as *mut Elf64_Vernaux;
            if (*sv).out_index < 1 as libc::c_int {
                continue;
            }
            if strcmp((*sv).lib, b"ld-linux.so.2\0" as *const u8 as *const libc::c_char)
                != 0
            {
                tcc_add_dllref(s1, (*sv).lib, 0 as libc::c_int);
            }
            vnofs = section_add(
                (*s1).verneed_section,
                ::core::mem::size_of::<Elf64_Verneed>() as libc::c_ulong,
                1 as libc::c_int,
            );
            vn = ((*(*s1).verneed_section).data).offset(vnofs as isize)
                as *mut Elf64_Verneed;
            (*vn).vn_version = 1 as libc::c_int as Elf64_Half;
            (*vn)
                .vn_file = put_elf_str((*(*s1).verneed_section).link, (*sv).lib)
                as Elf64_Word;
            (*vn)
                .vn_aux = ::core::mem::size_of::<Elf64_Verneed>() as libc::c_ulong
                as Elf64_Word;
            loop {
                prev = (*sv).prev_same_lib;
                if (*sv).out_index > 0 as libc::c_int {
                    vna = section_ptr_add(
                        (*s1).verneed_section,
                        ::core::mem::size_of::<Elf64_Vernaux>() as libc::c_ulong,
                    ) as *mut Elf64_Vernaux;
                    (*vna).vna_hash = elf_hash((*sv).version as *const libc::c_uchar);
                    (*vna).vna_flags = 0 as libc::c_int as Elf64_Half;
                    (*vna).vna_other = (*sv).out_index as Elf64_Half;
                    (*sv).out_index = -(2 as libc::c_int);
                    (*vna)
                        .vna_name = put_elf_str(
                        (*(*s1).verneed_section).link,
                        (*sv).version,
                    ) as Elf64_Word;
                    (*vna)
                        .vna_next = ::core::mem::size_of::<Elf64_Vernaux>()
                        as libc::c_ulong as Elf64_Word;
                    n_same_libs += 1;
                    n_same_libs;
                }
                if prev >= 0 as libc::c_int {
                    sv = &mut *((*s1).sym_versions).offset(prev as isize)
                        as *mut sym_version;
                }
                if !(prev >= 0 as libc::c_int) {
                    break;
                }
            }
            (*vna).vna_next = 0 as libc::c_int as Elf64_Word;
            vn = ((*(*s1).verneed_section).data).offset(vnofs as isize)
                as *mut Elf64_Verneed;
            (*vn).vn_cnt = n_same_libs as Elf64_Half;
            (*vn)
                .vn_next = (::core::mem::size_of::<Elf64_Verneed>() as libc::c_ulong)
                .wrapping_add(
                    (n_same_libs as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<Elf64_Vernaux>() as libc::c_ulong,
                        ),
                ) as Elf64_Word;
            nb_entries += 1;
            nb_entries;
        }
        if !vn.is_null() {
            (*vn).vn_next = 0 as libc::c_int as Elf64_Word;
        }
        (*(*s1).verneed_section).sh_info = nb_entries;
    }
    (*s1).dt_verneednum = nb_entries;
}
unsafe extern "C" fn set_elf_sym(
    mut s: *mut Section,
    mut value: Elf64_Addr,
    mut size: libc::c_ulong,
    mut info: libc::c_int,
    mut other: libc::c_int,
    mut shndx: libc::c_int,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut s1: *mut TCCState = (*s).s1;
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut sym_bind: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut sym_type: libc::c_int = 0;
    let mut esym_bind: libc::c_int = 0;
    let mut sym_vis: libc::c_uchar = 0;
    let mut esym_vis: libc::c_uchar = 0;
    let mut new_vis: libc::c_uchar = 0;
    sym_bind = info as libc::c_uchar as libc::c_int >> 4 as libc::c_int;
    sym_type = info & 0xf as libc::c_int;
    sym_vis = (other & 0x3 as libc::c_int) as libc::c_uchar;
    if sym_bind != 0 as libc::c_int {
        sym_index = find_elf_sym(s, name);
        if sym_index == 0 {
            current_block = 934281384036335307;
        } else {
            esym = &mut *((*s).data as *mut Elf64_Sym).offset(sym_index as isize)
                as *mut Elf64_Sym;
            if (*esym).st_value == value && (*esym).st_size == size
                && (*esym).st_info as libc::c_int == info
                && (*esym).st_other as libc::c_int == other
                && (*esym).st_shndx as libc::c_int == shndx
            {
                return sym_index;
            }
            if (*esym).st_shndx as libc::c_int != 0 as libc::c_int {
                esym_bind = (*esym).st_info as libc::c_int >> 4 as libc::c_int;
                esym_vis = ((*esym).st_other as libc::c_int & 0x3 as libc::c_int)
                    as libc::c_uchar;
                if esym_vis as libc::c_int == 0 as libc::c_int {
                    new_vis = sym_vis;
                } else if sym_vis as libc::c_int == 0 as libc::c_int {
                    new_vis = esym_vis;
                } else {
                    new_vis = (if (esym_vis as libc::c_int) < sym_vis as libc::c_int {
                        esym_vis as libc::c_int
                    } else {
                        sym_vis as libc::c_int
                    }) as libc::c_uchar;
                }
                (*esym)
                    .st_other = ((*esym).st_other as libc::c_int
                    & !(-(1 as libc::c_int) & 0x3 as libc::c_int)
                    | new_vis as libc::c_int) as libc::c_uchar;
                if shndx == 0 as libc::c_int {
                    current_block = 10891380440665537214;
                } else if sym_bind == 1 as libc::c_int && esym_bind == 2 as libc::c_int {
                    current_block = 17933960988044798249;
                } else if sym_bind == 2 as libc::c_int && esym_bind == 1 as libc::c_int {
                    current_block = 10891380440665537214;
                } else if sym_bind == 2 as libc::c_int && esym_bind == 2 as libc::c_int {
                    current_block = 10891380440665537214;
                } else if sym_vis as libc::c_int == 2 as libc::c_int
                    || sym_vis as libc::c_int == 1 as libc::c_int
                {
                    current_block = 10891380440665537214;
                } else if ((*esym).st_shndx as libc::c_int == 0xfff2 as libc::c_int
                    || (*esym).st_shndx as libc::c_int == (*(*s1).bss_section).sh_num)
                    && (shndx < 0xff00 as libc::c_int
                        && shndx != (*(*s1).bss_section).sh_num)
                {
                    current_block = 17933960988044798249;
                } else if shndx == 0xfff2 as libc::c_int
                    || shndx == (*(*s1).bss_section).sh_num
                {
                    current_block = 10891380440665537214;
                } else if (*s).sh_flags & 0x40000000 as libc::c_int != 0 {
                    current_block = 10891380440665537214;
                } else if (*esym).st_other as libc::c_int & 0x4 as libc::c_int != 0 {
                    current_block = 17933960988044798249;
                } else {
                    tcc_enter_state(s1);
                    (Some(
                        _tcc_error_noabort
                            as unsafe extern "C" fn(
                                *const libc::c_char,
                                ...
                            ) -> libc::c_int,
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        b"'%s' defined twice\0" as *const u8 as *const libc::c_char,
                        name,
                    );
                    current_block = 10891380440665537214;
                }
            } else {
                (*esym).st_other = other as libc::c_uchar;
                current_block = 17933960988044798249;
            }
            match current_block {
                10891380440665537214 => {}
                _ => {
                    (*esym)
                        .st_info = ((sym_bind << 4 as libc::c_int)
                        + (sym_type & 0xf as libc::c_int)) as libc::c_uchar;
                    (*esym).st_shndx = shndx as Elf64_Section;
                    (*esym).st_value = value;
                    (*esym).st_size = size;
                    current_block = 10891380440665537214;
                }
            }
        }
    } else {
        current_block = 934281384036335307;
    }
    match current_block {
        934281384036335307 => {
            sym_index = put_elf_sym(
                s,
                value,
                size,
                (sym_bind << 4 as libc::c_int) + (sym_type & 0xf as libc::c_int),
                other,
                shndx,
                name,
            );
        }
        _ => {}
    }
    return sym_index;
}
unsafe extern "C" fn put_elf_reloca(
    mut symtab: *mut Section,
    mut s: *mut Section,
    mut offset: libc::c_ulong,
    mut type_0: libc::c_int,
    mut symbol: libc::c_int,
    mut addend: Elf64_Addr,
) {
    let mut s1: *mut TCCState = (*s).s1;
    let mut buf: [libc::c_char; 256] = [0; 256];
    let mut sr: *mut Section = 0 as *mut Section;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    sr = (*s).reloc;
    if sr.is_null() {
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b".rela%s\0" as *const u8 as *const libc::c_char,
            ((*s).name).as_mut_ptr(),
        );
        sr = new_section(
            (*s).s1,
            buf.as_mut_ptr(),
            4 as libc::c_int,
            (*symtab).sh_flags,
        );
        (*sr)
            .sh_entsize = ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong
            as libc::c_int;
        (*sr).link = symtab;
        (*sr).sh_info = (*s).sh_num;
        (*s).reloc = sr;
    }
    rel = section_ptr_add(sr, ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong)
        as *mut Elf64_Rela;
    (*rel).r_offset = offset;
    (*rel)
        .r_info = ((symbol as Elf64_Xword) << 32 as libc::c_int)
        .wrapping_add(type_0 as Elf64_Xword);
    (*rel).r_addend = addend as Elf64_Sxword;
    if 4 as libc::c_int != 4 as libc::c_int && addend != 0 {
        tcc_enter_state(s1);
        (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(
            b"non-zero addend on REL architecture\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn put_elf_reloc(
    mut symtab: *mut Section,
    mut s: *mut Section,
    mut offset: libc::c_ulong,
    mut type_0: libc::c_int,
    mut symbol: libc::c_int,
) {
    put_elf_reloca(symtab, s, offset, type_0, symbol, 0 as libc::c_int as Elf64_Addr);
}
unsafe extern "C" fn get_sym_attr(
    mut s1: *mut TCCState,
    mut index: libc::c_int,
    mut alloc: libc::c_int,
) -> *mut sym_attr {
    let mut n: libc::c_int = 0;
    let mut tab: *mut sym_attr = 0 as *mut sym_attr;
    if index >= (*s1).nb_sym_attrs {
        if alloc == 0 {
            return (*s1).sym_attrs;
        }
        n = 1 as libc::c_int;
        while index >= n {
            n *= 2 as libc::c_int;
        }
        tab = tcc_realloc(
            (*s1).sym_attrs as *mut libc::c_void,
            (n as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<sym_attr>() as libc::c_ulong),
        ) as *mut sym_attr;
        (*s1).sym_attrs = tab;
        memset(
            ((*s1).sym_attrs).offset((*s1).nb_sym_attrs as isize) as *mut libc::c_void,
            0 as libc::c_int,
            ((n - (*s1).nb_sym_attrs) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<sym_attr>() as libc::c_ulong),
        );
        (*s1).nb_sym_attrs = n;
    }
    return &mut *((*s1).sym_attrs).offset(index as isize) as *mut sym_attr;
}
unsafe extern "C" fn update_relocs(
    mut s1: *mut TCCState,
    mut s: *mut Section,
    mut old_to_new_syms: *mut libc::c_int,
    mut first_sym: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut sr: *mut Section = 0 as *mut Section;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        sr = *((*s1).sections).offset(i as isize);
        if (*sr).sh_type == 4 as libc::c_int && (*sr).link == s {
            rel = ((*sr).data as *mut Elf64_Rela).offset(0 as libc::c_int as isize);
            while rel
                < ((*sr).data).offset((*sr).data_offset as isize) as *mut Elf64_Rela
            {
                sym_index = ((*rel).r_info >> 32 as libc::c_int) as libc::c_int;
                type_0 = ((*rel).r_info & 0xffffffff as libc::c_uint as Elf64_Xword)
                    as libc::c_int;
                sym_index -= first_sym;
                if !(sym_index < 0 as libc::c_int) {
                    sym_index = *old_to_new_syms.offset(sym_index as isize);
                    (*rel)
                        .r_info = ((sym_index as Elf64_Xword) << 32 as libc::c_int)
                        .wrapping_add(type_0 as Elf64_Xword);
                }
                rel = rel.offset(1);
                rel;
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn sort_syms(mut s1: *mut TCCState, mut s: *mut Section) {
    let mut old_to_new_syms: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut new_syms: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut nb_syms: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut p: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut q: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    nb_syms = ((*s).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    new_syms = tcc_malloc(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong),
    ) as *mut Elf64_Sym;
    old_to_new_syms = tcc_malloc(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    p = (*s).data as *mut Elf64_Sym;
    q = new_syms;
    i = 0 as libc::c_int;
    while i < nb_syms {
        if (*p).st_info as libc::c_int >> 4 as libc::c_int == 0 as libc::c_int {
            *old_to_new_syms
                .offset(
                    i as isize,
                ) = q.offset_from(new_syms) as libc::c_long as libc::c_int;
            let fresh37 = q;
            q = q.offset(1);
            *fresh37 = *p;
        }
        p = p.offset(1);
        p;
        i += 1;
        i;
    }
    if (*s).sh_size != 0 {
        (*s).sh_info = q.offset_from(new_syms) as libc::c_long as libc::c_int;
    }
    p = (*s).data as *mut Elf64_Sym;
    i = 0 as libc::c_int;
    while i < nb_syms {
        if (*p).st_info as libc::c_int >> 4 as libc::c_int != 0 as libc::c_int {
            *old_to_new_syms
                .offset(
                    i as isize,
                ) = q.offset_from(new_syms) as libc::c_long as libc::c_int;
            let fresh38 = q;
            q = q.offset(1);
            *fresh38 = *p;
        }
        p = p.offset(1);
        p;
        i += 1;
        i;
    }
    memcpy(
        (*s).data as *mut libc::c_void,
        new_syms as *const libc::c_void,
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong),
    );
    tcc_free(new_syms as *mut libc::c_void);
    update_relocs(s1, s, old_to_new_syms, 0 as libc::c_int);
    tcc_free(old_to_new_syms as *mut libc::c_void);
}
unsafe extern "C" fn create_gnu_hash(mut s1: *mut TCCState) -> *mut Section {
    let mut nb_syms: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut ndef: libc::c_int = 0;
    let mut nbuckets: libc::c_int = 0;
    let mut symoffset: libc::c_int = 0;
    let mut bloom_size: libc::c_int = 0;
    let mut bloom_shift: libc::c_int = 0;
    let mut p: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut gnu_hash: *mut Section = 0 as *mut Section;
    let mut dynsym: *mut Section = (*s1).dynsym;
    let mut ptr: *mut Elf32_Word = 0 as *mut Elf32_Word;
    gnu_hash = new_section(
        s1,
        b".gnu.hash\0" as *const u8 as *const libc::c_char,
        0x6ffffff6 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int,
    );
    (*gnu_hash).link = (*(*dynsym).hash).link;
    nb_syms = ((*dynsym).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    ndef = 0 as libc::c_int;
    p = (*dynsym).data as *mut Elf64_Sym;
    i = 0 as libc::c_int;
    while i < nb_syms {
        ndef += ((*p).st_shndx as libc::c_int != 0 as libc::c_int) as libc::c_int;
        i += 1;
        i;
        p = p.offset(1);
        p;
    }
    nbuckets = ndef / 4 as libc::c_int + 1 as libc::c_int;
    symoffset = nb_syms - ndef;
    bloom_shift = if 8 as libc::c_int == 8 as libc::c_int {
        6 as libc::c_int
    } else {
        5 as libc::c_int
    };
    bloom_size = 1 as libc::c_int;
    while ndef >= bloom_size * ((1 as libc::c_int) << bloom_shift - 3 as libc::c_int) {
        bloom_size *= 2 as libc::c_int;
    }
    ptr = section_ptr_add(
        gnu_hash,
        (4 as libc::c_int * 4 as libc::c_int + 8 as libc::c_int * bloom_size
            + nbuckets * 4 as libc::c_int + ndef * 4 as libc::c_int) as Elf64_Addr,
    ) as *mut Elf32_Word;
    *ptr.offset(0 as libc::c_int as isize) = nbuckets as Elf32_Word;
    *ptr.offset(1 as libc::c_int as isize) = symoffset as Elf32_Word;
    *ptr.offset(2 as libc::c_int as isize) = bloom_size as Elf32_Word;
    *ptr.offset(3 as libc::c_int as isize) = bloom_shift as Elf32_Word;
    return gnu_hash;
}
unsafe extern "C" fn elf_gnu_hash(mut name: *const libc::c_uchar) -> Elf32_Word {
    let mut h: Elf32_Word = 5381 as libc::c_int as Elf32_Word;
    let mut c: libc::c_uchar = 0;
    loop {
        let fresh39 = name;
        name = name.offset(1);
        c = *fresh39;
        if !(c != 0) {
            break;
        }
        h = (h * 33 as libc::c_int as Elf32_Word).wrapping_add(c as Elf32_Word);
    }
    return h;
}
unsafe extern "C" fn update_gnu_hash(mut s1: *mut TCCState, mut gnu_hash: *mut Section) {
    let mut old_to_new_syms: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut new_syms: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut nb_syms: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut nbuckets: libc::c_int = 0;
    let mut bloom_size: libc::c_int = 0;
    let mut bloom_shift: libc::c_int = 0;
    let mut p: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut q: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut vs: *mut Section = 0 as *mut Section;
    let mut dynsym: *mut Section = (*s1).dynsym;
    let mut ptr: *mut Elf32_Word = 0 as *mut Elf32_Word;
    let mut buckets: *mut Elf32_Word = 0 as *mut Elf32_Word;
    let mut chain: *mut Elf32_Word = 0 as *mut Elf32_Word;
    let mut hash: *mut Elf32_Word = 0 as *mut Elf32_Word;
    let mut nextbuck: *mut libc::c_uint = 0 as *mut libc::c_uint;
    let mut bloom: *mut Elf64_Addr = 0 as *mut Elf64_Addr;
    let mut strtab: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut buck: *mut C2RustUnnamed_23 = 0 as *mut C2RustUnnamed_23;
    strtab = (*(*dynsym).link).data;
    nb_syms = ((*dynsym).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    new_syms = tcc_malloc(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong),
    ) as *mut Elf64_Sym;
    old_to_new_syms = tcc_malloc(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    hash = tcc_malloc(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf32_Word>() as libc::c_ulong),
    ) as *mut Elf32_Word;
    nextbuck = tcc_malloc(
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_uint;
    p = (*dynsym).data as *mut Elf64_Sym;
    q = new_syms;
    i = 0 as libc::c_int;
    while i < nb_syms {
        if (*p).st_shndx as libc::c_int == 0 as libc::c_int {
            *old_to_new_syms
                .offset(
                    i as isize,
                ) = q.offset_from(new_syms) as libc::c_long as libc::c_int;
            let fresh40 = q;
            q = q.offset(1);
            *fresh40 = *p;
        } else {
            *hash
                .offset(i as isize) = elf_gnu_hash(strtab.offset((*p).st_name as isize));
        }
        i += 1;
        i;
        p = p.offset(1);
        p;
    }
    ptr = (*gnu_hash).data as *mut Elf32_Word;
    nbuckets = *ptr.offset(0 as libc::c_int as isize) as libc::c_int;
    bloom_size = *ptr.offset(2 as libc::c_int as isize) as libc::c_int;
    bloom_shift = *ptr.offset(3 as libc::c_int as isize) as libc::c_int;
    bloom = &mut *ptr.offset(4 as libc::c_int as isize) as *mut Elf32_Word
        as *mut libc::c_void as *mut Elf64_Addr;
    buckets = &mut *bloom.offset(bloom_size as isize) as *mut Elf64_Addr
        as *mut libc::c_void as *mut Elf32_Word;
    chain = &mut *buckets.offset(nbuckets as isize) as *mut Elf32_Word;
    buck = tcc_malloc(
        (nbuckets as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<C2RustUnnamed_23>() as libc::c_ulong),
    ) as *mut C2RustUnnamed_23;
    if (*gnu_hash).data_offset
        != ((4 as libc::c_int * 4 as libc::c_int + 8 as libc::c_int * bloom_size
            + nbuckets * 4 as libc::c_int) as libc::c_long
            + (nb_syms as libc::c_long - q.offset_from(new_syms) as libc::c_long)
                * 4 as libc::c_int as libc::c_long) as libc::c_ulong
    {
        tcc_enter_state(s1);
        (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(b"gnu_hash size incorrect\0" as *const u8 as *const libc::c_char);
    }
    i = 0 as libc::c_int;
    while i < nbuckets {
        (*buck.offset(i as isize)).first = -(1 as libc::c_int);
        i += 1;
        i;
    }
    p = (*dynsym).data as *mut Elf64_Sym;
    i = 0 as libc::c_int;
    while i < nb_syms {
        if (*p).st_shndx as libc::c_int != 0 as libc::c_int {
            let mut bucket: libc::c_int = (*hash.offset(i as isize)
                % nbuckets as Elf32_Word) as libc::c_int;
            if (*buck.offset(bucket as isize)).first == -(1 as libc::c_int) {
                let ref mut fresh41 = (*buck.offset(bucket as isize)).last;
                *fresh41 = i;
                (*buck.offset(bucket as isize)).first = *fresh41;
            } else {
                *nextbuck
                    .offset(
                        (*buck.offset(bucket as isize)).last as isize,
                    ) = i as libc::c_uint;
                (*buck.offset(bucket as isize)).last = i;
            }
        }
        i += 1;
        i;
        p = p.offset(1);
        p;
    }
    p = (*dynsym).data as *mut Elf64_Sym;
    i = 0 as libc::c_int;
    while i < nbuckets {
        let mut cur: libc::c_int = (*buck.offset(i as isize)).first;
        if cur != -(1 as libc::c_int) {
            *buckets
                .offset(
                    i as isize,
                ) = q.offset_from(new_syms) as libc::c_long as Elf32_Word;
            loop {
                *old_to_new_syms
                    .offset(
                        cur as isize,
                    ) = q.offset_from(new_syms) as libc::c_long as libc::c_int;
                let fresh42 = q;
                q = q.offset(1);
                *fresh42 = *p.offset(cur as isize);
                let fresh43 = chain;
                chain = chain.offset(1);
                *fresh43 = *hash.offset(cur as isize)
                    & !(1 as libc::c_int) as Elf32_Word;
                *bloom
                    .offset(
                        (*hash.offset(cur as isize)
                            / (8 as libc::c_int * 8 as libc::c_int) as Elf32_Word
                            % bloom_size as Elf32_Word) as isize,
                    )
                    |= (1 as libc::c_int as Elf64_Addr)
                        << *hash.offset(cur as isize)
                            % (8 as libc::c_int * 8 as libc::c_int) as Elf32_Word
                        | (1 as libc::c_int as Elf64_Addr)
                            << (*hash.offset(cur as isize) >> bloom_shift)
                                % (8 as libc::c_int * 8 as libc::c_int) as Elf32_Word;
                if cur == (*buck.offset(i as isize)).last {
                    break;
                }
                cur = *nextbuck.offset(cur as isize) as libc::c_int;
            }
            *chain.offset(-(1 as libc::c_int) as isize)
                |= 1 as libc::c_int as Elf32_Word;
        }
        i += 1;
        i;
    }
    memcpy(
        (*dynsym).data as *mut libc::c_void,
        new_syms as *const libc::c_void,
        (nb_syms as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong),
    );
    tcc_free(new_syms as *mut libc::c_void);
    tcc_free(hash as *mut libc::c_void);
    tcc_free(buck as *mut libc::c_void);
    tcc_free(nextbuck as *mut libc::c_void);
    update_relocs(s1, dynsym, old_to_new_syms, 0 as libc::c_int);
    vs = (*s1).versym_section;
    if !vs.is_null() {
        let mut newver: *mut Elf64_Half = 0 as *mut Elf64_Half;
        let mut versym: *mut Elf64_Half = (*vs).data as *mut Elf64_Half;
        newver = tcc_malloc(
            (nb_syms as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Elf64_Half>() as libc::c_ulong),
        ) as *mut Elf64_Half;
        i = 0 as libc::c_int;
        while i < nb_syms {
            *newver
                .offset(
                    *old_to_new_syms.offset(i as isize) as isize,
                ) = *versym.offset(i as isize);
            i += 1;
            i;
        }
        memcpy(
            (*vs).data as *mut libc::c_void,
            newver as *const libc::c_void,
            (nb_syms as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Elf64_Half>() as libc::c_ulong),
        );
        tcc_free(newver as *mut libc::c_void);
    }
    tcc_free(old_to_new_syms as *mut libc::c_void);
    ptr = (*(*dynsym).hash).data as *mut Elf32_Word;
    rebuild_hash(dynsym, *ptr.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn relocate_syms(
    mut s1: *mut TCCState,
    mut symtab: *mut Section,
    mut do_resolve: libc::c_int,
) {
    let mut current_block: u64;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut sym_bind: libc::c_int = 0;
    let mut sh_num: libc::c_int = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    sym = ((*symtab).data as *mut Elf64_Sym).offset(1 as libc::c_int as isize);
    while sym < ((*symtab).data).offset((*symtab).data_offset as isize) as *mut Elf64_Sym
    {
        sh_num = (*sym).st_shndx as libc::c_int;
        if sh_num == 0 as libc::c_int {
            if !(do_resolve == 2 as libc::c_int) {
                name = ((*(*(*s1).c2rust_unnamed.symtab).link).data as *mut libc::c_char)
                    .offset((*sym).st_name as isize);
                if do_resolve != 0 {
                    let mut name_ud: *const libc::c_char = &*name
                        .offset((*s1).leading_underscore as isize)
                        as *const libc::c_char;
                    let mut addr: *mut libc::c_void = 0 as *mut libc::c_void;
                    if (*s1).nostdlib == 0 {
                        addr = dlsym(0 as *mut libc::c_void, name_ud);
                    }
                    if addr.is_null() {
                        let mut i: libc::c_int = 0;
                        i = 0 as libc::c_int;
                        while i < (*s1).nb_loaded_dlls {
                            addr = dlsym(
                                (**((*s1).loaded_dlls).offset(i as isize)).handle,
                                name_ud,
                            );
                            if !addr.is_null() {
                                break;
                            }
                            i += 1;
                            i;
                        }
                    }
                    if !addr.is_null() {
                        (*sym).st_value = addr as Elf64_Addr;
                        current_block = 6239978542346980191;
                    } else {
                        current_block = 5689001924483802034;
                    }
                } else if !((*s1).dynsym).is_null()
                    && find_elf_sym((*s1).dynsym, name) != 0
                {
                    current_block = 6239978542346980191;
                } else {
                    current_block = 5689001924483802034;
                }
                match current_block {
                    6239978542346980191 => {}
                    _ => {
                        if !(strcmp(
                            name,
                            b"_fp_hw\0" as *const u8 as *const libc::c_char,
                        ) == 0)
                        {
                            sym_bind = (*sym).st_info as libc::c_int >> 4 as libc::c_int;
                            if sym_bind == 2 as libc::c_int {
                                (*sym).st_value = 0 as libc::c_int as Elf64_Addr;
                            } else {
                                tcc_enter_state(s1);
                                (Some(
                                    _tcc_error_noabort
                                        as unsafe extern "C" fn(
                                            *const libc::c_char,
                                            ...
                                        ) -> libc::c_int,
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    b"undefined symbol '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    name,
                                );
                            }
                        }
                    }
                }
            }
        } else if sh_num < 0xff00 as libc::c_int {
            (*sym)
                .st_value = ((*sym).st_value)
                .wrapping_add(
                    (**((*s1).sections).offset((*sym).st_shndx as isize)).sh_addr,
                );
        }
        sym = sym.offset(1);
        sym;
    }
}
unsafe extern "C" fn relocate_section(
    mut s1: *mut TCCState,
    mut s: *mut Section,
    mut sr: *mut Section,
) {
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut type_0: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut ptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut tgt: Elf64_Addr = 0;
    let mut addr: Elf64_Addr = 0;
    let mut is_dwarf: libc::c_int = ((*s).sh_num >= (*s1).dwlo
        && (*s).sh_num < (*s1).dwhi) as libc::c_int;
    (*s1).qrel = (*sr).data as *mut Elf64_Rela;
    rel = ((*sr).data as *mut Elf64_Rela).offset(0 as libc::c_int as isize);
    while rel < ((*sr).data).offset((*sr).data_offset as isize) as *mut Elf64_Rela {
        ptr = ((*s).data).offset((*rel).r_offset as isize);
        sym_index = ((*rel).r_info >> 32 as libc::c_int) as libc::c_int;
        sym = &mut *((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
            .offset(sym_index as isize) as *mut Elf64_Sym;
        type_0 = ((*rel).r_info & 0xffffffff as libc::c_uint as Elf64_Xword)
            as libc::c_int;
        tgt = (*sym).st_value;
        tgt = tgt.wrapping_add((*rel).r_addend as Elf64_Addr);
        if is_dwarf != 0 && type_0 == 10 as libc::c_int
            && (*sym).st_shndx as libc::c_int >= (*s1).dwlo
            && ((*sym).st_shndx as libc::c_int) < (*s1).dwhi
        {
            add32le(
                ptr,
                tgt
                    .wrapping_sub(
                        (**((*s1).sections).offset((*sym).st_shndx as isize)).sh_addr,
                    ) as int32_t,
            );
        } else {
            addr = ((*s).sh_addr).wrapping_add((*rel).r_offset);
            relocate(s1, rel, type_0, ptr, addr, tgt);
        }
        rel = rel.offset(1);
        rel;
    }
    if (*sr).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
        (*sr).link = (*s1).dynsym;
        if (*s1).output_type & 4 as libc::c_int != 0 {
            let mut r: size_t = ((*s1).qrel as *mut uint8_t).offset_from((*sr).data)
                as libc::c_long as size_t;
            if (::core::mem::size_of::<libc::c_uint>() as libc::c_ulong)
                < 8 as libc::c_int as libc::c_ulong
                && 0 as libc::c_int
                    == strcmp(
                        ((*s).name).as_mut_ptr(),
                        b".stab\0" as *const u8 as *const libc::c_char,
                    )
            {
                r = 0 as libc::c_int as size_t;
            }
            (*sr).sh_size = r;
            (*sr).data_offset = (*sr).sh_size;
        }
    }
}
unsafe extern "C" fn relocate_sections(mut s1: *mut TCCState) {
    let mut i: libc::c_int = 0;
    let mut s: *mut Section = 0 as *mut Section;
    let mut sr: *mut Section = 0 as *mut Section;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        sr = *((*s1).sections).offset(i as isize);
        if !((*sr).sh_type != 4 as libc::c_int) {
            s = *((*s1).sections).offset((*sr).sh_info as isize);
            if s != (*s1).got || (*s1).static_link as libc::c_int != 0
                || (*s1).output_type == 1 as libc::c_int
            {
                relocate_section(s1, s, sr);
            }
            if (*sr).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
                let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
                rel = ((*sr).data as *mut Elf64_Rela).offset(0 as libc::c_int as isize);
                while rel
                    < ((*sr).data).offset((*sr).data_offset as isize) as *mut Elf64_Rela
                {
                    (*rel).r_offset = ((*rel).r_offset).wrapping_add((*s).sh_addr);
                    rel = rel.offset(1);
                    rel;
                }
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn prepare_dynamic_rel(
    mut s1: *mut TCCState,
    mut sr: *mut Section,
) -> libc::c_int {
    let mut count: libc::c_int = 0 as libc::c_int;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    rel = ((*sr).data as *mut Elf64_Rela).offset(0 as libc::c_int as isize);
    while rel < ((*sr).data).offset((*sr).data_offset as isize) as *mut Elf64_Rela {
        let mut sym_index: libc::c_int = ((*rel).r_info >> 32 as libc::c_int)
            as libc::c_int;
        let mut type_0: libc::c_int = ((*rel).r_info
            & 0xffffffff as libc::c_uint as Elf64_Xword) as libc::c_int;
        match type_0 {
            10 | 11 | 1 => {
                count += 1;
                count;
            }
            2 => {
                let mut sym: *mut Elf64_Sym = &mut *((*(*s1)
                    .c2rust_unnamed
                    .symtab_section)
                    .data as *mut Elf64_Sym)
                    .offset(sym_index as isize) as *mut Elf64_Sym;
                if (*sym).st_shndx as libc::c_int != 0 as libc::c_int
                    && (*sym).st_other as libc::c_int & 0x3 as libc::c_int
                        == 2 as libc::c_int
                {
                    (*rel)
                        .r_info = ((sym_index as Elf64_Xword) << 32 as libc::c_int)
                        .wrapping_add(4 as libc::c_int as Elf64_Xword);
                } else if !((*s1).output_type != 4 as libc::c_int) {
                    if (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).dyn_index != 0 {
                        count += 1;
                        count;
                    }
                }
            }
            _ => {}
        }
        rel = rel.offset(1);
        rel;
    }
    return count;
}
unsafe extern "C" fn build_got(mut s1: *mut TCCState) -> libc::c_int {
    (*s1)
        .got = new_section(
        s1,
        b".got\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        (1 as libc::c_int) << 1 as libc::c_int | (1 as libc::c_int) << 0 as libc::c_int,
    );
    (*(*s1).got).sh_entsize = 4 as libc::c_int;
    section_ptr_add((*s1).got, (3 as libc::c_int * 8 as libc::c_int) as Elf64_Addr);
    return set_elf_sym(
        (*s1).c2rust_unnamed.symtab_section,
        0 as libc::c_int as Elf64_Addr,
        0 as libc::c_int as libc::c_ulong,
        ((1 as libc::c_int) << 4 as libc::c_int)
            + (1 as libc::c_int & 0xf as libc::c_int),
        0 as libc::c_int,
        (*(*s1).got).sh_num,
        b"_GLOBAL_OFFSET_TABLE_\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn put_got_entry(
    mut s1: *mut TCCState,
    mut dyn_reloc_type: libc::c_int,
    mut sym_index: libc::c_int,
) -> *mut sym_attr {
    let mut need_plt_entry: libc::c_int = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut attr: *mut sym_attr = 0 as *mut sym_attr;
    let mut got_offset: libc::c_uint = 0;
    let mut plt_name: [libc::c_char; 200] = [0; 200];
    let mut len: libc::c_int = 0;
    let mut s_rel: *mut Section = 0 as *mut Section;
    need_plt_entry = (dyn_reloc_type == 7 as libc::c_int) as libc::c_int;
    attr = get_sym_attr(s1, sym_index, 1 as libc::c_int);
    if if need_plt_entry != 0 { (*attr).plt_offset } else { (*attr).got_offset } != 0 {
        return attr;
    }
    s_rel = (*s1).got;
    if need_plt_entry != 0 {
        if ((*s1).plt).is_null() {
            (*s1)
                .plt = new_section(
                s1,
                b".plt\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                (1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int,
            );
            (*(*s1).plt).sh_entsize = 4 as libc::c_int;
        }
        s_rel = (*s1).plt;
    }
    got_offset = (*(*s1).got).data_offset as libc::c_uint;
    section_ptr_add((*s1).got, 8 as libc::c_int as Elf64_Addr);
    sym = &mut *((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
        .offset(sym_index as isize) as *mut Elf64_Sym;
    name = ((*(*(*s1).c2rust_unnamed.symtab_section).link).data as *mut libc::c_char)
        .offset((*sym).st_name as isize);
    if !((*s1).dynsym).is_null() {
        if (*sym).st_info as libc::c_int >> 4 as libc::c_int == 0 as libc::c_int {
            put_elf_reloc(
                (*s1).dynsym,
                (*s1).got,
                got_offset as libc::c_ulong,
                8 as libc::c_int,
                sym_index,
            );
        } else {
            if 0 as libc::c_int == (*attr).dyn_index {
                (*attr)
                    .dyn_index = set_elf_sym(
                    (*s1).dynsym,
                    (*sym).st_value,
                    (*sym).st_size,
                    (*sym).st_info as libc::c_int,
                    0 as libc::c_int,
                    (*sym).st_shndx as libc::c_int,
                    name,
                );
            }
            put_elf_reloc(
                (*s1).dynsym,
                s_rel,
                got_offset as libc::c_ulong,
                dyn_reloc_type,
                (*attr).dyn_index,
            );
        }
    } else {
        put_elf_reloc(
            (*s1).c2rust_unnamed.symtab_section,
            (*s1).got,
            got_offset as libc::c_ulong,
            dyn_reloc_type,
            sym_index,
        );
    }
    if need_plt_entry != 0 {
        (*attr).plt_offset = create_plt_entry(s1, got_offset, attr);
        len = strlen(name) as libc::c_int;
        if len as libc::c_ulong
            > (::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong)
                .wrapping_sub(5 as libc::c_int as libc::c_ulong)
        {
            len = (::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong)
                .wrapping_sub(5 as libc::c_int as libc::c_ulong) as libc::c_int;
        }
        memcpy(
            plt_name.as_mut_ptr() as *mut libc::c_void,
            name as *const libc::c_void,
            len as libc::c_ulong,
        );
        strcpy(
            plt_name.as_mut_ptr().offset(len as isize),
            b"@plt\0" as *const u8 as *const libc::c_char,
        );
        (*attr)
            .plt_sym = put_elf_sym(
            (*s1).c2rust_unnamed.symtab,
            (*attr).plt_offset as Elf64_Addr,
            0 as libc::c_int as libc::c_ulong,
            ((1 as libc::c_int) << 4 as libc::c_int)
                + (2 as libc::c_int & 0xf as libc::c_int),
            0 as libc::c_int,
            (*(*s1).plt).sh_num,
            plt_name.as_mut_ptr(),
        );
    } else {
        (*attr).got_offset = got_offset;
    }
    return attr;
}
unsafe extern "C" fn build_got_entries(mut s1: *mut TCCState, mut got_sym: libc::c_int) {
    let mut s: *mut Section = 0 as *mut Section;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut i: libc::c_int = 0;
    let mut type_0: libc::c_int = 0;
    let mut gotplt_entry: libc::c_int = 0;
    let mut reloc_type: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut attr: *mut sym_attr = 0 as *mut sym_attr;
    let mut pass: libc::c_int = 0 as libc::c_int;
    loop {
        i = 1 as libc::c_int;
        while i < (*s1).nb_sections {
            s = *((*s1).sections).offset(i as isize);
            if !((*s).sh_type != 4 as libc::c_int) {
                if !((*s).link != (*s1).c2rust_unnamed.symtab_section) {
                    let mut current_block_19: u64;
                    rel = ((*s).data as *mut Elf64_Rela)
                        .offset(0 as libc::c_int as isize);
                    while rel
                        < ((*s).data).offset((*s).data_offset as isize)
                            as *mut Elf64_Rela
                    {
                        type_0 = ((*rel).r_info
                            & 0xffffffff as libc::c_uint as Elf64_Xword) as libc::c_int;
                        gotplt_entry = gotplt_entry_type(type_0);
                        if gotplt_entry == -(1 as libc::c_int) {
                            tcc_enter_state(s1);
                            (Some(
                                _tcc_error_noabort
                                    as unsafe extern "C" fn(
                                        *const libc::c_char,
                                        ...
                                    ) -> libc::c_int,
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                b"Unknown relocation type for got: %d\0" as *const u8
                                    as *const libc::c_char,
                                type_0,
                            );
                        } else {
                            sym_index = ((*rel).r_info >> 32 as libc::c_int)
                                as libc::c_int;
                            sym = &mut *((*(*s1).c2rust_unnamed.symtab_section).data
                                as *mut Elf64_Sym)
                                .offset(sym_index as isize) as *mut Elf64_Sym;
                            if !(gotplt_entry == NO_GOTPLT_ENTRY as libc::c_int) {
                                if gotplt_entry == AUTO_GOTPLT_ENTRY as libc::c_int {
                                    if (*sym).st_shndx as libc::c_int == 0 as libc::c_int {
                                        let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
                                        let mut dynindex: libc::c_int = 0;
                                        if 1 as libc::c_int == 0
                                            && (*s1).output_type & 4 as libc::c_int != 0
                                        {
                                            current_block_19 = 7351195479953500246;
                                        } else if !((*s1).dynsym).is_null() {
                                            dynindex = (*get_sym_attr(s1, sym_index, 0 as libc::c_int))
                                                .dyn_index;
                                            esym = ((*(*s1).dynsym).data as *mut Elf64_Sym)
                                                .offset(dynindex as isize);
                                            if dynindex != 0
                                                && ((*esym).st_info as libc::c_int & 0xf as libc::c_int
                                                    == 2 as libc::c_int
                                                    || (*esym).st_info as libc::c_int & 0xf as libc::c_int
                                                        == 0 as libc::c_int
                                                        && (*sym).st_info as libc::c_int & 0xf as libc::c_int
                                                            == 2 as libc::c_int)
                                            {
                                                current_block_19 = 11793550633721587306;
                                            } else {
                                                current_block_19 = 4068382217303356765;
                                            }
                                        } else {
                                            current_block_19 = 4068382217303356765;
                                        }
                                    } else if (*sym).st_shndx as libc::c_int
                                        == 0xfff1 as libc::c_int
                                    {
                                        if (*sym).st_value == 0 as libc::c_int as Elf64_Addr {
                                            current_block_19 = 7351195479953500246;
                                        } else if 8 as libc::c_int != 8 as libc::c_int {
                                            current_block_19 = 7351195479953500246;
                                        } else {
                                            current_block_19 = 4068382217303356765;
                                        }
                                    } else {
                                        current_block_19 = 7351195479953500246;
                                    }
                                } else {
                                    current_block_19 = 4068382217303356765;
                                }
                                match current_block_19 {
                                    7351195479953500246 => {}
                                    _ => {
                                        match current_block_19 {
                                            4068382217303356765 => {
                                                if (type_0 == 4 as libc::c_int
                                                    || type_0 == 2 as libc::c_int)
                                                    && (*sym).st_shndx as libc::c_int != 0 as libc::c_int
                                                    && ((*sym).st_other as libc::c_int & 0x3 as libc::c_int
                                                        != 0 as libc::c_int
                                                        || (*sym).st_info as libc::c_int >> 4 as libc::c_int
                                                            == 0 as libc::c_int
                                                        || (*s1).output_type & 2 as libc::c_int != 0)
                                                {
                                                    if pass != 0 as libc::c_int {
                                                        current_block_19 = 7351195479953500246;
                                                    } else {
                                                        (*rel)
                                                            .r_info = ((sym_index as Elf64_Xword) << 32 as libc::c_int)
                                                            .wrapping_add(2 as libc::c_int as Elf64_Xword);
                                                        current_block_19 = 7351195479953500246;
                                                    }
                                                } else {
                                                    reloc_type = code_reloc(type_0);
                                                    if reloc_type == -(1 as libc::c_int) {
                                                        tcc_enter_state(s1);
                                                        (Some(
                                                            _tcc_error_noabort
                                                                as unsafe extern "C" fn(
                                                                    *const libc::c_char,
                                                                    ...
                                                                ) -> libc::c_int,
                                                        ))
                                                            .expect(
                                                                "non-null function pointer",
                                                            )(
                                                            b"Unknown relocation type: %d\0" as *const u8
                                                                as *const libc::c_char,
                                                            type_0,
                                                        );
                                                        current_block_19 = 7351195479953500246;
                                                    } else if reloc_type != 0 as libc::c_int {
                                                        current_block_19 = 11793550633721587306;
                                                    } else if pass != 1 as libc::c_int {
                                                        current_block_19 = 7351195479953500246;
                                                    } else {
                                                        reloc_type = 6 as libc::c_int;
                                                        current_block_19 = 14832935472441733737;
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                        match current_block_19 {
                                            7351195479953500246 => {}
                                            _ => {
                                                match current_block_19 {
                                                    11793550633721587306 => {
                                                        if pass != 0 as libc::c_int {
                                                            current_block_19 = 7351195479953500246;
                                                        } else {
                                                            reloc_type = 7 as libc::c_int;
                                                            current_block_19 = 14832935472441733737;
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                                match current_block_19 {
                                                    7351195479953500246 => {}
                                                    _ => {
                                                        if ((*s1).got).is_null() {
                                                            got_sym = build_got(s1);
                                                        }
                                                        if !(gotplt_entry == BUILD_GOT_ONLY as libc::c_int) {
                                                            attr = put_got_entry(s1, reloc_type, sym_index);
                                                            if reloc_type == 7 as libc::c_int {
                                                                (*rel)
                                                                    .r_info = (((*attr).plt_sym as Elf64_Xword)
                                                                    << 32 as libc::c_int)
                                                                    .wrapping_add(type_0 as Elf64_Xword);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        rel = rel.offset(1);
                        rel;
                    }
                }
            }
            i += 1;
            i;
        }
        pass += 1;
        if !(pass < 2 as libc::c_int) {
            break;
        }
    }
    if !((*s1).plt).is_null() && !((*(*s1).plt).reloc).is_null() {
        (*(*(*s1).plt).reloc).sh_info = (*(*s1).got).sh_num;
    }
    if got_sym != 0 {
        (*((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
            .offset(got_sym as isize))
            .st_size = (*(*s1).got).data_offset;
    }
}
unsafe extern "C" fn set_global_sym(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
    mut sec: *mut Section,
    mut offs: Elf64_Addr,
) -> libc::c_int {
    let mut shn: libc::c_int = if !sec.is_null() {
        (*sec).sh_num
    } else if offs != 0 || name.is_null() {
        0xfff1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if !sec.is_null() && offs == -(1 as libc::c_int) as Elf64_Addr {
        offs = (*sec).data_offset;
    }
    return set_elf_sym(
        (*s1).c2rust_unnamed.symtab_section,
        offs,
        0 as libc::c_int as libc::c_ulong,
        ((if !name.is_null() { 1 as libc::c_int } else { 0 as libc::c_int })
            << 4 as libc::c_int) + (0 as libc::c_int & 0xf as libc::c_int),
        0 as libc::c_int,
        shn,
        name,
    );
}
unsafe extern "C" fn add_init_array_defines(
    mut s1: *mut TCCState,
    mut section_name: *const libc::c_char,
) {
    let mut s: *mut Section = 0 as *mut Section;
    let mut end_offset: Elf64_Addr = 0;
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    s = have_section(s1, section_name);
    if s.is_null() || (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int == 0 {
        end_offset = 0 as libc::c_int as Elf64_Addr;
        s = (*s1).text_section;
    } else {
        end_offset = (*s).data_offset;
    }
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        b"__%s_start\0" as *const u8 as *const libc::c_char,
        section_name.offset(1 as libc::c_int as isize),
    );
    set_global_sym(s1, buf.as_mut_ptr(), s, 0 as libc::c_int as Elf64_Addr);
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        b"__%s_end\0" as *const u8 as *const libc::c_char,
        section_name.offset(1 as libc::c_int as isize),
    );
    set_global_sym(s1, buf.as_mut_ptr(), s, end_offset);
}
unsafe extern "C" fn add_array(
    mut s1: *mut TCCState,
    mut sec: *const libc::c_char,
    mut c: libc::c_int,
) {
    let mut s: *mut Section = 0 as *mut Section;
    s = find_section(s1, sec);
    (*s).sh_flags = (1 as libc::c_int) << 1 as libc::c_int;
    (*s)
        .sh_type = if *sec.offset(1 as libc::c_int as isize) as libc::c_int == 'i' as i32
    {
        14 as libc::c_int
    } else {
        15 as libc::c_int
    };
    put_elf_reloc((*s1).c2rust_unnamed.symtab, s, (*s).data_offset, 1 as libc::c_int, c);
    section_ptr_add(s, 8 as libc::c_int as Elf64_Addr);
}
unsafe extern "C" fn tcc_add_bcheck(mut s1: *mut TCCState) {
    if 0 as libc::c_int == (*s1).do_bounds_check as libc::c_int {
        return;
    }
    section_ptr_add(
        (*s1).bounds_section,
        ::core::mem::size_of::<Elf64_Addr>() as libc::c_ulong,
    );
}
unsafe extern "C" fn set_local_sym(
    mut s1: *mut TCCState,
    mut name: *const libc::c_char,
    mut s: *mut Section,
    mut offset: libc::c_int,
) {
    let mut c: libc::c_int = find_elf_sym((*s1).c2rust_unnamed.symtab, name);
    if c != 0 {
        let mut esym: *mut Elf64_Sym = ((*(*s1).c2rust_unnamed.symtab).data
            as *mut Elf64_Sym)
            .offset(c as isize);
        (*esym)
            .st_info = (((0 as libc::c_int) << 4 as libc::c_int)
            + (0 as libc::c_int & 0xf as libc::c_int)) as libc::c_uchar;
        (*esym).st_value = offset as Elf64_Addr;
        (*esym).st_shndx = (*s).sh_num as Elf64_Section;
    }
}
unsafe extern "C" fn tcc_compile_string_no_debug(
    mut s: *mut TCCState,
    mut str: *const libc::c_char,
) {
    let mut save_do_debug: libc::c_int = (*s).do_debug as libc::c_int;
    let mut save_test_coverage: libc::c_int = (*s).test_coverage as libc::c_int;
    (*s).do_debug = 0 as libc::c_int as libc::c_uchar;
    (*s).test_coverage = 0 as libc::c_int as libc::c_uchar;
    tcc_compile_string(s, str);
    (*s).do_debug = save_do_debug as libc::c_uchar;
    (*s).test_coverage = save_test_coverage as libc::c_uchar;
}
unsafe extern "C" fn put_ptr(
    mut s1: *mut TCCState,
    mut s: *mut Section,
    mut offs: libc::c_int,
) {
    let mut c: libc::c_int = 0;
    c = set_global_sym(s1, 0 as *const libc::c_char, s, offs as Elf64_Addr);
    s = (*s1).data_section;
    put_elf_reloc((*s1).c2rust_unnamed.symtab, s, (*s).data_offset, 1 as libc::c_int, c);
    section_ptr_add(s, 8 as libc::c_int as Elf64_Addr);
}
unsafe extern "C" fn tcc_add_btstub(mut s1: *mut TCCState) {
    let mut s: *mut Section = 0 as *mut Section;
    let mut n: libc::c_int = 0;
    let mut o_0: libc::c_int = 0;
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut cstr: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    let mut __rt_info: *const libc::c_char = &*(b"___rt_info\0" as *const u8
        as *const libc::c_char)
        .offset(((*s1).leading_underscore == 0) as libc::c_int as isize)
        as *const libc::c_char;
    s = (*s1).data_section;
    section_ptr_add(
        s,
        ((*s).data_offset).wrapping_neg()
            & (8 as libc::c_int - 1 as libc::c_int) as libc::c_ulong,
    );
    o_0 = (*s).data_offset as libc::c_int;
    if (*s1).dwarf != 0 {
        put_ptr(s1, (*s1).dwarf_line_section, 0 as libc::c_int);
        put_ptr(s1, (*s1).dwarf_line_section, -(1 as libc::c_int));
        if (*s1).dwarf as libc::c_int >= 5 as libc::c_int {
            put_ptr(s1, (*s1).dwarf_line_str_section, 0 as libc::c_int);
        } else {
            put_ptr(s1, (*s1).dwarf_str_section, 0 as libc::c_int);
        }
    } else {
        put_ptr(s1, (*s1).stab_section, 0 as libc::c_int);
        put_ptr(s1, (*s1).stab_section, -(1 as libc::c_int));
        put_ptr(s1, (*(*s1).stab_section).link, 0 as libc::c_int);
    }
    section_ptr_add(s, (3 as libc::c_int * 8 as libc::c_int) as Elf64_Addr);
    if (*s1).output_type == 1 as libc::c_int
        && 0 as libc::c_int == (*s1).dwarf as libc::c_int
    {
        put_ptr(s1, (*s1).text_section, 0 as libc::c_int);
    } else {
        put_ptr(s1, 0 as *mut Section, 0 as libc::c_int);
    }
    n = 3 as libc::c_int * 8 as libc::c_int;
    if (*s1).do_bounds_check != 0 {
        put_ptr(s1, (*s1).bounds_section, 0 as libc::c_int);
        n -= 8 as libc::c_int;
    }
    section_ptr_add(s, n as Elf64_Addr);
    p = section_ptr_add(
        s,
        (2 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    *p.offset(0 as libc::c_int as isize) = (*s1).rt_num_callers;
    *p.offset(1 as libc::c_int as isize) = (*s1).dwarf as libc::c_int;
    if (*s1).output_type == 1 as libc::c_int {
        set_global_sym(s1, __rt_info, s, o_0 as Elf64_Addr);
        return;
    }
    cstr_new(&mut cstr);
    cstr_printf(
        &mut cstr as *mut CString,
        b"extern void __bt_init(),__bt_exit(),__bt_init_dll();static void *__rt_info[];__attribute__((constructor)) static void __bt_init_rt(){\0"
            as *const u8 as *const libc::c_char,
    );
    cstr_printf(
        &mut cstr as *mut CString,
        b"__bt_init(__rt_info,%d);}\0" as *const u8 as *const libc::c_char,
        ((*s1).output_type != 4 as libc::c_int) as libc::c_int,
    );
    cstr_printf(
        &mut cstr as *mut CString,
        b"__attribute__((destructor)) static void __bt_exit_rt(){__bt_exit(__rt_info);}\0"
            as *const u8 as *const libc::c_char,
    );
    tcc_compile_string_no_debug(s1, cstr.data);
    cstr_free(&mut cstr);
    set_local_sym(s1, __rt_info, s, o_0);
}
unsafe extern "C" fn tcc_tcov_add_file(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) {
    let mut cstr: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut wd: [libc::c_char; 1024] = [0; 1024];
    if ((*s1).tcov_section).is_null() {
        return;
    }
    section_ptr_add((*s1).tcov_section, 1 as libc::c_int as Elf64_Addr);
    write32le((*(*s1).tcov_section).data, (*(*s1).tcov_section).data_offset as uint32_t);
    cstr_new(&mut cstr);
    if *filename.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        cstr_printf(
            &mut cstr as *mut CString,
            b"%s.tcov\0" as *const u8 as *const libc::c_char,
            filename,
        );
    } else {
        getcwd(
            wd.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        );
        cstr_printf(
            &mut cstr as *mut CString,
            b"%s/%s.tcov\0" as *const u8 as *const libc::c_char,
            wd.as_mut_ptr(),
            filename,
        );
    }
    ptr = section_ptr_add(
        (*s1).tcov_section,
        (cstr.size + 1 as libc::c_int) as Elf64_Addr,
    );
    strcpy(ptr as *mut libc::c_char, cstr.data);
    unlink(ptr as *mut libc::c_char);
    cstr_free(&mut cstr);
    cstr_new(&mut cstr);
    cstr_printf(
        &mut cstr as *mut CString,
        b"extern char *__tcov_data[];extern void __store_test_coverage ();__attribute__((destructor)) static void __tcov_exit() {__store_test_coverage(__tcov_data);}\0"
            as *const u8 as *const libc::c_char,
    );
    tcc_compile_string_no_debug(s1, cstr.data);
    cstr_free(&mut cstr);
    set_local_sym(
        s1,
        &*(b"___tcov_data\0" as *const u8 as *const libc::c_char)
            .offset(((*s1).leading_underscore == 0) as libc::c_int as isize),
        (*s1).tcov_section,
        0 as libc::c_int,
    );
}
unsafe extern "C" fn tccelf_add_crtbegin(mut s1: *mut TCCState) {
    if (*s1).output_type != 4 as libc::c_int {
        tcc_add_crt(s1, b"crt1.o\0" as *const u8 as *const libc::c_char);
    }
    tcc_add_crt(s1, b"crti.o\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn tccelf_add_crtend(mut s1: *mut TCCState) {
    tcc_add_crt(s1, b"crtn.o\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn tcc_add_runtime(mut s1: *mut TCCState) {
    (*s1).filetype = 0 as libc::c_int as libc::c_uchar;
    tcc_add_bcheck(s1);
    tcc_add_pragma_libs(s1);
    if (*s1).nostdlib == 0 {
        let mut lpthread: libc::c_int = (*s1).option_pthread as libc::c_int;
        if (*s1).do_bounds_check as libc::c_int != 0
            && (*s1).output_type != 4 as libc::c_int
        {
            tcc_add_support(s1, b"bcheck.o\0" as *const u8 as *const libc::c_char);
            tcc_add_library(s1, b"dl\0" as *const u8 as *const libc::c_char);
            lpthread = 1 as libc::c_int;
        }
        if (*s1).do_backtrace != 0 {
            if (*s1).output_type & 2 as libc::c_int != 0 {
                tcc_add_support(s1, b"bt-exe.o\0" as *const u8 as *const libc::c_char);
            }
            if (*s1).output_type != 4 as libc::c_int {
                tcc_add_support(s1, b"bt-log.o\0" as *const u8 as *const libc::c_char);
            }
            tcc_add_btstub(s1);
            lpthread = 1 as libc::c_int;
        }
        if lpthread != 0 {
            tcc_add_library(s1, b"pthread\0" as *const u8 as *const libc::c_char);
        }
        tcc_add_library(s1, b"c\0" as *const u8 as *const libc::c_char);
        if (*::core::mem::transmute::<
            &[u8; 10],
            &[libc::c_char; 10],
        >(b"libtcc1.a\0"))[0 as libc::c_int as usize] != 0
        {
            tcc_add_support(s1, b"libtcc1.a\0" as *const u8 as *const libc::c_char);
        }
        if (*s1).output_type != 1 as libc::c_int {
            tccelf_add_crtend(s1);
        }
    }
}
unsafe extern "C" fn tcc_add_linker_symbols(mut s1: *mut TCCState) {
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut i: libc::c_int = 0;
    let mut s: *mut Section = 0 as *mut Section;
    set_global_sym(
        s1,
        b"_etext\0" as *const u8 as *const libc::c_char,
        (*s1).text_section,
        -(1 as libc::c_int) as Elf64_Addr,
    );
    set_global_sym(
        s1,
        b"_edata\0" as *const u8 as *const libc::c_char,
        (*s1).data_section,
        -(1 as libc::c_int) as Elf64_Addr,
    );
    set_global_sym(
        s1,
        b"_end\0" as *const u8 as *const libc::c_char,
        (*s1).bss_section,
        -(1 as libc::c_int) as Elf64_Addr,
    );
    add_init_array_defines(s1, b".preinit_array\0" as *const u8 as *const libc::c_char);
    add_init_array_defines(s1, b".init_array\0" as *const u8 as *const libc::c_char);
    add_init_array_defines(s1, b".fini_array\0" as *const u8 as *const libc::c_char);
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        let mut current_block_17: u64;
        s = *((*s1).sections).offset(i as isize);
        if (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0
            && ((*s).sh_type == 1 as libc::c_int || (*s).sh_type == 8 as libc::c_int
                || (*s).sh_type == 3 as libc::c_int)
        {
            let mut p0: *const libc::c_char = 0 as *const libc::c_char;
            let mut p: *const libc::c_char = 0 as *const libc::c_char;
            p0 = ((*s).name).as_mut_ptr();
            if *p0 as libc::c_int == '.' as i32 {
                p0 = p0.offset(1);
                p0;
            }
            p = p0;
            loop {
                let mut c: libc::c_int = *p as libc::c_int;
                if c == 0 {
                    current_block_17 = 13056961889198038528;
                    break;
                }
                if isid(c) == 0 && isnum(c) == 0 {
                    current_block_17 = 4808432441040389987;
                    break;
                }
                p = p.offset(1);
                p;
            }
            match current_block_17 {
                4808432441040389987 => {}
                _ => {
                    snprintf(
                        buf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                        b"__start_%s\0" as *const u8 as *const libc::c_char,
                        p0,
                    );
                    set_global_sym(
                        s1,
                        buf.as_mut_ptr(),
                        s,
                        0 as libc::c_int as Elf64_Addr,
                    );
                    snprintf(
                        buf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                        b"__stop_%s\0" as *const u8 as *const libc::c_char,
                        p0,
                    );
                    set_global_sym(
                        s1,
                        buf.as_mut_ptr(),
                        s,
                        -(1 as libc::c_int) as Elf64_Addr,
                    );
                }
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn resolve_common_syms(mut s1: *mut TCCState) {
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    sym = ((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
        .offset(1 as libc::c_int as isize);
    while sym
        < ((*(*s1).c2rust_unnamed.symtab_section).data)
            .offset((*(*s1).c2rust_unnamed.symtab_section).data_offset as isize)
            as *mut Elf64_Sym
    {
        if (*sym).st_shndx as libc::c_int == 0xfff2 as libc::c_int {
            (*sym)
                .st_value = section_add(
                (*s1).bss_section,
                (*sym).st_size,
                (*sym).st_value as libc::c_int,
            );
            (*sym).st_shndx = (*(*s1).bss_section).sh_num as Elf64_Section;
        }
        sym = sym.offset(1);
        sym;
    }
    tcc_add_linker_symbols(s1);
}
unsafe extern "C" fn fill_got_entry(mut s1: *mut TCCState, mut rel: *mut Elf64_Rela) {
    let mut sym_index: libc::c_int = ((*rel).r_info >> 32 as libc::c_int) as libc::c_int;
    let mut sym: *mut Elf64_Sym = &mut *((*(*s1).c2rust_unnamed.symtab_section).data
        as *mut Elf64_Sym)
        .offset(sym_index as isize) as *mut Elf64_Sym;
    let mut attr: *mut sym_attr = get_sym_attr(s1, sym_index, 0 as libc::c_int);
    let mut offset: libc::c_uint = (*attr).got_offset;
    if 0 as libc::c_int as libc::c_uint == offset {
        return;
    }
    section_reserve(
        (*s1).got,
        offset.wrapping_add(8 as libc::c_int as libc::c_uint) as libc::c_ulong,
    );
    write64le(((*(*s1).got).data).offset(offset as isize), (*sym).st_value);
}
unsafe extern "C" fn fill_got(mut s1: *mut TCCState) {
    let mut s: *mut Section = 0 as *mut Section;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if !((*s).sh_type != 4 as libc::c_int) {
            if !((*s).link != (*s1).c2rust_unnamed.symtab_section) {
                rel = ((*s).data as *mut Elf64_Rela).offset(0 as libc::c_int as isize);
                while rel
                    < ((*s).data).offset((*s).data_offset as isize) as *mut Elf64_Rela
                {
                    match (*rel).r_info & 0xffffffff as libc::c_uint as Elf64_Xword {
                        3 | 9 | 41 | 42 | 4 => {
                            fill_got_entry(s1, rel);
                        }
                        _ => {}
                    }
                    rel = rel.offset(1);
                    rel;
                }
            }
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn fill_local_got_entries(mut s1: *mut TCCState) {
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    if ((*(*s1).got).reloc).is_null() {
        return;
    }
    rel = ((*(*(*s1).got).reloc).data as *mut Elf64_Rela)
        .offset(0 as libc::c_int as isize);
    while rel
        < ((*(*(*s1).got).reloc).data).offset((*(*(*s1).got).reloc).data_offset as isize)
            as *mut Elf64_Rela
    {
        if (*rel).r_info & 0xffffffff as libc::c_uint as Elf64_Xword
            == 8 as libc::c_int as Elf64_Xword
        {
            let mut sym_index: libc::c_int = ((*rel).r_info >> 32 as libc::c_int)
                as libc::c_int;
            let mut sym: *mut Elf64_Sym = &mut *((*(*s1).c2rust_unnamed.symtab_section)
                .data as *mut Elf64_Sym)
                .offset(sym_index as isize) as *mut Elf64_Sym;
            let mut attr: *mut sym_attr = get_sym_attr(s1, sym_index, 0 as libc::c_int);
            let mut offset: libc::c_uint = (*attr).got_offset;
            if offset as Elf64_Addr
                != ((*rel).r_offset).wrapping_sub((*(*s1).got).sh_addr)
            {
                tcc_enter_state(s1);
                (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"fill_local_got_entries: huh?\0" as *const u8 as *const libc::c_char,
                );
            }
            (*rel)
                .r_info = ((0 as libc::c_int as Elf64_Xword) << 32 as libc::c_int)
                .wrapping_add(8 as libc::c_int as Elf64_Xword);
            (*rel).r_addend = (*sym).st_value as Elf64_Sxword;
        }
        rel = rel.offset(1);
        rel;
    }
}
unsafe extern "C" fn bind_exe_dynsyms(mut s1: *mut TCCState, mut is_PIE: libc::c_int) {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym_index: libc::c_int = 0;
    let mut index: libc::c_int = 0;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut type_0: libc::c_int = 0;
    sym = ((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
        .offset(1 as libc::c_int as isize);
    while sym
        < ((*(*s1).c2rust_unnamed.symtab_section).data)
            .offset((*(*s1).c2rust_unnamed.symtab_section).data_offset as isize)
            as *mut Elf64_Sym
    {
        if (*sym).st_shndx as libc::c_int == 0 as libc::c_int {
            name = ((*(*(*s1).c2rust_unnamed.symtab_section).link).data
                as *mut libc::c_char)
                .offset((*sym).st_name as isize);
            sym_index = find_elf_sym((*s1).dynsymtab_section, name);
            if sym_index != 0 {
                if !(is_PIE != 0) {
                    esym = &mut *((*(*s1).dynsymtab_section).data as *mut Elf64_Sym)
                        .offset(sym_index as isize) as *mut Elf64_Sym;
                    type_0 = (*esym).st_info as libc::c_int & 0xf as libc::c_int;
                    if type_0 == 2 as libc::c_int || type_0 == 10 as libc::c_int {
                        let mut dynindex: libc::c_int = put_elf_sym(
                            (*s1).dynsym,
                            0 as libc::c_int as Elf64_Addr,
                            (*esym).st_size,
                            ((1 as libc::c_int) << 4 as libc::c_int)
                                + (2 as libc::c_int & 0xf as libc::c_int),
                            0 as libc::c_int,
                            0 as libc::c_int,
                            name,
                        );
                        let mut index_0: libc::c_int = sym
                            .offset_from(
                                (*(*s1).c2rust_unnamed.symtab_section).data
                                    as *mut Elf64_Sym,
                            ) as libc::c_long as libc::c_int;
                        (*get_sym_attr(s1, index_0, 1 as libc::c_int))
                            .dyn_index = dynindex;
                    } else if type_0 == 1 as libc::c_int {
                        let mut offset: libc::c_ulong = 0;
                        let mut dynsym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
                        offset = (*(*s1).bss_section).data_offset;
                        offset = offset
                            .wrapping_add(16 as libc::c_int as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                            & -(16 as libc::c_int) as libc::c_ulong;
                        set_elf_sym(
                            (*s1).c2rust_unnamed.symtab,
                            offset,
                            (*esym).st_size,
                            (*esym).st_info as libc::c_int,
                            0 as libc::c_int,
                            (*(*s1).bss_section).sh_num,
                            name,
                        );
                        index = put_elf_sym(
                            (*s1).dynsym,
                            offset,
                            (*esym).st_size,
                            (*esym).st_info as libc::c_int,
                            0 as libc::c_int,
                            (*(*s1).bss_section).sh_num,
                            name,
                        );
                        if (*esym).st_info as libc::c_int >> 4 as libc::c_int
                            == 2 as libc::c_int
                        {
                            dynsym = ((*(*s1).dynsymtab_section).data as *mut Elf64_Sym)
                                .offset(1 as libc::c_int as isize);
                            while dynsym
                                < ((*(*s1).dynsymtab_section).data)
                                    .offset((*(*s1).dynsymtab_section).data_offset as isize)
                                    as *mut Elf64_Sym
                            {
                                if (*dynsym).st_value == (*esym).st_value
                                    && (*dynsym).st_info as libc::c_int >> 4 as libc::c_int
                                        == 1 as libc::c_int
                                {
                                    let mut dynname: *mut libc::c_char = ((*(*(*s1)
                                        .dynsymtab_section)
                                        .link)
                                        .data as *mut libc::c_char)
                                        .offset((*dynsym).st_name as isize);
                                    put_elf_sym(
                                        (*s1).dynsym,
                                        offset,
                                        (*dynsym).st_size,
                                        (*dynsym).st_info as libc::c_int,
                                        0 as libc::c_int,
                                        (*(*s1).bss_section).sh_num,
                                        dynname,
                                    );
                                    break;
                                } else {
                                    dynsym = dynsym.offset(1);
                                    dynsym;
                                }
                            }
                        }
                        put_elf_reloc(
                            (*s1).dynsym,
                            (*s1).bss_section,
                            offset,
                            5 as libc::c_int,
                            index,
                        );
                        offset = offset.wrapping_add((*esym).st_size);
                        (*(*s1).bss_section).data_offset = offset;
                    }
                }
            } else if !((*sym).st_info as libc::c_int >> 4 as libc::c_int
                == 2 as libc::c_int
                || strcmp(name, b"_fp_hw\0" as *const u8 as *const libc::c_char) == 0)
            {
                tcc_enter_state(s1);
                (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"undefined symbol '%s'\0" as *const u8 as *const libc::c_char,
                    name,
                );
            }
        }
        sym = sym.offset(1);
        sym;
    }
}
unsafe extern "C" fn bind_libs_dynsyms(mut s1: *mut TCCState) {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut dynsym_index: libc::c_int = 0;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    sym = ((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
        .offset(1 as libc::c_int as isize);
    while sym
        < ((*(*s1).c2rust_unnamed.symtab_section).data)
            .offset((*(*s1).c2rust_unnamed.symtab_section).data_offset as isize)
            as *mut Elf64_Sym
    {
        name = ((*(*(*s1).c2rust_unnamed.symtab_section).link).data as *mut libc::c_char)
            .offset((*sym).st_name as isize);
        dynsym_index = find_elf_sym((*s1).dynsymtab_section, name);
        if (*sym).st_shndx as libc::c_int != 0 as libc::c_int {
            if (*sym).st_info as libc::c_int >> 4 as libc::c_int != 0 as libc::c_int
                && (dynsym_index != 0 || (*s1).rdynamic as libc::c_int != 0)
            {
                set_elf_sym(
                    (*s1).dynsym,
                    (*sym).st_value,
                    (*sym).st_size,
                    (*sym).st_info as libc::c_int,
                    0 as libc::c_int,
                    (*sym).st_shndx as libc::c_int,
                    name,
                );
            }
        } else if dynsym_index != 0 {
            esym = ((*(*s1).dynsymtab_section).data as *mut Elf64_Sym)
                .offset(dynsym_index as isize);
            if (*esym).st_shndx as libc::c_int == 0 as libc::c_int {
                if (*esym).st_info as libc::c_int >> 4 as libc::c_int != 2 as libc::c_int
                {
                    tcc_enter_state(s1);
                    (Some(
                        _tcc_warning
                            as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        b"undefined dynamic symbol '%s'\0" as *const u8
                            as *const libc::c_char,
                        name,
                    );
                }
            }
        }
        sym = sym.offset(1);
        sym;
    }
}
unsafe extern "C" fn export_global_syms(mut s1: *mut TCCState) {
    let mut dynindex: libc::c_int = 0;
    let mut index: libc::c_int = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    sym = ((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
        .offset(1 as libc::c_int as isize);
    while sym
        < ((*(*s1).c2rust_unnamed.symtab_section).data)
            .offset((*(*s1).c2rust_unnamed.symtab_section).data_offset as isize)
            as *mut Elf64_Sym
    {
        if (*sym).st_info as libc::c_int >> 4 as libc::c_int != 0 as libc::c_int {
            name = ((*(*(*s1).c2rust_unnamed.symtab_section).link).data
                as *mut libc::c_char)
                .offset((*sym).st_name as isize);
            dynindex = set_elf_sym(
                (*s1).dynsym,
                (*sym).st_value,
                (*sym).st_size,
                (*sym).st_info as libc::c_int,
                0 as libc::c_int,
                (*sym).st_shndx as libc::c_int,
                name,
            );
            index = sym
                .offset_from(
                    (*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym,
                ) as libc::c_long as libc::c_int;
            (*get_sym_attr(s1, index, 1 as libc::c_int)).dyn_index = dynindex;
        }
        sym = sym.offset(1);
        sym;
    }
}
unsafe extern "C" fn set_sec_sizes(mut s1: *mut TCCState) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut s: *mut Section = 0 as *mut Section;
    let mut textrel: libc::c_int = 0 as libc::c_int;
    let mut file_type: libc::c_int = (*s1).output_type;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if (*s).sh_type == 4 as libc::c_int
            && (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int == 0
        {
            if file_type & 4 as libc::c_int != 0
                && (**((*s1).sections).offset((*s).sh_info as isize)).sh_flags
                    & (1 as libc::c_int) << 1 as libc::c_int != 0
            {
                let mut count: libc::c_int = prepare_dynamic_rel(s1, s);
                if count != 0 {
                    (*s).sh_flags |= (1 as libc::c_int) << 1 as libc::c_int;
                    (*s)
                        .sh_size = (count as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong,
                        );
                    if (**((*s1).sections).offset((*s).sh_info as isize)).sh_flags
                        & (1 as libc::c_int) << 2 as libc::c_int != 0
                    {
                        textrel += count;
                    }
                }
            }
        } else if (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0
            || (*s1).do_debug as libc::c_int != 0
        {
            (*s).sh_size = (*s).data_offset;
        }
        i += 1;
        i;
    }
    return textrel;
}
unsafe extern "C" fn sort_sections(
    mut s1: *mut TCCState,
    mut sec_order: *mut libc::c_int,
    mut d: *mut dyn_inf,
) -> libc::c_int {
    let mut s: *mut Section = 0 as *mut Section;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut f: libc::c_int = 0;
    let mut f0: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut nb_sections: libc::c_int = (*s1).nb_sections;
    let mut sec_cls: *mut libc::c_int = sec_order.offset(nb_sections as isize);
    i = 1 as libc::c_int;
    while i < nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if 0 as libc::c_int == (*s).sh_name {
            j = 0x900 as libc::c_int;
        } else if (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0 {
            j = 0x100 as libc::c_int;
            if (*s).sh_flags & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                j = 0x200 as libc::c_int;
            }
            if (*s).sh_flags & (1 as libc::c_int) << 10 as libc::c_int != 0 {
                j += 0x200 as libc::c_int;
            }
        } else {
            j = 0x700 as libc::c_int;
        }
        if j >= 0x700 as libc::c_int && (*s1).output_format != 0 as libc::c_int {
            (*s).sh_size = 0 as libc::c_int as libc::c_ulong;
            j = 0x900 as libc::c_int;
        }
        if (*s).sh_type == 2 as libc::c_int || (*s).sh_type == 11 as libc::c_int {
            k = 0x10 as libc::c_int;
        } else if (*s).sh_type == 3 as libc::c_int
            && strcmp(
                ((*s).name).as_mut_ptr(),
                b".stabstr\0" as *const u8 as *const libc::c_char,
            ) != 0
        {
            k = 0x11 as libc::c_int;
            if i == nb_sections - 1 as libc::c_int {
                k = 0xff as libc::c_int;
            }
        } else if (*s).sh_type == 5 as libc::c_int
            || (*s).sh_type == 0x6ffffff6 as libc::c_int
        {
            k = 0x12 as libc::c_int;
        } else if (*s).sh_type == 0x6ffffffd as libc::c_int
            || (*s).sh_type == 0x6ffffffe as libc::c_int
            || (*s).sh_type == 0x6fffffff as libc::c_int
        {
            k = 0x13 as libc::c_int;
        } else if (*s).sh_type == 4 as libc::c_int {
            k = 0x20 as libc::c_int;
            if !((*s1).plt).is_null() && s == (*(*s1).plt).reloc {
                k = 0x21 as libc::c_int;
            }
        } else if (*s).sh_flags & (1 as libc::c_int) << 2 as libc::c_int != 0 {
            k = 0x30 as libc::c_int;
        } else if (*s).sh_type == 16 as libc::c_int {
            k = 0x41 as libc::c_int;
        } else if (*s).sh_type == 14 as libc::c_int {
            k = 0x42 as libc::c_int;
        } else if (*s).sh_type == 15 as libc::c_int {
            k = 0x43 as libc::c_int;
        } else if (*s).sh_type == 6 as libc::c_int {
            k = 0x46 as libc::c_int;
        } else if s == (*s1).got {
            k = 0x47 as libc::c_int;
        } else if !((*s).reloc).is_null()
            && (*(*s).reloc).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0
            && j == 0x100 as libc::c_int
        {
            k = 0x44 as libc::c_int;
        } else if (*s).sh_type == 7 as libc::c_int {
            k = 0x60 as libc::c_int;
        } else if (*s).sh_type == 8 as libc::c_int {
            k = 0x70 as libc::c_int;
        } else if s == (*d).interp {
            k = 0 as libc::c_int;
        } else {
            k = 0x50 as libc::c_int;
        }
        k += j;
        if k & 0xfff0 as libc::c_int == 0x140 as libc::c_int {
            k += 0x100 as libc::c_int;
            (*s).sh_flags |= (1 as libc::c_int) << 0 as libc::c_int;
        }
        n = i;
        while n > 1 as libc::c_int
            && {
                f = *sec_cls.offset((n - 1 as libc::c_int) as isize);
                k < f
            }
        {
            *sec_cls.offset(n as isize) = f;
            *sec_order
                .offset(n as isize) = *sec_order.offset((n - 1 as libc::c_int) as isize);
            n -= 1;
            n;
        }
        *sec_cls.offset(n as isize) = k;
        *sec_order.offset(n as isize) = i;
        i += 1;
        i;
    }
    *sec_order.offset(0 as libc::c_int as isize) = 0 as libc::c_int;
    (*d).shnum = 1 as libc::c_int;
    f0 = 0 as libc::c_int;
    n = f0;
    i = 1 as libc::c_int;
    while i < nb_sections {
        s = *((*s1).sections).offset(*sec_order.offset(i as isize) as isize);
        k = *sec_cls.offset(i as isize);
        f = 0 as libc::c_int;
        if k < 0x900 as libc::c_int {
            (*d).shnum += 1;
            (*d).shnum;
        }
        if k < 0x700 as libc::c_int {
            f = (*s).sh_flags
                & ((1 as libc::c_int) << 1 as libc::c_int
                    | (1 as libc::c_int) << 0 as libc::c_int
                    | (1 as libc::c_int) << 2 as libc::c_int
                    | (1 as libc::c_int) << 10 as libc::c_int);
            if k & 0xfff0 as libc::c_int == 0x240 as libc::c_int {
                f |= (1 as libc::c_int) << 4 as libc::c_int;
            }
            if f != f0 && (*s).sh_size != 0 {
                f0 = f;
                n += 1;
                n;
                f |= (1 as libc::c_int) << 8 as libc::c_int;
            }
        }
        *sec_cls.offset(i as isize) = f;
        i += 1;
        i;
    }
    return n;
}
unsafe extern "C" fn fill_phdr(
    mut ph: *mut Elf64_Phdr,
    mut type_0: libc::c_int,
    mut s: *mut Section,
) -> *mut Elf64_Phdr {
    if !s.is_null() {
        (*ph).p_offset = (*s).sh_offset;
        (*ph).p_vaddr = (*s).sh_addr;
        (*ph).p_filesz = (*s).sh_size;
        (*ph).p_align = (*s).sh_addralign as Elf64_Xword;
    }
    (*ph).p_type = type_0 as Elf64_Word;
    (*ph).p_flags = ((1 as libc::c_int) << 2 as libc::c_int) as Elf64_Word;
    (*ph).p_paddr = (*ph).p_vaddr;
    (*ph).p_memsz = (*ph).p_filesz;
    return ph;
}
unsafe extern "C" fn layout_sections(
    mut s1: *mut TCCState,
    mut sec_order: *mut libc::c_int,
    mut d: *mut dyn_inf,
) -> libc::c_int {
    let mut s: *mut Section = 0 as *mut Section;
    let mut addr: Elf64_Addr = 0;
    let mut tmp: Elf64_Addr = 0;
    let mut align: Elf64_Addr = 0;
    let mut s_align: Elf64_Addr = 0;
    let mut base: Elf64_Addr = 0;
    let mut ph: *mut Elf64_Phdr = 0 as *mut Elf64_Phdr;
    let mut i: libc::c_int = 0;
    let mut f: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut phnum: libc::c_int = 0;
    let mut phfill: libc::c_int = 0;
    let mut file_offset: libc::c_int = 0;
    phnum = sort_sections(s1, sec_order, d);
    phfill = 0 as libc::c_int;
    if !((*d).interp).is_null() {
        phfill = 2 as libc::c_int;
    }
    phnum += phfill;
    if !((*d).note).is_null() {
        phnum += 1;
        phnum;
    }
    if !((*d).dynamic).is_null() {
        phnum += 1;
        phnum;
    }
    if !((*s1).eh_frame_hdr_section).is_null() {
        phnum += 1;
        phnum;
    }
    if !((*d).roinf).is_null() {
        phnum += 1;
        phnum;
    }
    (*d).phnum = phnum;
    (*d)
        .phdr = tcc_mallocz(
        (phnum as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Phdr>() as libc::c_ulong),
    ) as *mut Elf64_Phdr;
    file_offset = 0 as libc::c_int;
    if (*s1).output_format == 0 as libc::c_int {
        file_offset = ((::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong)
            .wrapping_add(
                (phnum as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<Elf64_Phdr>() as libc::c_ulong),
            )
            .wrapping_add(3 as libc::c_int as libc::c_ulong)
            & -(4 as libc::c_int) as libc::c_ulong) as libc::c_int;
        file_offset = (file_offset as libc::c_ulong)
            .wrapping_add(
                ((*d).shnum as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
    }
    s_align = 0x200000 as libc::c_int as Elf64_Addr;
    if (*s1).section_align != 0 {
        s_align = (*s1).section_align as Elf64_Addr;
    }
    addr = 0x400000 as libc::c_int as Elf64_Addr;
    if (*s1).output_type & 4 as libc::c_int != 0 {
        addr = 0 as libc::c_int as Elf64_Addr;
    }
    if (*s1).has_text_addr != 0 {
        addr = (*s1).text_addr;
    }
    base = addr;
    addr = addr.wrapping_add(file_offset as Elf64_Addr);
    n = 0 as libc::c_int;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(*sec_order.offset(i as isize) as isize);
        f = *sec_order.offset((i + (*s1).nb_sections) as isize);
        align = ((*s).sh_addralign - 1 as libc::c_int) as Elf64_Addr;
        if f == 0 as libc::c_int {
            file_offset = ((file_offset as Elf64_Addr).wrapping_add(align) & !align)
                as libc::c_int;
            (*s).sh_offset = file_offset as libc::c_ulong;
            if (*s).sh_type != 8 as libc::c_int {
                file_offset = (file_offset as libc::c_ulong).wrapping_add((*s).sh_size)
                    as libc::c_int as libc::c_int;
            }
        } else {
            if f & (1 as libc::c_int) << 8 as libc::c_int != 0 && n != 0 {
                if (*s1).output_format == 0 as libc::c_int {
                    if addr & s_align.wrapping_sub(1 as libc::c_int as Elf64_Addr)
                        != 0 as libc::c_int as Elf64_Addr
                    {
                        addr = addr.wrapping_add(s_align);
                    }
                } else {
                    align = s_align.wrapping_sub(1 as libc::c_int as Elf64_Addr);
                }
            }
            tmp = addr;
            addr = addr.wrapping_add(align) & !align;
            file_offset += addr.wrapping_sub(tmp) as libc::c_int;
            (*s).sh_offset = file_offset as libc::c_ulong;
            (*s).sh_addr = addr;
            if f & (1 as libc::c_int) << 8 as libc::c_int != 0 {
                ph = &mut *((*d).phdr).offset((phfill + n) as isize) as *mut Elf64_Phdr;
                (*ph).p_type = 1 as libc::c_int as Elf64_Word;
                (*ph).p_align = s_align;
                (*ph).p_flags = ((1 as libc::c_int) << 2 as libc::c_int) as Elf64_Word;
                if f & (1 as libc::c_int) << 0 as libc::c_int != 0 {
                    (*ph).p_flags
                        |= ((1 as libc::c_int) << 1 as libc::c_int) as Elf64_Word;
                }
                if f & (1 as libc::c_int) << 2 as libc::c_int != 0 {
                    (*ph).p_flags
                        |= ((1 as libc::c_int) << 0 as libc::c_int) as Elf64_Word;
                }
                if f & (1 as libc::c_int) << 10 as libc::c_int != 0 {
                    (*ph).p_type = 7 as libc::c_int as Elf64_Word;
                    (*ph).p_align = align.wrapping_add(1 as libc::c_int as Elf64_Addr);
                }
                (*ph).p_offset = file_offset as Elf64_Off;
                (*ph).p_vaddr = addr;
                if n == 0 as libc::c_int {
                    (*ph).p_offset = 0 as libc::c_int as Elf64_Off;
                    (*ph).p_vaddr = base;
                }
                (*ph).p_paddr = (*ph).p_vaddr;
                n += 1;
                n;
            }
            if f & (1 as libc::c_int) << 4 as libc::c_int != 0 {
                let mut roinf: *mut Section = &mut (*d)._roinf;
                if (*roinf).sh_size == 0 as libc::c_int as libc::c_ulong {
                    (*roinf).sh_offset = (*s).sh_offset;
                    (*roinf).sh_addr = (*s).sh_addr;
                    (*roinf).sh_addralign = 1 as libc::c_int;
                }
                (*roinf)
                    .sh_size = addr
                    .wrapping_sub((*roinf).sh_addr)
                    .wrapping_add((*s).sh_size);
            }
            addr = (addr as libc::c_ulong).wrapping_add((*s).sh_size) as Elf64_Addr
                as Elf64_Addr;
            if (*s).sh_type != 8 as libc::c_int {
                file_offset = (file_offset as libc::c_ulong).wrapping_add((*s).sh_size)
                    as libc::c_int as libc::c_int;
            }
            (*ph).p_filesz = (file_offset as Elf64_Off).wrapping_sub((*ph).p_offset);
            (*ph).p_memsz = addr.wrapping_sub((*ph).p_vaddr);
        }
        i += 1;
        i;
    }
    if !((*d).note).is_null() {
        ph = ph.offset(1);
        fill_phdr(ph, 4 as libc::c_int, (*d).note);
    }
    if !((*d).dynamic).is_null() {
        ph = ph.offset(1);
        (*fill_phdr(ph, 2 as libc::c_int, (*d).dynamic)).p_flags
            |= ((1 as libc::c_int) << 1 as libc::c_int) as Elf64_Word;
    }
    if !((*s1).eh_frame_hdr_section).is_null() {
        ph = ph.offset(1);
        fill_phdr(ph, 0x6474e550 as libc::c_int, (*s1).eh_frame_hdr_section);
    }
    if !((*d).roinf).is_null() {
        ph = ph.offset(1);
        (*fill_phdr(ph, 0x6474e552 as libc::c_int, (*d).roinf)).p_flags
            |= ((1 as libc::c_int) << 1 as libc::c_int) as Elf64_Word;
    }
    if !((*d).interp).is_null() {
        fill_phdr(
            &mut *((*d).phdr).offset(1 as libc::c_int as isize),
            3 as libc::c_int,
            (*d).interp,
        );
    }
    if phfill != 0 {
        ph = &mut *((*d).phdr).offset(0 as libc::c_int as isize) as *mut Elf64_Phdr;
        (*ph).p_offset = ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong;
        (*ph).p_vaddr = base.wrapping_add((*ph).p_offset);
        (*ph)
            .p_filesz = (phnum as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Elf64_Phdr>() as libc::c_ulong);
        (*ph).p_align = 4 as libc::c_int as Elf64_Xword;
        fill_phdr(ph, 6 as libc::c_int, 0 as *mut Section);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn put_dt(
    mut dynamic: *mut Section,
    mut dt: libc::c_int,
    mut val: Elf64_Addr,
) {
    let mut dyn_0: *mut Elf64_Dyn = 0 as *mut Elf64_Dyn;
    dyn_0 = section_ptr_add(
        dynamic,
        ::core::mem::size_of::<Elf64_Dyn>() as libc::c_ulong,
    ) as *mut Elf64_Dyn;
    (*dyn_0).d_tag = dt as Elf64_Sxword;
    (*dyn_0).d_un.d_val = val;
}
unsafe extern "C" fn fill_dynamic(mut s1: *mut TCCState, mut dyninf: *mut dyn_inf) {
    let mut dynamic: *mut Section = (*dyninf).dynamic;
    let mut s: *mut Section = 0 as *mut Section;
    put_dt(dynamic, 4 as libc::c_int, (*(*(*s1).dynsym).hash).sh_addr);
    put_dt(dynamic, 0x6ffffef5 as libc::c_int, (*(*dyninf).gnu_hash).sh_addr);
    put_dt(dynamic, 5 as libc::c_int, (*(*dyninf).dynstr).sh_addr);
    put_dt(dynamic, 6 as libc::c_int, (*(*s1).dynsym).sh_addr);
    put_dt(dynamic, 10 as libc::c_int, (*(*dyninf).dynstr).data_offset);
    put_dt(
        dynamic,
        11 as libc::c_int,
        ::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong,
    );
    put_dt(dynamic, 7 as libc::c_int, (*dyninf).c2rust_unnamed.rel_addr);
    put_dt(dynamic, 8 as libc::c_int, (*dyninf).c2rust_unnamed.rel_size);
    put_dt(
        dynamic,
        9 as libc::c_int,
        ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong,
    );
    if !((*s1).plt).is_null() && !((*(*s1).plt).reloc).is_null() {
        put_dt(dynamic, 3 as libc::c_int, (*(*s1).got).sh_addr);
        put_dt(dynamic, 2 as libc::c_int, (*(*(*s1).plt).reloc).data_offset);
        put_dt(dynamic, 23 as libc::c_int, (*(*(*s1).plt).reloc).sh_addr);
        put_dt(dynamic, 20 as libc::c_int, 7 as libc::c_int as Elf64_Addr);
    }
    put_dt(dynamic, 0x6ffffff9 as libc::c_int, 0 as libc::c_int as Elf64_Addr);
    if !((*s1).versym_section).is_null() && !((*s1).verneed_section).is_null() {
        put_dt(dynamic, 0x6ffffff0 as libc::c_int, (*(*s1).versym_section).sh_addr);
        put_dt(dynamic, 0x6ffffffe as libc::c_int, (*(*s1).verneed_section).sh_addr);
        put_dt(dynamic, 0x6fffffff as libc::c_int, (*s1).dt_verneednum as Elf64_Addr);
    }
    s = have_section(s1, b".preinit_array\0" as *const u8 as *const libc::c_char);
    if !s.is_null() && (*s).data_offset != 0 {
        put_dt(dynamic, 32 as libc::c_int, (*s).sh_addr);
        put_dt(dynamic, 33 as libc::c_int, (*s).data_offset);
    }
    s = have_section(s1, b".init_array\0" as *const u8 as *const libc::c_char);
    if !s.is_null() && (*s).data_offset != 0 {
        put_dt(dynamic, 25 as libc::c_int, (*s).sh_addr);
        put_dt(dynamic, 27 as libc::c_int, (*s).data_offset);
    }
    s = have_section(s1, b".fini_array\0" as *const u8 as *const libc::c_char);
    if !s.is_null() && (*s).data_offset != 0 {
        put_dt(dynamic, 26 as libc::c_int, (*s).sh_addr);
        put_dt(dynamic, 28 as libc::c_int, (*s).data_offset);
    }
    s = have_section(s1, b".init\0" as *const u8 as *const libc::c_char);
    if !s.is_null() && (*s).data_offset != 0 {
        put_dt(dynamic, 12 as libc::c_int, (*s).sh_addr);
    }
    s = have_section(s1, b".fini\0" as *const u8 as *const libc::c_char);
    if !s.is_null() && (*s).data_offset != 0 {
        put_dt(dynamic, 13 as libc::c_int, (*s).sh_addr);
    }
    if (*s1).do_debug != 0 {
        put_dt(dynamic, 21 as libc::c_int, 0 as libc::c_int as Elf64_Addr);
    }
    put_dt(dynamic, 0 as libc::c_int, 0 as libc::c_int as Elf64_Addr);
}
unsafe extern "C" fn update_reloc_sections(
    mut s1: *mut TCCState,
    mut dyninf: *mut dyn_inf,
) {
    let mut i: libc::c_int = 0;
    let mut file_offset: libc::c_ulong = 0 as libc::c_int as libc::c_ulong;
    let mut s: *mut Section = 0 as *mut Section;
    let mut relocplt: *mut Section = if !((*s1).plt).is_null() {
        (*(*s1).plt).reloc
    } else {
        0 as *mut Section
    };
    (*dyninf).c2rust_unnamed.rel_size = 0 as libc::c_int as Elf64_Addr;
    (*dyninf).c2rust_unnamed.rel_addr = (*dyninf).c2rust_unnamed.rel_size;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if (*s).sh_type == 4 as libc::c_int && s != relocplt {
            if (*dyninf).c2rust_unnamed.rel_size == 0 as libc::c_int as Elf64_Addr {
                (*dyninf).c2rust_unnamed.rel_addr = (*s).sh_addr;
                file_offset = (*s).sh_offset;
            } else {
                (*s)
                    .sh_addr = ((*dyninf).c2rust_unnamed.rel_addr)
                    .wrapping_add((*dyninf).c2rust_unnamed.rel_size);
                (*s)
                    .sh_offset = file_offset
                    .wrapping_add((*dyninf).c2rust_unnamed.rel_size);
            }
            (*dyninf)
                .c2rust_unnamed
                .rel_size = ((*dyninf).c2rust_unnamed.rel_size as libc::c_ulong)
                .wrapping_add((*s).sh_size) as Elf64_Addr as Elf64_Addr;
        }
        i += 1;
        i;
    }
}
unsafe extern "C" fn tcc_output_elf(
    mut s1: *mut TCCState,
    mut f: *mut FILE,
    mut phnum: libc::c_int,
    mut phdr: *mut Elf64_Phdr,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut shnum: libc::c_int = 0;
    let mut offset: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut file_type: libc::c_int = 0;
    let mut s: *mut Section = 0 as *mut Section;
    let mut ehdr: Elf64_Ehdr = Elf64_Ehdr {
        e_ident: [0; 16],
        e_type: 0,
        e_machine: 0,
        e_version: 0,
        e_entry: 0,
        e_phoff: 0,
        e_shoff: 0,
        e_flags: 0,
        e_ehsize: 0,
        e_phentsize: 0,
        e_phnum: 0,
        e_shentsize: 0,
        e_shnum: 0,
        e_shstrndx: 0,
    };
    let mut shdr: Elf64_Shdr = Elf64_Shdr {
        sh_name: 0,
        sh_type: 0,
        sh_flags: 0,
        sh_addr: 0,
        sh_offset: 0,
        sh_size: 0,
        sh_link: 0,
        sh_info: 0,
        sh_addralign: 0,
        sh_entsize: 0,
    };
    let mut sh: *mut Elf64_Shdr = 0 as *mut Elf64_Shdr;
    file_type = (*s1).output_type;
    shnum = (*s1).nb_sections;
    memset(
        &mut ehdr as *mut Elf64_Ehdr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong,
    );
    if phnum > 0 as libc::c_int {
        ehdr
            .e_phentsize = ::core::mem::size_of::<Elf64_Phdr>() as libc::c_ulong
            as Elf64_Half;
        ehdr.e_phnum = phnum as Elf64_Half;
        ehdr.e_phoff = ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong;
    }
    ehdr.e_ident[0 as libc::c_int as usize] = 0x7f as libc::c_int as libc::c_uchar;
    ehdr.e_ident[1 as libc::c_int as usize] = 'E' as i32 as libc::c_uchar;
    ehdr.e_ident[2 as libc::c_int as usize] = 'L' as i32 as libc::c_uchar;
    ehdr.e_ident[3 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
    ehdr.e_ident[4 as libc::c_int as usize] = 2 as libc::c_int as libc::c_uchar;
    ehdr.e_ident[5 as libc::c_int as usize] = 1 as libc::c_int as libc::c_uchar;
    ehdr.e_ident[6 as libc::c_int as usize] = 1 as libc::c_int as libc::c_uchar;
    if file_type == 3 as libc::c_int {
        ehdr.e_type = 1 as libc::c_int as Elf64_Half;
    } else {
        if file_type & 4 as libc::c_int != 0 {
            ehdr.e_type = 3 as libc::c_int as Elf64_Half;
        } else {
            ehdr.e_type = 2 as libc::c_int as Elf64_Half;
        }
        if !((*s1).elf_entryname).is_null() {
            ehdr
                .e_entry = get_sym_addr(
                s1,
                (*s1).elf_entryname,
                1 as libc::c_int,
                0 as libc::c_int,
            );
        } else {
            ehdr
                .e_entry = get_sym_addr(
                s1,
                b"_start\0" as *const u8 as *const libc::c_char,
                (file_type & 2 as libc::c_int != 0) as libc::c_int,
                0 as libc::c_int,
            );
        }
        if ehdr.e_entry == -(1 as libc::c_int) as Elf64_Addr {
            ehdr.e_entry = (*(*s1).text_section).sh_addr;
        }
        if (*s1).nb_errors != 0 {
            return -(1 as libc::c_int);
        }
    }
    sort_syms(s1, (*s1).c2rust_unnamed.symtab);
    ehdr.e_machine = 62 as libc::c_int as Elf64_Half;
    ehdr.e_version = 1 as libc::c_int as Elf64_Word;
    ehdr
        .e_shoff = (::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong)
        .wrapping_add(
            (phnum as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Elf64_Phdr>() as libc::c_ulong),
        )
        .wrapping_add(3 as libc::c_int as libc::c_ulong)
        & -(4 as libc::c_int) as libc::c_ulong;
    ehdr.e_ehsize = ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong as Elf64_Half;
    ehdr
        .e_shentsize = ::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong
        as Elf64_Half;
    ehdr.e_shnum = shnum as Elf64_Half;
    ehdr.e_shstrndx = (shnum - 1 as libc::c_int) as Elf64_Half;
    offset = fwrite(
        &mut ehdr as *mut Elf64_Ehdr as *const libc::c_void,
        1 as libc::c_int as libc::c_ulong,
        ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong,
        f,
    ) as libc::c_int;
    if !phdr.is_null() {
        offset = (offset as libc::c_ulong)
            .wrapping_add(
                fwrite(
                    phdr as *const libc::c_void,
                    1 as libc::c_int as libc::c_ulong,
                    (phnum as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<Elf64_Phdr>() as libc::c_ulong,
                        ),
                    f,
                ),
            ) as libc::c_int as libc::c_int;
    }
    while (offset as Elf64_Off) < ehdr.e_shoff {
        fputc(0 as libc::c_int, f);
        offset += 1;
        offset;
    }
    i = 0 as libc::c_int;
    while i < shnum {
        sh = &mut shdr;
        memset(
            sh as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong,
        );
        if i != 0 {
            s = *((*s1).sections).offset(i as isize);
            (*sh).sh_name = (*s).sh_name as Elf64_Word;
            (*sh).sh_type = (*s).sh_type as Elf64_Word;
            (*sh).sh_flags = (*s).sh_flags as Elf64_Xword;
            (*sh).sh_entsize = (*s).sh_entsize as Elf64_Xword;
            (*sh).sh_info = (*s).sh_info as Elf64_Word;
            if !((*s).link).is_null() {
                (*sh).sh_link = (*(*s).link).sh_num as Elf64_Word;
            }
            (*sh).sh_addralign = (*s).sh_addralign as Elf64_Xword;
            (*sh).sh_addr = (*s).sh_addr;
            (*sh).sh_offset = (*s).sh_offset;
            (*sh).sh_size = (*s).sh_size;
        }
        offset = (offset as libc::c_ulong)
            .wrapping_add(
                fwrite(
                    sh as *const libc::c_void,
                    1 as libc::c_int as libc::c_ulong,
                    ::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong,
                    f,
                ),
            ) as libc::c_int as libc::c_int;
        i += 1;
        i;
    }
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if (*s).sh_type != 8 as libc::c_int {
            while (offset as libc::c_ulong) < (*s).sh_offset {
                fputc(0 as libc::c_int, f);
                offset += 1;
                offset;
            }
            size = (*s).sh_size as libc::c_int;
            if size != 0 {
                offset = (offset as libc::c_ulong)
                    .wrapping_add(
                        fwrite(
                            (*s).data as *const libc::c_void,
                            1 as libc::c_int as libc::c_ulong,
                            size as libc::c_ulong,
                            f,
                        ),
                    ) as libc::c_int as libc::c_int;
            }
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcc_output_binary(
    mut s1: *mut TCCState,
    mut f: *mut FILE,
) -> libc::c_int {
    let mut s: *mut Section = 0 as *mut Section;
    let mut i: libc::c_int = 0;
    let mut offset: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    offset = 0 as libc::c_int;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if (*s).sh_type != 8 as libc::c_int
            && (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0
        {
            while (offset as libc::c_ulong) < (*s).sh_offset {
                fputc(0 as libc::c_int, f);
                offset += 1;
                offset;
            }
            size = (*s).sh_size as libc::c_int;
            fwrite(
                (*s).data as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                size as libc::c_ulong,
                f,
            );
            offset += size;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcc_write_elf_file(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
    mut phnum: libc::c_int,
    mut phdr: *mut Elf64_Phdr,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    let mut mode: libc::c_int = 0;
    let mut file_type: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut f: *mut FILE = 0 as *mut FILE;
    file_type = (*s1).output_type;
    if file_type == 3 as libc::c_int {
        mode = 0o666 as libc::c_int;
    } else {
        mode = 0o777 as libc::c_int;
    }
    unlink(filename);
    fd = open(
        filename,
        0o1 as libc::c_int | 0o100 as libc::c_int | 0o1000 as libc::c_int
            | 0 as libc::c_int,
        mode,
    );
    if fd < 0 as libc::c_int
        || {
            f = fdopen(fd, b"wb\0" as *const u8 as *const libc::c_char);
            f.is_null()
        }
    {
        tcc_enter_state(s1);
        return (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(
            b"could not write '%s: %s'\0" as *const u8 as *const libc::c_char,
            filename,
            strerror(*__errno_location()),
        );
    }
    if (*s1).verbose != 0 {
        printf(b"<- %s\n\0" as *const u8 as *const libc::c_char, filename);
    }
    if (*s1).output_format == 0 as libc::c_int {
        ret = tcc_output_elf(s1, f, phnum, phdr);
    } else {
        ret = tcc_output_binary(s1, f);
    }
    fclose(f);
    return ret;
}
unsafe extern "C" fn reorder_sections(
    mut s1: *mut TCCState,
    mut sec_order: *mut libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut nnew: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut backmap: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut snew: *mut *mut Section = 0 as *mut *mut Section;
    let mut s: *mut Section = 0 as *mut Section;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    backmap = tcc_malloc(
        ((*s1).nb_sections as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    ) as *mut libc::c_int;
    i = 0 as libc::c_int;
    nnew = 0 as libc::c_int;
    snew = 0 as *mut *mut Section;
    while i < (*s1).nb_sections {
        k = *sec_order.offset(i as isize);
        s = *((*s1).sections).offset(k as isize);
        if i == 0 || (*s).sh_name != 0 {
            *backmap.offset(k as isize) = nnew;
            dynarray_add(
                &mut snew as *mut *mut *mut Section as *mut libc::c_void,
                &mut nnew,
                s as *mut libc::c_void,
            );
        } else {
            *backmap.offset(k as isize) = 0 as libc::c_int;
            dynarray_add(
                &mut (*s1).priv_sections as *mut *mut *mut Section as *mut libc::c_void,
                &mut (*s1).nb_priv_sections,
                s as *mut libc::c_void,
            );
        }
        i += 1;
        i;
    }
    i = 1 as libc::c_int;
    while i < nnew {
        s = *snew.offset(i as isize);
        (*s).sh_num = i;
        if (*s).sh_type == 4 as libc::c_int {
            (*s).sh_info = *backmap.offset((*s).sh_info as isize);
        } else if (*s).sh_type == 2 as libc::c_int || (*s).sh_type == 11 as libc::c_int {
            sym = ((*s).data as *mut Elf64_Sym).offset(1 as libc::c_int as isize);
            while sym < ((*s).data).offset((*s).data_offset as isize) as *mut Elf64_Sym {
                if ((*sym).st_shndx as libc::c_int) < (*s1).nb_sections {
                    (*sym)
                        .st_shndx = *backmap.offset((*sym).st_shndx as isize)
                        as Elf64_Section;
                }
                sym = sym.offset(1);
                sym;
            }
        }
        i += 1;
        i;
    }
    tcc_free((*s1).sections as *mut libc::c_void);
    (*s1).sections = snew;
    (*s1).nb_sections = nnew;
    tcc_free(backmap as *mut libc::c_void);
}
unsafe extern "C" fn elf_output_file(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut file_type: libc::c_int = 0;
    let mut sec_order: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut dyninf: dyn_inf = {
        let mut init = dyn_inf {
            dynamic: 0 as *mut Section,
            dynstr: 0 as *mut Section,
            c2rust_unnamed: C2RustUnnamed_22 {
                data_offset: 0,
                rel_addr: 0,
                rel_size: 0,
            },
            phdr: 0 as *mut Elf64_Phdr,
            phnum: 0,
            shnum: 0,
            interp: 0 as *mut Section,
            note: 0 as *mut Section,
            gnu_hash: 0 as *mut Section,
            _roinf: Section {
                data_offset: 0,
                data: 0 as *mut libc::c_uchar,
                data_allocated: 0,
                s1: 0 as *mut TCCState,
                sh_name: 0,
                sh_num: 0,
                sh_type: 0,
                sh_flags: 0,
                sh_info: 0,
                sh_addralign: 0,
                sh_entsize: 0,
                sh_size: 0,
                sh_addr: 0,
                sh_offset: 0,
                nb_hashed_syms: 0,
                link: 0 as *mut Section,
                reloc: 0 as *mut Section,
                hash: 0 as *mut Section,
                prev: 0 as *mut Section,
                name: [0; 1],
            },
            roinf: 0 as *mut Section,
        };
        init
    };
    let mut interp: *mut Section = 0 as *mut Section;
    let mut dynstr: *mut Section = 0 as *mut Section;
    let mut dynamic: *mut Section = 0 as *mut Section;
    let mut textrel: libc::c_int = 0;
    let mut got_sym: libc::c_int = 0;
    let mut dt_flags_1: libc::c_int = 0;
    file_type = (*s1).output_type;
    (*s1).nb_errors = 0 as libc::c_int;
    ret = -(1 as libc::c_int);
    dynamic = 0 as *mut Section;
    dynstr = dynamic;
    interp = dynstr;
    sec_order = 0 as *mut libc::c_int;
    dyninf.roinf = &mut dyninf._roinf;
    tcc_add_runtime(s1);
    resolve_common_syms(s1);
    if (*s1).static_link == 0 {
        if file_type & 2 as libc::c_int != 0 {
            let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut elfint: *const libc::c_char = (*s1).elfint;
            if elfint.is_null() {
                elfint = getenv(b"LD_SO\0" as *const u8 as *const libc::c_char);
            }
            if elfint.is_null() {
                elfint = b"/lib64/ld-linux-x86-64.so.2\0" as *const u8
                    as *const libc::c_char;
            }
            interp = new_section(
                s1,
                b".interp\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                (1 as libc::c_int) << 1 as libc::c_int,
            );
            (*interp).sh_addralign = 1 as libc::c_int;
            ptr = section_ptr_add(
                interp,
                (1 as libc::c_int as libc::c_ulong).wrapping_add(strlen(elfint)),
            ) as *mut libc::c_char;
            strcpy(ptr, elfint);
            dyninf.interp = interp;
        }
        (*s1)
            .dynsym = new_symtab(
            s1,
            b".dynsym\0" as *const u8 as *const libc::c_char,
            11 as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int,
            b".dynstr\0" as *const u8 as *const libc::c_char,
            b".hash\0" as *const u8 as *const libc::c_char,
            (1 as libc::c_int) << 1 as libc::c_int,
        );
        (*(*s1).dynsym).sh_info = 1 as libc::c_int;
        dynstr = (*(*s1).dynsym).link;
        dynamic = new_section(
            s1,
            b".dynamic\0" as *const u8 as *const libc::c_char,
            6 as libc::c_int,
            (1 as libc::c_int) << 1 as libc::c_int
                | (1 as libc::c_int) << 0 as libc::c_int,
        );
        (*dynamic).link = dynstr;
        (*dynamic)
            .sh_entsize = ::core::mem::size_of::<Elf64_Dyn>() as libc::c_ulong
            as libc::c_int;
        got_sym = build_got(s1);
        if file_type & 2 as libc::c_int != 0 {
            bind_exe_dynsyms(s1, file_type & 4 as libc::c_int);
            if (*s1).nb_errors != 0 {
                current_block = 16862532934077727985;
            } else {
                current_block = 14401909646449704462;
            }
        } else {
            current_block = 14401909646449704462;
        }
        match current_block {
            16862532934077727985 => {}
            _ => {
                build_got_entries(s1, got_sym);
                if file_type & 2 as libc::c_int != 0 {
                    bind_libs_dynsyms(s1);
                } else {
                    export_global_syms(s1);
                }
                tcc_eh_frame_hdr(s1, 0 as libc::c_int);
                dyninf.gnu_hash = create_gnu_hash(s1);
                current_block = 11636175345244025579;
            }
        }
    } else {
        build_got_entries(s1, 0 as libc::c_int);
        current_block = 11636175345244025579;
    }
    match current_block {
        11636175345244025579 => {
            version_add(s1);
            textrel = set_sec_sizes(s1);
            if (*s1).static_link == 0 {
                i = 0 as libc::c_int;
                while i < (*s1).nb_loaded_dlls {
                    let mut dllref: *mut DLLReference = *((*s1).loaded_dlls)
                        .offset(i as isize);
                    if (*dllref).level == 0 as libc::c_int {
                        put_dt(
                            dynamic,
                            1 as libc::c_int,
                            put_elf_str(dynstr, ((*dllref).name).as_mut_ptr())
                                as Elf64_Addr,
                        );
                    }
                    i += 1;
                    i;
                }
                if !((*s1).rpath).is_null() {
                    put_dt(
                        dynamic,
                        if (*s1).enable_new_dtags as libc::c_int != 0 {
                            29 as libc::c_int
                        } else {
                            15 as libc::c_int
                        },
                        put_elf_str(dynstr, (*s1).rpath) as Elf64_Addr,
                    );
                }
                dt_flags_1 = 0x1 as libc::c_int;
                if file_type & 4 as libc::c_int != 0 {
                    if !((*s1).soname).is_null() {
                        put_dt(
                            dynamic,
                            14 as libc::c_int,
                            put_elf_str(dynstr, (*s1).soname) as Elf64_Addr,
                        );
                    }
                    if textrel != 0 {
                        put_dt(
                            dynamic,
                            22 as libc::c_int,
                            0 as libc::c_int as Elf64_Addr,
                        );
                    }
                    if file_type & 2 as libc::c_int != 0 {
                        dt_flags_1 = 0x1 as libc::c_int | 0x8000000 as libc::c_int;
                    }
                }
                put_dt(dynamic, 30 as libc::c_int, 0x8 as libc::c_int as Elf64_Addr);
                put_dt(dynamic, 0x6ffffffb as libc::c_int, dt_flags_1 as Elf64_Addr);
                if (*s1).symbolic != 0 {
                    put_dt(dynamic, 16 as libc::c_int, 0 as libc::c_int as Elf64_Addr);
                }
                dyninf.dynamic = dynamic;
                dyninf.dynstr = dynstr;
                dyninf.c2rust_unnamed.data_offset = (*dynamic).data_offset;
                fill_dynamic(s1, &mut dyninf);
                (*dynamic).sh_size = (*dynamic).data_offset;
                (*dynstr).sh_size = (*dynstr).data_offset;
            }
            alloc_sec_names(s1, 0 as libc::c_int);
            sec_order = tcc_malloc(
                (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                    .wrapping_mul((*s1).nb_sections as libc::c_ulong),
            ) as *mut libc::c_int;
            layout_sections(s1, sec_order, &mut dyninf);
            if !dynamic.is_null() {
                write32le((*(*s1).got).data, (*dynamic).sh_addr as uint32_t);
                if file_type == 2 as libc::c_int
                    || 1 as libc::c_int != 0 && file_type & 4 as libc::c_int != 0
                {
                    relocate_plt(s1);
                }
                relocate_syms(s1, (*s1).dynsym, 2 as libc::c_int);
            }
            relocate_syms(s1, (*s1).c2rust_unnamed.symtab, 0 as libc::c_int);
            if !((*s1).nb_errors != 0 as libc::c_int) {
                relocate_sections(s1);
                if !dynamic.is_null() {
                    update_reloc_sections(s1, &mut dyninf);
                    (*dynamic).data_offset = dyninf.c2rust_unnamed.data_offset;
                    fill_dynamic(s1, &mut dyninf);
                }
                if file_type == 2 as libc::c_int && (*s1).static_link as libc::c_int != 0
                {
                    fill_got(s1);
                } else if !((*s1).got).is_null() {
                    fill_local_got_entries(s1);
                }
                if !(dyninf.gnu_hash).is_null() {
                    update_gnu_hash(s1, dyninf.gnu_hash);
                }
                reorder_sections(s1, sec_order);
                tcc_eh_frame_hdr(s1, 1 as libc::c_int);
                ret = tcc_write_elf_file(s1, filename, dyninf.phnum, dyninf.phdr);
            }
        }
        _ => {}
    }
    tcc_free(sec_order as *mut libc::c_void);
    tcc_free(dyninf.phdr as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn alloc_sec_names(mut s1: *mut TCCState, mut is_obj: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut s: *mut Section = 0 as *mut Section;
    let mut strsec: *mut Section = 0 as *mut Section;
    strsec = new_section(
        s1,
        b".shstrtab\0" as *const u8 as *const libc::c_char,
        3 as libc::c_int,
        0 as libc::c_int,
    );
    put_elf_str(strsec, b"\0" as *const u8 as *const libc::c_char);
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        if is_obj != 0 {
            (*s).sh_size = (*s).data_offset;
        }
        if (*s).sh_size != 0 || s == strsec
            || (*s).sh_flags & (1 as libc::c_int) << 1 as libc::c_int != 0 || is_obj != 0
        {
            (*s).sh_name = put_elf_str(strsec, ((*s).name).as_mut_ptr());
        }
        i += 1;
        i;
    }
    (*strsec).sh_size = (*strsec).data_offset;
}
unsafe extern "C" fn elf_output_obj(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    let mut s: *mut Section = 0 as *mut Section;
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut file_offset: libc::c_int = 0;
    (*s1).nb_errors = 0 as libc::c_int;
    alloc_sec_names(s1, 1 as libc::c_int);
    file_offset = ((::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong)
        .wrapping_add(3 as libc::c_int as libc::c_ulong)
        & -(4 as libc::c_int) as libc::c_ulong) as libc::c_int;
    file_offset = (file_offset as libc::c_ulong)
        .wrapping_add(
            ((*s1).nb_sections as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong),
        ) as libc::c_int as libc::c_int;
    i = 1 as libc::c_int;
    while i < (*s1).nb_sections {
        s = *((*s1).sections).offset(i as isize);
        file_offset = file_offset + 15 as libc::c_int & -(16 as libc::c_int);
        (*s).sh_offset = file_offset as libc::c_ulong;
        if (*s).sh_type != 8 as libc::c_int {
            file_offset = (file_offset as libc::c_ulong).wrapping_add((*s).sh_size)
                as libc::c_int as libc::c_int;
        }
        i += 1;
        i;
    }
    ret = tcc_write_elf_file(s1, filename, 0 as libc::c_int, 0 as *mut Elf64_Phdr);
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_output_file(
    mut s: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    if (*s).test_coverage != 0 {
        tcc_tcov_add_file(s, filename);
    }
    if (*s).output_type == 3 as libc::c_int {
        return elf_output_obj(s, filename);
    }
    return elf_output_file(s, filename);
}
unsafe extern "C" fn full_read(
    mut fd: libc::c_int,
    mut buf: *mut libc::c_void,
    mut count: size_t,
) -> ssize_t {
    let mut cbuf: *mut libc::c_char = buf as *mut libc::c_char;
    let mut rnum: size_t = 0 as libc::c_int as size_t;
    loop {
        let mut num: ssize_t = read(
            fd,
            cbuf as *mut libc::c_void,
            count.wrapping_sub(rnum),
        );
        if num < 0 as libc::c_int as ssize_t {
            return num;
        }
        if num == 0 as libc::c_int as ssize_t {
            return rnum as ssize_t;
        }
        rnum = rnum.wrapping_add(num as size_t);
        cbuf = cbuf.offset(num as isize);
    };
}
unsafe extern "C" fn load_data(
    mut fd: libc::c_int,
    mut file_offset: libc::c_ulong,
    mut size: libc::c_ulong,
) -> *mut libc::c_void {
    let mut data: *mut libc::c_void = 0 as *mut libc::c_void;
    data = tcc_malloc(size);
    lseek(fd, file_offset as __off_t, 0 as libc::c_int);
    full_read(fd, data, size);
    return data;
}
unsafe extern "C" fn tcc_object_type(
    mut fd: libc::c_int,
    mut h: *mut Elf64_Ehdr,
) -> libc::c_int {
    let mut size: libc::c_int = full_read(
        fd,
        h as *mut libc::c_void,
        ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong,
    ) as libc::c_int;
    if size as libc::c_ulong == ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong
        && 0 as libc::c_int
            == memcmp(
                h as *const libc::c_void,
                b"\x7FELF\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                4 as libc::c_int as libc::c_ulong,
            )
    {
        if (*h).e_type as libc::c_int == 1 as libc::c_int {
            return 1 as libc::c_int;
        }
        if (*h).e_type as libc::c_int == 3 as libc::c_int {
            return 2 as libc::c_int;
        }
    } else if size >= 8 as libc::c_int {
        if 0 as libc::c_int
            == memcmp(
                h as *const libc::c_void,
                b"!<arch>\n\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                8 as libc::c_int as libc::c_ulong,
            )
        {
            return 3 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcc_load_object_file(
    mut s1: *mut TCCState,
    mut fd: libc::c_int,
    mut file_offset: libc::c_ulong,
) -> libc::c_int {
    let mut current_block: u64;
    let mut ehdr: Elf64_Ehdr = Elf64_Ehdr {
        e_ident: [0; 16],
        e_type: 0,
        e_machine: 0,
        e_version: 0,
        e_entry: 0,
        e_phoff: 0,
        e_shoff: 0,
        e_flags: 0,
        e_ehsize: 0,
        e_phentsize: 0,
        e_phnum: 0,
        e_shentsize: 0,
        e_shnum: 0,
        e_shstrndx: 0,
    };
    let mut shdr: *mut Elf64_Shdr = 0 as *mut Elf64_Shdr;
    let mut sh: *mut Elf64_Shdr = 0 as *mut Elf64_Shdr;
    let mut size: libc::c_ulong = 0;
    let mut offset: libc::c_ulong = 0;
    let mut offseti: libc::c_ulong = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut nb_syms: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut seencompressed: libc::c_int = 0;
    let mut strsec: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut strtab: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut stab_index: libc::c_int = 0;
    let mut stabstr_index: libc::c_int = 0;
    let mut old_to_new_syms: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut sh_name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut name: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sm_table: *mut SectionMergeInfo = 0 as *mut SectionMergeInfo;
    let mut sm: *mut SectionMergeInfo = 0 as *mut SectionMergeInfo;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut symtab: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut s: *mut Section = 0 as *mut Section;
    lseek(fd, file_offset as __off_t, 0 as libc::c_int);
    if !(tcc_object_type(fd, &mut ehdr) != 1 as libc::c_int) {
        if !(ehdr.e_ident[5 as libc::c_int as usize] as libc::c_int != 1 as libc::c_int
            || ehdr.e_machine as libc::c_int != 62 as libc::c_int)
        {
            shdr = load_data(
                fd,
                file_offset.wrapping_add(ehdr.e_shoff),
                (::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong)
                    .wrapping_mul(ehdr.e_shnum as libc::c_ulong),
            ) as *mut Elf64_Shdr;
            sm_table = tcc_mallocz(
                (::core::mem::size_of::<SectionMergeInfo>() as libc::c_ulong)
                    .wrapping_mul(ehdr.e_shnum as libc::c_ulong),
            ) as *mut SectionMergeInfo;
            sh = &mut *shdr.offset(ehdr.e_shstrndx as isize) as *mut Elf64_Shdr;
            strsec = load_data(
                fd,
                file_offset.wrapping_add((*sh).sh_offset),
                (*sh).sh_size,
            ) as *mut libc::c_char;
            old_to_new_syms = 0 as *mut libc::c_int;
            symtab = 0 as *mut Elf64_Sym;
            strtab = 0 as *mut libc::c_char;
            nb_syms = 0 as libc::c_int;
            seencompressed = 0 as libc::c_int;
            stabstr_index = 0 as libc::c_int;
            stab_index = stabstr_index;
            ret = -(1 as libc::c_int);
            i = 1 as libc::c_int;
            loop {
                if !(i < ehdr.e_shnum as libc::c_int) {
                    current_block = 6669252993407410313;
                    break;
                }
                sh = &mut *shdr.offset(i as isize) as *mut Elf64_Shdr;
                if (*sh).sh_type == 2 as libc::c_int as Elf64_Word {
                    if !symtab.is_null() {
                        tcc_enter_state(s1);
                        (Some(
                            _tcc_error_noabort
                                as unsafe extern "C" fn(
                                    *const libc::c_char,
                                    ...
                                ) -> libc::c_int,
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            b"object must contain only one symtab\0" as *const u8
                                as *const libc::c_char,
                        );
                        current_block = 3957405341070239145;
                        break;
                    } else {
                        nb_syms = ((*sh).sh_size)
                            .wrapping_div(
                                ::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong,
                            ) as libc::c_int;
                        symtab = load_data(
                            fd,
                            file_offset.wrapping_add((*sh).sh_offset),
                            (*sh).sh_size,
                        ) as *mut Elf64_Sym;
                        let ref mut fresh44 = (*sm_table.offset(i as isize)).s;
                        *fresh44 = (*s1).c2rust_unnamed.symtab_section;
                        sh = &mut *shdr.offset((*sh).sh_link as isize)
                            as *mut Elf64_Shdr;
                        strtab = load_data(
                            fd,
                            file_offset.wrapping_add((*sh).sh_offset),
                            (*sh).sh_size,
                        ) as *mut libc::c_char;
                    }
                }
                if (*sh).sh_flags
                    & ((1 as libc::c_int) << 11 as libc::c_int) as Elf64_Xword != 0
                {
                    seencompressed = 1 as libc::c_int;
                }
                i += 1;
                i;
            }
            match current_block {
                6669252993407410313 => {
                    i = 1 as libc::c_int;
                    's_132: loop {
                        if !(i < ehdr.e_shnum as libc::c_int) {
                            current_block = 5028470053297453708;
                            break;
                        }
                        if !(i == ehdr.e_shstrndx as libc::c_int) {
                            sh = &mut *shdr.offset(i as isize) as *mut Elf64_Shdr;
                            if (*sh).sh_type == 4 as libc::c_int as Elf64_Word {
                                sh = &mut *shdr.offset((*sh).sh_info as isize)
                                    as *mut Elf64_Shdr;
                            }
                            sh_name = strsec.offset((*sh).sh_name as isize);
                            if 0 as libc::c_int
                                == strncmp(
                                    sh_name,
                                    b".debug_\0" as *const u8 as *const libc::c_char,
                                    7 as libc::c_int as libc::c_ulong,
                                )
                                || 0 as libc::c_int
                                    == strncmp(
                                        sh_name,
                                        b".stab\0" as *const u8 as *const libc::c_char,
                                        5 as libc::c_int as libc::c_ulong,
                                    )
                            {
                                if (*s1).do_debug == 0 || seencompressed != 0 {
                                    current_block = 7056779235015430508;
                                } else {
                                    current_block = 15597372965620363352;
                                }
                            } else if 0 as libc::c_int
                                == strncmp(
                                    sh_name,
                                    b".eh_frame\0" as *const u8 as *const libc::c_char,
                                    9 as libc::c_int as libc::c_ulong,
                                )
                            {
                                if ((*s1).eh_frame_section).is_null() {
                                    current_block = 7056779235015430508;
                                } else {
                                    current_block = 15597372965620363352;
                                }
                            } else if (*sh).sh_type != 1 as libc::c_int as Elf64_Word
                                && (*sh).sh_type != 7 as libc::c_int as Elf64_Word
                                && (*sh).sh_type != 8 as libc::c_int as Elf64_Word
                                && (*sh).sh_type != 16 as libc::c_int as Elf64_Word
                                && (*sh).sh_type != 14 as libc::c_int as Elf64_Word
                                && (*sh).sh_type != 15 as libc::c_int as Elf64_Word
                            {
                                current_block = 7056779235015430508;
                            } else {
                                current_block = 15597372965620363352;
                            }
                            match current_block {
                                7056779235015430508 => {}
                                _ => {
                                    sh = &mut *shdr.offset(i as isize) as *mut Elf64_Shdr;
                                    sh_name = strsec.offset((*sh).sh_name as isize);
                                    if (*sh).sh_addralign < 1 as libc::c_int as Elf64_Xword {
                                        (*sh).sh_addralign = 1 as libc::c_int as Elf64_Xword;
                                    }
                                    j = 1 as libc::c_int;
                                    loop {
                                        if !(j < (*s1).nb_sections) {
                                            current_block = 2290177392965769716;
                                            break;
                                        }
                                        s = *((*s1).sections).offset(j as isize);
                                        if strcmp(((*s).name).as_mut_ptr(), sh_name) != 0 {
                                            j += 1;
                                            j;
                                        } else if (*sh).sh_type != (*s).sh_type as Elf64_Word
                                            && strcmp(
                                                ((*s).name).as_mut_ptr(),
                                                b".eh_frame\0" as *const u8 as *const libc::c_char,
                                            ) != 0
                                        {
                                            tcc_enter_state(s1);
                                            (Some(
                                                _tcc_error_noabort
                                                    as unsafe extern "C" fn(
                                                        *const libc::c_char,
                                                        ...
                                                    ) -> libc::c_int,
                                            ))
                                                .expect(
                                                    "non-null function pointer",
                                                )(
                                                b"section type conflict: %s %02x <> %02x\0" as *const u8
                                                    as *const libc::c_char,
                                                ((*s).name).as_mut_ptr(),
                                                (*sh).sh_type,
                                                (*s).sh_type,
                                            );
                                            current_block = 3957405341070239145;
                                            break 's_132;
                                        } else if strncmp(
                                            sh_name,
                                            b".gnu.linkonce\0" as *const u8 as *const libc::c_char,
                                            13 as libc::c_int as libc::c_ulong,
                                        ) == 0
                                        {
                                            (*sm_table.offset(i as isize))
                                                .link_once = 1 as libc::c_int as uint8_t;
                                            current_block = 7056779235015430508;
                                            break;
                                        } else {
                                            if !((*s1).stab_section).is_null() {
                                                if s == (*s1).stab_section {
                                                    stab_index = i;
                                                }
                                                if s == (*(*s1).stab_section).link {
                                                    stabstr_index = i;
                                                }
                                            }
                                            current_block = 18390240475710248433;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        7056779235015430508 => {}
                                        _ => {
                                            match current_block {
                                                2290177392965769716 => {
                                                    s = new_section(
                                                        s1,
                                                        sh_name,
                                                        (*sh).sh_type as libc::c_int,
                                                        ((*sh).sh_flags
                                                            & !((1 as libc::c_int) << 9 as libc::c_int) as Elf64_Xword)
                                                            as libc::c_int,
                                                    );
                                                    (*s).sh_addralign = (*sh).sh_addralign as libc::c_int;
                                                    (*s).sh_entsize = (*sh).sh_entsize as libc::c_int;
                                                    (*sm_table.offset(i as isize))
                                                        .new_section = 1 as libc::c_int as uint8_t;
                                                }
                                                _ => {}
                                            }
                                            (*s)
                                                .data_offset = ((*s).data_offset)
                                                .wrapping_add(
                                                    ((*s).data_offset).wrapping_neg()
                                                        & ((*sh).sh_addralign)
                                                            .wrapping_sub(1 as libc::c_int as Elf64_Xword),
                                                );
                                            if (*sh).sh_addralign > (*s).sh_addralign as Elf64_Xword {
                                                (*s).sh_addralign = (*sh).sh_addralign as libc::c_int;
                                            }
                                            (*sm_table.offset(i as isize)).offset = (*s).data_offset;
                                            let ref mut fresh45 = (*sm_table.offset(i as isize)).s;
                                            *fresh45 = s;
                                            size = (*sh).sh_size;
                                            if (*sh).sh_type != 8 as libc::c_int as Elf64_Word {
                                                let mut ptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                                                lseek(
                                                    fd,
                                                    file_offset.wrapping_add((*sh).sh_offset) as __off_t,
                                                    0 as libc::c_int,
                                                );
                                                ptr = section_ptr_add(s, size) as *mut libc::c_uchar;
                                                full_read(fd, ptr as *mut libc::c_void, size);
                                            } else {
                                                (*s).data_offset = ((*s).data_offset).wrapping_add(size);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        i += 1;
                        i;
                    }
                    match current_block {
                        3957405341070239145 => {}
                        _ => {
                            if stab_index != 0 && stabstr_index != 0 {
                                let mut a: *mut Stab_Sym = 0 as *mut Stab_Sym;
                                let mut b: *mut Stab_Sym = 0 as *mut Stab_Sym;
                                let mut o_0: libc::c_uint = 0;
                                s = (*sm_table.offset(stab_index as isize)).s;
                                a = ((*s).data)
                                    .offset(
                                        (*sm_table.offset(stab_index as isize)).offset as isize,
                                    ) as *mut Stab_Sym;
                                b = ((*s).data).offset((*s).data_offset as isize)
                                    as *mut Stab_Sym;
                                o_0 = (*sm_table.offset(stabstr_index as isize)).offset
                                    as libc::c_uint;
                                while a < b {
                                    if (*a).n_strx != 0 {
                                        (*a).n_strx = ((*a).n_strx).wrapping_add(o_0);
                                    }
                                    a = a.offset(1);
                                    a;
                                }
                            }
                            i = 1 as libc::c_int;
                            while i < ehdr.e_shnum as libc::c_int {
                                s = (*sm_table.offset(i as isize)).s;
                                if !(s.is_null()
                                    || (*sm_table.offset(i as isize)).new_section == 0)
                                {
                                    sh = &mut *shdr.offset(i as isize) as *mut Elf64_Shdr;
                                    if (*sh).sh_link > 0 as libc::c_int as Elf64_Word {
                                        (*s).link = (*sm_table.offset((*sh).sh_link as isize)).s;
                                    }
                                    if (*sh).sh_type == 4 as libc::c_int as Elf64_Word {
                                        (*s)
                                            .sh_info = (*(*sm_table.offset((*sh).sh_info as isize)).s)
                                            .sh_num;
                                        let ref mut fresh46 = (**((*s1).sections)
                                            .offset((*s).sh_info as isize))
                                            .reloc;
                                        *fresh46 = s;
                                    }
                                }
                                i += 1;
                                i;
                            }
                            old_to_new_syms = tcc_mallocz(
                                (nb_syms as libc::c_ulong)
                                    .wrapping_mul(
                                        ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                                    ),
                            ) as *mut libc::c_int;
                            sym = symtab.offset(1 as libc::c_int as isize);
                            let mut current_block_95: u64;
                            i = 1 as libc::c_int;
                            while i < nb_syms {
                                if (*sym).st_shndx as libc::c_int != 0 as libc::c_int
                                    && ((*sym).st_shndx as libc::c_int) < 0xff00 as libc::c_int
                                {
                                    sm = &mut *sm_table.offset((*sym).st_shndx as isize)
                                        as *mut SectionMergeInfo;
                                    if (*sm).link_once != 0 {
                                        if (*sym).st_info as libc::c_int >> 4 as libc::c_int
                                            != 0 as libc::c_int
                                        {
                                            name = strtab.offset((*sym).st_name as isize);
                                            sym_index = find_elf_sym(
                                                (*s1).c2rust_unnamed.symtab_section,
                                                name,
                                            );
                                            if sym_index != 0 {
                                                *old_to_new_syms.offset(i as isize) = sym_index;
                                            }
                                        }
                                        current_block_95 = 12705158477165241210;
                                    } else if ((*sm).s).is_null() {
                                        current_block_95 = 12705158477165241210;
                                    } else {
                                        (*sym).st_shndx = (*(*sm).s).sh_num as Elf64_Section;
                                        (*sym)
                                            .st_value = ((*sym).st_value as libc::c_ulong)
                                            .wrapping_add((*sm).offset) as Elf64_Addr as Elf64_Addr;
                                        current_block_95 = 1417769144978639029;
                                    }
                                } else {
                                    current_block_95 = 1417769144978639029;
                                }
                                match current_block_95 {
                                    1417769144978639029 => {
                                        name = strtab.offset((*sym).st_name as isize);
                                        sym_index = set_elf_sym(
                                            (*s1).c2rust_unnamed.symtab_section,
                                            (*sym).st_value,
                                            (*sym).st_size,
                                            (*sym).st_info as libc::c_int,
                                            (*sym).st_other as libc::c_int,
                                            (*sym).st_shndx as libc::c_int,
                                            name,
                                        );
                                        *old_to_new_syms.offset(i as isize) = sym_index;
                                    }
                                    _ => {}
                                }
                                i += 1;
                                i;
                                sym = sym.offset(1);
                                sym;
                            }
                            i = 1 as libc::c_int;
                            's_516: loop {
                                if !(i < ehdr.e_shnum as libc::c_int) {
                                    current_block = 9180031981464905198;
                                    break;
                                }
                                s = (*sm_table.offset(i as isize)).s;
                                if !s.is_null() {
                                    sh = &mut *shdr.offset(i as isize) as *mut Elf64_Shdr;
                                    offset = (*sm_table.offset(i as isize)).offset;
                                    size = (*sh).sh_size;
                                    match (*s).sh_type {
                                        4 => {
                                            offseti = (*sm_table.offset((*sh).sh_info as isize)).offset;
                                            rel = ((*s).data as *mut Elf64_Rela)
                                                .offset(
                                                    offset
                                                        .wrapping_div(
                                                            ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong,
                                                        ) as isize,
                                                );
                                            while rel
                                                < ((*s).data as *mut Elf64_Rela)
                                                    .offset(
                                                        offset
                                                            .wrapping_add(size)
                                                            .wrapping_div(
                                                                ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong,
                                                            ) as isize,
                                                    )
                                            {
                                                let mut type_0: libc::c_int = 0;
                                                let mut sym_index_0: libc::c_uint = 0;
                                                type_0 = ((*rel).r_info
                                                    & 0xffffffff as libc::c_uint as Elf64_Xword) as libc::c_int;
                                                sym_index_0 = ((*rel).r_info >> 32 as libc::c_int)
                                                    as libc::c_uint;
                                                if !(sym_index_0 >= nb_syms as libc::c_uint) {
                                                    sym_index_0 = *old_to_new_syms.offset(sym_index_0 as isize)
                                                        as libc::c_uint;
                                                    if !(sym_index_0 == 0
                                                        && (*sm_table.offset((*sh).sh_info as isize)).link_once
                                                            == 0)
                                                    {
                                                        (*rel)
                                                            .r_info = ((sym_index_0 as Elf64_Xword)
                                                            << 32 as libc::c_int)
                                                            .wrapping_add(type_0 as Elf64_Xword);
                                                        (*rel)
                                                            .r_offset = ((*rel).r_offset as libc::c_ulong)
                                                            .wrapping_add(offseti) as Elf64_Addr as Elf64_Addr;
                                                        rel = rel.offset(1);
                                                        rel;
                                                        continue;
                                                    }
                                                }
                                                tcc_enter_state(s1);
                                                (Some(
                                                    _tcc_error_noabort
                                                        as unsafe extern "C" fn(
                                                            *const libc::c_char,
                                                            ...
                                                        ) -> libc::c_int,
                                                ))
                                                    .expect(
                                                        "non-null function pointer",
                                                    )(
                                                    b"Invalid relocation entry [%2d] '%s' @ %.8x\0" as *const u8
                                                        as *const libc::c_char,
                                                    i,
                                                    strsec.offset((*sh).sh_name as isize),
                                                    (*rel).r_offset as libc::c_int,
                                                );
                                                current_block = 3957405341070239145;
                                                break 's_516;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                i += 1;
                                i;
                            }
                            match current_block {
                                3957405341070239145 => {}
                                _ => {
                                    ret = 0 as libc::c_int;
                                }
                            }
                        }
                    }
                }
                _ => {}
            }
            tcc_free(symtab as *mut libc::c_void);
            tcc_free(strtab as *mut libc::c_void);
            tcc_free(old_to_new_syms as *mut libc::c_void);
            tcc_free(sm_table as *mut libc::c_void);
            tcc_free(strsec as *mut libc::c_void);
            tcc_free(shdr as *mut libc::c_void);
            return ret;
        }
    }
    tcc_enter_state(s1);
    return (Some(
        _tcc_error_noabort
            as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
    ))
        .expect(
            "non-null function pointer",
        )(b"invalid object file\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn get_be(
    mut b: *const uint8_t,
    mut n: libc::c_int,
) -> libc::c_ulonglong {
    let mut ret: libc::c_ulonglong = 0 as libc::c_int as libc::c_ulonglong;
    while n != 0 {
        let fresh47 = b;
        b = b.offset(1);
        ret = ret << 8 as libc::c_int | *fresh47 as libc::c_ulonglong;
        n -= 1;
        n;
    }
    return ret;
}
unsafe extern "C" fn read_ar_header(
    mut fd: libc::c_int,
    mut offset: libc::c_int,
    mut hdr: *mut ArchiveHeader,
) -> libc::c_int {
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut len: libc::c_int = 0;
    lseek(fd, offset as __off_t, 0 as libc::c_int);
    len = full_read(
        fd,
        hdr as *mut libc::c_void,
        ::core::mem::size_of::<ArchiveHeader>() as libc::c_ulong,
    ) as libc::c_int;
    if len as libc::c_ulong != ::core::mem::size_of::<ArchiveHeader>() as libc::c_ulong {
        return if len != 0 { -(1 as libc::c_int) } else { 0 as libc::c_int };
    }
    if memcmp(
        ((*hdr).ar_fmag).as_mut_ptr() as *const libc::c_void,
        b"`\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 2]>() as libc::c_ulong,
    ) != 0
    {
        return -(1 as libc::c_int);
    }
    p = ((*hdr).ar_name).as_mut_ptr();
    e = p.offset(::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as isize);
    while e > p && *e.offset(-(1 as libc::c_int) as isize) as libc::c_int == ' ' as i32 {
        e = e.offset(-1);
        e;
    }
    *e = '\0' as i32 as libc::c_char;
    (*hdr)
        .ar_size[(::core::mem::size_of::<[libc::c_char; 10]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as usize] = 0 as libc::c_int as libc::c_char;
    return len;
}
unsafe extern "C" fn tcc_load_alacarte(
    mut s1: *mut TCCState,
    mut fd: libc::c_int,
    mut size: libc::c_int,
    mut entrysize: libc::c_int,
) -> libc::c_int {
    let mut s: *mut Section = 0 as *mut Section;
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut bound: libc::c_int = 0;
    let mut nsyms: libc::c_int = 0;
    let mut sym_index: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut ret: libc::c_int = -(1 as libc::c_int);
    let mut off: libc::c_ulonglong = 0;
    let mut data: *mut uint8_t = 0 as *mut uint8_t;
    let mut ar_names: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut ar_index: *const uint8_t = 0 as *const uint8_t;
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut hdr: ArchiveHeader = ArchiveHeader {
        ar_name: [0; 16],
        ar_date: [0; 12],
        ar_uid: [0; 6],
        ar_gid: [0; 6],
        ar_mode: [0; 8],
        ar_size: [0; 10],
        ar_fmag: [0; 2],
    };
    data = tcc_malloc(size as libc::c_ulong) as *mut uint8_t;
    if full_read(fd, data as *mut libc::c_void, size as size_t) != size as ssize_t {
        current_block = 13957021456979406793;
    } else {
        nsyms = get_be(data, entrysize) as libc::c_int;
        ar_index = data.offset(entrysize as isize);
        ar_names = (ar_index as *mut libc::c_char).offset((nsyms * entrysize) as isize);
        's_35: loop {
            bound = 0 as libc::c_int;
            p = ar_names;
            i = 0 as libc::c_int;
            while i < nsyms {
                s = (*s1).c2rust_unnamed.symtab_section;
                sym_index = find_elf_sym(s, p);
                if !(sym_index == 0) {
                    sym = &mut *((*s).data as *mut Elf64_Sym).offset(sym_index as isize)
                        as *mut Elf64_Sym;
                    if !((*sym).st_shndx as libc::c_int != 0 as libc::c_int) {
                        off = get_be(
                            ar_index.offset((i * entrysize) as isize),
                            entrysize,
                        );
                        len = read_ar_header(fd, off as libc::c_int, &mut hdr);
                        if len <= 0 as libc::c_int
                            || memcmp(
                                (hdr.ar_fmag).as_mut_ptr() as *const libc::c_void,
                                b"`\n\0" as *const u8 as *const libc::c_char
                                    as *const libc::c_void,
                                2 as libc::c_int as libc::c_ulong,
                            ) != 0
                        {
                            current_block = 13957021456979406793;
                            break 's_35;
                        }
                        off = off.wrapping_add(len as libc::c_ulonglong);
                        if (*s1).verbose as libc::c_int == 2 as libc::c_int {
                            printf(
                                b"   -> %s\n\0" as *const u8 as *const libc::c_char,
                                (hdr.ar_name).as_mut_ptr(),
                            );
                        }
                        if tcc_load_object_file(s1, fd, off as libc::c_ulong)
                            < 0 as libc::c_int
                        {
                            current_block = 16770508579828589929;
                            break 's_35;
                        }
                        bound += 1;
                        bound;
                    }
                }
                i += 1;
                i;
                p = p
                    .offset(
                        (strlen(p)).wrapping_add(1 as libc::c_int as libc::c_ulong)
                            as isize,
                    );
            }
            if bound != 0 {
                continue;
            }
            ret = 0 as libc::c_int;
            current_block = 16770508579828589929;
            break;
        }
    }
    match current_block {
        13957021456979406793 => {
            tcc_enter_state(s1);
            (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(b"invalid archive\0" as *const u8 as *const libc::c_char);
        }
        _ => {}
    }
    tcc_free(data as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn tcc_load_archive(
    mut s1: *mut TCCState,
    mut fd: libc::c_int,
    mut alacarte: libc::c_int,
) -> libc::c_int {
    let mut hdr: ArchiveHeader = ArchiveHeader {
        ar_name: [0; 16],
        ar_date: [0; 12],
        ar_uid: [0; 6],
        ar_gid: [0; 6],
        ar_mode: [0; 8],
        ar_size: [0; 10],
        ar_fmag: [0; 2],
    };
    let mut size: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut file_offset: libc::c_ulong = 0;
    let mut ehdr: Elf64_Ehdr = Elf64_Ehdr {
        e_ident: [0; 16],
        e_type: 0,
        e_machine: 0,
        e_version: 0,
        e_entry: 0,
        e_phoff: 0,
        e_shoff: 0,
        e_flags: 0,
        e_ehsize: 0,
        e_phentsize: 0,
        e_phnum: 0,
        e_shentsize: 0,
        e_shnum: 0,
        e_shstrndx: 0,
    };
    file_offset = (::core::mem::size_of::<[libc::c_char; 9]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong);
    loop {
        len = read_ar_header(fd, file_offset as libc::c_int, &mut hdr);
        if len == 0 as libc::c_int {
            return 0 as libc::c_int;
        }
        if len < 0 as libc::c_int {
            tcc_enter_state(s1);
            return (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(b"invalid archive\0" as *const u8 as *const libc::c_char);
        }
        file_offset = file_offset.wrapping_add(len as libc::c_ulong);
        size = strtol(
            (hdr.ar_size).as_mut_ptr(),
            0 as *mut *mut libc::c_char,
            0 as libc::c_int,
        ) as libc::c_int;
        if alacarte != 0 {
            if strcmp(
                (hdr.ar_name).as_mut_ptr(),
                b"/\0" as *const u8 as *const libc::c_char,
            ) == 0
            {
                return tcc_load_alacarte(s1, fd, size, 4 as libc::c_int);
            }
            if strcmp(
                (hdr.ar_name).as_mut_ptr(),
                b"/SYM64/\0" as *const u8 as *const libc::c_char,
            ) == 0
            {
                return tcc_load_alacarte(s1, fd, size, 8 as libc::c_int);
            }
        } else if tcc_object_type(fd, &mut ehdr) == 1 as libc::c_int {
            if (*s1).verbose as libc::c_int == 2 as libc::c_int {
                printf(
                    b"   -> %s\n\0" as *const u8 as *const libc::c_char,
                    (hdr.ar_name).as_mut_ptr(),
                );
            }
            if tcc_load_object_file(s1, fd, file_offset) < 0 as libc::c_int {
                return -(1 as libc::c_int);
            }
        }
        file_offset = file_offset
            .wrapping_add(size as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            & !(1 as libc::c_int) as libc::c_ulong;
    };
}
unsafe extern "C" fn set_ver_to_ver(
    mut s1: *mut TCCState,
    mut n: *mut libc::c_int,
    mut lv: *mut *mut libc::c_int,
    mut i: libc::c_int,
    mut lib: *mut libc::c_char,
    mut version: *mut libc::c_char,
) {
    while i >= *n {
        *lv = tcc_realloc(
            *lv as *mut libc::c_void,
            ((*n + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        let fresh48 = *n;
        *n = *n + 1;
        *(*lv).offset(fresh48 as isize) = -(1 as libc::c_int);
    }
    if *(*lv).offset(i as isize) == -(1 as libc::c_int) {
        let mut v: libc::c_int = 0;
        let mut prev_same_lib: libc::c_int = -(1 as libc::c_int);
        v = 0 as libc::c_int;
        while v < (*s1).nb_sym_versions {
            if !(strcmp((*((*s1).sym_versions).offset(v as isize)).lib, lib) != 0) {
                prev_same_lib = v;
                if strcmp((*((*s1).sym_versions).offset(v as isize)).version, version)
                    == 0
                {
                    break;
                }
            }
            v += 1;
            v;
        }
        if v == (*s1).nb_sym_versions {
            (*s1)
                .sym_versions = tcc_realloc(
                (*s1).sym_versions as *mut libc::c_void,
                ((v + 1 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<sym_version>() as libc::c_ulong),
            ) as *mut sym_version;
            let ref mut fresh49 = (*((*s1).sym_versions).offset(v as isize)).lib;
            *fresh49 = tcc_strdup(lib);
            let ref mut fresh50 = (*((*s1).sym_versions).offset(v as isize)).version;
            *fresh50 = tcc_strdup(version);
            (*((*s1).sym_versions).offset(v as isize)).out_index = 0 as libc::c_int;
            (*((*s1).sym_versions).offset(v as isize)).prev_same_lib = prev_same_lib;
            (*s1).nb_sym_versions += 1;
            (*s1).nb_sym_versions;
        }
        *(*lv).offset(i as isize) = v;
    }
}
unsafe extern "C" fn set_sym_version(
    mut s1: *mut TCCState,
    mut sym_index: libc::c_int,
    mut verndx: libc::c_int,
) {
    if sym_index >= (*s1).nb_sym_to_version {
        let mut newelems: libc::c_int = if sym_index != 0 {
            sym_index * 2 as libc::c_int
        } else {
            1 as libc::c_int
        };
        (*s1)
            .sym_to_version = tcc_realloc(
            (*s1).sym_to_version as *mut libc::c_void,
            (newelems as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        memset(
            ((*s1).sym_to_version).offset((*s1).nb_sym_to_version as isize)
                as *mut libc::c_void,
            -(1 as libc::c_int),
            ((newelems - (*s1).nb_sym_to_version) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*s1).nb_sym_to_version = newelems;
    }
    if *((*s1).sym_to_version).offset(sym_index as isize) < 0 as libc::c_int {
        *((*s1).sym_to_version).offset(sym_index as isize) = verndx;
    }
}
unsafe extern "C" fn store_version(
    mut s1: *mut TCCState,
    mut v: *mut versym_info,
    mut dynstr: *mut libc::c_char,
) {
    let mut lib: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut version: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut next_0: uint32_t = 0;
    let mut i: libc::c_int = 0;
    if !((*v).versym).is_null() && !((*v).verdef).is_null() {
        let mut vdef: *mut Elf64_Verdef = (*v).verdef;
        lib = 0 as *mut libc::c_char;
        loop {
            let mut verdaux: *mut Elf64_Verdaux = (vdef as *mut libc::c_char)
                .offset((*vdef).vd_aux as isize) as *mut Elf64_Verdaux;
            if (*vdef).vd_cnt != 0 {
                version = dynstr.offset((*verdaux).vda_name as isize);
                if lib.is_null() {
                    lib = version;
                } else {
                    set_ver_to_ver(
                        s1,
                        &mut (*v).nb_local_ver,
                        &mut (*v).local_ver,
                        (*vdef).vd_ndx as libc::c_int,
                        lib,
                        version,
                    );
                }
            }
            next_0 = (*vdef).vd_next;
            vdef = (vdef as *mut libc::c_char).offset(next_0 as isize)
                as *mut Elf64_Verdef;
            if !(next_0 != 0) {
                break;
            }
        }
    }
    if !((*v).versym).is_null() && !((*v).verneed).is_null() {
        let mut vneed: *mut Elf64_Verneed = (*v).verneed;
        loop {
            let mut vernaux: *mut Elf64_Vernaux = (vneed as *mut libc::c_char)
                .offset((*vneed).vn_aux as isize) as *mut Elf64_Vernaux;
            lib = dynstr.offset((*vneed).vn_file as isize);
            i = 0 as libc::c_int;
            while i < (*vneed).vn_cnt as libc::c_int {
                if (*vernaux).vna_other as libc::c_int & 0x8000 as libc::c_int
                    == 0 as libc::c_int
                {
                    version = dynstr.offset((*vernaux).vna_name as isize);
                    set_ver_to_ver(
                        s1,
                        &mut (*v).nb_local_ver,
                        &mut (*v).local_ver,
                        (*vernaux).vna_other as libc::c_int,
                        lib,
                        version,
                    );
                }
                vernaux = (vernaux as *mut libc::c_char)
                    .offset((*vernaux).vna_next as isize) as *mut Elf64_Vernaux;
                i += 1;
                i;
            }
            next_0 = (*vneed).vn_next;
            vneed = (vneed as *mut libc::c_char).offset(next_0 as isize)
                as *mut Elf64_Verneed;
            if !(next_0 != 0) {
                break;
            }
        }
    }
}
unsafe extern "C" fn tcc_load_dll(
    mut s1: *mut TCCState,
    mut fd: libc::c_int,
    mut filename: *const libc::c_char,
    mut level: libc::c_int,
) -> libc::c_int {
    let mut ehdr: Elf64_Ehdr = Elf64_Ehdr {
        e_ident: [0; 16],
        e_type: 0,
        e_machine: 0,
        e_version: 0,
        e_entry: 0,
        e_phoff: 0,
        e_shoff: 0,
        e_flags: 0,
        e_ehsize: 0,
        e_phentsize: 0,
        e_phnum: 0,
        e_shentsize: 0,
        e_shnum: 0,
        e_shstrndx: 0,
    };
    let mut shdr: *mut Elf64_Shdr = 0 as *mut Elf64_Shdr;
    let mut sh: *mut Elf64_Shdr = 0 as *mut Elf64_Shdr;
    let mut sh1: *mut Elf64_Shdr = 0 as *mut Elf64_Shdr;
    let mut i: libc::c_int = 0;
    let mut nb_syms: libc::c_int = 0;
    let mut nb_dts: libc::c_int = 0;
    let mut sym_bind: libc::c_int = 0;
    let mut ret: libc::c_int = -(1 as libc::c_int);
    let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut dynsym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut dt: *mut Elf64_Dyn = 0 as *mut Elf64_Dyn;
    let mut dynamic: *mut Elf64_Dyn = 0 as *mut Elf64_Dyn;
    let mut dynstr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sym_index: libc::c_int = 0;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut soname: *const libc::c_char = 0 as *const libc::c_char;
    let mut v: versym_info = versym_info {
        nb_versyms: 0,
        verdef: 0 as *mut Elf64_Verdef,
        verneed: 0 as *mut Elf64_Verneed,
        versym: 0 as *mut Elf64_Half,
        nb_local_ver: 0,
        local_ver: 0 as *mut libc::c_int,
    };
    full_read(
        fd,
        &mut ehdr as *mut Elf64_Ehdr as *mut libc::c_void,
        ::core::mem::size_of::<Elf64_Ehdr>() as libc::c_ulong,
    );
    if ehdr.e_ident[5 as libc::c_int as usize] as libc::c_int != 1 as libc::c_int
        || ehdr.e_machine as libc::c_int != 62 as libc::c_int
    {
        tcc_enter_state(s1);
        return (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(b"bad architecture\0" as *const u8 as *const libc::c_char);
    }
    shdr = load_data(
        fd,
        ehdr.e_shoff,
        (::core::mem::size_of::<Elf64_Shdr>() as libc::c_ulong)
            .wrapping_mul(ehdr.e_shnum as libc::c_ulong),
    ) as *mut Elf64_Shdr;
    nb_syms = 0 as libc::c_int;
    nb_dts = 0 as libc::c_int;
    dynamic = 0 as *mut Elf64_Dyn;
    dynsym = 0 as *mut Elf64_Sym;
    dynstr = 0 as *mut libc::c_char;
    memset(
        &mut v as *mut versym_info as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<versym_info>() as libc::c_ulong,
    );
    i = 0 as libc::c_int;
    sh = shdr;
    while i < ehdr.e_shnum as libc::c_int {
        match (*sh).sh_type {
            6 => {
                nb_dts = ((*sh).sh_size)
                    .wrapping_div(::core::mem::size_of::<Elf64_Dyn>() as libc::c_ulong)
                    as libc::c_int;
                dynamic = load_data(fd, (*sh).sh_offset, (*sh).sh_size)
                    as *mut Elf64_Dyn;
            }
            11 => {
                nb_syms = ((*sh).sh_size)
                    .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
                    as libc::c_int;
                dynsym = load_data(fd, (*sh).sh_offset, (*sh).sh_size) as *mut Elf64_Sym;
                sh1 = &mut *shdr.offset((*sh).sh_link as isize) as *mut Elf64_Shdr;
                dynstr = load_data(fd, (*sh1).sh_offset, (*sh1).sh_size)
                    as *mut libc::c_char;
            }
            1879048189 => {
                v
                    .verdef = load_data(fd, (*sh).sh_offset, (*sh).sh_size)
                    as *mut Elf64_Verdef;
            }
            1879048190 => {
                v
                    .verneed = load_data(fd, (*sh).sh_offset, (*sh).sh_size)
                    as *mut Elf64_Verneed;
            }
            1879048191 => {
                v
                    .nb_versyms = ((*sh).sh_size)
                    .wrapping_div(::core::mem::size_of::<Elf64_Half>() as libc::c_ulong)
                    as libc::c_int;
                v
                    .versym = load_data(fd, (*sh).sh_offset, (*sh).sh_size)
                    as *mut Elf64_Half;
            }
            _ => {}
        }
        i += 1;
        i;
        sh = sh.offset(1);
        sh;
    }
    if !dynamic.is_null() {
        soname = tcc_basename(filename);
        i = 0 as libc::c_int;
        dt = dynamic;
        while i < nb_dts {
            if (*dt).d_tag == 14 as libc::c_int as Elf64_Sxword {
                soname = dynstr.offset((*dt).d_un.d_val as isize);
            }
            i += 1;
            i;
            dt = dt.offset(1);
            dt;
        }
        if !((*tcc_add_dllref(s1, soname, level)).found != 0) {
            if v.nb_versyms != nb_syms {
                tcc_free(v.versym as *mut libc::c_void);
                v.versym = 0 as *mut Elf64_Half;
            } else {
                store_version(s1, &mut v, dynstr);
            }
            i = 1 as libc::c_int;
            sym = dynsym.offset(1 as libc::c_int as isize);
            while i < nb_syms {
                sym_bind = (*sym).st_info as libc::c_int >> 4 as libc::c_int;
                if !(sym_bind == 0 as libc::c_int) {
                    name = dynstr.offset((*sym).st_name as isize);
                    sym_index = set_elf_sym(
                        (*s1).dynsymtab_section,
                        (*sym).st_value,
                        (*sym).st_size,
                        (*sym).st_info as libc::c_int,
                        (*sym).st_other as libc::c_int,
                        (*sym).st_shndx as libc::c_int,
                        name,
                    );
                    if !(v.versym).is_null() {
                        let mut vsym: Elf64_Half = *(v.versym).offset(i as isize);
                        if vsym as libc::c_int & 0x8000 as libc::c_int
                            == 0 as libc::c_int && vsym as libc::c_int > 0 as libc::c_int
                            && (vsym as libc::c_int) < v.nb_local_ver
                        {
                            set_sym_version(
                                s1,
                                sym_index,
                                *(v.local_ver).offset(vsym as isize),
                            );
                        }
                    }
                }
                i += 1;
                i;
                sym = sym.offset(1);
                sym;
            }
        }
        ret = 0 as libc::c_int;
    }
    tcc_free(dynstr as *mut libc::c_void);
    tcc_free(dynsym as *mut libc::c_void);
    tcc_free(dynamic as *mut libc::c_void);
    tcc_free(shdr as *mut libc::c_void);
    tcc_free(v.local_ver as *mut libc::c_void);
    tcc_free(v.verdef as *mut libc::c_void);
    tcc_free(v.verneed as *mut libc::c_void);
    tcc_free(v.versym as *mut libc::c_void);
    return ret;
}
unsafe extern "C" fn ld_inp(mut s1: *mut TCCState) -> libc::c_int {
    let mut c: libc::c_int = *(*s1).ld_p as libc::c_int;
    if c == 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    (*s1).ld_p = ((*s1).ld_p).offset(1);
    (*s1).ld_p;
    return c;
}
unsafe extern "C" fn ld_next(
    mut s1: *mut TCCState,
    mut name: *mut libc::c_char,
    mut name_size: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut c: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    let mut ch: libc::c_int = 0;
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    loop {
        ch = ld_inp(s1);
        q = name;
        let fresh51 = q;
        q = q.offset(1);
        *fresh51 = ch as libc::c_char;
        match ch {
            32 | 9 | 12 | 11 | 13 | 10 => {}
            47 => {
                ch = ld_inp(s1);
                if !(ch == '*' as i32) {
                    current_block = 17636958641591210995;
                    break;
                }
                d = 0 as libc::c_int;
                loop {
                    ch = ld_inp(s1);
                    if ch == -(1 as libc::c_int) || ch == '/' as i32 && d == '*' as i32 {
                        break;
                    }
                    d = ch;
                }
            }
            92 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109
            | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122
            | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79
            | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 45 | 95 | 46 | 36
            | 126 => {
                current_block = 10599921512955367680;
                break;
            }
            -1 => {
                c = -(1 as libc::c_int);
                current_block = 313581471991351815;
                break;
            }
            _ => {
                c = ch;
                current_block = 313581471991351815;
                break;
            }
        }
    }
    loop {
        match current_block {
            313581471991351815 => {
                *q = '\0' as i32 as libc::c_char;
                break;
            }
            10599921512955367680 => {
                ch = ld_inp(s1);
                current_block = 17636958641591210995;
            }
            _ => {
                if !(ch >= 'a' as i32 && ch <= 'z' as i32
                    || ch >= 'A' as i32 && ch <= 'Z' as i32
                    || ch >= '0' as i32 && ch <= '9' as i32
                    || !(strchr(
                        b"/.-_+=$:\\,~\0" as *const u8 as *const libc::c_char,
                        ch,
                    ))
                        .is_null())
                {
                    if ch != -(1 as libc::c_int) {
                        (*s1).ld_p = ((*s1).ld_p).offset(-1);
                        (*s1).ld_p;
                    }
                    c = 256 as libc::c_int;
                    current_block = 313581471991351815;
                } else {
                    if (q.offset_from(name) as libc::c_long)
                        < (name_size - 1 as libc::c_int) as libc::c_long
                    {
                        let fresh52 = q;
                        q = q.offset(1);
                        *fresh52 = ch as libc::c_char;
                    }
                    current_block = 10599921512955367680;
                }
            }
        }
    }
    return c;
}
unsafe extern "C" fn ld_add_file(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    if *filename.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
        && *filename.offset(1 as libc::c_int as isize) as libc::c_int == 'l' as i32
    {
        return tcc_add_library(s1, filename.offset(2 as libc::c_int as isize));
    }
    if (*::core::mem::transmute::<
        &[u8; 1],
        &[libc::c_char; 1],
    >(b"\0"))[0 as libc::c_int as usize] as libc::c_int != '\0' as i32
    {
        let mut ret: libc::c_int = tcc_add_dll(
            s1,
            tcc_basename(filename),
            0 as libc::c_int,
        );
        if ret != -(2 as libc::c_int) {
            return ret;
        }
    }
    return tcc_add_file_internal(s1, filename, 0x10 as libc::c_int);
}
unsafe extern "C" fn new_undef_sym(
    mut s1: *mut TCCState,
    mut sym_offset: libc::c_int,
) -> libc::c_int {
    while (sym_offset as libc::c_ulong) < (*(*s1).c2rust_unnamed.symtab).data_offset {
        let mut esym: *mut Elf64_Sym = ((*(*s1).c2rust_unnamed.symtab).data)
            .offset(sym_offset as isize) as *mut libc::c_void as *mut Elf64_Sym;
        if (*esym).st_shndx as libc::c_int == 0 as libc::c_int {
            return 1 as libc::c_int;
        }
        sym_offset = (sym_offset as libc::c_ulong)
            .wrapping_add(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
            as libc::c_int as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn ld_add_file_list(
    mut s1: *mut TCCState,
    mut cmd: *const libc::c_char,
) -> libc::c_int {
    let mut filename: [libc::c_char; 1024] = [0; 1024];
    let mut t: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut sym_offset: libc::c_int = 0;
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut pos: *mut libc::c_uchar = (*s1).ld_p;
    loop {
        (*s1).ld_p = pos;
        sym_offset = (*(*s1).c2rust_unnamed.symtab).data_offset as libc::c_int;
        c = *cmd.offset(0 as libc::c_int as isize) as libc::c_int;
        t = ld_next(
            s1,
            filename.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong
                as libc::c_int,
        );
        if t != '(' as i32 {
            tcc_enter_state(s1);
            return (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(b"expected '(' after %s\0" as *const u8 as *const libc::c_char, cmd);
        }
        t = ld_next(
            s1,
            filename.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong
                as libc::c_int,
        );
        loop {
            if t == -(1 as libc::c_int) {
                tcc_enter_state(s1);
                return (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(b"unexpected end of file\0" as *const u8 as *const libc::c_char);
            } else {
                if t == ')' as i32 {
                    break;
                }
                if t != 256 as libc::c_int {
                    tcc_enter_state(s1);
                    return (Some(
                        _tcc_error_noabort
                            as unsafe extern "C" fn(
                                *const libc::c_char,
                                ...
                            ) -> libc::c_int,
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        b"unexpected token '%c'\0" as *const u8 as *const libc::c_char,
                        t,
                    );
                } else if strcmp(
                    filename.as_mut_ptr(),
                    b"AS_NEEDED\0" as *const u8 as *const libc::c_char,
                ) == 0
                {
                    ret = ld_add_file_list(s1, filename.as_mut_ptr());
                } else if c == 'I' as i32 || c == 'G' as i32 || c == 'A' as i32 {
                    ret = ld_add_file(s1, filename.as_mut_ptr() as *const libc::c_char);
                }
                if ret != 0 {
                    return -(1 as libc::c_int);
                }
                t = ld_next(
                    s1,
                    filename.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong
                        as libc::c_int,
                );
                if t == ',' as i32 {
                    t = ld_next(
                        s1,
                        filename.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong
                            as libc::c_int,
                    );
                }
            }
        }
        if !(c == 'G' as i32 && new_undef_sym(s1, sym_offset) != 0) {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcc_load_ldscript(
    mut s1: *mut TCCState,
    mut fd: libc::c_int,
) -> libc::c_int {
    let mut cmd: [libc::c_char; 64] = [0; 64];
    let mut t: libc::c_int = 0;
    let mut ret: libc::c_int = -(3 as libc::c_int);
    let mut text_ptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut saved_ptr: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    saved_ptr = (*s1).ld_p;
    text_ptr = tcc_load_text(fd) as *mut libc::c_void as *mut libc::c_uchar;
    (*s1).ld_p = text_ptr;
    loop {
        t = ld_next(
            s1,
            cmd.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong as libc::c_int,
        );
        if t == -(1 as libc::c_int) {
            break;
        }
        if strcmp(cmd.as_mut_ptr(), b"INPUT\0" as *const u8 as *const libc::c_char) == 0
            || strcmp(cmd.as_mut_ptr(), b"GROUP\0" as *const u8 as *const libc::c_char)
                == 0
        {
            ret = ld_add_file_list(s1, cmd.as_mut_ptr());
        } else if strcmp(
            cmd.as_mut_ptr(),
            b"OUTPUT_FORMAT\0" as *const u8 as *const libc::c_char,
        ) == 0
            || strcmp(cmd.as_mut_ptr(), b"TARGET\0" as *const u8 as *const libc::c_char)
                == 0
        {
            ret = ld_add_file_list(s1, cmd.as_mut_ptr());
        } else if 0 as libc::c_int == ret {
            tcc_enter_state(s1);
            ret = (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(
                b"unexpected '%s'\0" as *const u8 as *const libc::c_char,
                cmd.as_mut_ptr(),
            );
        }
        if ret != 0 {
            break;
        }
    }
    tcc_free(text_ptr as *mut libc::c_void);
    (*s1).ld_p = saved_ptr;
    return ret;
}
static mut g_rc: *mut rt_context = 0 as *const rt_context as *mut rt_context;
static mut signal_set: libc::c_int = 0;
static mut g_s1: *mut TCCState = 0 as *const TCCState as *mut TCCState;
static mut rt_sem: TCCSem = TCCSem {
    init: 0,
    sem: sem_t { __size: [0; 32] },
};
unsafe extern "C" fn rt_wait_sem() {
    wait_sem(&mut rt_sem);
}
unsafe extern "C" fn rt_post_sem() {
    post_sem(&mut rt_sem);
}
unsafe extern "C" fn rt_mem(
    mut s1: *mut TCCState,
    mut size: libc::c_int,
) -> libc::c_int {
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut ptr_diff: libc::c_int = 0 as libc::c_int;
    size = (size as libc::c_long + sysconf(_SC_PAGESIZE as libc::c_int)) as libc::c_int;
    ptr = tcc_malloc(size as libc::c_ulong);
    (*s1).run_ptr = ptr;
    (*s1).run_size = size as libc::c_uint;
    return ptr_diff;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_relocate(mut s1: *mut TCCState) -> libc::c_int {
    let mut size: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut ptr_diff: libc::c_int = 0;
    if !((*s1).run_ptr).is_null() {
        tcc_enter_state(s1);
        exit(
            (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(
                b"'tcc_relocate()' twice is no longer supported\0" as *const u8
                    as *const libc::c_char,
            ),
        );
    }
    if (*s1).do_backtrace != 0 {
        tcc_add_symbol(
            s1,
            b"_tcc_backtrace\0" as *const u8 as *const libc::c_char,
            ::core::mem::transmute::<
                Option::<
                    unsafe extern "C" fn(
                        *mut rt_frame,
                        *const libc::c_char,
                        ::core::ffi::VaList,
                    ) -> libc::c_int,
                >,
                *const libc::c_void,
            >(
                Some(
                    _tcc_backtrace
                        as unsafe extern "C" fn(
                            *mut rt_frame,
                            *const libc::c_char,
                            ::core::ffi::VaList,
                        ) -> libc::c_int,
                ),
            ),
        );
    }
    size = tcc_relocate_ex(s1, 0 as *mut libc::c_void, 0 as libc::c_int as libc::c_uint);
    if size < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    ptr_diff = rt_mem(s1, size);
    if ptr_diff < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    ret = tcc_relocate_ex(s1, (*s1).run_ptr, ptr_diff as libc::c_uint);
    if ret == 0 as libc::c_int {
        st_link(s1);
    }
    return ret;
}
unsafe extern "C" fn tcc_run_free(mut s1: *mut TCCState) {
    let mut size: libc::c_uint = 0;
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s1).nb_loaded_dlls {
        let mut ref_0: *mut DLLReference = *((*s1).loaded_dlls).offset(i as isize);
        if !((*ref_0).handle).is_null() {
            dlclose((*ref_0).handle);
        }
        i += 1;
        i;
    }
    ptr = (*s1).run_ptr;
    if ptr.is_null() {
        return;
    }
    st_unlink(s1);
    size = (*s1).run_size;
    protect_pages(
        (ptr as Elf64_Addr)
            .wrapping_add(
                (ptr as Elf64_Addr).wrapping_neg()
                    & (sysconf(_SC_PAGESIZE as libc::c_int)
                        - 1 as libc::c_int as libc::c_long) as Elf64_Addr,
            ) as *mut libc::c_void,
        (size as libc::c_long - sysconf(_SC_PAGESIZE as libc::c_int)) as libc::c_ulong,
        2 as libc::c_int,
    );
    tcc_free(ptr);
}
#[no_mangle]
pub unsafe extern "C" fn tcc_run(
    mut s1: *mut TCCState,
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut prog_main: Option::<
        unsafe extern "C" fn(
            libc::c_int,
            *mut *mut libc::c_char,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    > = None;
    let mut ret: libc::c_int = 0;
    let mut top_sym: *const libc::c_char = 0 as *const libc::c_char;
    let mut main_jb: jmp_buf = [__jmp_buf_tag {
        __jmpbuf: [0; 8],
        __mask_was_saved: 0,
        __saved_mask: __sigset_t { __val: [0; 16] },
    }; 1];
    let mut envp: *mut *mut libc::c_char = environ;
    if (*s1).dflag as libc::c_int & 16 as libc::c_int != 0
        && -(1 as libc::c_int) as Elf64_Addr
            == get_sym_addr(
                s1,
                b"main\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int,
                1 as libc::c_int,
            )
    {
        return 0 as libc::c_int;
    }
    tcc_add_symbol(
        s1,
        b"__rt_exit\0" as *const u8 as *const libc::c_char,
        ::core::mem::transmute::<
            Option::<unsafe extern "C" fn(*mut rt_frame, libc::c_int) -> ()>,
            *const libc::c_void,
        >(Some(rt_exit as unsafe extern "C" fn(*mut rt_frame, libc::c_int) -> ())),
    );
    if (*s1).nostdlib != 0 {
        top_sym = if !((*s1).elf_entryname).is_null() {
            (*s1).elf_entryname as *const libc::c_char
        } else {
            b"_start\0" as *const u8 as *const libc::c_char
        };
        (*s1).run_main = top_sym;
    } else {
        tcc_add_support(s1, b"runmain.o\0" as *const u8 as *const libc::c_char);
        (*s1).run_main = b"_runmain\0" as *const u8 as *const libc::c_char;
        top_sym = b"main\0" as *const u8 as *const libc::c_char;
    }
    if tcc_relocate(s1) < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    prog_main = ::core::mem::transmute::<
        *mut libc::c_void,
        Option::<
            unsafe extern "C" fn(
                libc::c_int,
                *mut *mut libc::c_char,
                *mut *mut libc::c_char,
            ) -> libc::c_int,
        >,
    >(
        get_sym_addr(s1, (*s1).run_main, 1 as libc::c_int, 1 as libc::c_int)
            as *mut libc::c_void,
    );
    if -(1 as libc::c_int) as Elf64_Addr
        == ::core::mem::transmute::<
            Option::<
                unsafe extern "C" fn(
                    libc::c_int,
                    *mut *mut libc::c_char,
                    *mut *mut libc::c_char,
                ) -> libc::c_int,
            >,
            Elf64_Addr,
        >(prog_main)
    {
        return -(1 as libc::c_int);
    }
    *__errno_location() = 0 as libc::c_int;
    fflush(stdout);
    fflush(stderr);
    ret = _setjmp(
        _tcc_setjmp(
            s1,
            main_jb.as_mut_ptr() as *mut libc::c_void,
            tcc_get_symbol(s1, top_sym),
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut __jmp_buf_tag, libc::c_int) -> !>,
                *mut libc::c_void,
            >(
                Some(
                    longjmp as unsafe extern "C" fn(*mut __jmp_buf_tag, libc::c_int) -> !,
                ),
            ),
        ) as *mut __jmp_buf_tag,
    );
    if 0 as libc::c_int == ret {
        ret = prog_main.expect("non-null function pointer")(argc, argv, envp);
    } else if 0xe0e00e0e as libc::c_uint == ret as libc::c_uint {
        ret = 0 as libc::c_int;
    }
    if (*s1).dflag as libc::c_int & 16 as libc::c_int != 0 && ret != 0 {
        fprintf(
            (*s1).ppfp,
            b"[returns %d]\n\0" as *const u8 as *const libc::c_char,
            ret,
        );
        fflush((*s1).ppfp);
    }
    return ret;
}
unsafe extern "C" fn cleanup_symbols(mut s1: *mut TCCState) {
    let mut s: *mut Section = (*s1).c2rust_unnamed.symtab;
    let mut sym_index: libc::c_int = 0;
    let mut end_sym: libc::c_int = ((*s).data_offset)
        .wrapping_div(::core::mem::size_of::<Elf64_Sym>() as libc::c_ulong)
        as libc::c_int;
    (*(*s).hash).data_offset = 0 as libc::c_int as libc::c_ulong;
    (*(*s).link).data_offset = (*(*s).hash).data_offset;
    (*s).data_offset = (*(*s).link).data_offset;
    init_symtab(s);
    sym_index = 1 as libc::c_int;
    while sym_index < end_sym {
        let mut sym: *mut Elf64_Sym = &mut *((*s).data as *mut Elf64_Sym)
            .offset(sym_index as isize) as *mut Elf64_Sym;
        let mut name: *const libc::c_char = ((*(*s).link).data as *mut libc::c_char)
            .offset((*sym).st_name as isize);
        if !((*sym).st_info as libc::c_int >> 4 as libc::c_int == 0 as libc::c_int) {
            put_elf_sym(
                s,
                (*sym).st_value,
                (*sym).st_size,
                (*sym).st_info as libc::c_int,
                (*sym).st_other as libc::c_int,
                (*sym).st_shndx as libc::c_int,
                name,
            );
        }
        sym_index += 1;
        sym_index;
    }
}
unsafe extern "C" fn cleanup_sections(mut s1: *mut TCCState) {
    let mut p: *mut C2RustUnnamed_37 = &mut (*s1).sections as *mut *mut *mut Section
        as *mut libc::c_void as *mut C2RustUnnamed_37;
    let mut i: libc::c_int = 0;
    let mut f: libc::c_int = 2 as libc::c_int;
    loop {
        f -= 1;
        i = f;
        while i < (*p).nb_secs {
            let mut s: *mut Section = *((*p).secs).offset(i as isize);
            if s == (*s1).c2rust_unnamed.symtab
                || s == (*(*s1).c2rust_unnamed.symtab).link
                || s == (*(*s1).c2rust_unnamed.symtab).hash
            {
                (*s).data_allocated = (*s).data_offset;
                (*s)
                    .data = tcc_realloc(
                    (*s).data as *mut libc::c_void,
                    (*s).data_allocated,
                ) as *mut libc::c_uchar;
            } else {
                free_section(s);
                tcc_free(s as *mut libc::c_void);
                let ref mut fresh53 = *((*p).secs).offset(i as isize);
                *fresh53 = 0 as *mut Section;
            }
            i += 1;
            i;
        }
        p = p.offset(1);
        p;
        if !(f != 0) {
            break;
        }
    };
}
unsafe extern "C" fn tcc_relocate_ex(
    mut s1: *mut TCCState,
    mut ptr: *mut libc::c_void,
    mut ptr_diff: libc::c_uint,
) -> libc::c_int {
    let mut s: *mut Section = 0 as *mut Section;
    let mut offset: libc::c_uint = 0;
    let mut length: libc::c_uint = 0;
    let mut align: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut k: libc::c_uint = 0;
    let mut f: libc::c_uint = 0;
    let mut n: libc::c_uint = 0;
    let mut copy: libc::c_uint = 0;
    let mut mem: Elf64_Addr = 0;
    let mut addr: Elf64_Addr = 0;
    if ptr.is_null() {
        tcc_add_runtime(s1);
        resolve_common_syms(s1);
        build_got_entries(s1, 0 as libc::c_int);
    }
    copy = 0 as libc::c_int as libc::c_uint;
    offset = copy;
    mem = ptr as Elf64_Addr;
    loop {
        if (*s1).verbose as libc::c_int == 2 as libc::c_int && copy != 0 {
            printf(
                &*(b"-----------------------------------------------------\n\0"
                    as *const u8 as *const libc::c_char)
                    .offset(
                        (8 as libc::c_int * 2 as libc::c_int - 8 as libc::c_int) as isize,
                    ) as *const libc::c_char,
            );
        }
        if (*s1).nb_errors != 0 {
            return -(1 as libc::c_int);
        }
        if copy == 3 as libc::c_int as libc::c_uint {
            return 0 as libc::c_int;
        }
        let mut current_block_50: u64;
        k = 0 as libc::c_int as libc::c_uint;
        while k < 3 as libc::c_int as libc::c_uint {
            n = 0 as libc::c_int as libc::c_uint;
            addr = 0 as libc::c_int as Elf64_Addr;
            i = 1 as libc::c_int as libc::c_uint;
            while i < (*s1).nb_sections as libc::c_uint {
                static mut shf: [libc::c_char; 3] = [
                    ((1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 2 as libc::c_int) as libc::c_char,
                    ((1 as libc::c_int) << 1 as libc::c_int) as libc::c_char,
                    ((1 as libc::c_int) << 1 as libc::c_int
                        | (1 as libc::c_int) << 0 as libc::c_int) as libc::c_char,
                ];
                s = *((*s1).sections).offset(i as isize);
                if !(shf[k as usize] as libc::c_int
                    != (*s).sh_flags
                        & ((1 as libc::c_int) << 1 as libc::c_int
                            | (1 as libc::c_int) << 0 as libc::c_int
                            | (1 as libc::c_int) << 2 as libc::c_int))
                {
                    length = (*s).data_offset as libc::c_uint;
                    if copy == 2 as libc::c_int as libc::c_uint {
                        if addr == 0 as libc::c_int as Elf64_Addr {
                            addr = (*s).sh_addr;
                        }
                        n = ((*s).sh_addr)
                            .wrapping_sub(addr)
                            .wrapping_add(length as Elf64_Addr) as libc::c_uint;
                    } else if copy != 0 {
                        if (*s1).verbose as libc::c_int == 2 as libc::c_int {
                            printf(
                                b"%d: %-16s %p  len %05x  align %04x\n\0" as *const u8
                                    as *const libc::c_char,
                                k,
                                ((*s).name).as_mut_ptr(),
                                (*s).sh_addr as *mut libc::c_void,
                                length,
                                (*s).sh_addralign,
                            );
                        }
                        ptr = (*s).sh_addr as *mut libc::c_void;
                        if k == 0 as libc::c_int as libc::c_uint {
                            ptr = ((*s).sh_addr).wrapping_add(ptr_diff as Elf64_Addr)
                                as *mut libc::c_void;
                        }
                        if ((*s).data).is_null() || (*s).sh_type == 8 as libc::c_int {
                            memset(ptr, 0 as libc::c_int, length as libc::c_ulong);
                        } else {
                            memcpy(
                                ptr,
                                (*s).data as *const libc::c_void,
                                length as libc::c_ulong,
                            );
                        }
                    } else {
                        align = (*s).sh_addralign as libc::c_uint;
                        n = n.wrapping_add(1);
                        if n == 1 as libc::c_int as libc::c_uint {
                            if align < 64 as libc::c_int as libc::c_uint {
                                align = 64 as libc::c_int as libc::c_uint;
                            }
                            if k <= 0 as libc::c_int as libc::c_uint {
                                align = sysconf(_SC_PAGESIZE as libc::c_int)
                                    as libc::c_uint;
                            }
                        }
                        (*s).sh_addralign = align as libc::c_int;
                        addr = if k != 0 {
                            mem.wrapping_add(ptr_diff as Elf64_Addr)
                        } else {
                            mem
                        };
                        offset = (offset as Elf64_Addr)
                            .wrapping_add(
                                addr.wrapping_add(offset as Elf64_Addr).wrapping_neg()
                                    & align.wrapping_sub(1 as libc::c_int as libc::c_uint)
                                        as Elf64_Addr,
                            ) as libc::c_uint as libc::c_uint;
                        (*s)
                            .sh_addr = if mem != 0 {
                            addr.wrapping_add(offset as Elf64_Addr)
                        } else {
                            0 as libc::c_int as Elf64_Addr
                        };
                        offset = offset.wrapping_add(length);
                    }
                }
                i = i.wrapping_add(1);
                i;
            }
            if copy == 2 as libc::c_int as libc::c_uint {
                if !(n == 0 as libc::c_int as libc::c_uint) {
                    f = k;
                    if f >= 0 as libc::c_int as libc::c_uint {
                        if f != 0 as libc::c_int as libc::c_uint {
                            current_block_50 = 12209867499936983673;
                        } else {
                            f = 3 as libc::c_int as libc::c_uint;
                            current_block_50 = 1356832168064818221;
                        }
                    } else {
                        current_block_50 = 1356832168064818221;
                    }
                    match current_block_50 {
                        12209867499936983673 => {}
                        _ => {
                            n = (n as Elf64_Addr)
                                .wrapping_add(
                                    (n as Elf64_Addr).wrapping_neg()
                                        & (sysconf(_SC_PAGESIZE as libc::c_int)
                                            - 1 as libc::c_int as libc::c_long) as Elf64_Addr,
                                ) as libc::c_uint;
                            if (*s1).verbose as libc::c_int == 2 as libc::c_int {
                                printf(
                                    b"protect         %3s %p  len %05x\n\0" as *const u8
                                        as *const libc::c_char,
                                    &*(b"rx\0ro\0rw\0rwx\0" as *const u8 as *const libc::c_char)
                                        .offset(
                                            f.wrapping_mul(3 as libc::c_int as libc::c_uint) as isize,
                                        ) as *const libc::c_char,
                                    addr as *mut libc::c_void,
                                    n,
                                );
                            }
                            if protect_pages(
                                addr as *mut libc::c_void,
                                n as libc::c_ulong,
                                f as libc::c_int,
                            ) < 0 as libc::c_int
                            {
                                tcc_enter_state(s1);
                                return (Some(
                                    _tcc_error_noabort
                                        as unsafe extern "C" fn(
                                            *const libc::c_char,
                                            ...
                                        ) -> libc::c_int,
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    b"mprotect failed (did you mean to configure --with-selinux?)\0"
                                        as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                    }
                }
            }
            k = k.wrapping_add(1);
            k;
        }
        if 0 as libc::c_int as Elf64_Addr == mem {
            return (offset as Elf64_Addr)
                .wrapping_add(
                    (offset as Elf64_Addr).wrapping_neg()
                        & (sysconf(_SC_PAGESIZE as libc::c_int)
                            - 1 as libc::c_int as libc::c_long) as Elf64_Addr,
                ) as libc::c_int;
        }
        copy = copy.wrapping_add(1);
        if copy == 2 as libc::c_int as libc::c_uint {
            continue;
        }
        if copy == 3 as libc::c_int as libc::c_uint {
            cleanup_symbols(s1);
            cleanup_sections(s1);
        } else {
            relocate_syms(s1, (*s1).c2rust_unnamed.symtab, 1 as libc::c_int);
            relocate_plt(s1);
            relocate_sections(s1);
        }
    };
}
unsafe extern "C" fn protect_pages(
    mut ptr: *mut libc::c_void,
    mut length: libc::c_ulong,
    mut mode: libc::c_int,
) -> libc::c_int {
    static mut protect: [libc::c_uchar; 4] = [
        (0x1 as libc::c_int | 0x4 as libc::c_int) as libc::c_uchar,
        0x1 as libc::c_int as libc::c_uchar,
        (0x1 as libc::c_int | 0x2 as libc::c_int) as libc::c_uchar,
        (0x1 as libc::c_int | 0x2 as libc::c_int | 0x4 as libc::c_int) as libc::c_uchar,
    ];
    if mprotect(ptr, length, protect[mode as usize] as libc::c_int) != 0 {
        return -(1 as libc::c_int);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn bt_link(mut s1: *mut TCCState) {
    let mut rc: *mut rt_context = 0 as *mut rt_context;
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    if (*s1).do_backtrace == 0 {
        return;
    }
    rc = tcc_get_symbol(s1, b"__rt_info\0" as *const u8 as *const libc::c_char)
        as *mut rt_context;
    if rc.is_null() {
        return;
    }
    (*rc).esym_start = (*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym;
    (*rc)
        .esym_end = ((*(*s1).c2rust_unnamed.symtab_section).data)
        .offset((*(*s1).c2rust_unnamed.symtab_section).data_offset as isize)
        as *mut Elf64_Sym;
    (*rc)
        .elf_str = (*(*(*s1).c2rust_unnamed.symtab_section).link).data
        as *mut libc::c_char;
    if 8 as libc::c_int == 8 as libc::c_int && (*s1).dwarf == 0 {
        (*rc)
            .prog_base = ((*rc).prog_base as libc::c_ulonglong
            & 0xffffffff00000000 as libc::c_ulonglong) as Elf64_Addr;
    }
    if (*s1).do_bounds_check != 0 {
        p = tcc_get_symbol(s1, b"__bound_init\0" as *const u8 as *const libc::c_char);
        if !p.is_null() {
            (::core::mem::transmute::<
                *mut libc::c_void,
                Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
            >(p))
                .expect(
                    "non-null function pointer",
                )((*rc).bounds_start, 1 as libc::c_int);
        }
    }
    (*rc).next = g_rc;
    g_rc = rc;
    (*s1).rc = rc;
    if 0 as libc::c_int == signal_set {
        set_exception_handler();
        signal_set = 1 as libc::c_int;
    }
}
unsafe extern "C" fn st_link(mut s1: *mut TCCState) {
    rt_wait_sem();
    (*s1).next = g_s1;
    g_s1 = s1;
    bt_link(s1);
    rt_post_sem();
}
unsafe extern "C" fn ptr_unlink(
    mut list: *mut libc::c_void,
    mut e: *mut libc::c_void,
    mut next_0: libc::c_uint,
) {
    let mut pp: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
    let mut nn: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    pp = list as *mut *mut libc::c_void;
    loop {
        p = *pp;
        if p.is_null() {
            break;
        }
        nn = (p as *mut libc::c_char).offset(next_0 as isize) as *mut libc::c_void
            as *mut *mut libc::c_void;
        if p == e {
            *pp = *nn;
            break;
        } else {
            pp = nn;
        }
    };
}
unsafe extern "C" fn st_unlink(mut s1: *mut TCCState) {
    rt_wait_sem();
    ptr_unlink(
        &mut g_rc as *mut *mut rt_context as *mut libc::c_void,
        (*s1).rc as *mut libc::c_void,
        &mut (*(0 as *mut rt_context)).next as *mut *mut rt_context as size_t
            as libc::c_uint,
    );
    ptr_unlink(
        &mut g_s1 as *mut *mut TCCState as *mut libc::c_void,
        s1 as *mut libc::c_void,
        &mut (*(0 as *mut TCCState)).next as *mut *mut TCCState as size_t as libc::c_uint,
    );
    rt_post_sem();
}
#[no_mangle]
pub unsafe extern "C" fn _tcc_setjmp(
    mut s1: *mut TCCState,
    mut p_jmp_buf: *mut libc::c_void,
    mut func: *mut libc::c_void,
    mut p_longjmp: *mut libc::c_void,
) -> *mut libc::c_void {
    (*s1).run_lj = p_longjmp;
    (*s1).run_jb = p_jmp_buf;
    if !((*s1).rc).is_null() {
        (*(*s1).rc).top_func = func;
    }
    return p_jmp_buf;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_set_backtrace_func(
    mut s1: *mut TCCState,
    mut data: *mut libc::c_void,
    mut func: Option::<TCCBtFunc>,
) {
    (*s1).bt_func = func;
    (*s1).bt_data = data;
}
unsafe extern "C" fn rt_find_state(mut f: *mut rt_frame) -> *mut TCCState {
    let mut s: *mut TCCState = 0 as *mut TCCState;
    let mut level: libc::c_int = 0;
    let mut pc: Elf64_Addr = 0;
    s = g_s1;
    if s.is_null() || ((*s).next).is_null() {
        return s;
    }
    level = 0 as libc::c_int;
    while level < 8 as libc::c_int {
        if rt_get_caller_pc(&mut pc, f, level) < 0 as libc::c_int {
            break;
        }
        s = g_s1;
        while !s.is_null() {
            if pc >= (*s).run_ptr as Elf64_Addr
                && pc
                    < ((*s).run_ptr as Elf64_Addr)
                        .wrapping_add((*s).run_size as Elf64_Addr)
            {
                return s;
            }
            s = (*s).next;
        }
        level += 1;
        level;
    }
    return 0 as *mut TCCState;
}
unsafe extern "C" fn rt_exit(mut f: *mut rt_frame, mut code: libc::c_int) {
    let mut s: *mut TCCState = 0 as *mut TCCState;
    rt_wait_sem();
    s = rt_find_state(f);
    rt_post_sem();
    if !s.is_null() && !((*s).run_lj).is_null() {
        if code == 0 as libc::c_int {
            code = 0xe0e00e0e as libc::c_uint as libc::c_int;
        }
        (::core::mem::transmute::<
            *mut libc::c_void,
            Option::<unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> ()>,
        >((*s).run_lj))
            .expect("non-null function pointer")((*s).run_jb, code);
    }
    exit(code);
}
unsafe extern "C" fn rt_vprintf(
    mut fmt: *const libc::c_char,
    mut ap: ::core::ffi::VaList,
) -> libc::c_int {
    let mut ret: libc::c_int = vfprintf(stderr, fmt, ap.as_va_list());
    fflush(stderr);
    return ret;
}
unsafe extern "C" fn rt_printf(
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    let mut r: libc::c_int = 0;
    ap = args.clone();
    r = rt_vprintf(fmt, ap.as_va_list());
    return r;
}
unsafe extern "C" fn rt_elfsym(
    mut rc: *mut rt_context,
    mut wanted_pc: Elf64_Addr,
    mut func_addr: *mut Elf64_Addr,
) -> *mut libc::c_char {
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    esym = ((*rc).esym_start).offset(1 as libc::c_int as isize);
    while esym < (*rc).esym_end {
        let mut type_0: libc::c_int = (*esym).st_info as libc::c_int
            & 0xf as libc::c_int;
        if (type_0 == 2 as libc::c_int || type_0 == 10 as libc::c_int)
            && wanted_pc >= (*esym).st_value
            && wanted_pc < ((*esym).st_value).wrapping_add((*esym).st_size)
        {
            *func_addr = (*esym).st_value;
            return ((*rc).elf_str).offset((*esym).st_name as isize);
        }
        esym = esym.offset(1);
        esym;
    }
    return 0 as *mut libc::c_char;
}
unsafe extern "C" fn rt_printline(
    mut rc: *mut rt_context,
    mut wanted_pc: Elf64_Addr,
    mut bi: *mut bt_info,
) -> Elf64_Addr {
    let mut current_block: u64;
    let mut func_name: [libc::c_char; 128] = [0; 128];
    let mut func_addr: Elf64_Addr = 0;
    let mut last_pc: Elf64_Addr = 0;
    let mut pc: Elf64_Addr = 0;
    let mut incl_files: [*const libc::c_char; 32] = [0 as *const libc::c_char; 32];
    let mut incl_index: libc::c_int = 0;
    let mut last_incl_index: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut last_line_num_0: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut sym: *mut Stab_Sym = 0 as *mut Stab_Sym;
    func_name[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    func_addr = 0 as libc::c_int as Elf64_Addr;
    incl_index = 0 as libc::c_int;
    last_pc = -(1 as libc::c_int) as Elf64_Addr;
    last_line_num_0 = 1 as libc::c_int;
    last_incl_index = 0 as libc::c_int;
    sym = ((*rc).c2rust_unnamed.c2rust_unnamed.stab_sym)
        .offset(1 as libc::c_int as isize);
    loop {
        if !(sym < (*rc).c2rust_unnamed.c2rust_unnamed.stab_sym_end) {
            current_block = 5330834795799507926;
            break;
        }
        str = ((*rc).c2rust_unnamed.c2rust_unnamed.stab_str)
            .offset((*sym).n_strx as isize);
        pc = (*sym).n_value as Elf64_Addr;
        match (*sym).n_type as libc::c_int {
            68 => {
                if func_addr != 0 {
                    current_block = 6085873854048821940;
                } else {
                    current_block = 17477724584390429951;
                }
            }
            100 | 132 => {
                current_block = 17477724584390429951;
            }
            36 => {
                if (*sym).n_strx == 0 as libc::c_int as libc::c_uint {
                    current_block = 6085873854048821940;
                } else {
                    current_block = 17477724584390429951;
                }
            }
            _ => {
                current_block = 17833034027772472439;
            }
        }
        match current_block {
            17477724584390429951 => {
                pc = pc.wrapping_add((*rc).prog_base);
                current_block = 4203359689375638918;
            }
            6085873854048821940 => {
                pc = pc.wrapping_add(func_addr);
                current_block = 4203359689375638918;
            }
            _ => {}
        }
        match current_block {
            4203359689375638918 => {
                if pc >= wanted_pc && wanted_pc >= last_pc {
                    current_block = 15656765100548859355;
                    break;
                }
            }
            _ => {}
        }
        let mut current_block_33: u64;
        match (*sym).n_type as libc::c_int {
            36 => {
                if (*sym).n_strx == 0 as libc::c_int as libc::c_uint {
                    current_block_33 = 1566480483637074976;
                } else {
                    p = strchr(str, ':' as i32);
                    if p.is_null()
                        || {
                            len = (p.offset_from(str) as libc::c_long
                                + 1 as libc::c_int as libc::c_long) as libc::c_int;
                            len as libc::c_ulong
                                > ::core::mem::size_of::<[libc::c_char; 128]>()
                                    as libc::c_ulong
                        }
                    {
                        len = ::core::mem::size_of::<[libc::c_char; 128]>()
                            as libc::c_ulong as libc::c_int;
                    }
                    pstrcpy(func_name.as_mut_ptr(), len as size_t, str);
                    func_addr = pc;
                    current_block_33 = 10891380440665537214;
                }
            }
            68 => {
                last_pc = pc;
                last_line_num_0 = (*sym).n_desc as libc::c_int;
                last_incl_index = incl_index;
                current_block_33 = 10891380440665537214;
            }
            130 => {
                if incl_index < 32 as libc::c_int {
                    let fresh54 = incl_index;
                    incl_index = incl_index + 1;
                    incl_files[fresh54 as usize] = str;
                }
                current_block_33 = 10891380440665537214;
            }
            162 => {
                if incl_index > 1 as libc::c_int {
                    incl_index -= 1;
                    incl_index;
                }
                current_block_33 = 10891380440665537214;
            }
            100 => {
                incl_index = 0 as libc::c_int;
                if (*sym).n_strx != 0 {
                    len = strlen(str) as libc::c_int;
                    if len > 0 as libc::c_int
                        && *str.offset((len - 1 as libc::c_int) as isize) as libc::c_int
                            != '/' as i32
                    {
                        let fresh55 = incl_index;
                        incl_index = incl_index + 1;
                        incl_files[fresh55 as usize] = str;
                    }
                }
                current_block_33 = 1566480483637074976;
            }
            132 => {
                if incl_index != 0 {
                    incl_files[(incl_index - 1 as libc::c_int) as usize] = str;
                }
                current_block_33 = 10891380440665537214;
            }
            _ => {
                current_block_33 = 10891380440665537214;
            }
        }
        match current_block_33 {
            1566480483637074976 => {
                func_name[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
                func_addr = 0 as libc::c_int as Elf64_Addr;
                last_pc = -(1 as libc::c_int) as Elf64_Addr;
            }
            _ => {}
        }
        sym = sym.offset(1);
        sym;
    }
    match current_block {
        5330834795799507926 => {
            last_incl_index = 0 as libc::c_int;
            func_name[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            func_addr = 0 as libc::c_int as Elf64_Addr;
        }
        _ => {}
    }
    i = last_incl_index;
    if i > 0 as libc::c_int {
        i -= 1;
        pstrcpy(
            ((*bi).file).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            incl_files[i as usize],
        );
        (*bi).line = last_line_num_0;
    }
    pstrcpy(
        ((*bi).func).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
        func_name.as_mut_ptr(),
    );
    (*bi).func_pc = func_addr;
    return func_addr;
}
unsafe extern "C" fn rt_printline_dwarf(
    mut rc: *mut rt_context,
    mut wanted_pc: Elf64_Addr,
    mut bi: *mut bt_info,
) -> Elf64_Addr {
    let mut current_block: u64;
    let mut ln: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut cp: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut end: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut opcode_length: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut size: libc::c_ulonglong = 0;
    let mut length: libc::c_uint = 0;
    let mut version: libc::c_uchar = 0;
    let mut min_insn_length: libc::c_uint = 0;
    let mut max_ops_per_insn: libc::c_uint = 0;
    let mut line_base: libc::c_int = 0;
    let mut line_range: libc::c_uint = 0;
    let mut opcode_base: libc::c_uint = 0;
    let mut opindex: libc::c_uint = 0;
    let mut col: libc::c_uint = 0;
    let mut i: libc::c_uint = 0;
    let mut j: libc::c_uint = 0;
    let mut len: libc::c_uint = 0;
    let mut value: libc::c_ulonglong = 0;
    let mut entry_format: [C2RustUnnamed_36; 256] = [C2RustUnnamed_36 {
        type_0: 0,
        form: 0,
    }; 256];
    let mut dir_size: libc::c_uint = 0;
    let mut filename_size: libc::c_uint = 0;
    let mut filename_table: [C2RustUnnamed_35; 512] = [C2RustUnnamed_35 {
        dir_entry: 0,
        name: 0 as *mut libc::c_char,
    }; 512];
    let mut last_pc: Elf64_Addr = 0;
    let mut pc: Elf64_Addr = 0;
    let mut func_addr: Elf64_Addr = 0;
    let mut line: libc::c_int = 0;
    let mut filename: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut function: *mut libc::c_char = 0 as *mut libc::c_char;
    filename = 0 as *mut libc::c_char;
    function = 0 as *mut libc::c_char;
    func_addr = 0 as libc::c_int as Elf64_Addr;
    line = 0 as libc::c_int;
    ln = (*rc).c2rust_unnamed.c2rust_unnamed_0.dwarf_line;
    's_72: loop {
        if !(ln < (*rc).c2rust_unnamed.c2rust_unnamed_0.dwarf_line_end) {
            current_block = 8466485602140941539;
            break;
        }
        dir_size = 0 as libc::c_int as libc::c_uint;
        filename_size = 0 as libc::c_int as libc::c_uint;
        last_pc = 0 as libc::c_int as Elf64_Addr;
        pc = 0 as libc::c_int as Elf64_Addr;
        func_addr = 0 as libc::c_int as Elf64_Addr;
        line = 1 as libc::c_int;
        filename = 0 as *mut libc::c_char;
        function = 0 as *mut libc::c_char;
        length = 4 as libc::c_int as libc::c_uint;
        size = (if ln.offset(3 as libc::c_int as isize)
            < (*rc).c2rust_unnamed.c2rust_unnamed_0.dwarf_line_end
        {
            ln = ln.offset(4 as libc::c_int as isize);
            read32le(ln.offset(-(4 as libc::c_int as isize)))
        } else {
            0 as libc::c_int as uint32_t
        }) as libc::c_ulonglong;
        if size == 0xffffffff as libc::c_uint as libc::c_ulonglong {
            length = 8 as libc::c_int as libc::c_uint;
            size = (if ln.offset(7 as libc::c_int as isize)
                < (*rc).c2rust_unnamed.c2rust_unnamed_0.dwarf_line_end
            {
                ln = ln.offset(8 as libc::c_int as isize);
                read64le(ln.offset(-(8 as libc::c_int as isize)))
            } else {
                0 as libc::c_int as uint64_t
            }) as libc::c_ulonglong;
        }
        end = ln.offset(size as isize);
        if end < ln || end > (*rc).c2rust_unnamed.c2rust_unnamed_0.dwarf_line_end {
            current_block = 8466485602140941539;
            break;
        }
        version = (if ln.offset(1 as libc::c_int as isize) < end {
            ln = ln.offset(2 as libc::c_int as isize);
            read16le(ln.offset(-(2 as libc::c_int as isize))) as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uchar;
        if version as libc::c_int >= 5 as libc::c_int {
            ln = ln
                .offset(length.wrapping_add(2 as libc::c_int as libc::c_uint) as isize);
        } else {
            ln = ln.offset(length as isize);
        }
        min_insn_length = (if ln < end {
            let fresh56 = ln;
            ln = ln.offset(1);
            *fresh56 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        if version as libc::c_int >= 4 as libc::c_int {
            max_ops_per_insn = (if ln < end {
                let fresh57 = ln;
                ln = ln.offset(1);
                *fresh57 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uint;
        } else {
            max_ops_per_insn = 1 as libc::c_int as libc::c_uint;
        }
        ln = ln.offset(1);
        ln;
        line_base = if ln < end {
            let fresh58 = ln;
            ln = ln.offset(1);
            *fresh58 as libc::c_int
        } else {
            0 as libc::c_int
        };
        line_base
            |= if line_base >= 0x80 as libc::c_int {
                !(0xff as libc::c_int)
            } else {
                0 as libc::c_int
            };
        line_range = (if ln < end {
            let fresh59 = ln;
            ln = ln.offset(1);
            *fresh59 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        opcode_base = (if ln < end {
            let fresh60 = ln;
            ln = ln.offset(1);
            *fresh60 as libc::c_int
        } else {
            0 as libc::c_int
        }) as libc::c_uint;
        opcode_length = ln;
        ln = ln
            .offset(opcode_base.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize);
        opindex = 0 as libc::c_int as libc::c_uint;
        if version as libc::c_int >= 5 as libc::c_int {
            col = (if ln < end {
                let fresh61 = ln;
                ln = ln.offset(1);
                *fresh61 as libc::c_int
            } else {
                0 as libc::c_int
            }) as libc::c_uint;
            i = 0 as libc::c_int as libc::c_uint;
            while i < col {
                entry_format[i as usize]
                    .type_0 = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                entry_format[i as usize]
                    .form = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                i = i.wrapping_add(1);
                i;
            }
            dir_size = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
            i = 0 as libc::c_int as libc::c_uint;
            's_208: loop {
                if !(i < dir_size) {
                    current_block = 9512719473022792396;
                    break;
                }
                j = 0 as libc::c_int as libc::c_uint;
                while j < col {
                    if entry_format[j as usize].type_0
                        == DW_LNCT_path as libc::c_int as libc::c_uint
                    {
                        if entry_format[j as usize].form
                            != DW_FORM_line_strp as libc::c_int as libc::c_uint
                        {
                            current_block = 5627086376286249267;
                            break 's_208;
                        }
                        if length == 4 as libc::c_int as libc::c_uint {
                            if ln.offset(3 as libc::c_int as isize) < end {
                                ln = ln.offset(4 as libc::c_int as isize);
                                read32le(ln.offset(-(4 as libc::c_int as isize)));
                            } else {};
                        } else {
                            if ln.offset(7 as libc::c_int as isize) < end {
                                ln = ln.offset(8 as libc::c_int as isize);
                                read64le(ln.offset(-(8 as libc::c_int as isize)));
                            } else {};
                        };
                    } else {
                        match entry_format[j as usize].form {
                            11 => {
                                ln = ln.offset(1 as libc::c_int as isize);
                            }
                            5 => {
                                ln = ln.offset(2 as libc::c_int as isize);
                            }
                            6 => {
                                ln = ln.offset(3 as libc::c_int as isize);
                            }
                            7 => {
                                ln = ln.offset(8 as libc::c_int as isize);
                            }
                            30 => {
                                ln = ln.offset(16 as libc::c_int as isize);
                            }
                            15 => {
                                dwarf_read_uleb128(&mut ln, end);
                            }
                            _ => {
                                current_block = 5627086376286249267;
                                break 's_208;
                            }
                        }
                    }
                    j = j.wrapping_add(1);
                    j;
                }
                i = i.wrapping_add(1);
                i;
            }
            match current_block {
                5627086376286249267 => {}
                _ => {
                    col = (if ln < end {
                        let fresh62 = ln;
                        ln = ln.offset(1);
                        *fresh62 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uint;
                    i = 0 as libc::c_int as libc::c_uint;
                    while i < col {
                        entry_format[i as usize]
                            .type_0 = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                        entry_format[i as usize]
                            .form = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                        i = i.wrapping_add(1);
                        i;
                    }
                    filename_size = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                    i = 0 as libc::c_int as libc::c_uint;
                    's_330: loop {
                        if !(i < filename_size) {
                            current_block = 2522825242109451841;
                            break;
                        }
                        j = 0 as libc::c_int as libc::c_uint;
                        while j < col {
                            if entry_format[j as usize].type_0
                                == DW_LNCT_path as libc::c_int as libc::c_uint
                            {
                                if entry_format[j as usize].form
                                    != DW_FORM_line_strp as libc::c_int as libc::c_uint
                                {
                                    current_block = 5627086376286249267;
                                    break 's_330;
                                }
                                value = (if length == 4 as libc::c_int as libc::c_uint {
                                    (if ln.offset(3 as libc::c_int as isize) < end {
                                        ln = ln.offset(4 as libc::c_int as isize);
                                        read32le(ln.offset(-(4 as libc::c_int as isize)))
                                    } else {
                                        0 as libc::c_int as uint32_t
                                    }) as uint64_t
                                } else if ln.offset(7 as libc::c_int as isize) < end {
                                    ln = ln.offset(8 as libc::c_int as isize);
                                    read64le(ln.offset(-(8 as libc::c_int as isize)))
                                } else {
                                    0 as libc::c_int as uint64_t
                                }) as libc::c_ulonglong;
                                if i < 512 as libc::c_int as libc::c_uint {
                                    filename_table[i as usize]
                                        .name = ((*rc)
                                        .c2rust_unnamed
                                        .c2rust_unnamed_0
                                        .dwarf_line_str as *mut libc::c_char)
                                        .offset(value as isize);
                                }
                            } else if entry_format[j as usize].type_0
                                == DW_LNCT_directory_index as libc::c_int as libc::c_uint
                            {
                                match entry_format[j as usize].form {
                                    11 => {
                                        value = (if ln < end {
                                            let fresh63 = ln;
                                            ln = ln.offset(1);
                                            *fresh63 as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_ulonglong;
                                    }
                                    5 => {
                                        value = (if ln.offset(1 as libc::c_int as isize) < end {
                                            ln = ln.offset(2 as libc::c_int as isize);
                                            read16le(ln.offset(-(2 as libc::c_int as isize)))
                                                as libc::c_int
                                        } else {
                                            0 as libc::c_int
                                        }) as libc::c_ulonglong;
                                    }
                                    6 => {
                                        value = (if ln.offset(3 as libc::c_int as isize) < end {
                                            ln = ln.offset(4 as libc::c_int as isize);
                                            read32le(ln.offset(-(4 as libc::c_int as isize)))
                                        } else {
                                            0 as libc::c_int as uint32_t
                                        }) as libc::c_ulonglong;
                                    }
                                    15 => {
                                        value = dwarf_read_uleb128(&mut ln, end)
                                            as libc::c_ulonglong;
                                    }
                                    _ => {
                                        current_block = 5627086376286249267;
                                        break 's_330;
                                    }
                                }
                                if i < 512 as libc::c_int as libc::c_uint {
                                    filename_table[i as usize]
                                        .dir_entry = value as libc::c_uint;
                                }
                            } else {
                                match entry_format[j as usize].form {
                                    11 => {
                                        ln = ln.offset(1 as libc::c_int as isize);
                                    }
                                    5 => {
                                        ln = ln.offset(2 as libc::c_int as isize);
                                    }
                                    6 => {
                                        ln = ln.offset(3 as libc::c_int as isize);
                                    }
                                    7 => {
                                        ln = ln.offset(8 as libc::c_int as isize);
                                    }
                                    30 => {
                                        ln = ln.offset(16 as libc::c_int as isize);
                                    }
                                    15 => {
                                        dwarf_read_uleb128(&mut ln, end);
                                    }
                                    _ => {
                                        current_block = 5627086376286249267;
                                        break 's_330;
                                    }
                                }
                            }
                            j = j.wrapping_add(1);
                            j;
                        }
                        i = i.wrapping_add(1);
                        i;
                    }
                }
            }
        } else {
            while if ln < end {
                let fresh64 = ln;
                ln = ln.offset(1);
                *fresh64 as libc::c_int
            } else {
                0 as libc::c_int
            } != 0
            {
                while if ln < end {
                    let fresh65 = ln;
                    ln = ln.offset(1);
                    *fresh65 as libc::c_int
                } else {
                    0 as libc::c_int
                } != 0
                {}
            }
            while if ln < end {
                let fresh66 = ln;
                ln = ln.offset(1);
                *fresh66 as libc::c_int
            } else {
                0 as libc::c_int
            } != 0
            {
                filename_size = filename_size.wrapping_add(1);
                if filename_size < 512 as libc::c_int as libc::c_uint {
                    filename_table[filename_size
                            .wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                        .name = (ln as *mut libc::c_char)
                        .offset(-(1 as libc::c_int as isize));
                    while if ln < end {
                        let fresh67 = ln;
                        ln = ln.offset(1);
                        *fresh67 as libc::c_int
                    } else {
                        0 as libc::c_int
                    } != 0
                    {}
                    filename_table[filename_size
                            .wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                        .dir_entry = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                } else {
                    while if ln < end {
                        let fresh68 = ln;
                        ln = ln.offset(1);
                        *fresh68 as libc::c_int
                    } else {
                        0 as libc::c_int
                    } != 0
                    {}
                    dwarf_read_uleb128(&mut ln, end);
                }
                dwarf_read_uleb128(&mut ln, end);
                dwarf_read_uleb128(&mut ln, end);
            }
            current_block = 2522825242109451841;
        }
        match current_block {
            2522825242109451841 => {
                if filename_size >= 1 as libc::c_int as libc::c_uint {
                    filename = filename_table[0 as libc::c_int as usize].name;
                }
                while ln < end {
                    last_pc = pc;
                    i = (if ln < end {
                        let fresh69 = ln;
                        ln = ln.offset(1);
                        *fresh69 as libc::c_int
                    } else {
                        0 as libc::c_int
                    }) as libc::c_uint;
                    if i >= opcode_base {
                        if max_ops_per_insn == 1 as libc::c_int as libc::c_uint {
                            pc = pc
                                .wrapping_add(
                                    i
                                        .wrapping_sub(opcode_base)
                                        .wrapping_div(line_range)
                                        .wrapping_mul(min_insn_length) as Elf64_Addr,
                                );
                        } else {
                            pc = pc
                                .wrapping_add(
                                    opindex
                                        .wrapping_add(
                                            i.wrapping_sub(opcode_base).wrapping_div(line_range),
                                        )
                                        .wrapping_div(max_ops_per_insn)
                                        .wrapping_mul(min_insn_length) as Elf64_Addr,
                                );
                            opindex = opindex
                                .wrapping_add(
                                    i.wrapping_sub(opcode_base).wrapping_div(line_range),
                                )
                                .wrapping_rem(max_ops_per_insn);
                        }
                        i = (i.wrapping_sub(opcode_base).wrapping_rem(line_range)
                            as libc::c_int + line_base) as libc::c_uint;
                    } else {
                        match i {
                            0 => {
                                len = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                                cp = ln;
                                ln = ln.offset(len as isize);
                                if len == 0 as libc::c_int as libc::c_uint {
                                    break;
                                }
                                match if cp < end {
                                    let fresh70 = cp;
                                    cp = cp.offset(1);
                                    *fresh70 as libc::c_int
                                } else {
                                    0 as libc::c_int
                                } {
                                    2 => {
                                        pc = if cp.offset(7 as libc::c_int as isize) < end {
                                            cp = cp.offset(8 as libc::c_int as isize);
                                            read64le(cp.offset(-(8 as libc::c_int as isize)))
                                        } else {
                                            0 as libc::c_int as uint64_t
                                        };
                                        opindex = 0 as libc::c_int as libc::c_uint;
                                    }
                                    3 => {
                                        filename_size = filename_size.wrapping_add(1);
                                        if filename_size < 512 as libc::c_int as libc::c_uint {
                                            filename_table[filename_size
                                                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                                                .name = (ln as *mut libc::c_char)
                                                .offset(-(1 as libc::c_int as isize));
                                            while if ln < end {
                                                let fresh71 = ln;
                                                ln = ln.offset(1);
                                                *fresh71 as libc::c_int
                                            } else {
                                                0 as libc::c_int
                                            } != 0
                                            {}
                                            filename_table[filename_size
                                                    .wrapping_sub(1 as libc::c_int as libc::c_uint) as usize]
                                                .dir_entry = dwarf_read_uleb128(&mut ln, end)
                                                as libc::c_uint;
                                        } else {
                                            while if ln < end {
                                                let fresh72 = ln;
                                                ln = ln.offset(1);
                                                *fresh72 as libc::c_int
                                            } else {
                                                0 as libc::c_int
                                            } != 0
                                            {}
                                            dwarf_read_uleb128(&mut ln, end);
                                        }
                                        dwarf_read_uleb128(&mut ln, end);
                                        dwarf_read_uleb128(&mut ln, end);
                                    }
                                    254 => {
                                        function = cp as *mut libc::c_char;
                                        func_addr = pc;
                                    }
                                    1 | _ => {}
                                }
                                continue;
                            }
                            2 => {
                                if max_ops_per_insn == 1 as libc::c_int as libc::c_uint {
                                    pc = (pc as uint64_t)
                                        .wrapping_add(
                                            dwarf_read_uleb128(&mut ln, end)
                                                * min_insn_length as uint64_t,
                                        ) as Elf64_Addr as Elf64_Addr;
                                } else {
                                    let mut off: libc::c_ulonglong = dwarf_read_uleb128(
                                        &mut ln,
                                        end,
                                    ) as libc::c_ulonglong;
                                    pc = (pc as libc::c_ulonglong)
                                        .wrapping_add(
                                            (opindex as libc::c_ulonglong)
                                                .wrapping_add(off)
                                                .wrapping_div(max_ops_per_insn as libc::c_ulonglong)
                                                .wrapping_mul(min_insn_length as libc::c_ulonglong),
                                        ) as Elf64_Addr as Elf64_Addr;
                                    opindex = (opindex as libc::c_ulonglong)
                                        .wrapping_add(off)
                                        .wrapping_rem(max_ops_per_insn as libc::c_ulonglong)
                                        as libc::c_uint;
                                }
                                i = 0 as libc::c_int as libc::c_uint;
                            }
                            3 => {
                                line = (line as int64_t + dwarf_read_sleb128(&mut ln, end))
                                    as libc::c_int;
                                continue;
                            }
                            4 => {
                                i = dwarf_read_uleb128(&mut ln, end) as libc::c_uint;
                                i = i
                                    .wrapping_sub(
                                        (i > 0 as libc::c_int as libc::c_uint
                                            && (version as libc::c_int) < 5 as libc::c_int)
                                            as libc::c_int as libc::c_uint,
                                    );
                                if i < 512 as libc::c_int as libc::c_uint
                                    && i < filename_size
                                {
                                    filename = filename_table[i as usize].name;
                                }
                                continue;
                            }
                            8 => {
                                if max_ops_per_insn == 1 as libc::c_int as libc::c_uint {
                                    pc = pc
                                        .wrapping_add(
                                            (255 as libc::c_int as libc::c_uint)
                                                .wrapping_sub(opcode_base)
                                                .wrapping_div(line_range)
                                                .wrapping_mul(min_insn_length) as Elf64_Addr,
                                        );
                                } else {
                                    let mut off_0: libc::c_uint = (255 as libc::c_int
                                        as libc::c_uint)
                                        .wrapping_sub(opcode_base)
                                        .wrapping_div(line_range);
                                    pc = pc
                                        .wrapping_add(
                                            opindex
                                                .wrapping_add(off_0)
                                                .wrapping_div(max_ops_per_insn)
                                                .wrapping_mul(min_insn_length) as Elf64_Addr,
                                        );
                                    opindex = opindex
                                        .wrapping_add(off_0)
                                        .wrapping_rem(max_ops_per_insn);
                                }
                                i = 0 as libc::c_int as libc::c_uint;
                            }
                            9 => {
                                i = (if ln.offset(1 as libc::c_int as isize) < end {
                                    ln = ln.offset(2 as libc::c_int as isize);
                                    read16le(ln.offset(-(2 as libc::c_int as isize)))
                                        as libc::c_int
                                } else {
                                    0 as libc::c_int
                                }) as libc::c_uint;
                                pc = pc.wrapping_add(i as Elf64_Addr);
                                opindex = 0 as libc::c_int as libc::c_uint;
                                i = 0 as libc::c_int as libc::c_uint;
                            }
                            _ => {
                                j = 0 as libc::c_int as libc::c_uint;
                                while j
                                    < *opcode_length
                                        .offset(
                                            i.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize,
                                        ) as libc::c_uint
                                {
                                    dwarf_read_uleb128(&mut ln, end);
                                    j = j.wrapping_add(1);
                                    j;
                                }
                                continue;
                            }
                        }
                    }
                    if pc >= wanted_pc && wanted_pc >= last_pc {
                        current_block = 7595157757081118675;
                        break 's_72;
                    }
                    line = (line as libc::c_uint).wrapping_add(i) as libc::c_int
                        as libc::c_int;
                }
            }
            _ => {}
        }
        ln = end;
    }
    match current_block {
        8466485602140941539 => {
            function = 0 as *mut libc::c_char;
            filename = function;
            func_addr = 0 as libc::c_int as Elf64_Addr;
        }
        _ => {}
    }
    if !filename.is_null() {
        pstrcpy(
            ((*bi).file).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            filename,
        );
        (*bi).line = line;
    }
    if !function.is_null() {
        pstrcpy(
            ((*bi).func).as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
            function,
        );
    }
    (*bi).func_pc = func_addr;
    return func_addr;
}
unsafe extern "C" fn _tcc_backtrace(
    mut f: *mut rt_frame,
    mut fmt: *const libc::c_char,
    mut ap: ::core::ffi::VaList,
) -> libc::c_int {
    let mut rc: *mut rt_context = 0 as *mut rt_context;
    let mut rc2: *mut rt_context = 0 as *mut rt_context;
    let mut pc: Elf64_Addr = 0;
    let mut skip_0: [libc::c_char; 40] = [0; 40];
    let mut msg: [libc::c_char; 200] = [0; 200];
    let mut i: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut one: libc::c_int = 0;
    let mut a: *const libc::c_char = 0 as *const libc::c_char;
    let mut b: *const libc::c_char = 0 as *const libc::c_char;
    let mut bi: bt_info = bt_info {
        file: [0; 100],
        line: 0,
        func: [0; 100],
        func_pc: 0,
    };
    let mut getinfo: Option::<
        unsafe extern "C" fn(*mut rt_context, Elf64_Addr, *mut bt_info) -> Elf64_Addr,
    > = None;
    skip_0[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if *fmt.offset(0 as libc::c_int as isize) as libc::c_int == '^' as i32
        && {
            a = fmt.offset(1 as libc::c_int as isize);
            b = strchr(a, *fmt.offset(0 as libc::c_int as isize) as libc::c_int);
            !b.is_null()
        }
    {
        memcpy(
            skip_0.as_mut_ptr() as *mut libc::c_void,
            a as *const libc::c_void,
            b.offset_from(a) as libc::c_long as libc::c_ulong,
        );
        skip_0[b.offset_from(a) as libc::c_long
            as usize] = 0 as libc::c_int as libc::c_char;
        fmt = b.offset(1 as libc::c_int as isize);
    }
    one = 0 as libc::c_int;
    if *fmt.offset(0 as libc::c_int as isize) as libc::c_int == '\u{1}' as i32 {
        fmt = fmt.offset(1);
        fmt;
        one = 1 as libc::c_int;
    }
    vsnprintf(
        msg.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong,
        fmt,
        ap.as_va_list(),
    );
    rt_wait_sem();
    rc = g_rc;
    getinfo = Some(
        rt_printline
            as unsafe extern "C" fn(
                *mut rt_context,
                Elf64_Addr,
                *mut bt_info,
            ) -> Elf64_Addr,
    );
    n = 6 as libc::c_int;
    if !rc.is_null() {
        if (*rc).dwarf != 0 {
            getinfo = Some(
                rt_printline_dwarf
                    as unsafe extern "C" fn(
                        *mut rt_context,
                        Elf64_Addr,
                        *mut bt_info,
                    ) -> Elf64_Addr,
            );
        }
        if (*rc).num_callers != 0 {
            n = (*rc).num_callers;
        }
    }
    level = 0 as libc::c_int;
    i = level;
    while level < n {
        ret = rt_get_caller_pc(&mut pc, f, i);
        if ret == -(1 as libc::c_int) {
            break;
        }
        memset(
            &mut bi as *mut bt_info as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<bt_info>() as libc::c_ulong,
        );
        rc2 = rc;
        while !rc2.is_null() {
            if getinfo.expect("non-null function pointer")(rc2, pc, &mut bi) != 0 {
                break;
            }
            a = rt_elfsym(rc2, pc, &mut bi.func_pc);
            if !a.is_null() {
                pstrcpy(
                    (bi.func).as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
                    a,
                );
                break;
            } else {
                rc2 = (*rc2).next;
            }
        }
        if !(skip_0[0 as libc::c_int as usize] as libc::c_int != 0
            && !(strstr((bi.file).as_mut_ptr(), skip_0.as_mut_ptr())).is_null())
        {
            let mut s: *mut TCCState = rt_find_state(f);
            if !s.is_null() && ((*s).bt_func).is_some() {
                ret = ((*s).bt_func)
                    .expect(
                        "non-null function pointer",
                    )(
                    (*s).bt_data,
                    pc as *mut libc::c_void,
                    if bi.file[0 as libc::c_int as usize] as libc::c_int != 0 {
                        (bi.file).as_mut_ptr()
                    } else {
                        0 as *mut libc::c_char
                    },
                    bi.line,
                    if bi.func[0 as libc::c_int as usize] as libc::c_int != 0 {
                        (bi.func).as_mut_ptr()
                    } else {
                        0 as *mut libc::c_char
                    },
                    if level == 0 as libc::c_int {
                        msg.as_mut_ptr()
                    } else {
                        0 as *mut libc::c_char
                    },
                );
                if ret == 0 as libc::c_int {
                    break;
                }
            } else {
                if bi.file[0 as libc::c_int as usize] != 0 {
                    rt_printf(
                        b"%s:%d\0" as *const u8 as *const libc::c_char,
                        (bi.file).as_mut_ptr(),
                        bi.line,
                    );
                } else {
                    rt_printf(
                        b"0x%08llx\0" as *const u8 as *const libc::c_char,
                        pc as libc::c_longlong,
                    );
                }
                rt_printf(
                    b": %s %s\0" as *const u8 as *const libc::c_char,
                    if level != 0 {
                        b"by\0" as *const u8 as *const libc::c_char
                    } else {
                        b"at\0" as *const u8 as *const libc::c_char
                    },
                    if bi.func[0 as libc::c_int as usize] as libc::c_int != 0 {
                        (bi.func).as_mut_ptr() as *const libc::c_char
                    } else {
                        b"???\0" as *const u8 as *const libc::c_char
                    },
                );
                if level == 0 as libc::c_int {
                    rt_printf(
                        b": %s\0" as *const u8 as *const libc::c_char,
                        msg.as_mut_ptr(),
                    );
                    if one != 0 {
                        break;
                    }
                }
                rt_printf(b"\n\0" as *const u8 as *const libc::c_char);
            }
            if !rc2.is_null() && bi.func_pc != 0
                && bi.func_pc == (*rc2).top_func as Elf64_Addr
            {
                break;
            }
            level += 1;
            level;
        }
        i += 1;
        i;
    }
    rt_post_sem();
    return 0 as libc::c_int;
}
unsafe extern "C" fn rt_error(
    mut f: *mut rt_frame,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    let mut msg: [libc::c_char; 200] = [0; 200];
    let mut ret: libc::c_int = 0;
    ap = args.clone();
    snprintf(
        msg.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong,
        b"RUNTIME ERROR: %s\0" as *const u8 as *const libc::c_char,
        fmt,
    );
    ret = _tcc_backtrace(f, msg.as_mut_ptr(), ap.as_va_list());
    return ret;
}
unsafe extern "C" fn rt_getcontext(mut uc: *mut ucontext_t, mut rc: *mut rt_frame) {
    (*rc).ip = (*uc).uc_mcontext.gregs[REG_RIP as libc::c_int as usize] as Elf64_Addr;
    (*rc).fp = (*uc).uc_mcontext.gregs[REG_RBP as libc::c_int as usize] as Elf64_Addr;
}
unsafe extern "C" fn sig_error(
    mut signum: libc::c_int,
    mut siginf: *mut siginfo_t,
    mut puc: *mut libc::c_void,
) {
    let mut f: rt_frame = rt_frame { ip: 0, fp: 0, sp: 0 };
    rt_getcontext(puc as *mut ucontext_t, &mut f);
    match signum {
        8 => {
            match (*siginf).si_code {
                1 | 3 => {
                    rt_error(
                        &mut f as *mut rt_frame,
                        b"division by zero\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {
                    rt_error(
                        &mut f as *mut rt_frame,
                        b"floating point exception\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
        }
        7 | 11 => {
            rt_error(
                &mut f as *mut rt_frame,
                b"invalid memory access\0" as *const u8 as *const libc::c_char,
            );
        }
        4 => {
            rt_error(
                &mut f as *mut rt_frame,
                b"illegal instruction\0" as *const u8 as *const libc::c_char,
            );
        }
        6 => {
            rt_error(
                &mut f as *mut rt_frame,
                b"abort() called\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {
            rt_error(
                &mut f as *mut rt_frame,
                b"caught signal %d\0" as *const u8 as *const libc::c_char,
                signum,
            );
        }
    }
    let mut s: sigset_t = __sigset_t { __val: [0; 16] };
    sigemptyset(&mut s);
    sigaddset(&mut s, signum);
    sigprocmask(1 as libc::c_int, &mut s, 0 as *mut sigset_t);
    rt_exit(&mut f, 255 as libc::c_int);
}
unsafe extern "C" fn set_exception_handler() {
    let mut sigact: sigaction = sigaction {
        __sigaction_handler: C2RustUnnamed_24 {
            sa_handler: None,
        },
        sa_mask: __sigset_t { __val: [0; 16] },
        sa_flags: 0,
        sa_restorer: None,
    };
    sigemptyset(&mut sigact.sa_mask);
    sigact.sa_flags = 4 as libc::c_int;
    sigact
        .__sigaction_handler
        .sa_sigaction = Some(
        sig_error
            as unsafe extern "C" fn(libc::c_int, *mut siginfo_t, *mut libc::c_void) -> (),
    );
    sigaction(8 as libc::c_int, &mut sigact, 0 as *mut sigaction);
    sigaction(4 as libc::c_int, &mut sigact, 0 as *mut sigaction);
    sigaction(11 as libc::c_int, &mut sigact, 0 as *mut sigaction);
    sigaction(7 as libc::c_int, &mut sigact, 0 as *mut sigaction);
    sigaction(6 as libc::c_int, &mut sigact, 0 as *mut sigaction);
}
unsafe extern "C" fn rt_get_caller_pc(
    mut paddr: *mut Elf64_Addr,
    mut rc: *mut rt_frame,
    mut level: libc::c_int,
) -> libc::c_int {
    if level == 0 as libc::c_int {
        *paddr = (*rc).ip;
    } else {
        let mut fp: Elf64_Addr = (*rc).fp;
        loop {
            if fp < 0x1000 as libc::c_int as Elf64_Addr {
                return -(1 as libc::c_int);
            }
            level -= 1;
            if 0 as libc::c_int == level {
                break;
            }
            fp = *(fp as *mut Elf64_Addr).offset(0 as libc::c_int as isize);
        }
        *paddr = *(fp as *mut Elf64_Addr).offset(1 as libc::c_int as isize);
    }
    return 0 as libc::c_int;
}
static mut target_machine_defs: *const libc::c_char = b"__x86_64__\0__amd64__\0\0"
    as *const u8 as *const libc::c_char;
static mut reg_classes: [libc::c_int; 25] = [
    0x1 as libc::c_int | 0x4 as libc::c_int,
    0x1 as libc::c_int | 0x10 as libc::c_int,
    0x1 as libc::c_int | 0x8 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0x20 as libc::c_int,
    0x40 as libc::c_int,
    0x100 as libc::c_int,
    0x200 as libc::c_int,
    0x400 as libc::c_int,
    0x800 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0 as libc::c_int,
    0x2 as libc::c_int | 0x1000 as libc::c_int,
    0x2 as libc::c_int | 0x2000 as libc::c_int,
    0x2 as libc::c_int | 0x4000 as libc::c_int,
    0x2 as libc::c_int | 0x8000 as libc::c_int,
    0x2 as libc::c_int | 0x10000 as libc::c_int,
    0x2 as libc::c_int | 0x20000 as libc::c_int,
    0x40000 as libc::c_int,
    0x80000 as libc::c_int,
    0x80 as libc::c_int,
];
static mut func_sub_sp_offset: libc::c_ulong = 0;
static mut func_ret_sub: libc::c_int = 0;
static mut func_bound_offset: Elf64_Addr = 0;
static mut func_bound_ind: libc::c_ulong = 0;
static mut func_bound_add_epilog: libc::c_int = 0;
unsafe extern "C" fn g(mut c: libc::c_int) {
    let mut ind1: libc::c_int = 0;
    if nocode_wanted != 0 {
        return;
    }
    ind1 = ind + 1 as libc::c_int;
    if ind1 as libc::c_ulong > (*(*tcc_state).cur_text_section).data_allocated {
        section_realloc((*tcc_state).cur_text_section, ind1 as libc::c_ulong);
    }
    *((*(*tcc_state).cur_text_section).data).offset(ind as isize) = c as libc::c_uchar;
    ind = ind1;
}
unsafe extern "C" fn o(mut c: libc::c_uint) {
    while c != 0 {
        g(c as libc::c_int);
        c = c >> 8 as libc::c_int;
    }
}
unsafe extern "C" fn gen_le16(mut v: libc::c_int) {
    g(v);
    g(v >> 8 as libc::c_int);
}
unsafe extern "C" fn gen_le32(mut c: libc::c_int) {
    g(c);
    g(c >> 8 as libc::c_int);
    g(c >> 16 as libc::c_int);
    g(c >> 24 as libc::c_int);
}
unsafe extern "C" fn gen_le64(mut c: int64_t) {
    g(c as libc::c_int);
    g((c >> 8 as libc::c_int) as libc::c_int);
    g((c >> 16 as libc::c_int) as libc::c_int);
    g((c >> 24 as libc::c_int) as libc::c_int);
    g((c >> 32 as libc::c_int) as libc::c_int);
    g((c >> 40 as libc::c_int) as libc::c_int);
    g((c >> 48 as libc::c_int) as libc::c_int);
    g((c >> 56 as libc::c_int) as libc::c_int);
}
unsafe extern "C" fn orex(
    mut ll: libc::c_int,
    mut r: libc::c_int,
    mut r2: libc::c_int,
    mut b: libc::c_int,
) {
    if r & 0x3f as libc::c_int >= 0x30 as libc::c_int {
        r = 0 as libc::c_int;
    }
    if r2 & 0x3f as libc::c_int >= 0x30 as libc::c_int {
        r2 = 0 as libc::c_int;
    }
    if ll != 0 || r >> 3 as libc::c_int & 1 as libc::c_int != 0
        || r2 >> 3 as libc::c_int & 1 as libc::c_int != 0
    {
        o(
            (0x40 as libc::c_int | r >> 3 as libc::c_int & 1 as libc::c_int
                | (r2 >> 3 as libc::c_int & 1 as libc::c_int) << 2 as libc::c_int
                | ll << 3 as libc::c_int) as libc::c_uint,
        );
    }
    o(b as libc::c_uint);
}
unsafe extern "C" fn gsym_addr(mut t: libc::c_int, mut a: libc::c_int) {
    while t != 0 {
        let mut ptr: *mut libc::c_uchar = ((*(*tcc_state).cur_text_section).data)
            .offset(t as isize);
        let mut n: uint32_t = read32le(ptr);
        write32le(
            ptr,
            (if a < 0 as libc::c_int { -a } else { a - t - 4 as libc::c_int })
                as uint32_t,
        );
        t = n as libc::c_int;
    }
}
unsafe extern "C" fn is64_type(mut t: libc::c_int) -> libc::c_int {
    return (t & 0xf as libc::c_int == 5 as libc::c_int
        || t & 0xf as libc::c_int == 6 as libc::c_int
        || t & 0xf as libc::c_int == 4 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn oad(mut c: libc::c_int, mut s: libc::c_int) -> libc::c_int {
    let mut t: libc::c_int = 0;
    if nocode_wanted != 0 {
        return s;
    }
    o(c as libc::c_uint);
    t = ind;
    gen_le32(s);
    return t;
}
unsafe extern "C" fn gen_addr32(
    mut r: libc::c_int,
    mut sym: *mut Sym,
    mut c: libc::c_int,
) {
    if r & 0x200 as libc::c_int != 0 {
        greloca(
            (*tcc_state).cur_text_section,
            sym,
            ind as libc::c_ulong,
            11 as libc::c_int,
            c as Elf64_Addr,
        );
        c = 0 as libc::c_int;
    }
    gen_le32(c);
}
unsafe extern "C" fn gen_addr64(mut r: libc::c_int, mut sym: *mut Sym, mut c: int64_t) {
    if r & 0x200 as libc::c_int != 0 {
        greloca(
            (*tcc_state).cur_text_section,
            sym,
            ind as libc::c_ulong,
            1 as libc::c_int,
            c as Elf64_Addr,
        );
        c = 0 as libc::c_int as int64_t;
    }
    gen_le64(c);
}
unsafe extern "C" fn gen_addrpc32(
    mut r: libc::c_int,
    mut sym: *mut Sym,
    mut c: libc::c_int,
) {
    if r & 0x200 as libc::c_int != 0 {
        greloca(
            (*tcc_state).cur_text_section,
            sym,
            ind as libc::c_ulong,
            2 as libc::c_int,
            (c - 4 as libc::c_int) as Elf64_Addr,
        );
        c = 4 as libc::c_int;
    }
    gen_le32(c - 4 as libc::c_int);
}
unsafe extern "C" fn gen_gotpcrel(
    mut r: libc::c_int,
    mut sym: *mut Sym,
    mut c: libc::c_int,
) {
    greloca(
        (*tcc_state).cur_text_section,
        sym,
        ind as libc::c_ulong,
        9 as libc::c_int,
        -(4 as libc::c_int) as Elf64_Addr,
    );
    gen_le32(0 as libc::c_int);
    if c != 0 {
        orex(1 as libc::c_int, r, 0 as libc::c_int, 0x81 as libc::c_int);
        o((0xc0 as libc::c_int + (r & 7 as libc::c_int)) as libc::c_uint);
        gen_le32(c);
    }
}
unsafe extern "C" fn gen_modrm_impl(
    mut op_reg: libc::c_int,
    mut r: libc::c_int,
    mut sym: *mut Sym,
    mut c: libc::c_int,
    mut is_got: libc::c_int,
) {
    op_reg = (op_reg & 7 as libc::c_int) << 3 as libc::c_int;
    if r & 0x3f as libc::c_int == 0x30 as libc::c_int {
        if r & 0x200 as libc::c_int == 0 {
            o((0x4 as libc::c_int | op_reg) as libc::c_uint);
            oad(0x25 as libc::c_int, c);
        } else {
            o((0x5 as libc::c_int | op_reg) as libc::c_uint);
            if is_got != 0 {
                gen_gotpcrel(r, sym, c);
            } else {
                gen_addrpc32(r, sym, c);
            }
        }
    } else if r & 0x3f as libc::c_int == 0x32 as libc::c_int {
        if c == c as libc::c_char as libc::c_int {
            o((0x45 as libc::c_int | op_reg) as libc::c_uint);
            g(c);
        } else {
            oad(0x85 as libc::c_int | op_reg, c);
        }
    } else if r & 0x3f as libc::c_int >= TREG_MEM as libc::c_int {
        if c != 0 {
            g(0x80 as libc::c_int | op_reg | r & 7 as libc::c_int);
            gen_le32(c);
        } else {
            g(0 as libc::c_int | op_reg | r & 7 as libc::c_int);
        }
    } else {
        g(0 as libc::c_int | op_reg | r & 7 as libc::c_int);
    };
}
unsafe extern "C" fn gen_modrm(
    mut op_reg: libc::c_int,
    mut r: libc::c_int,
    mut sym: *mut Sym,
    mut c: libc::c_int,
) {
    gen_modrm_impl(op_reg, r, sym, c, 0 as libc::c_int);
}
unsafe extern "C" fn gen_modrm64(
    mut opcode: libc::c_int,
    mut op_reg: libc::c_int,
    mut r: libc::c_int,
    mut sym: *mut Sym,
    mut c: libc::c_int,
) {
    let mut is_got: libc::c_int = 0;
    is_got = (op_reg & TREG_MEM as libc::c_int != 0
        && (*sym).type_0.t & 0x2000 as libc::c_int == 0) as libc::c_int;
    orex(1 as libc::c_int, r, op_reg, opcode);
    gen_modrm_impl(op_reg, r, sym, c, is_got);
}
unsafe extern "C" fn load(mut r: libc::c_int, mut sv: *mut SValue) {
    let mut v: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut ft: libc::c_int = 0;
    let mut fc: libc::c_int = 0;
    let mut fr: libc::c_int = 0;
    let mut v1: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    fr = (*sv).r as libc::c_int;
    ft = (*sv).type_0.t & !(0x20 as libc::c_int);
    fc = (*sv).c2rust_unnamed.c.i as libc::c_int;
    if fc as uint64_t != (*sv).c2rust_unnamed.c.i && fr & 0x200 as libc::c_int != 0 {
        _tcc_error(b"64 bit addend in load\0" as *const u8 as *const libc::c_char);
    }
    ft &= !(0x200 as libc::c_int | 0x100 as libc::c_int);
    if fr & 0x3f as libc::c_int == 0x30 as libc::c_int && fr & 0x200 as libc::c_int != 0
        && fr & 0x100 as libc::c_int != 0
        && (*(*sv).c2rust_unnamed_0.sym).type_0.t & 0x2000 as libc::c_int == 0
    {
        let mut tr: libc::c_int = r | TREG_MEM as libc::c_int;
        if is_float(ft) != 0 {
            tr = get_reg(0x1 as libc::c_int) | TREG_MEM as libc::c_int;
        }
        gen_modrm64(
            0x8b as libc::c_int,
            tr,
            fr,
            (*sv).c2rust_unnamed_0.sym,
            0 as libc::c_int,
        );
        fr = tr | 0x100 as libc::c_int;
    }
    v = fr & 0x3f as libc::c_int;
    if fr & 0x100 as libc::c_int != 0 {
        let mut b: libc::c_int = 0;
        let mut ll: libc::c_int = 0;
        if v == 0x31 as libc::c_int {
            v1.type_0.t = 5 as libc::c_int;
            v1.r = (0x32 as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
            v1.c2rust_unnamed.c.i = fc as uint64_t;
            fr = r;
            if reg_classes[fr as usize] & (0x1 as libc::c_int | 0x800 as libc::c_int)
                == 0
            {
                fr = get_reg(0x1 as libc::c_int);
            }
            load(fr, &mut v1);
        }
        if fc as uint64_t != (*sv).c2rust_unnamed.c.i {
            v1.type_0.t = 4 as libc::c_int;
            v1.r = 0x30 as libc::c_int as libc::c_ushort;
            v1.c2rust_unnamed.c.i = (*sv).c2rust_unnamed.c.i;
            fr = r;
            if reg_classes[fr as usize] & (0x1 as libc::c_int | 0x800 as libc::c_int)
                == 0
            {
                fr = get_reg(0x1 as libc::c_int);
            }
            load(fr, &mut v1);
            fc = 0 as libc::c_int;
        }
        ll = 0 as libc::c_int;
        if ft & 0xf as libc::c_int == 7 as libc::c_int {
            let mut align: libc::c_int = 0;
            match type_size(&mut (*sv).type_0, &mut align) {
                1 => {
                    ft = 1 as libc::c_int;
                }
                2 => {
                    ft = 2 as libc::c_int;
                }
                4 => {
                    ft = 3 as libc::c_int;
                }
                8 => {
                    ft = 4 as libc::c_int;
                }
                _ => {
                    _tcc_error(
                        b"invalid aggregate type for register load\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
        }
        if ft & 0xf as libc::c_int == 8 as libc::c_int {
            b = 0x6e0f66 as libc::c_int;
            r = r & 7 as libc::c_int;
        } else if ft & 0xf as libc::c_int == 9 as libc::c_int {
            b = 0x7e0ff3 as libc::c_int;
            r = r & 7 as libc::c_int;
        } else if ft & 0xf as libc::c_int == 10 as libc::c_int {
            b = 0xdb as libc::c_int;
            r = 5 as libc::c_int;
        } else if ft as libc::c_uint
            & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int) as libc::c_uint
                | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint))
            == 1 as libc::c_int as libc::c_uint
            || ft as libc::c_uint
                & !((0x1000 as libc::c_int | 0x2000 as libc::c_int
                    | 0x4000 as libc::c_int | 0x8000 as libc::c_int) as libc::c_uint
                    | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint))
                == 11 as libc::c_int as libc::c_uint
        {
            b = 0xbe0f as libc::c_int;
        } else if ft as libc::c_uint
            & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int) as libc::c_uint
                | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint))
            == (1 as libc::c_int | 0x10 as libc::c_int) as libc::c_uint
        {
            b = 0xb60f as libc::c_int;
        } else if ft as libc::c_uint
            & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int) as libc::c_uint
                | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint))
            == 2 as libc::c_int as libc::c_uint
        {
            b = 0xbf0f as libc::c_int;
        } else if ft as libc::c_uint
            & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int) as libc::c_uint
                | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint))
            == (2 as libc::c_int | 0x10 as libc::c_int) as libc::c_uint
        {
            b = 0xb70f as libc::c_int;
        } else if ft as libc::c_uint
            & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int) as libc::c_uint
                | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint))
            == 0 as libc::c_int as libc::c_uint
        {
            return
        } else {
            if ft & 0xf as libc::c_int == 3 as libc::c_int
                || ft & 0xf as libc::c_int == 4 as libc::c_int
                || ft & 0xf as libc::c_int == 5 as libc::c_int
                || ft & 0xf as libc::c_int == 6 as libc::c_int
            {} else {
                __assert_fail(
                    b"((ft & VT_BTYPE) == VT_INT) || ((ft & VT_BTYPE) == VT_LLONG) || ((ft & VT_BTYPE) == VT_PTR) || ((ft & VT_BTYPE) == VT_FUNC)\0"
                        as *const u8 as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    458 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 25],
                        &[libc::c_char; 25],
                    >(b"void load(int, SValue *)\0"))
                        .as_ptr(),
                );
            }
            'c_32725: {
                if ft & 0xf as libc::c_int == 3 as libc::c_int
                    || ft & 0xf as libc::c_int == 4 as libc::c_int
                    || ft & 0xf as libc::c_int == 5 as libc::c_int
                    || ft & 0xf as libc::c_int == 6 as libc::c_int
                {} else {
                    __assert_fail(
                        b"((ft & VT_BTYPE) == VT_INT) || ((ft & VT_BTYPE) == VT_LLONG) || ((ft & VT_BTYPE) == VT_PTR) || ((ft & VT_BTYPE) == VT_FUNC)\0"
                            as *const u8 as *const libc::c_char,
                        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                            as *const u8 as *const libc::c_char,
                        458 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 25],
                            &[libc::c_char; 25],
                        >(b"void load(int, SValue *)\0"))
                            .as_ptr(),
                    );
                }
            };
            ll = is64_type(ft);
            b = 0x8b as libc::c_int;
        }
        if ll != 0 {
            gen_modrm64(b, r, fr, (*sv).c2rust_unnamed_0.sym, fc);
        } else {
            orex(ll, fr, r, b);
            gen_modrm(r, fr, (*sv).c2rust_unnamed_0.sym, fc);
        }
    } else if v == 0x30 as libc::c_int {
        if fr & 0x200 as libc::c_int != 0 {
            if (*(*sv).c2rust_unnamed_0.sym).type_0.t & 0x2000 as libc::c_int != 0 {
                orex(1 as libc::c_int, 0 as libc::c_int, r, 0x8d as libc::c_int);
                o(
                    (0x5 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                        as libc::c_uint,
                );
                gen_addrpc32(fr, (*sv).c2rust_unnamed_0.sym, fc);
            } else {
                orex(1 as libc::c_int, 0 as libc::c_int, r, 0x8b as libc::c_int);
                o(
                    (0x5 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                        as libc::c_uint,
                );
                gen_gotpcrel(r, (*sv).c2rust_unnamed_0.sym, fc);
            }
        } else if is64_type(ft) != 0 {
            if (*sv).c2rust_unnamed.c.i >> 32 as libc::c_int != 0 {
                orex(
                    1 as libc::c_int,
                    r,
                    0 as libc::c_int,
                    0xb8 as libc::c_int + (r & 7 as libc::c_int),
                );
                gen_le64((*sv).c2rust_unnamed.c.i as int64_t);
            } else if (*sv).c2rust_unnamed.c.i > 0 as libc::c_int as uint64_t {
                orex(
                    0 as libc::c_int,
                    r,
                    0 as libc::c_int,
                    0xb8 as libc::c_int + (r & 7 as libc::c_int),
                );
                gen_le32((*sv).c2rust_unnamed.c.i as libc::c_int);
            } else {
                o(
                    (0xc031 as libc::c_int
                        + (r & 7 as libc::c_int) * 0x900 as libc::c_int) as libc::c_uint,
                );
            }
        } else {
            orex(
                0 as libc::c_int,
                r,
                0 as libc::c_int,
                0xb8 as libc::c_int + (r & 7 as libc::c_int),
            );
            gen_le32(fc);
        }
    } else if v == 0x32 as libc::c_int {
        orex(1 as libc::c_int, 0 as libc::c_int, r, 0x8d as libc::c_int);
        gen_modrm(r, 0x32 as libc::c_int, (*sv).c2rust_unnamed_0.sym, fc);
    } else if v == 0x33 as libc::c_int {
        if fc & 0x100 as libc::c_int != 0 {
            v = (*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_r as libc::c_int;
            fc &= !(0x100 as libc::c_int);
            orex(
                0 as libc::c_int,
                r,
                0 as libc::c_int,
                0xb0 as libc::c_int + (r & 7 as libc::c_int),
            );
            g(v ^ fc ^ (v == 0x95 as libc::c_int) as libc::c_int);
            o(
                (0x37a as libc::c_int
                    + ((r >> 3 as libc::c_int & 1 as libc::c_int) << 8 as libc::c_int))
                    as libc::c_uint,
            );
        }
        orex(0 as libc::c_int, r, 0 as libc::c_int, 0xf as libc::c_int);
        o(fc as libc::c_uint);
        o((0xc0 as libc::c_int + (r & 7 as libc::c_int)) as libc::c_uint);
        orex(0 as libc::c_int, r, 0 as libc::c_int, 0xf as libc::c_int);
        o(
            (0xc0b6 as libc::c_int + (r & 7 as libc::c_int) * 0x900 as libc::c_int)
                as libc::c_uint,
        );
    } else if v == 0x34 as libc::c_int || v == 0x35 as libc::c_int {
        t = v & 1 as libc::c_int;
        orex(0 as libc::c_int, r, 0 as libc::c_int, 0 as libc::c_int);
        oad(0xb8 as libc::c_int + (r & 7 as libc::c_int), t);
        o(
            (0x5eb as libc::c_int
                + ((r >> 3 as libc::c_int & 1 as libc::c_int) << 8 as libc::c_int))
                as libc::c_uint,
        );
        gsym(fc);
        orex(0 as libc::c_int, r, 0 as libc::c_int, 0 as libc::c_int);
        oad(0xb8 as libc::c_int + (r & 7 as libc::c_int), t ^ 1 as libc::c_int);
    } else if v != r {
        if r >= TREG_XMM0 as libc::c_int && r <= TREG_XMM7 as libc::c_int {
            if v == TREG_ST0 as libc::c_int {
                o(0xf0245cdd as libc::c_uint);
                o(0x100ff2 as libc::c_int as libc::c_uint);
                o(
                    (0x44 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                        as libc::c_uint,
                );
                o(0xf024 as libc::c_int as libc::c_uint);
            } else {
                if v >= TREG_XMM0 as libc::c_int && v <= TREG_XMM7 as libc::c_int
                {} else {
                    __assert_fail(
                        b"(v >= TREG_XMM0) && (v <= TREG_XMM7)\0" as *const u8
                            as *const libc::c_char,
                        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                            as *const u8 as *const libc::c_char,
                        538 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 25],
                            &[libc::c_char; 25],
                        >(b"void load(int, SValue *)\0"))
                            .as_ptr(),
                    );
                }
                'c_23764: {
                    if v >= TREG_XMM0 as libc::c_int && v <= TREG_XMM7 as libc::c_int
                    {} else {
                        __assert_fail(
                            b"(v >= TREG_XMM0) && (v <= TREG_XMM7)\0" as *const u8
                                as *const libc::c_char,
                            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                as *const u8 as *const libc::c_char,
                            538 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 25],
                                &[libc::c_char; 25],
                            >(b"void load(int, SValue *)\0"))
                                .as_ptr(),
                        );
                    }
                };
                if ft & 0xf as libc::c_int == 8 as libc::c_int {
                    o(0x100ff3 as libc::c_int as libc::c_uint);
                } else {
                    if ft & 0xf as libc::c_int == 9 as libc::c_int {} else {
                        __assert_fail(
                            b"(ft & VT_BTYPE) == VT_DOUBLE\0" as *const u8
                                as *const libc::c_char,
                            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                as *const u8 as *const libc::c_char,
                            542 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 25],
                                &[libc::c_char; 25],
                            >(b"void load(int, SValue *)\0"))
                                .as_ptr(),
                        );
                    }
                    'c_23709: {
                        if ft & 0xf as libc::c_int == 9 as libc::c_int {} else {
                            __assert_fail(
                                b"(ft & VT_BTYPE) == VT_DOUBLE\0" as *const u8
                                    as *const libc::c_char,
                                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                    as *const u8 as *const libc::c_char,
                                542 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 25],
                                    &[libc::c_char; 25],
                                >(b"void load(int, SValue *)\0"))
                                    .as_ptr(),
                            );
                        }
                    };
                    o(0x100ff2 as libc::c_int as libc::c_uint);
                }
                o(
                    (0xc0 as libc::c_int + (v & 7 as libc::c_int)
                        + (r & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
                );
            }
        } else if r == TREG_ST0 as libc::c_int {
            if v >= TREG_XMM0 as libc::c_int && v <= TREG_XMM7 as libc::c_int {} else {
                __assert_fail(
                    b"(v >= TREG_XMM0) && (v <= TREG_XMM7)\0" as *const u8
                        as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    548 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 25],
                        &[libc::c_char; 25],
                    >(b"void load(int, SValue *)\0"))
                        .as_ptr(),
                );
            }
            'c_23606: {
                if v >= TREG_XMM0 as libc::c_int && v <= TREG_XMM7 as libc::c_int
                {} else {
                    __assert_fail(
                        b"(v >= TREG_XMM0) && (v <= TREG_XMM7)\0" as *const u8
                            as *const libc::c_char,
                        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                            as *const u8 as *const libc::c_char,
                        548 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 25],
                            &[libc::c_char; 25],
                        >(b"void load(int, SValue *)\0"))
                            .as_ptr(),
                    );
                }
            };
            o(0x110ff2 as libc::c_int as libc::c_uint);
            o(
                (0x44 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                    as libc::c_uint,
            );
            o(0xf024 as libc::c_int as libc::c_uint);
            o(0xf02444dd as libc::c_uint);
        } else {
            orex(is64_type(ft), r, v, 0x89 as libc::c_int);
            o(
                (0xc0 as libc::c_int + (r & 7 as libc::c_int)
                    + (v & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
            );
        }
    }
}
unsafe extern "C" fn store(mut r: libc::c_int, mut v: *mut SValue) {
    let mut fr: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut ft: libc::c_int = 0;
    let mut fc: libc::c_int = 0;
    let mut op64: libc::c_int = 0 as libc::c_int;
    let mut pic: libc::c_int = 0 as libc::c_int;
    fr = (*v).r as libc::c_int & 0x3f as libc::c_int;
    ft = (*v).type_0.t;
    fc = (*v).c2rust_unnamed.c.i as libc::c_int;
    if fc as uint64_t != (*v).c2rust_unnamed.c.i && fr & 0x200 as libc::c_int != 0 {
        _tcc_error(b"64 bit addend in store\0" as *const u8 as *const libc::c_char);
    }
    ft &= !(0x200 as libc::c_int | 0x100 as libc::c_int);
    bt = ft & 0xf as libc::c_int;
    if fr == 0x30 as libc::c_int && (*v).r as libc::c_int & 0x200 as libc::c_int != 0
        && (*(*v).c2rust_unnamed_0.sym).type_0.t & 0x2000 as libc::c_int == 0
    {
        o(0x1d8b4c as libc::c_int as libc::c_uint);
        gen_gotpcrel(
            TREG_R11 as libc::c_int,
            (*v).c2rust_unnamed_0.sym,
            (*v).c2rust_unnamed.c.i as libc::c_int,
        );
        pic = if is64_type(bt) != 0 { 0x49 as libc::c_int } else { 0x41 as libc::c_int };
    }
    if bt == 8 as libc::c_int {
        o(0x66 as libc::c_int as libc::c_uint);
        o(pic as libc::c_uint);
        o(0x7e0f as libc::c_int as libc::c_uint);
        r = r & 7 as libc::c_int;
    } else if bt == 9 as libc::c_int {
        o(0x66 as libc::c_int as libc::c_uint);
        o(pic as libc::c_uint);
        o(0xd60f as libc::c_int as libc::c_uint);
        r = r & 7 as libc::c_int;
    } else if bt == 10 as libc::c_int {
        o(0xc0d9 as libc::c_int as libc::c_uint);
        o(pic as libc::c_uint);
        o(0xdb as libc::c_int as libc::c_uint);
        r = 7 as libc::c_int;
    } else {
        if bt == 2 as libc::c_int {
            o(0x66 as libc::c_int as libc::c_uint);
        }
        o(pic as libc::c_uint);
        if bt == 1 as libc::c_int || bt == 11 as libc::c_int {
            orex(0 as libc::c_int, 0 as libc::c_int, r, 0x88 as libc::c_int);
        } else if is64_type(bt) != 0 {
            op64 = 0x89 as libc::c_int;
        } else {
            orex(0 as libc::c_int, 0 as libc::c_int, r, 0x89 as libc::c_int);
        }
    }
    if pic != 0 {
        if op64 != 0 {
            o(op64 as libc::c_uint);
        }
        o((3 as libc::c_int + (r << 3 as libc::c_int)) as libc::c_uint);
    } else if op64 != 0 {
        if fr == 0x30 as libc::c_int || fr == 0x32 as libc::c_int
            || (*v).r as libc::c_int & 0x100 as libc::c_int != 0
        {
            gen_modrm64(op64, r, (*v).r as libc::c_int, (*v).c2rust_unnamed_0.sym, fc);
        } else if fr != r {
            orex(1 as libc::c_int, fr, r, op64);
            o((0xc0 as libc::c_int + fr + r * 8 as libc::c_int) as libc::c_uint);
        }
    } else if fr == 0x30 as libc::c_int || fr == 0x32 as libc::c_int
        || (*v).r as libc::c_int & 0x100 as libc::c_int != 0
    {
        gen_modrm(r, (*v).r as libc::c_int, (*v).c2rust_unnamed_0.sym, fc);
    } else if fr != r {
        o((0xc0 as libc::c_int + fr + r * 8 as libc::c_int) as libc::c_uint);
    }
}
unsafe extern "C" fn gcall_or_jmp(mut is_jmp: libc::c_int) {
    let mut r: libc::c_int = 0;
    if (*vtop).r as libc::c_int & (0x3f as libc::c_int | 0x100 as libc::c_int)
        == 0x30 as libc::c_int
        && ((*vtop).r as libc::c_int & 0x200 as libc::c_int != 0
            && ((*vtop).c2rust_unnamed.c.i).wrapping_sub(4 as libc::c_int as uint64_t)
                == ((*vtop).c2rust_unnamed.c.i)
                    .wrapping_sub(4 as libc::c_int as uint64_t) as libc::c_int
                    as uint64_t)
    {
        greloca(
            (*tcc_state).cur_text_section,
            (*vtop).c2rust_unnamed_0.sym,
            (ind + 1 as libc::c_int) as libc::c_ulong,
            4 as libc::c_int,
            ((*vtop).c2rust_unnamed.c.i).wrapping_sub(4 as libc::c_int as uint64_t)
                as libc::c_int as Elf64_Addr,
        );
        oad(0xe8 as libc::c_int + is_jmp, 0 as libc::c_int);
    } else {
        r = TREG_R11 as libc::c_int;
        load(r, vtop);
        o(0x41 as libc::c_int as libc::c_uint);
        o(0xff as libc::c_int as libc::c_uint);
        o(
            (0xd0 as libc::c_int + (r & 7 as libc::c_int) + (is_jmp << 4 as libc::c_int))
                as libc::c_uint,
        );
    };
}
unsafe extern "C" fn gen_bounds_call(mut v: libc::c_int) {
    let mut sym: *mut Sym = external_helper_sym(v);
    oad(0xe8 as libc::c_int, 0 as libc::c_int);
    greloca(
        (*tcc_state).cur_text_section,
        sym,
        (ind - 4 as libc::c_int) as libc::c_ulong,
        4 as libc::c_int,
        -(4 as libc::c_int) as Elf64_Addr,
    );
}
unsafe extern "C" fn gen_bounds_prolog() {
    func_bound_offset = (*(*tcc_state).lbounds_section).data_offset;
    func_bound_ind = ind as libc::c_ulong;
    func_bound_add_epilog = 0 as libc::c_int;
    o(
        (0xd8d48 as libc::c_int
            + (TREG_RDI as libc::c_int == TREG_RDI as libc::c_int) as libc::c_int
                * 0x300000 as libc::c_int) as libc::c_uint,
    );
    gen_le32(0 as libc::c_int);
    oad(0xb8 as libc::c_int, 0 as libc::c_int);
}
unsafe extern "C" fn gen_bounds_epilog() {
    let mut saved_ind: Elf64_Addr = 0;
    let mut bounds_ptr: *mut Elf64_Addr = 0 as *mut Elf64_Addr;
    let mut sym_data: *mut Sym = 0 as *mut Sym;
    let mut offset_modified: libc::c_int = (func_bound_offset
        != (*(*tcc_state).lbounds_section).data_offset) as libc::c_int;
    if offset_modified == 0 && func_bound_add_epilog == 0 {
        return;
    }
    bounds_ptr = section_ptr_add(
        (*tcc_state).lbounds_section,
        ::core::mem::size_of::<Elf64_Addr>() as libc::c_ulong,
    ) as *mut Elf64_Addr;
    *bounds_ptr = 0 as libc::c_int as Elf64_Addr;
    sym_data = get_sym_ref(
        &mut char_pointer_type,
        (*tcc_state).lbounds_section,
        func_bound_offset,
        8 as libc::c_int as libc::c_ulong,
    );
    if offset_modified != 0 {
        saved_ind = ind as Elf64_Addr;
        ind = func_bound_ind as libc::c_int;
        greloca(
            (*tcc_state).cur_text_section,
            sym_data,
            (ind + 3 as libc::c_int) as libc::c_ulong,
            2 as libc::c_int,
            -(4 as libc::c_int) as Elf64_Addr,
        );
        ind = ind + 7 as libc::c_int;
        gen_bounds_call(TOK___bound_local_new as libc::c_int);
        ind = saved_ind as libc::c_int;
    }
    o(0x5250 as libc::c_int as libc::c_uint);
    o(0x20ec8348 as libc::c_int as libc::c_uint);
    o(0x290f as libc::c_int as libc::c_uint);
    o(0x102444 as libc::c_int as libc::c_uint);
    o(0x240c290f as libc::c_int as libc::c_uint);
    greloca(
        (*tcc_state).cur_text_section,
        sym_data,
        (ind + 3 as libc::c_int) as libc::c_ulong,
        2 as libc::c_int,
        -(4 as libc::c_int) as Elf64_Addr,
    );
    o(
        (0xd8d48 as libc::c_int
            + (TREG_RDI as libc::c_int == TREG_RDI as libc::c_int) as libc::c_int
                * 0x300000 as libc::c_int) as libc::c_uint,
    );
    gen_le32(0 as libc::c_int);
    gen_bounds_call(TOK___bound_local_delete as libc::c_int);
    o(0x280f as libc::c_int as libc::c_uint);
    o(0x102444 as libc::c_int as libc::c_uint);
    o(0x240c280f as libc::c_int as libc::c_uint);
    o(0x20c48348 as libc::c_int as libc::c_uint);
    o(0x585a as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn gadd_sp(mut val: libc::c_int) {
    if val == val as libc::c_char as libc::c_int {
        o(0xc48348 as libc::c_int as libc::c_uint);
        g(val);
    } else {
        oad(0xc48148 as libc::c_int, val);
    };
}
unsafe extern "C" fn classify_x86_64_merge(
    mut a: X86_64_Mode,
    mut b: X86_64_Mode,
) -> X86_64_Mode {
    if a as libc::c_uint == b as libc::c_uint {
        return a
    } else if a as libc::c_uint == x86_64_mode_none as libc::c_int as libc::c_uint {
        return b
    } else if b as libc::c_uint == x86_64_mode_none as libc::c_int as libc::c_uint {
        return a
    } else if a as libc::c_uint == x86_64_mode_memory as libc::c_int as libc::c_uint
        || b as libc::c_uint == x86_64_mode_memory as libc::c_int as libc::c_uint
    {
        return x86_64_mode_memory
    } else if a as libc::c_uint == x86_64_mode_integer as libc::c_int as libc::c_uint
        || b as libc::c_uint == x86_64_mode_integer as libc::c_int as libc::c_uint
    {
        return x86_64_mode_integer
    } else if a as libc::c_uint == x86_64_mode_x87 as libc::c_int as libc::c_uint
        || b as libc::c_uint == x86_64_mode_x87 as libc::c_int as libc::c_uint
    {
        return x86_64_mode_memory
    } else {
        return x86_64_mode_sse
    };
}
unsafe extern "C" fn classify_x86_64_inner(mut ty: *mut CType) -> X86_64_Mode {
    let mut mode: X86_64_Mode = x86_64_mode_none;
    let mut f: *mut Sym = 0 as *mut Sym;
    match (*ty).t & 0xf as libc::c_int {
        0 => return x86_64_mode_none,
        3 | 1 | 2 | 4 | 11 | 5 | 6 => return x86_64_mode_integer,
        8 | 9 => return x86_64_mode_sse,
        10 => return x86_64_mode_x87,
        7 => {
            f = (*ty).ref_0;
            mode = x86_64_mode_none;
            f = (*f).c2rust_unnamed_0.next;
            while !f.is_null() {
                mode = classify_x86_64_merge(
                    mode,
                    classify_x86_64_inner(&mut (*f).type_0),
                );
                f = (*f).c2rust_unnamed_0.next;
            }
            return mode;
        }
        _ => {}
    }
    __assert_fail(
        b"0\0" as *const u8 as *const libc::c_char,
        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
            as *const u8 as *const libc::c_char,
        1122 as libc::c_int as libc::c_uint,
        (*::core::mem::transmute::<
            &[u8; 43],
            &[libc::c_char; 43],
        >(b"X86_64_Mode classify_x86_64_inner(CType *)\0"))
            .as_ptr(),
    );
    'c_42430: {
        __assert_fail(
            b"0\0" as *const u8 as *const libc::c_char,
            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                as *const u8 as *const libc::c_char,
            1122 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 43],
                &[libc::c_char; 43],
            >(b"X86_64_Mode classify_x86_64_inner(CType *)\0"))
                .as_ptr(),
        );
    };
    return x86_64_mode_none;
}
unsafe extern "C" fn classify_x86_64_arg(
    mut ty: *mut CType,
    mut ret: *mut CType,
    mut psize: *mut libc::c_int,
    mut palign: *mut libc::c_int,
    mut reg_count: *mut libc::c_int,
) -> X86_64_Mode {
    let mut mode: X86_64_Mode = x86_64_mode_none;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut ret_t: libc::c_int = 0 as libc::c_int;
    if (*ty).t & (0x80 as libc::c_int | 0x40 as libc::c_int) != 0 {
        *psize = 8 as libc::c_int;
        *palign = 8 as libc::c_int;
        *reg_count = 1 as libc::c_int;
        ret_t = (*ty).t;
        mode = x86_64_mode_integer;
    } else {
        size = type_size(ty, &mut align);
        *psize = size + 7 as libc::c_int & !(7 as libc::c_int);
        *palign = align + 7 as libc::c_int & !(7 as libc::c_int);
        *reg_count = 0 as libc::c_int;
        if size > 16 as libc::c_int {
            mode = x86_64_mode_memory;
        } else {
            mode = classify_x86_64_inner(ty);
            match mode as libc::c_uint {
                2 => {
                    if size > 8 as libc::c_int {
                        *reg_count = 2 as libc::c_int;
                        ret_t = 13 as libc::c_int;
                    } else {
                        *reg_count = 1 as libc::c_int;
                        if size > 4 as libc::c_int {
                            ret_t = 4 as libc::c_int;
                        } else if size > 2 as libc::c_int {
                            ret_t = 3 as libc::c_int;
                        } else if size > 1 as libc::c_int {
                            ret_t = 2 as libc::c_int;
                        } else {
                            ret_t = 1 as libc::c_int;
                        }
                        if (*ty).t & 0xf as libc::c_int == 7 as libc::c_int
                            || (*ty).t & 0x10 as libc::c_int != 0
                        {
                            ret_t |= 0x10 as libc::c_int;
                        }
                    }
                }
                4 => {
                    *reg_count = 1 as libc::c_int;
                    ret_t = 10 as libc::c_int;
                }
                3 => {
                    if size > 8 as libc::c_int {
                        *reg_count = 2 as libc::c_int;
                        ret_t = 14 as libc::c_int;
                    } else {
                        *reg_count = 1 as libc::c_int;
                        ret_t = if size > 4 as libc::c_int {
                            9 as libc::c_int
                        } else {
                            8 as libc::c_int
                        };
                    }
                }
                _ => {}
            }
        }
    }
    if !ret.is_null() {
        (*ret).ref_0 = 0 as *mut Sym;
        (*ret).t = ret_t;
    }
    return mode;
}
unsafe extern "C" fn classify_x86_64_va_arg(mut ty: *mut CType) -> libc::c_int {
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut reg_count: libc::c_int = 0;
    let mut mode: X86_64_Mode = classify_x86_64_arg(
        ty,
        0 as *mut CType,
        &mut size,
        &mut align,
        &mut reg_count,
    );
    match mode as libc::c_uint {
        2 => return __va_gen_reg as libc::c_int,
        3 => return __va_float_reg as libc::c_int,
        _ => return __va_stack as libc::c_int,
    };
}
unsafe extern "C" fn gfunc_sret(
    mut vt: *mut CType,
    mut variadic: libc::c_int,
    mut ret: *mut CType,
    mut ret_align: *mut libc::c_int,
    mut regsize: *mut libc::c_int,
) -> libc::c_int {
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut reg_count: libc::c_int = 0;
    if classify_x86_64_arg(vt, ret, &mut size, &mut align, &mut reg_count)
        as libc::c_uint == x86_64_mode_memory as libc::c_int as libc::c_uint
    {
        return 0 as libc::c_int;
    }
    *ret_align = 1 as libc::c_int;
    *regsize = 8 as libc::c_int * reg_count;
    return 1 as libc::c_int;
}
static mut arg_regs: [uint8_t; 6] = [
    TREG_RDI as libc::c_int as uint8_t,
    TREG_RSI as libc::c_int as uint8_t,
    TREG_RDX as libc::c_int as uint8_t,
    TREG_RCX as libc::c_int as uint8_t,
    TREG_R8 as libc::c_int as uint8_t,
    TREG_R9 as libc::c_int as uint8_t,
];
unsafe extern "C" fn arg_prepare_reg(mut idx: libc::c_int) -> libc::c_int {
    if idx == 2 as libc::c_int || idx == 3 as libc::c_int {
        return idx + 8 as libc::c_int
    } else {
        return if idx >= 0 as libc::c_int && idx < 6 as libc::c_int {
            arg_regs[idx as usize] as libc::c_int
        } else {
            0 as libc::c_int
        }
    };
}
unsafe extern "C" fn gfunc_call(mut nb_args: libc::c_int) {
    let mut mode: X86_64_Mode = x86_64_mode_none;
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut args_size: libc::c_int = 0;
    let mut stack_adjust: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut reg_count: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut nb_reg_args: libc::c_int = 0 as libc::c_int;
    let mut nb_sse_args: libc::c_int = 0 as libc::c_int;
    let mut sse_reg: libc::c_int = 0;
    let mut gen_reg: libc::c_int = 0;
    let mut onstack: *mut libc::c_char = tcc_malloc(
        ((nb_args + 1 as libc::c_int) as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    ) as *mut libc::c_char;
    if (*tcc_state).do_bounds_check != 0 {
        gbound_args(nb_args);
    }
    stack_adjust = 0 as libc::c_int;
    i = nb_args - 1 as libc::c_int;
    while i >= 0 as libc::c_int {
        mode = classify_x86_64_arg(
            &mut (*vtop.offset(-i as isize)).type_0,
            0 as *mut CType,
            &mut size,
            &mut align,
            &mut reg_count,
        );
        if !(size == 0 as libc::c_int) {
            if mode as libc::c_uint == x86_64_mode_sse as libc::c_int as libc::c_uint
                && nb_sse_args + reg_count <= 8 as libc::c_int
            {
                nb_sse_args += reg_count;
                *onstack.offset(i as isize) = 0 as libc::c_int as libc::c_char;
            } else if mode as libc::c_uint
                == x86_64_mode_integer as libc::c_int as libc::c_uint
                && nb_reg_args + reg_count <= 6 as libc::c_int
            {
                nb_reg_args += reg_count;
                *onstack.offset(i as isize) = 0 as libc::c_int as libc::c_char;
            } else if mode as libc::c_uint
                == x86_64_mode_none as libc::c_int as libc::c_uint
            {
                *onstack.offset(i as isize) = 0 as libc::c_int as libc::c_char;
            } else {
                if align == 16 as libc::c_int
                    && {
                        stack_adjust &= 15 as libc::c_int;
                        stack_adjust != 0
                    }
                {
                    *onstack.offset(i as isize) = 2 as libc::c_int as libc::c_char;
                    stack_adjust = 0 as libc::c_int;
                } else {
                    *onstack.offset(i as isize) = 1 as libc::c_int as libc::c_char;
                }
                stack_adjust += size;
            }
        }
        i -= 1;
        i;
    }
    if nb_sse_args != 0 && (*tcc_state).nosse as libc::c_int != 0 {
        _tcc_error(
            b"SSE disabled but floating point arguments passed\0" as *const u8
                as *const libc::c_char,
        );
    }
    gen_reg = nb_reg_args;
    sse_reg = nb_sse_args;
    args_size = 0 as libc::c_int;
    stack_adjust &= 15 as libc::c_int;
    k = 0 as libc::c_int;
    i = k;
    while i < nb_args {
        mode = classify_x86_64_arg(
            &mut (*vtop.offset(-i as isize)).type_0,
            0 as *mut CType,
            &mut size,
            &mut align,
            &mut reg_count,
        );
        if size != 0 {
            if *onstack.offset((i + k) as isize) == 0 {
                i += 1;
                i;
                continue;
            } else {
                if stack_adjust != 0 {
                    o(0x50 as libc::c_int as libc::c_uint);
                    args_size += 8 as libc::c_int;
                    stack_adjust = 0 as libc::c_int;
                }
                if *onstack.offset((i + k) as isize) as libc::c_int == 2 as libc::c_int {
                    stack_adjust = 1 as libc::c_int;
                }
            }
        }
        vrotb(i + 1 as libc::c_int);
        match (*vtop).type_0.t & 0xf as libc::c_int {
            7 => {
                o(0x48 as libc::c_int as libc::c_uint);
                oad(0xec81 as libc::c_int, size);
                r = get_reg(0x1 as libc::c_int);
                orex(1 as libc::c_int, r, 0 as libc::c_int, 0x89 as libc::c_int);
                o((0xe0 as libc::c_int + (r & 7 as libc::c_int)) as libc::c_uint);
                vset(&mut (*vtop).type_0, r | 0x100 as libc::c_int, 0 as libc::c_int);
                vswap();
                o(0x10ec8348 as libc::c_int as libc::c_uint);
                o(0xf0e48348 as libc::c_uint);
                orex(
                    0 as libc::c_int,
                    r,
                    0 as libc::c_int,
                    0x50 as libc::c_int + (r & 7 as libc::c_int),
                );
                o(0x8ec8348 as libc::c_int as libc::c_uint);
                vstore();
                o(0x8c48348 as libc::c_int as libc::c_uint);
                o(0x5c as libc::c_int as libc::c_uint);
            }
            10 => {
                gv(0x80 as libc::c_int);
                oad(0xec8148 as libc::c_int, size);
                o(0x7cdb as libc::c_int as libc::c_uint);
                g(0x24 as libc::c_int);
                g(0 as libc::c_int);
            }
            8 | 9 => {
                if mode as libc::c_uint == x86_64_mode_sse as libc::c_int as libc::c_uint
                {} else {
                    __assert_fail(
                        b"mode == x86_64_mode_sse\0" as *const u8 as *const libc::c_char,
                        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                            as *const u8 as *const libc::c_char,
                        1341 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 21],
                            &[libc::c_char; 21],
                        >(b"void gfunc_call(int)\0"))
                            .as_ptr(),
                    );
                }
                'c_43010: {
                    if mode as libc::c_uint
                        == x86_64_mode_sse as libc::c_int as libc::c_uint
                    {} else {
                        __assert_fail(
                            b"mode == x86_64_mode_sse\0" as *const u8
                                as *const libc::c_char,
                            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                as *const u8 as *const libc::c_char,
                            1341 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 21],
                                &[libc::c_char; 21],
                            >(b"void gfunc_call(int)\0"))
                                .as_ptr(),
                        );
                    }
                };
                r = gv(0x2 as libc::c_int);
                o(0x50 as libc::c_int as libc::c_uint);
                o(0xd60f66 as libc::c_int as libc::c_uint);
                o(
                    (0x4 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                        as libc::c_uint,
                );
                o(0x24 as libc::c_int as libc::c_uint);
            }
            _ => {
                if mode as libc::c_uint
                    == x86_64_mode_integer as libc::c_int as libc::c_uint
                {} else {
                    __assert_fail(
                        b"mode == x86_64_mode_integer\0" as *const u8
                            as *const libc::c_char,
                        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                            as *const u8 as *const libc::c_char,
                        1351 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 21],
                            &[libc::c_char; 21],
                        >(b"void gfunc_call(int)\0"))
                            .as_ptr(),
                    );
                }
                'c_42931: {
                    if mode as libc::c_uint
                        == x86_64_mode_integer as libc::c_int as libc::c_uint
                    {} else {
                        __assert_fail(
                            b"mode == x86_64_mode_integer\0" as *const u8
                                as *const libc::c_char,
                            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                as *const u8 as *const libc::c_char,
                            1351 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 21],
                                &[libc::c_char; 21],
                            >(b"void gfunc_call(int)\0"))
                                .as_ptr(),
                        );
                    }
                };
                r = gv(0x1 as libc::c_int);
                orex(
                    0 as libc::c_int,
                    r,
                    0 as libc::c_int,
                    0x50 as libc::c_int + (r & 7 as libc::c_int),
                );
            }
        }
        args_size += size;
        vpop();
        nb_args -= 1;
        nb_args;
        k += 1;
        k;
    }
    tcc_free(onstack as *mut libc::c_void);
    save_regs(0 as libc::c_int);
    if gen_reg <= 6 as libc::c_int {} else {
        __assert_fail(
            b"gen_reg <= REGN\0" as *const u8 as *const libc::c_char,
            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                as *const u8 as *const libc::c_char,
            1374 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"void gfunc_call(int)\0"))
                .as_ptr(),
        );
    }
    'c_42793: {
        if gen_reg <= 6 as libc::c_int {} else {
            __assert_fail(
                b"gen_reg <= REGN\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                1374 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 21],
                    &[libc::c_char; 21],
                >(b"void gfunc_call(int)\0"))
                    .as_ptr(),
            );
        }
    };
    if sse_reg <= 8 as libc::c_int {} else {
        __assert_fail(
            b"sse_reg <= 8\0" as *const u8 as *const libc::c_char,
            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                as *const u8 as *const libc::c_char,
            1375 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"void gfunc_call(int)\0"))
                .as_ptr(),
        );
    }
    'c_42757: {
        if sse_reg <= 8 as libc::c_int {} else {
            __assert_fail(
                b"sse_reg <= 8\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                1375 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 21],
                    &[libc::c_char; 21],
                >(b"void gfunc_call(int)\0"))
                    .as_ptr(),
            );
        }
    };
    i = 0 as libc::c_int;
    while i < nb_args {
        mode = classify_x86_64_arg(
            &mut (*vtop).type_0,
            &mut type_0,
            &mut size,
            &mut align,
            &mut reg_count,
        );
        if !(size == 0 as libc::c_int) {
            (*vtop).type_0 = type_0;
            if mode as libc::c_uint == x86_64_mode_sse as libc::c_int as libc::c_uint {
                if reg_count == 2 as libc::c_int {
                    sse_reg -= 2 as libc::c_int;
                    gv(0x1000 as libc::c_int);
                    if sse_reg != 0 {
                        o(0x280f as libc::c_int as libc::c_uint);
                        o(
                            (0xc1 as libc::c_int
                                + ((sse_reg + 1 as libc::c_int) << 3 as libc::c_int))
                                as libc::c_uint,
                        );
                        o(0x280f as libc::c_int as libc::c_uint);
                        o(
                            (0xc0 as libc::c_int + (sse_reg << 3 as libc::c_int))
                                as libc::c_uint,
                        );
                    }
                } else {
                    if reg_count == 1 as libc::c_int {} else {
                        __assert_fail(
                            b"reg_count == 1\0" as *const u8 as *const libc::c_char,
                            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                as *const u8 as *const libc::c_char,
                            1394 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 21],
                                &[libc::c_char; 21],
                            >(b"void gfunc_call(int)\0"))
                                .as_ptr(),
                        );
                    }
                    'c_42090: {
                        if reg_count == 1 as libc::c_int {} else {
                            __assert_fail(
                                b"reg_count == 1\0" as *const u8 as *const libc::c_char,
                                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                                    as *const u8 as *const libc::c_char,
                                1394 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 21],
                                    &[libc::c_char; 21],
                                >(b"void gfunc_call(int)\0"))
                                    .as_ptr(),
                            );
                        }
                    };
                    sse_reg -= 1;
                    sse_reg;
                    gv((0x1000 as libc::c_int) << sse_reg);
                }
            } else if mode as libc::c_uint
                == x86_64_mode_integer as libc::c_int as libc::c_uint
            {
                let mut d: libc::c_int = 0;
                gen_reg -= reg_count;
                r = gv(0x1 as libc::c_int);
                d = arg_prepare_reg(gen_reg);
                orex(1 as libc::c_int, d, r, 0x89 as libc::c_int);
                o(
                    (0xc0 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int
                        + (d & 7 as libc::c_int)) as libc::c_uint,
                );
                if reg_count == 2 as libc::c_int {
                    d = arg_prepare_reg(gen_reg + 1 as libc::c_int);
                    orex(
                        1 as libc::c_int,
                        d,
                        (*vtop).r2 as libc::c_int,
                        0x89 as libc::c_int,
                    );
                    o(
                        (0xc0 as libc::c_int
                            + ((*vtop).r2 as libc::c_int & 7 as libc::c_int)
                                * 8 as libc::c_int + (d & 7 as libc::c_int)) as libc::c_uint,
                    );
                }
            }
            vtop = vtop.offset(-1);
            vtop;
        }
        i += 1;
        i;
    }
    if gen_reg == 0 as libc::c_int {} else {
        __assert_fail(
            b"gen_reg == 0\0" as *const u8 as *const libc::c_char,
            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                as *const u8 as *const libc::c_char,
            1416 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"void gfunc_call(int)\0"))
                .as_ptr(),
        );
    }
    'c_41835: {
        if gen_reg == 0 as libc::c_int {} else {
            __assert_fail(
                b"gen_reg == 0\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                1416 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 21],
                    &[libc::c_char; 21],
                >(b"void gfunc_call(int)\0"))
                    .as_ptr(),
            );
        }
    };
    if sse_reg == 0 as libc::c_int {} else {
        __assert_fail(
            b"sse_reg == 0\0" as *const u8 as *const libc::c_char,
            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                as *const u8 as *const libc::c_char,
            1417 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 21],
                &[libc::c_char; 21],
            >(b"void gfunc_call(int)\0"))
                .as_ptr(),
        );
    }
    'c_41798: {
        if sse_reg == 0 as libc::c_int {} else {
            __assert_fail(
                b"sse_reg == 0\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                1417 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 21],
                    &[libc::c_char; 21],
                >(b"void gfunc_call(int)\0"))
                    .as_ptr(),
            );
        }
    };
    save_regs(0 as libc::c_int);
    if nb_reg_args > 2 as libc::c_int {
        o(0xd2894c as libc::c_int as libc::c_uint);
        if nb_reg_args > 3 as libc::c_int {
            o(0xd9894c as libc::c_int as libc::c_uint);
        }
    }
    if ((*(*vtop).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
        .func_type() as libc::c_int != 1 as libc::c_int
    {
        oad(
            0xb8 as libc::c_int,
            if nb_sse_args < 8 as libc::c_int { nb_sse_args } else { 8 as libc::c_int },
        );
    }
    gcall_or_jmp(0 as libc::c_int);
    if args_size != 0 {
        gadd_sp(args_size);
    }
    vtop = vtop.offset(-1);
    vtop;
}
unsafe extern "C" fn push_arg_reg(mut i: libc::c_int) {
    loc -= 8 as libc::c_int;
    gen_modrm64(
        0x89 as libc::c_int,
        arg_regs[i as usize] as libc::c_int,
        0x32 as libc::c_int,
        0 as *mut Sym,
        loc,
    );
}
unsafe extern "C" fn gfunc_prolog(mut func_sym: *mut Sym) {
    let mut func_type: *mut CType = &mut (*func_sym).type_0;
    let mut mode: X86_64_Mode = x86_64_mode_none;
    let mut ret_mode: X86_64_Mode = x86_64_mode_none;
    let mut i: libc::c_int = 0;
    let mut addr: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut reg_count: libc::c_int = 0;
    let mut param_addr: libc::c_int = 0 as libc::c_int;
    let mut reg_param_index: libc::c_int = 0;
    let mut sse_param_index: libc::c_int = 0;
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut type_0: *mut CType = 0 as *mut CType;
    sym = (*func_type).ref_0;
    addr = 8 as libc::c_int * 2 as libc::c_int;
    loc = 0 as libc::c_int;
    ind += 11 as libc::c_int;
    func_sub_sp_offset = ind as libc::c_ulong;
    func_ret_sub = 0 as libc::c_int;
    ret_mode = classify_x86_64_arg(
        &mut func_vt,
        0 as *mut CType,
        &mut size,
        &mut align,
        &mut reg_count,
    );
    if func_var != 0 {
        let mut seen_reg_num: libc::c_int = 0;
        let mut seen_sse_num: libc::c_int = 0;
        let mut seen_stack_size: libc::c_int = 0;
        seen_reg_num = (ret_mode as libc::c_uint
            == x86_64_mode_memory as libc::c_int as libc::c_uint) as libc::c_int;
        seen_sse_num = 0 as libc::c_int;
        seen_stack_size = 8 as libc::c_int * 2 as libc::c_int;
        sym = (*func_type).ref_0;
        loop {
            sym = (*sym).c2rust_unnamed_0.next;
            if sym.is_null() {
                break;
            }
            type_0 = &mut (*sym).type_0;
            mode = classify_x86_64_arg(
                type_0,
                0 as *mut CType,
                &mut size,
                &mut align,
                &mut reg_count,
            );
            match mode as libc::c_uint {
                2 => {
                    if !(seen_reg_num + reg_count > 6 as libc::c_int) {
                        seen_reg_num += reg_count;
                        continue;
                    }
                }
                3 => {
                    if !(seen_sse_num + reg_count > 8 as libc::c_int) {
                        seen_sse_num += reg_count;
                        continue;
                    }
                }
                _ => {}
            }
            seen_stack_size = (seen_stack_size + align - 1 as libc::c_int & -align)
                + size;
        }
        loc -= 24 as libc::c_int;
        o(0xe845c7 as libc::c_int as libc::c_uint);
        gen_le32(seen_reg_num * 8 as libc::c_int);
        o(0xec45c7 as libc::c_int as libc::c_uint);
        gen_le32(seen_sse_num * 16 as libc::c_int + 48 as libc::c_int);
        o(0x9d8d4c as libc::c_int as libc::c_uint);
        gen_le32(seen_stack_size);
        o(0xf05d894c as libc::c_uint);
        o(0x9d8d4c as libc::c_int as libc::c_uint);
        gen_le32(-(176 as libc::c_int) - 24 as libc::c_int);
        o(0xf85d894c as libc::c_uint);
        i = 0 as libc::c_int;
        while i < 8 as libc::c_int {
            loc -= 16 as libc::c_int;
            if (*tcc_state).nosse == 0 {
                o(0xd60f66 as libc::c_int as libc::c_uint);
                gen_modrm(7 as libc::c_int - i, 0x32 as libc::c_int, 0 as *mut Sym, loc);
            }
            o(0x85c748 as libc::c_int as libc::c_uint);
            gen_le32(loc + 8 as libc::c_int);
            gen_le32(0 as libc::c_int);
            i += 1;
            i;
        }
        i = 0 as libc::c_int;
        while i < 6 as libc::c_int {
            push_arg_reg(6 as libc::c_int - 1 as libc::c_int - i);
            i += 1;
            i;
        }
    }
    sym = (*func_type).ref_0;
    reg_param_index = 0 as libc::c_int;
    sse_param_index = 0 as libc::c_int;
    if ret_mode as libc::c_uint == x86_64_mode_memory as libc::c_int as libc::c_uint {
        push_arg_reg(reg_param_index);
        func_vc = loc;
        reg_param_index += 1;
        reg_param_index;
    }
    loop {
        sym = (*sym).c2rust_unnamed_0.next;
        if sym.is_null() {
            break;
        }
        type_0 = &mut (*sym).type_0;
        mode = classify_x86_64_arg(
            type_0,
            0 as *mut CType,
            &mut size,
            &mut align,
            &mut reg_count,
        );
        match mode as libc::c_uint {
            3 => {
                if (*tcc_state).nosse != 0 {
                    _tcc_error(
                        b"SSE disabled but floating point arguments used\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if sse_param_index + reg_count <= 8 as libc::c_int {
                    loc -= reg_count * 8 as libc::c_int;
                    param_addr = loc;
                    i = 0 as libc::c_int;
                    while i < reg_count {
                        o(0xd60f66 as libc::c_int as libc::c_uint);
                        gen_modrm(
                            sse_param_index,
                            0x32 as libc::c_int,
                            0 as *mut Sym,
                            param_addr + i * 8 as libc::c_int,
                        );
                        sse_param_index += 1;
                        sse_param_index;
                        i += 1;
                        i;
                    }
                } else {
                    addr = addr + align - 1 as libc::c_int & -align;
                    param_addr = addr;
                    addr += size;
                }
            }
            1 | 4 => {
                addr = addr + align - 1 as libc::c_int & -align;
                param_addr = addr;
                addr += size;
            }
            2 => {
                if reg_param_index + reg_count <= 6 as libc::c_int {
                    loc -= reg_count * 8 as libc::c_int;
                    param_addr = loc;
                    i = 0 as libc::c_int;
                    while i < reg_count {
                        gen_modrm64(
                            0x89 as libc::c_int,
                            arg_regs[reg_param_index as usize] as libc::c_int,
                            0x32 as libc::c_int,
                            0 as *mut Sym,
                            param_addr + i * 8 as libc::c_int,
                        );
                        reg_param_index += 1;
                        reg_param_index;
                        i += 1;
                        i;
                    }
                } else {
                    addr = addr + align - 1 as libc::c_int & -align;
                    param_addr = addr;
                    addr += size;
                }
            }
            _ => {}
        }
        sym_push(
            (*sym).v & !(0x20000000 as libc::c_int),
            type_0,
            0x32 as libc::c_int | 0x100 as libc::c_int,
            param_addr,
        );
    }
    if (*tcc_state).do_bounds_check != 0 {
        gen_bounds_prolog();
    }
}
unsafe extern "C" fn gfunc_epilog() {
    let mut v: libc::c_int = 0;
    let mut saved_ind: libc::c_int = 0;
    if (*tcc_state).do_bounds_check != 0 {
        gen_bounds_epilog();
    }
    o(0xc9 as libc::c_int as libc::c_uint);
    if func_ret_sub == 0 as libc::c_int {
        o(0xc3 as libc::c_int as libc::c_uint);
    } else {
        o(0xc2 as libc::c_int as libc::c_uint);
        g(func_ret_sub);
        g(func_ret_sub >> 8 as libc::c_int);
    }
    v = -loc + 15 as libc::c_int & -(16 as libc::c_int);
    saved_ind = ind;
    ind = func_sub_sp_offset.wrapping_sub(11 as libc::c_int as libc::c_ulong)
        as libc::c_int;
    o(0xe5894855 as libc::c_uint);
    o(0xec8148 as libc::c_int as libc::c_uint);
    gen_le32(v);
    ind = saved_ind;
}
unsafe extern "C" fn gen_fill_nops(mut bytes: libc::c_int) {
    loop {
        let fresh73 = bytes;
        bytes = bytes - 1;
        if !(fresh73 != 0) {
            break;
        }
        g(0x90 as libc::c_int);
    };
}
unsafe extern "C" fn gjmp(mut t: libc::c_int) -> libc::c_int {
    return oad(0xe9 as libc::c_int, t);
}
unsafe extern "C" fn gjmp_addr(mut a: libc::c_int) {
    let mut r: libc::c_int = 0;
    r = a - ind - 2 as libc::c_int;
    if r == r as libc::c_char as libc::c_int {
        g(0xeb as libc::c_int);
        g(r);
    } else {
        oad(0xe9 as libc::c_int, a - ind - 5 as libc::c_int);
    };
}
unsafe extern "C" fn gjmp_append(mut n: libc::c_int, mut t: libc::c_int) -> libc::c_int {
    let mut p: *mut libc::c_void = 0 as *mut libc::c_void;
    if n != 0 {
        let mut n1: uint32_t = n as uint32_t;
        let mut n2: uint32_t = 0;
        loop {
            p = ((*(*tcc_state).cur_text_section).data).offset(n1 as isize)
                as *mut libc::c_void;
            n2 = read32le(p as *mut libc::c_uchar);
            if !(n2 != 0) {
                break;
            }
            n1 = n2;
        }
        write32le(p as *mut libc::c_uchar, t as uint32_t);
        t = n;
    }
    return t;
}
unsafe extern "C" fn gjmp_cond(mut op: libc::c_int, mut t: libc::c_int) -> libc::c_int {
    if op & 0x100 as libc::c_int != 0 {
        let mut v: libc::c_int = (*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_r
            as libc::c_int;
        op &= !(0x100 as libc::c_int);
        if op ^ v ^ (v != 0x95 as libc::c_int) as libc::c_int != 0 {
            o(0x67a as libc::c_int as libc::c_uint);
        } else {
            g(0xf as libc::c_int);
            t = oad(0x8a as libc::c_int, t);
        }
    }
    g(0xf as libc::c_int);
    t = oad(op - 16 as libc::c_int, t);
    return t;
}
unsafe extern "C" fn gen_opi(mut op: libc::c_int) {
    let mut current_block: u64;
    let mut r: libc::c_int = 0;
    let mut fr: libc::c_int = 0;
    let mut opc: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut ll: libc::c_int = 0;
    let mut uu: libc::c_int = 0;
    let mut cc: libc::c_int = 0;
    ll = is64_type((*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t);
    uu = ((*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t & 0x10 as libc::c_int
        != 0 as libc::c_int) as libc::c_int;
    cc = ((*vtop).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int) as libc::c_int;
    match op {
        43 | 135 => {
            opc = 0 as libc::c_int;
            current_block = 7998613804975135905;
        }
        45 | 137 => {
            opc = 5 as libc::c_int;
            current_block = 7998613804975135905;
        }
        136 => {
            opc = 2 as libc::c_int;
            current_block = 7998613804975135905;
        }
        138 => {
            opc = 3 as libc::c_int;
            current_block = 7998613804975135905;
        }
        38 => {
            opc = 4 as libc::c_int;
            current_block = 7998613804975135905;
        }
        94 => {
            opc = 6 as libc::c_int;
            current_block = 7998613804975135905;
        }
        124 => {
            opc = 1 as libc::c_int;
            current_block = 7998613804975135905;
        }
        42 => {
            gv2(0x1 as libc::c_int, 0x1 as libc::c_int);
            r = (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int;
            fr = (*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int;
            orex(ll, fr, r, 0xaf0f as libc::c_int);
            o(
                (0xc0 as libc::c_int + (fr & 7 as libc::c_int)
                    + (r & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
            );
            vtop = vtop.offset(-1);
            vtop;
            current_block = 5807581744382915773;
        }
        60 => {
            opc = 4 as libc::c_int;
            current_block = 14475218119735768718;
        }
        139 => {
            opc = 5 as libc::c_int;
            current_block = 14475218119735768718;
        }
        62 => {
            opc = 7 as libc::c_int;
            current_block = 14475218119735768718;
        }
        131 | 132 => {
            uu = 1 as libc::c_int;
            current_block = 3371062692360161293;
        }
        47 | 37 | 133 => {
            uu = 0 as libc::c_int;
            current_block = 3371062692360161293;
        }
        _ => {
            opc = 7 as libc::c_int;
            current_block = 7998613804975135905;
        }
    }
    match current_block {
        3371062692360161293 => {
            gv2(0x4 as libc::c_int, 0x10 as libc::c_int);
            r = (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int;
            fr = (*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int;
            vtop = vtop.offset(-1);
            vtop;
            save_reg(TREG_RDX as libc::c_int);
            orex(
                ll,
                0 as libc::c_int,
                0 as libc::c_int,
                if uu != 0 { 0xd231 as libc::c_int } else { 0x99 as libc::c_int },
            );
            orex(ll, fr, 0 as libc::c_int, 0xf7 as libc::c_int);
            o(
                ((if uu != 0 { 0xf0 as libc::c_int } else { 0xf8 as libc::c_int })
                    + (fr & 7 as libc::c_int)) as libc::c_uint,
            );
            if op == '%' as i32 || op == 0x84 as libc::c_int {
                r = TREG_RDX as libc::c_int;
            } else {
                r = TREG_RAX as libc::c_int;
            }
            (*vtop).r = r as libc::c_ushort;
        }
        14475218119735768718 => {
            opc = 0xc0 as libc::c_int | opc << 3 as libc::c_int;
            if cc != 0 {
                vswap();
                r = gv(0x1 as libc::c_int);
                vswap();
                orex(ll, r, 0 as libc::c_int, 0xc1 as libc::c_int);
                o((opc | r & 7 as libc::c_int) as libc::c_uint);
                g(
                    ((*vtop).c2rust_unnamed.c.i
                        & (if ll != 0 { 63 as libc::c_int } else { 31 as libc::c_int })
                            as uint64_t) as libc::c_int,
                );
            } else {
                gv2(0x1 as libc::c_int, 0x10 as libc::c_int);
                r = (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int;
                orex(ll, r, 0 as libc::c_int, 0xd3 as libc::c_int);
                o((opc | r & 7 as libc::c_int) as libc::c_uint);
            }
            vtop = vtop.offset(-1);
            vtop;
        }
        7998613804975135905 => {
            if cc != 0
                && (ll == 0
                    || (*vtop).c2rust_unnamed.c.i as libc::c_int as uint64_t
                        == (*vtop).c2rust_unnamed.c.i)
            {
                vswap();
                r = gv(0x1 as libc::c_int);
                vswap();
                c = (*vtop).c2rust_unnamed.c.i as libc::c_int;
                if c == c as libc::c_char as libc::c_int {
                    orex(ll, r, 0 as libc::c_int, 0x83 as libc::c_int);
                    o(
                        (0xc0 as libc::c_int | opc << 3 as libc::c_int
                            | r & 7 as libc::c_int) as libc::c_uint,
                    );
                    g(c);
                } else {
                    orex(ll, r, 0 as libc::c_int, 0x81 as libc::c_int);
                    oad(
                        0xc0 as libc::c_int | opc << 3 as libc::c_int
                            | r & 7 as libc::c_int,
                        c,
                    );
                }
            } else {
                gv2(0x1 as libc::c_int, 0x1 as libc::c_int);
                r = (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int;
                fr = (*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int;
                orex(ll, r, fr, opc << 3 as libc::c_int | 0x1 as libc::c_int);
                o(
                    (0xc0 as libc::c_int + (r & 7 as libc::c_int)
                        + (fr & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
                );
            }
            vtop = vtop.offset(-1);
            vtop;
            if op >= 0x92 as libc::c_int && op <= 0x9f as libc::c_int {
                vset_VT_CMP(op);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn gen_opl(mut op: libc::c_int) {
    gen_opi(op);
}
unsafe extern "C" fn gen_opf(mut op: libc::c_int) {
    let mut a: libc::c_int = 0;
    let mut ft: libc::c_int = 0;
    let mut fc: libc::c_int = 0;
    let mut swapped: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut bt: libc::c_int = (*vtop).type_0.t & 0xf as libc::c_int;
    let mut float_type: libc::c_int = if bt == 10 as libc::c_int {
        0x80 as libc::c_int
    } else {
        0x2 as libc::c_int
    };
    if op == 0x81 as libc::c_int {
        gv(float_type);
        if float_type == 0x80 as libc::c_int {
            o(0xe0d9 as libc::c_int as libc::c_uint);
        } else {
            save_reg((*vtop).r as libc::c_int);
            o(0x80 as libc::c_int as libc::c_uint);
            gen_modrm(
                6 as libc::c_int,
                (*vtop).r as libc::c_int,
                0 as *mut Sym,
                ((*vtop).c2rust_unnamed.c.i)
                    .wrapping_add(
                        (if bt == 9 as libc::c_int {
                            7 as libc::c_int
                        } else {
                            3 as libc::c_int
                        }) as uint64_t,
                    ) as libc::c_int,
            );
            o(0x80 as libc::c_int as libc::c_uint);
        }
        return;
    }
    if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int) == 0x30 as libc::c_int
    {
        vswap();
        gv(float_type);
        vswap();
    }
    if (*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int) == 0x30 as libc::c_int
    {
        gv(float_type);
    }
    if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
        & 0x100 as libc::c_int != 0
        && (*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int
            & 0x100 as libc::c_int != 0
    {
        vswap();
        gv(float_type);
        vswap();
    }
    swapped = 0 as libc::c_int;
    if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
        & 0x100 as libc::c_int != 0
    {
        vswap();
        swapped = 1 as libc::c_int;
    }
    if (*vtop).type_0.t & 0xf as libc::c_int == 10 as libc::c_int {
        if op >= 0x92 as libc::c_int && op <= 0x9f as libc::c_int {
            load(TREG_ST0 as libc::c_int, vtop);
            save_reg(TREG_RAX as libc::c_int);
            if op == 0x9d as libc::c_int || op == 0x9f as libc::c_int {
                swapped = (swapped == 0) as libc::c_int;
            } else if op == 0x94 as libc::c_int || op == 0x95 as libc::c_int {
                swapped = 0 as libc::c_int;
            }
            if swapped != 0 {
                o(0xc9d9 as libc::c_int as libc::c_uint);
            }
            if op == 0x94 as libc::c_int || op == 0x95 as libc::c_int {
                o(0xe9da as libc::c_int as libc::c_uint);
            } else {
                o(0xd9de as libc::c_int as libc::c_uint);
            }
            o(0xe0df as libc::c_int as libc::c_uint);
            if op == 0x94 as libc::c_int {
                o(0x45e480 as libc::c_int as libc::c_uint);
                o(0x40fc80 as libc::c_int as libc::c_uint);
            } else if op == 0x95 as libc::c_int {
                o(0x45e480 as libc::c_int as libc::c_uint);
                o(0x40f480 as libc::c_int as libc::c_uint);
                op = 0x95 as libc::c_int;
            } else if op == 0x9d as libc::c_int || op == 0x9e as libc::c_int {
                o(0x5c4f6 as libc::c_int as libc::c_uint);
                op = 0x94 as libc::c_int;
            } else {
                o(0x45c4f6 as libc::c_int as libc::c_uint);
                op = 0x94 as libc::c_int;
            }
            vtop = vtop.offset(-1);
            vtop;
            vset_VT_CMP(op);
        } else {
            load(TREG_ST0 as libc::c_int, vtop);
            swapped = (swapped == 0) as libc::c_int;
            match op {
                45 => {
                    a = 4 as libc::c_int;
                    if swapped != 0 {
                        a += 1;
                        a;
                    }
                }
                42 => {
                    a = 1 as libc::c_int;
                }
                47 => {
                    a = 6 as libc::c_int;
                    if swapped != 0 {
                        a += 1;
                        a;
                    }
                }
                43 | _ => {
                    a = 0 as libc::c_int;
                }
            }
            ft = (*vtop).type_0.t;
            fc = (*vtop).c2rust_unnamed.c.i as libc::c_int;
            o(0xde as libc::c_int as libc::c_uint);
            o((0xc1 as libc::c_int + (a << 3 as libc::c_int)) as libc::c_uint);
            vtop = vtop.offset(-1);
            vtop;
        }
    } else if op >= 0x92 as libc::c_int && op <= 0x9f as libc::c_int {
        r = (*vtop).r as libc::c_int;
        fc = (*vtop).c2rust_unnamed.c.i as libc::c_int;
        if r & 0x3f as libc::c_int == 0x31 as libc::c_int {
            let mut v1: SValue = SValue {
                type_0: CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                },
                r: 0,
                r2: 0,
                c2rust_unnamed: C2RustUnnamed_15 {
                    c2rust_unnamed: C2RustUnnamed_16 {
                        jtrue: 0,
                        jfalse: 0,
                    },
                },
                c2rust_unnamed_0: C2RustUnnamed_13 {
                    c2rust_unnamed: C2RustUnnamed_14 {
                        cmp_op: 0,
                        cmp_r: 0,
                    },
                },
            };
            r = get_reg(0x1 as libc::c_int);
            v1.type_0.t = 5 as libc::c_int;
            v1.r = (0x32 as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
            v1.c2rust_unnamed.c.i = fc as uint64_t;
            load(r, &mut v1);
            fc = 0 as libc::c_int;
            r = r | 0x100 as libc::c_int;
            (*vtop).r = r as libc::c_ushort;
        }
        if op == 0x94 as libc::c_int || op == 0x95 as libc::c_int {
            swapped = 0 as libc::c_int;
        } else {
            if op == 0x9e as libc::c_int || op == 0x9c as libc::c_int {
                swapped = (swapped == 0) as libc::c_int;
            }
            if op == 0x9e as libc::c_int || op == 0x9d as libc::c_int {
                op = 0x93 as libc::c_int;
            } else {
                op = 0x97 as libc::c_int;
            }
        }
        if swapped != 0 {
            gv(0x2 as libc::c_int);
            vswap();
        }
        if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
            & 0x100 as libc::c_int == 0
        {} else {
            __assert_fail(
                b"!(vtop[-1].r & VT_LVAL)\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                1966 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"void gen_opf(int)\0"))
                    .as_ptr(),
            );
        }
        'c_38059: {
            if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
                & 0x100 as libc::c_int == 0
            {} else {
                __assert_fail(
                    b"!(vtop[-1].r & VT_LVAL)\0" as *const u8 as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    1966 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"void gen_opf(int)\0"))
                        .as_ptr(),
                );
            }
        };
        if (*vtop).type_0.t & 0xf as libc::c_int == 9 as libc::c_int {
            o(0x66 as libc::c_int as libc::c_uint);
        }
        if op == 0x94 as libc::c_int || op == 0x95 as libc::c_int {
            o(0x2e0f as libc::c_int as libc::c_uint);
        } else {
            o(0x2f0f as libc::c_int as libc::c_uint);
        }
        if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {
            gen_modrm(
                (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int,
                r,
                (*vtop).c2rust_unnamed_0.sym,
                fc,
            );
        } else {
            o(
                (0xc0 as libc::c_int
                    + ((*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int
                        & 7 as libc::c_int)
                    + ((*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
                        & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
            );
        }
        vtop = vtop.offset(-1);
        vtop;
        vset_VT_CMP(op | 0x100 as libc::c_int);
        (*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_r = op as libc::c_ushort;
    } else {
        if (*vtop).type_0.t & 0xf as libc::c_int != 10 as libc::c_int {} else {
            __assert_fail(
                b"(vtop->type.t & VT_BTYPE) != VT_LDOUBLE\0" as *const u8
                    as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                1985 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"void gen_opf(int)\0"))
                    .as_ptr(),
            );
        }
        'c_37881: {
            if (*vtop).type_0.t & 0xf as libc::c_int != 10 as libc::c_int {} else {
                __assert_fail(
                    b"(vtop->type.t & VT_BTYPE) != VT_LDOUBLE\0" as *const u8
                        as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    1985 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"void gen_opf(int)\0"))
                        .as_ptr(),
                );
            }
        };
        match op {
            45 => {
                a = 4 as libc::c_int;
            }
            42 => {
                a = 1 as libc::c_int;
            }
            47 => {
                a = 6 as libc::c_int;
            }
            43 | _ => {
                a = 0 as libc::c_int;
            }
        }
        ft = (*vtop).type_0.t;
        fc = (*vtop).c2rust_unnamed.c.i as libc::c_int;
        if ft & 0xf as libc::c_int != 10 as libc::c_int {} else {
            __assert_fail(
                b"(ft & VT_BTYPE) != VT_LDOUBLE\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                2003 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"void gen_opf(int)\0"))
                    .as_ptr(),
            );
        }
        'c_37787: {
            if ft & 0xf as libc::c_int != 10 as libc::c_int {} else {
                __assert_fail(
                    b"(ft & VT_BTYPE) != VT_LDOUBLE\0" as *const u8
                        as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    2003 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"void gen_opf(int)\0"))
                        .as_ptr(),
                );
            }
        };
        r = (*vtop).r as libc::c_int;
        if (*vtop).r as libc::c_int & 0x3f as libc::c_int == 0x31 as libc::c_int {
            let mut v1_0: SValue = SValue {
                type_0: CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                },
                r: 0,
                r2: 0,
                c2rust_unnamed: C2RustUnnamed_15 {
                    c2rust_unnamed: C2RustUnnamed_16 {
                        jtrue: 0,
                        jfalse: 0,
                    },
                },
                c2rust_unnamed_0: C2RustUnnamed_13 {
                    c2rust_unnamed: C2RustUnnamed_14 {
                        cmp_op: 0,
                        cmp_r: 0,
                    },
                },
            };
            r = get_reg(0x1 as libc::c_int);
            v1_0.type_0.t = 5 as libc::c_int;
            v1_0.r = (0x32 as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
            v1_0.c2rust_unnamed.c.i = fc as uint64_t;
            load(r, &mut v1_0);
            fc = 0 as libc::c_int;
            r = r | 0x100 as libc::c_int;
            (*vtop).r = r as libc::c_ushort;
        }
        if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
            & 0x100 as libc::c_int == 0
        {} else {
            __assert_fail(
                b"!(vtop[-1].r & VT_LVAL)\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                2018 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"void gen_opf(int)\0"))
                    .as_ptr(),
            );
        }
        'c_37661: {
            if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
                & 0x100 as libc::c_int == 0
            {} else {
                __assert_fail(
                    b"!(vtop[-1].r & VT_LVAL)\0" as *const u8 as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    2018 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"void gen_opf(int)\0"))
                        .as_ptr(),
                );
            }
        };
        if swapped != 0 {
            if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {} else {
                __assert_fail(
                    b"vtop->r & VT_LVAL\0" as *const u8 as *const libc::c_char,
                    b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                        as *const u8 as *const libc::c_char,
                    2020 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 18],
                        &[libc::c_char; 18],
                    >(b"void gen_opf(int)\0"))
                        .as_ptr(),
                );
            }
            'c_37617: {
                if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {} else {
                    __assert_fail(
                        b"vtop->r & VT_LVAL\0" as *const u8 as *const libc::c_char,
                        b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                            as *const u8 as *const libc::c_char,
                        2020 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 18],
                            &[libc::c_char; 18],
                        >(b"void gen_opf(int)\0"))
                            .as_ptr(),
                    );
                }
            };
            gv(0x2 as libc::c_int);
            vswap();
            fc = (*vtop).c2rust_unnamed.c.i as libc::c_int;
        }
        if ft & 0xf as libc::c_int == 9 as libc::c_int {
            o(0xf2 as libc::c_int as libc::c_uint);
        } else {
            o(0xf3 as libc::c_int as libc::c_uint);
        }
        o(0xf as libc::c_int as libc::c_uint);
        o((0x58 as libc::c_int + a) as libc::c_uint);
        if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {
            gen_modrm(
                (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int,
                r,
                (*vtop).c2rust_unnamed_0.sym,
                fc,
            );
        } else {
            o(
                (0xc0 as libc::c_int
                    + ((*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int
                        & 7 as libc::c_int)
                    + ((*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
                        & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
            );
        }
        vtop = vtop.offset(-1);
        vtop;
    };
}
unsafe extern "C" fn gen_cvt_itof(mut t: libc::c_int) {
    if t & 0xf as libc::c_int == 10 as libc::c_int {
        save_reg(TREG_ST0 as libc::c_int);
        gv(0x1 as libc::c_int);
        if (*vtop).type_0.t & 0xf as libc::c_int == 4 as libc::c_int {
            o(
                (0x50 as libc::c_int + ((*vtop).r as libc::c_int & 0x3f as libc::c_int))
                    as libc::c_uint,
            );
            o(0x242cdf as libc::c_int as libc::c_uint);
            o(0x8c48348 as libc::c_int as libc::c_uint);
        } else if (*vtop).type_0.t & (0xf as libc::c_int | 0x10 as libc::c_int)
            == 3 as libc::c_int | 0x10 as libc::c_int
        {
            o(0x6a as libc::c_int as libc::c_uint);
            g(0 as libc::c_int);
            o(
                (0x50 as libc::c_int + ((*vtop).r as libc::c_int & 0x3f as libc::c_int))
                    as libc::c_uint,
            );
            o(0x242cdf as libc::c_int as libc::c_uint);
            o(0x10c48348 as libc::c_int as libc::c_uint);
        } else {
            o(
                (0x50 as libc::c_int + ((*vtop).r as libc::c_int & 0x3f as libc::c_int))
                    as libc::c_uint,
            );
            o(0x2404db as libc::c_int as libc::c_uint);
            o(0x8c48348 as libc::c_int as libc::c_uint);
        }
        (*vtop).r = TREG_ST0 as libc::c_int as libc::c_ushort;
    } else {
        let mut r: libc::c_int = get_reg(0x2 as libc::c_int);
        gv(0x1 as libc::c_int);
        o(
            (0xf2 as libc::c_int
                + (if t & 0xf as libc::c_int == 8 as libc::c_int {
                    1 as libc::c_int
                } else {
                    0 as libc::c_int
                })) as libc::c_uint,
        );
        if (*vtop).type_0.t & (0xf as libc::c_int | 0x10 as libc::c_int)
            == 3 as libc::c_int | 0x10 as libc::c_int
            || (*vtop).type_0.t & 0xf as libc::c_int == 4 as libc::c_int
        {
            o(0x48 as libc::c_int as libc::c_uint);
        }
        o(0x2a0f as libc::c_int as libc::c_uint);
        o(
            (0xc0 as libc::c_int + ((*vtop).r as libc::c_int & 0x3f as libc::c_int)
                + (r & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
        );
        (*vtop).r = r as libc::c_ushort;
    };
}
unsafe extern "C" fn gen_cvt_ftof(mut t: libc::c_int) {
    let mut ft: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut tbt: libc::c_int = 0;
    ft = (*vtop).type_0.t;
    bt = ft & 0xf as libc::c_int;
    tbt = t & 0xf as libc::c_int;
    if bt == 8 as libc::c_int {
        gv(0x2 as libc::c_int);
        if tbt == 9 as libc::c_int {
            o(0x140f as libc::c_int as libc::c_uint);
            o(
                (0xc0 as libc::c_int
                    + ((*vtop).r as libc::c_int & 7 as libc::c_int) * 9 as libc::c_int)
                    as libc::c_uint,
            );
            o(0x5a0f as libc::c_int as libc::c_uint);
            o(
                (0xc0 as libc::c_int
                    + ((*vtop).r as libc::c_int & 7 as libc::c_int) * 9 as libc::c_int)
                    as libc::c_uint,
            );
        } else if tbt == 10 as libc::c_int {
            save_reg(0x80 as libc::c_int);
            o(0x110ff3 as libc::c_int as libc::c_uint);
            o(
                (0x44 as libc::c_int
                    + ((*vtop).r as libc::c_int & 7 as libc::c_int) * 8 as libc::c_int)
                    as libc::c_uint,
            );
            o(0xf024 as libc::c_int as libc::c_uint);
            o(0xf02444d9 as libc::c_uint);
            (*vtop).r = TREG_ST0 as libc::c_int as libc::c_ushort;
        }
    } else if bt == 9 as libc::c_int {
        gv(0x2 as libc::c_int);
        if tbt == 8 as libc::c_int {
            o(0x140f66 as libc::c_int as libc::c_uint);
            o(
                (0xc0 as libc::c_int
                    + ((*vtop).r as libc::c_int & 7 as libc::c_int) * 9 as libc::c_int)
                    as libc::c_uint,
            );
            o(0x5a0f66 as libc::c_int as libc::c_uint);
            o(
                (0xc0 as libc::c_int
                    + ((*vtop).r as libc::c_int & 7 as libc::c_int) * 9 as libc::c_int)
                    as libc::c_uint,
            );
        } else if tbt == 10 as libc::c_int {
            save_reg(0x80 as libc::c_int);
            o(0x110ff2 as libc::c_int as libc::c_uint);
            o(
                (0x44 as libc::c_int
                    + ((*vtop).r as libc::c_int & 7 as libc::c_int) * 8 as libc::c_int)
                    as libc::c_uint,
            );
            o(0xf024 as libc::c_int as libc::c_uint);
            o(0xf02444dd as libc::c_uint);
            (*vtop).r = TREG_ST0 as libc::c_int as libc::c_ushort;
        }
    } else {
        let mut r: libc::c_int = 0;
        gv(0x80 as libc::c_int);
        r = get_reg(0x2 as libc::c_int);
        if tbt == 9 as libc::c_int {
            o(0xf0245cdd as libc::c_uint);
            o(0x100ff2 as libc::c_int as libc::c_uint);
            o(
                (0x44 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                    as libc::c_uint,
            );
            o(0xf024 as libc::c_int as libc::c_uint);
            (*vtop).r = r as libc::c_ushort;
        } else if tbt == 8 as libc::c_int {
            o(0xf0245cd9 as libc::c_uint);
            o(0x100ff3 as libc::c_int as libc::c_uint);
            o(
                (0x44 as libc::c_int + (r & 7 as libc::c_int) * 8 as libc::c_int)
                    as libc::c_uint,
            );
            o(0xf024 as libc::c_int as libc::c_uint);
            (*vtop).r = r as libc::c_ushort;
        }
    };
}
unsafe extern "C" fn gen_cvt_ftoi(mut t: libc::c_int) {
    let mut ft: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    ft = (*vtop).type_0.t;
    bt = ft & 0xf as libc::c_int;
    if bt == 10 as libc::c_int {
        gen_cvt_ftof(9 as libc::c_int);
        bt = 9 as libc::c_int;
    }
    gv(0x2 as libc::c_int);
    if t != 3 as libc::c_int {
        size = 8 as libc::c_int;
    } else {
        size = 4 as libc::c_int;
    }
    r = get_reg(0x1 as libc::c_int);
    if bt == 8 as libc::c_int {
        o(0xf3 as libc::c_int as libc::c_uint);
    } else if bt == 9 as libc::c_int {
        o(0xf2 as libc::c_int as libc::c_uint);
    } else {
        __assert_fail(
            b"0\0" as *const u8 as *const libc::c_char,
            b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                as *const u8 as *const libc::c_char,
            2174 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 23],
                &[libc::c_char; 23],
            >(b"void gen_cvt_ftoi(int)\0"))
                .as_ptr(),
        );
        'c_40936: {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"/mnt/c/Users/mazin/Downloads/School/Research/datasets/tinycc/x86_64-gen.c\0"
                    as *const u8 as *const libc::c_char,
                2174 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 23],
                    &[libc::c_char; 23],
                >(b"void gen_cvt_ftoi(int)\0"))
                    .as_ptr(),
            );
        };
    }
    orex(
        (size == 8 as libc::c_int) as libc::c_int,
        r,
        0 as libc::c_int,
        0x2c0f as libc::c_int,
    );
    o(
        (0xc0 as libc::c_int + ((*vtop).r as libc::c_int & 7 as libc::c_int)
            + (r & 7 as libc::c_int) * 8 as libc::c_int) as libc::c_uint,
    );
    (*vtop).r = r as libc::c_ushort;
}
unsafe extern "C" fn gen_cvt_sxtw() {
    let mut r: libc::c_int = gv(0x1 as libc::c_int);
    o(0x6348 as libc::c_int as libc::c_uint);
    o(
        (0xc0 as libc::c_int + ((r & 7 as libc::c_int) << 3 as libc::c_int)
            + (r & 7 as libc::c_int)) as libc::c_uint,
    );
}
unsafe extern "C" fn gen_cvt_csti(mut t: libc::c_int) {
    let mut r: libc::c_int = 0;
    let mut sz: libc::c_int = 0;
    let mut xl: libc::c_int = 0;
    let mut ll: libc::c_int = 0;
    r = gv(0x1 as libc::c_int);
    sz = (t & 0x10 as libc::c_int == 0) as libc::c_int;
    xl = (t & 0xf as libc::c_int == 2 as libc::c_int) as libc::c_int;
    ll = ((*vtop).type_0.t & 0xf as libc::c_int == 4 as libc::c_int) as libc::c_int;
    orex(
        ll,
        r,
        0 as libc::c_int,
        0xc0b60f as libc::c_int | (sz << 3 as libc::c_int | xl) << 8 as libc::c_int
            | ((r & 7 as libc::c_int) << 3 as libc::c_int | r & 7 as libc::c_int)
                << 16 as libc::c_int,
    );
}
unsafe extern "C" fn gen_increment_tcov(mut sv: *mut SValue) {
    o(0x58348 as libc::c_int as libc::c_uint);
    greloca(
        (*tcc_state).cur_text_section,
        (*sv).c2rust_unnamed_0.sym,
        ind as libc::c_ulong,
        2 as libc::c_int,
        -(5 as libc::c_int) as Elf64_Addr,
    );
    gen_le32(0 as libc::c_int);
    o(1 as libc::c_int as libc::c_uint);
}
unsafe extern "C" fn ggoto() {
    gcall_or_jmp(1 as libc::c_int);
    vtop = vtop.offset(-1);
    vtop;
}
unsafe extern "C" fn gen_vla_sp_save(mut addr: libc::c_int) {
    gen_modrm64(
        0x89 as libc::c_int,
        TREG_RSP as libc::c_int,
        0x32 as libc::c_int,
        0 as *mut Sym,
        addr,
    );
}
unsafe extern "C" fn gen_vla_sp_restore(mut addr: libc::c_int) {
    gen_modrm64(
        0x8b as libc::c_int,
        TREG_RSP as libc::c_int,
        0x32 as libc::c_int,
        0 as *mut Sym,
        addr,
    );
}
unsafe extern "C" fn gen_vla_alloc(mut type_0: *mut CType, mut align: libc::c_int) {
    let mut use_call: libc::c_int = 0 as libc::c_int;
    use_call = (*tcc_state).do_bounds_check as libc::c_int;
    if use_call != 0 {
        vpush_helper_func(TOK_alloca as libc::c_int);
        vswap();
        gfunc_call(1 as libc::c_int);
    } else {
        let mut r: libc::c_int = 0;
        r = gv(0x1 as libc::c_int);
        o(0x2b48 as libc::c_int as libc::c_uint);
        o((0xe0 as libc::c_int | r & 7 as libc::c_int) as libc::c_uint);
        o(0xf0e48348 as libc::c_uint);
        vpop();
    };
}
unsafe extern "C" fn gen_struct_copy(mut size: libc::c_int) {
    let mut n: libc::c_int = size / 8 as libc::c_int;
    gv2(0x40 as libc::c_int, 0x20 as libc::c_int);
    if n <= 4 as libc::c_int {
        while n != 0 {
            o(0xa548 as libc::c_int as libc::c_uint);
            n -= 1;
            n;
        }
    } else {
        vpushi(n);
        gv(0x10 as libc::c_int);
        o(0xa548f3 as libc::c_int as libc::c_uint);
        vpop();
    }
    if size & 0x4 as libc::c_int != 0 {
        o(0xa5 as libc::c_int as libc::c_uint);
    }
    if size & 0x2 as libc::c_int != 0 {
        o(0xa566 as libc::c_int as libc::c_uint);
    }
    if size & 0x1 as libc::c_int != 0 {
        o(0xa4 as libc::c_int as libc::c_uint);
    }
    vpop();
    vpop();
}
static mut tok_flags: libc::c_int = 0;
static mut parse_flags: libc::c_int = 0;
static mut file: *mut BufferedFile = 0 as *const BufferedFile as *mut BufferedFile;
static mut tok: libc::c_int = 0;
static mut tokc: CValue = CValue { ld: f128::f128::ZERO };
static mut macro_ptr: *const libc::c_int = 0 as *const libc::c_int;
static mut tokcstr: CString = CString {
    size: 0,
    size_allocated: 0,
    data: 0 as *mut libc::c_char,
};
static mut tok_ident: libc::c_int = 0;
static mut table_ident: *mut *mut TokenSym = 0 as *const *mut TokenSym
    as *mut *mut TokenSym;
static mut pp_expr: libc::c_int = 0;
static mut hash_ident: [*mut TokenSym; 16384] = [0 as *const TokenSym
    as *mut TokenSym; 16384];
static mut token_buf: [libc::c_char; 1025] = [0; 1025];
static mut cstr_buf: CString = CString {
    size: 0,
    size_allocated: 0,
    data: 0 as *mut libc::c_char,
};
static mut tokstr_buf: TokenString = TokenString {
    str_0: 0 as *const libc::c_int as *mut libc::c_int,
    len: 0,
    need_spc: 0,
    allocated_len: 0,
    last_line_num: 0,
    save_line_num: 0,
    prev: 0 as *const TokenString as *mut TokenString,
    prev_ptr: 0 as *const libc::c_int,
    alloc: 0,
};
static mut unget_buf: TokenString = TokenString {
    str_0: 0 as *const libc::c_int as *mut libc::c_int,
    len: 0,
    need_spc: 0,
    allocated_len: 0,
    last_line_num: 0,
    save_line_num: 0,
    prev: 0 as *const TokenString as *mut TokenString,
    prev_ptr: 0 as *const libc::c_int,
    alloc: 0,
};
static mut isidnum_table: [libc::c_uchar; 257] = [0; 257];
static mut pp_debug_tok: libc::c_int = 0;
static mut pp_debug_symv: libc::c_int = 0;
static mut pp_counter: libc::c_int = 0;
static mut toksym_alloc: *mut TinyAlloc = 0 as *const TinyAlloc as *mut TinyAlloc;
static mut tokstr_alloc: *mut TinyAlloc = 0 as *const TinyAlloc as *mut TinyAlloc;
static mut macro_stack: *mut TokenString = 0 as *const TokenString as *mut TokenString;
static mut tcc_keywords: [libc::c_char; 7148] = unsafe {
    *::core::mem::transmute::<
        &[u8; 7148],
        &[libc::c_char; 7148],
    >(
        b"if\0else\0while\0for\0do\0continue\0break\0return\0goto\0switch\0case\0default\0asm\0__asm\0__asm__\0extern\0static\0unsigned\0_Atomic\0const\0__const\0__const__\0volatile\0__volatile\0__volatile__\0register\0signed\0__signed\0__signed__\0auto\0inline\0__inline\0__inline__\0restrict\0__restrict\0__restrict__\0__extension__\0_Thread_local\0_Generic\0_Static_assert\0void\0char\0int\0float\0double\0_Bool\0_Complex\0short\0long\0struct\0union\0typedef\0enum\0sizeof\0__attribute\0__attribute__\0__alignof\0__alignof__\0_Alignof\0_Alignas\0typeof\0__typeof\0__typeof__\0__label__\0define\0include\0include_next\0ifdef\0ifndef\0elif\0endif\0defined\0undef\0error\0warning\0line\0pragma\0__LINE__\0__FILE__\0__DATE__\0__TIME__\0__FUNCTION__\0__VA_ARGS__\0__COUNTER__\0__has_include\0__has_include_next\0__func__\0__nan__\0__snan__\0__inf__\0section\0__section__\0aligned\0__aligned__\0packed\0__packed__\0weak\0__weak__\0alias\0__alias__\0unused\0__unused__\0nodebug\0__nodebug__\0cdecl\0__cdecl\0__cdecl__\0stdcall\0__stdcall\0__stdcall__\0fastcall\0__fastcall\0__fastcall__\0thiscall\0__thiscall\0__thiscall__\0regparm\0__regparm__\0cleanup\0__cleanup__\0constructor\0__constructor__\0destructor\0__destructor__\0always_inline\0__always_inline__\0__mode__\0__QI__\0__DI__\0__HI__\0__SI__\0__word__\0dllexport\0dllimport\0nodecorate\0noreturn\0__noreturn__\0_Noreturn\0visibility\0__visibility__\0__builtin_types_compatible_p\0__builtin_choose_expr\0__builtin_constant_p\0__builtin_frame_address\0__builtin_return_address\0__builtin_expect\0__builtin_unreachable\0__builtin_va_arg_types\0__atomic_store\0__atomic_load\0__atomic_exchange\0__atomic_compare_exchange\0__atomic_fetch_add\0__atomic_fetch_sub\0__atomic_fetch_or\0__atomic_fetch_xor\0__atomic_fetch_and\0__atomic_fetch_nand\0__atomic_add_fetch\0__atomic_sub_fetch\0__atomic_or_fetch\0__atomic_xor_fetch\0__atomic_and_fetch\0__atomic_nand_fetch\0pack\0comment\0lib\0push_macro\0pop_macro\0once\0option\0memcpy\0memmove\0memset\0__divdi3\0__moddi3\0__udivdi3\0__umoddi3\0__ashrdi3\0__lshrdi3\0__ashldi3\0__floatundisf\0__floatundidf\0__floatundixf\0__fixunsxfdi\0__fixunssfdi\0__fixunsdfdi\0alloca\0__bound_ptr_add\0__bound_ptr_indir1\0__bound_ptr_indir2\0__bound_ptr_indir4\0__bound_ptr_indir8\0__bound_ptr_indir12\0__bound_ptr_indir16\0__bound_main_arg\0__bound_local_new\0__bound_local_delete\0__bound_setjmp\0__bound_longjmp\0__bound_new_region\0sigsetjmp\0__sigsetjmp\0siglongjmp\0setjmp\0_setjmp\0longjmp\0.byte\0.word\0.align\0.balign\0.p2align\0.set\0.skip\0.space\0.string\0.asciz\0.ascii\0.file\0.globl\0.global\0.weak\0.hidden\0.ident\0.size\0.type\0.text\0.data\0.bss\0.previous\0.pushsection\0.popsection\0.fill\0.rept\0.endr\0.org\0.quad\0.code64\0.short\0.long\0.int\0.symver\0.section\0al\0cl\0dl\0bl\0ah\0ch\0dh\0bh\0ax\0cx\0dx\0bx\0sp\0bp\0si\0di\0eax\0ecx\0edx\0ebx\0esp\0ebp\0esi\0edi\0rax\0rcx\0rdx\0rbx\0rsp\0rbp\0rsi\0rdi\0mm0\0mm1\0mm2\0mm3\0mm4\0mm5\0mm6\0mm7\0xmm0\0xmm1\0xmm2\0xmm3\0xmm4\0xmm5\0xmm6\0xmm7\0cr0\0cr1\0cr2\0cr3\0cr4\0cr5\0cr6\0cr7\0tr0\0tr1\0tr2\0tr3\0tr4\0tr5\0tr6\0tr7\0db0\0db1\0db2\0db3\0db4\0db5\0db6\0db7\0dr0\0dr1\0dr2\0dr3\0dr4\0dr5\0dr6\0dr7\0es\0cs\0ss\0ds\0fs\0gs\0st\0rip\0spl\0bpl\0sil\0dil\0movb\0movw\0movl\0movq\0mov\0addb\0addw\0addl\0addq\0add\0orb\0orw\0orl\0orq\0or\0adcb\0adcw\0adcl\0adcq\0adc\0sbbb\0sbbw\0sbbl\0sbbq\0sbb\0andb\0andw\0andl\0andq\0and\0subb\0subw\0subl\0subq\0sub\0xorb\0xorw\0xorl\0xorq\0xor\0cmpb\0cmpw\0cmpl\0cmpq\0cmp\0incb\0incw\0incl\0incq\0inc\0decb\0decw\0decl\0decq\0dec\0notb\0notw\0notl\0notq\0not\0negb\0negw\0negl\0negq\0neg\0mulb\0mulw\0mull\0mulq\0mul\0imulb\0imulw\0imull\0imulq\0imul\0divb\0divw\0divl\0divq\0div\0idivb\0idivw\0idivl\0idivq\0idiv\0xchgb\0xchgw\0xchgl\0xchgq\0xchg\0testb\0testw\0testl\0testq\0test\0rolb\0rolw\0roll\0rolq\0rol\0rorb\0rorw\0rorl\0rorq\0ror\0rclb\0rclw\0rcll\0rclq\0rcl\0rcrb\0rcrw\0rcrl\0rcrq\0rcr\0shlb\0shlw\0shll\0shlq\0shl\0shrb\0shrw\0shrl\0shrq\0shr\0sarb\0sarw\0sarl\0sarq\0sar\0shldw\0shldl\0shldq\0shld\0shrdw\0shrdl\0shrdq\0shrd\0pushw\0pushl\0pushq\0push\0popw\0popl\0popq\0pop\0inb\0inw\0inl\0in\0outb\0outw\0outl\0out\0movzbw\0movzbl\0movzbq\0movzb\0movzwl\0movsbw\0movsbl\0movswl\0movsbq\0movswq\0movzwq\0movslq\0leaw\0leal\0leaq\0lea\0les\0lds\0lss\0lfs\0lgs\0call\0jmp\0lcall\0ljmp\0jo\0jno\0jb\0jc\0jnae\0jnb\0jnc\0jae\0je\0jz\0jne\0jnz\0jbe\0jna\0jnbe\0ja\0js\0jns\0jp\0jpe\0jnp\0jpo\0jl\0jnge\0jnl\0jge\0jle\0jng\0jnle\0jg\0seto\0setno\0setb\0setc\0setnae\0setnb\0setnc\0setae\0sete\0setz\0setne\0setnz\0setbe\0setna\0setnbe\0seta\0sets\0setns\0setp\0setpe\0setnp\0setpo\0setl\0setnge\0setnl\0setge\0setle\0setng\0setnle\0setg\0setob\0setnob\0setbb\0setcb\0setnaeb\0setnbb\0setncb\0setaeb\0seteb\0setzb\0setneb\0setnzb\0setbeb\0setnab\0setnbeb\0setab\0setsb\0setnsb\0setpb\0setpeb\0setnpb\0setpob\0setlb\0setngeb\0setnlb\0setgeb\0setleb\0setngb\0setnleb\0setgb\0cmovo\0cmovno\0cmovb\0cmovc\0cmovnae\0cmovnb\0cmovnc\0cmovae\0cmove\0cmovz\0cmovne\0cmovnz\0cmovbe\0cmovna\0cmovnbe\0cmova\0cmovs\0cmovns\0cmovp\0cmovpe\0cmovnp\0cmovpo\0cmovl\0cmovnge\0cmovnl\0cmovge\0cmovle\0cmovng\0cmovnle\0cmovg\0bsfw\0bsfl\0bsfq\0bsf\0bsrw\0bsrl\0bsrq\0bsr\0btw\0btl\0btq\0bt\0btsw\0btsl\0btsq\0bts\0btrw\0btrl\0btrq\0btr\0btcw\0btcl\0btcq\0btc\0popcntw\0popcntl\0popcntq\0popcnt\0tzcntw\0tzcntl\0tzcntq\0tzcnt\0lzcntw\0lzcntl\0lzcntq\0lzcnt\0larw\0larl\0larq\0lar\0lslw\0lsll\0lslq\0lsl\0fadd\0faddp\0fadds\0fiaddl\0faddl\0fiadds\0fmul\0fmulp\0fmuls\0fimull\0fmull\0fimuls\0fcom\0fcom_1\0fcoms\0ficoml\0fcoml\0ficoms\0fcomp\0fcompp\0fcomps\0ficompl\0fcompl\0ficomps\0fsub\0fsubp\0fsubs\0fisubl\0fsubl\0fisubs\0fsubr\0fsubrp\0fsubrs\0fisubrl\0fsubrl\0fisubrs\0fdiv\0fdivp\0fdivs\0fidivl\0fdivl\0fidivs\0fdivr\0fdivrp\0fdivrs\0fidivrl\0fdivrl\0fidivrs\0xaddb\0xaddw\0xaddl\0xaddq\0xadd\0cmpxchgb\0cmpxchgw\0cmpxchgl\0cmpxchgq\0cmpxchg\0cmpsb\0cmpsw\0cmpsl\0cmpsq\0cmps\0scmpb\0scmpw\0scmpl\0scmpq\0scmp\0insb\0insw\0insl\0ins\0outsb\0outsw\0outsl\0outs\0lodsb\0lodsw\0lodsl\0lodsq\0lods\0slodb\0slodw\0slodl\0slodq\0slod\0movsb\0movsw\0movsl\0movsq\0movs\0smovb\0smovw\0smovl\0smovq\0smov\0scasb\0scasw\0scasl\0scasq\0scas\0sscab\0sscaw\0sscal\0sscaq\0ssca\0stosb\0stosw\0stosl\0stosq\0stos\0sstob\0sstow\0sstol\0sstoq\0ssto\0clc\0cld\0cli\0clts\0cmc\0lahf\0sahf\0pushfq\0popfq\0pushf\0popf\0stc\0std\0sti\0aaa\0aas\0daa\0das\0aad\0aam\0cbw\0cwd\0cwde\0cdq\0cbtw\0cwtl\0cwtd\0cltd\0cqto\0int3\0into\0iret\0iretw\0iretl\0iretq\0rsm\0hlt\0wait\0nop\0pause\0xlat\0lock\0rep\0repe\0repz\0repne\0repnz\0invd\0wbinvd\0cpuid\0wrmsr\0rdtsc\0rdmsr\0rdpmc\0syscall\0sysret\0ud2\0leave\0ret\0retq\0lret\0fucompp\0ftst\0fxam\0fld1\0fldl2t\0fldl2e\0fldpi\0fldlg2\0fldln2\0fldz\0f2xm1\0fyl2x\0fptan\0fpatan\0fxtract\0fprem1\0fdecstp\0fincstp\0fprem\0fyl2xp1\0fsqrt\0fsincos\0frndint\0fscale\0fsin\0fcos\0fchs\0fabs\0fninit\0fnclex\0fnop\0fwait\0fxch\0fnstsw\0emms\0vmcall\0vmlaunch\0vmresume\0vmxoff\0sysretq\0callq\0ljmpw\0ljmpl\0enter\0loopne\0loopnz\0loope\0loopz\0loop\0jecxz\0fld\0fldl\0flds\0fildl\0fildq\0fildll\0fldt\0fbld\0fst\0fstl\0fsts\0fstps\0fstpl\0fist\0fistp\0fistl\0fistpl\0fstp\0fistpq\0fistpll\0fstpt\0fbstp\0fucom\0fucomp\0finit\0fldcw\0fnstcw\0fstcw\0fstsw\0fclex\0fnstenv\0fstenv\0fldenv\0fnsave\0fsave\0frstor\0ffree\0ffreep\0fxsave\0fxrstor\0fxsaveq\0fxrstorq\0arpl\0lgdt\0lgdtq\0lidt\0lidtq\0lldt\0lmsw\0ltr\0sgdt\0sgdtq\0sidt\0sidtq\0sldt\0smsw\0str\0verr\0verw\0swapgs\0bswap\0bswapl\0bswapq\0invlpg\0cmpxchg8b\0cmpxchg16b\0fcmovb\0fcmove\0fcmovbe\0fcmovu\0fcmovnb\0fcmovne\0fcmovnbe\0fcmovnu\0fucomi\0fcomi\0fucomip\0fcomip\0movd\0packssdw\0packsswb\0packuswb\0paddb\0paddw\0paddd\0paddsb\0paddsw\0paddusb\0paddusw\0pand\0pandn\0pcmpeqb\0pcmpeqw\0pcmpeqd\0pcmpgtb\0pcmpgtw\0pcmpgtd\0pmaddwd\0pmulhw\0pmullw\0por\0psllw\0pslld\0psllq\0psraw\0psrad\0psrlw\0psrld\0psrlq\0psubb\0psubw\0psubd\0psubsb\0psubsw\0psubusb\0psubusw\0punpckhbw\0punpckhwd\0punpckhdq\0punpcklbw\0punpcklwd\0punpckldq\0pxor\0ldmxcsr\0stmxcsr\0movups\0movaps\0movhps\0addps\0cvtpi2ps\0cvtps2pi\0cvttps2pi\0divps\0maxps\0minps\0mulps\0pavgb\0pavgw\0pmaxsw\0pmaxub\0pminsw\0pminub\0rcpss\0rsqrtps\0sqrtps\0subps\0movnti\0movntil\0movntiq\0prefetchnta\0prefetcht0\0prefetcht1\0prefetcht2\0prefetchw\0lfence\0mfence\0sfence\0clflush\0endbr64\0\0",
    )
};
static mut tok_two_chars: [libc::c_uchar; 64] = [
    '<' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0x9e as libc::c_int as libc::c_uchar,
    '>' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0x9d as libc::c_int as libc::c_uchar,
    '!' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0x95 as libc::c_int as libc::c_uchar,
    '&' as i32 as libc::c_uchar,
    '&' as i32 as libc::c_uchar,
    0x90 as libc::c_int as libc::c_uchar,
    '|' as i32 as libc::c_uchar,
    '|' as i32 as libc::c_uchar,
    0x91 as libc::c_int as libc::c_uchar,
    '+' as i32 as libc::c_uchar,
    '+' as i32 as libc::c_uchar,
    0x82 as libc::c_int as libc::c_uchar,
    '-' as i32 as libc::c_uchar,
    '-' as i32 as libc::c_uchar,
    0x80 as libc::c_int as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0x94 as libc::c_int as libc::c_uchar,
    '<' as i32 as libc::c_uchar,
    '<' as i32 as libc::c_uchar,
    '<' as i32 as libc::c_uchar,
    '>' as i32 as libc::c_uchar,
    '>' as i32 as libc::c_uchar,
    '>' as i32 as libc::c_uchar,
    '+' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb0 as libc::c_int as libc::c_uchar,
    '-' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb1 as libc::c_int as libc::c_uchar,
    '*' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb2 as libc::c_int as libc::c_uchar,
    '/' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb3 as libc::c_int as libc::c_uchar,
    '%' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb4 as libc::c_int as libc::c_uchar,
    '&' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb5 as libc::c_int as libc::c_uchar,
    '^' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb7 as libc::c_int as libc::c_uchar,
    '|' as i32 as libc::c_uchar,
    '=' as i32 as libc::c_uchar,
    0xb6 as libc::c_int as libc::c_uchar,
    '-' as i32 as libc::c_uchar,
    '>' as i32 as libc::c_uchar,
    0xa0 as libc::c_int as libc::c_uchar,
    '.' as i32 as libc::c_uchar,
    '.' as i32 as libc::c_uchar,
    0xa2 as libc::c_int as libc::c_uchar,
    '#' as i32 as libc::c_uchar,
    '#' as i32 as libc::c_uchar,
    0xa3 as libc::c_int as libc::c_uchar,
    0 as libc::c_int as libc::c_uchar,
];
unsafe extern "C" fn skip(mut c: libc::c_int) {
    if tok != c {
        let mut tmp: [libc::c_char; 40] = [0; 40];
        pstrcpy(
            tmp.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 40]>() as libc::c_ulong,
            get_tok_str(c, &mut tokc),
        );
        _tcc_error(
            b"'%s' expected (got \"%s\")\0" as *const u8 as *const libc::c_char,
            tmp.as_mut_ptr(),
            get_tok_str(tok, &mut tokc),
        );
    }
    next();
}
unsafe extern "C" fn expect(mut msg: *const libc::c_char) -> ! {
    _tcc_error(b"%s expected\0" as *const u8 as *const libc::c_char, msg);
}
unsafe extern "C" fn tal_new(
    mut pal: *mut *mut TinyAlloc,
    mut limit: libc::c_uint,
    mut size: libc::c_uint,
) -> *mut TinyAlloc {
    let mut al: *mut TinyAlloc = tcc_mallocz(
        ::core::mem::size_of::<TinyAlloc>() as libc::c_ulong,
    ) as *mut TinyAlloc;
    (*al).buffer = tcc_malloc(size as libc::c_ulong) as *mut uint8_t;
    (*al).p = (*al).buffer;
    (*al).limit = limit;
    (*al).size = size;
    if !pal.is_null() {
        *pal = al;
    }
    return al;
}
unsafe extern "C" fn tal_delete(mut al: *mut TinyAlloc) {
    let mut next_0: *mut TinyAlloc = 0 as *mut TinyAlloc;
    loop {
        if al.is_null() {
            return;
        }
        next_0 = (*al).next;
        tcc_free((*al).buffer as *mut libc::c_void);
        tcc_free(al as *mut libc::c_void);
        al = next_0;
    };
}
unsafe extern "C" fn tal_free_impl(mut al: *mut TinyAlloc, mut p: *mut libc::c_void) {
    if p.is_null() {
        return;
    }
    loop {
        if (*al).buffer <= p as *mut uint8_t
            && (p as *mut uint8_t) < ((*al).buffer).offset((*al).size as isize)
        {
            (*al).nb_allocs = ((*al).nb_allocs).wrapping_sub(1);
            (*al).nb_allocs;
            if (*al).nb_allocs == 0 {
                (*al).p = (*al).buffer;
            }
            break;
        } else if !((*al).next).is_null() {
            al = (*al).next;
        } else {
            tcc_free(p);
            break;
        }
    };
}
unsafe extern "C" fn tal_realloc_impl(
    mut pal: *mut *mut TinyAlloc,
    mut p: *mut libc::c_void,
    mut size: libc::c_uint,
) -> *mut libc::c_void {
    let mut header: *mut tal_header_t = 0 as *mut tal_header_t;
    let mut ret: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut is_own: libc::c_int = 0;
    let mut adj_size: libc::c_uint = size.wrapping_add(3 as libc::c_int as libc::c_uint)
        & -(4 as libc::c_int) as libc::c_uint;
    let mut al: *mut TinyAlloc = *pal;
    loop {
        is_own = ((*al).buffer <= p as *mut uint8_t
            && (p as *mut uint8_t) < ((*al).buffer).offset((*al).size as isize))
            as libc::c_int;
        if (p.is_null() || is_own != 0) && size <= (*al).limit {
            if ((((*al).p).offset_from((*al).buffer) as libc::c_long
                + adj_size as libc::c_long) as libc::c_ulong)
                .wrapping_add(::core::mem::size_of::<tal_header_t>() as libc::c_ulong)
                < (*al).size as libc::c_ulong
            {
                header = (*al).p as *mut tal_header_t;
                (*header).size = adj_size;
                ret = ((*al).p)
                    .offset(
                        ::core::mem::size_of::<tal_header_t>() as libc::c_ulong as isize,
                    ) as *mut libc::c_void;
                (*al)
                    .p = ((*al).p)
                    .offset(
                        (adj_size as libc::c_ulong)
                            .wrapping_add(
                                ::core::mem::size_of::<tal_header_t>() as libc::c_ulong,
                            ) as isize,
                    );
                if is_own != 0 {
                    header = (p as *mut tal_header_t)
                        .offset(-(1 as libc::c_int as isize));
                    if !p.is_null() {
                        memcpy(ret, p, (*header).size as libc::c_ulong);
                    }
                } else {
                    (*al).nb_allocs = ((*al).nb_allocs).wrapping_add(1);
                    (*al).nb_allocs;
                }
                return ret;
            } else if is_own != 0 {
                (*al).nb_allocs = ((*al).nb_allocs).wrapping_sub(1);
                (*al).nb_allocs;
                ret = tal_realloc_impl(pal, 0 as *mut libc::c_void, size);
                header = (p as *mut tal_header_t).offset(-(1 as libc::c_int as isize));
                if !p.is_null() {
                    memcpy(ret, p, (*header).size as libc::c_ulong);
                }
                return ret;
            }
            if !((*al).next).is_null() {
                al = (*al).next;
            } else {
                let mut bottom: *mut TinyAlloc = al;
                let mut next_0: *mut TinyAlloc = if !((*al).top).is_null() {
                    (*al).top
                } else {
                    al
                };
                al = tal_new(
                    pal,
                    (*next_0).limit,
                    ((*next_0).size).wrapping_mul(2 as libc::c_int as libc::c_uint),
                );
                (*al).next = next_0;
                (*bottom).top = al;
            }
        } else if is_own != 0 {
            (*al).nb_allocs = ((*al).nb_allocs).wrapping_sub(1);
            (*al).nb_allocs;
            ret = tcc_malloc(size as libc::c_ulong);
            header = (p as *mut tal_header_t).offset(-(1 as libc::c_int as isize));
            if !p.is_null() {
                memcpy(ret, p, (*header).size as libc::c_ulong);
            }
            break;
        } else if !((*al).next).is_null() {
            al = (*al).next;
        } else {
            ret = tcc_realloc(p, size as libc::c_ulong);
            break;
        }
    }
    return ret;
}
unsafe extern "C" fn cstr_realloc(mut cstr: *mut CString, mut new_size: libc::c_int) {
    let mut size: libc::c_int = 0;
    size = (*cstr).size_allocated;
    if size < 8 as libc::c_int {
        size = 8 as libc::c_int;
    }
    while size < new_size {
        size = size * 2 as libc::c_int;
    }
    (*cstr)
        .data = tcc_realloc((*cstr).data as *mut libc::c_void, size as libc::c_ulong)
        as *mut libc::c_char;
    (*cstr).size_allocated = size;
}
#[inline]
unsafe extern "C" fn cstr_ccat(mut cstr: *mut CString, mut ch: libc::c_int) {
    let mut size: libc::c_int = 0;
    size = (*cstr).size + 1 as libc::c_int;
    if size > (*cstr).size_allocated {
        cstr_realloc(cstr, size);
    }
    *((*cstr).data).offset((size - 1 as libc::c_int) as isize) = ch as libc::c_char;
    (*cstr).size = size;
}
#[inline]
unsafe extern "C" fn unicode_to_utf8(
    mut b: *mut libc::c_char,
    mut Uc: uint32_t,
) -> *mut libc::c_char {
    if Uc < 0x80 as libc::c_int as uint32_t {
        let fresh74 = b;
        b = b.offset(1);
        *fresh74 = Uc as libc::c_char;
    } else if Uc < 0x800 as libc::c_int as uint32_t {
        let fresh75 = b;
        b = b.offset(1);
        *fresh75 = (192 as libc::c_int as uint32_t)
            .wrapping_add(Uc / 64 as libc::c_int as uint32_t) as libc::c_char;
        let fresh76 = b;
        b = b.offset(1);
        *fresh76 = (128 as libc::c_int as uint32_t)
            .wrapping_add(Uc % 64 as libc::c_int as uint32_t) as libc::c_char;
    } else {
        's_37: {
            let mut current_block_4: u64;
            if !(Uc.wrapping_sub(0xd800 as libc::c_uint)
                < 0x800 as libc::c_int as libc::c_uint)
            {
                if Uc < 0x10000 as libc::c_int as uint32_t {
                    let fresh77 = b;
                    b = b.offset(1);
                    *fresh77 = (224 as libc::c_int as uint32_t)
                        .wrapping_add(Uc / 4096 as libc::c_int as uint32_t)
                        as libc::c_char;
                    let fresh78 = b;
                    b = b.offset(1);
                    *fresh78 = (128 as libc::c_int as uint32_t)
                        .wrapping_add(
                            Uc / 64 as libc::c_int as uint32_t
                                % 64 as libc::c_int as uint32_t,
                        ) as libc::c_char;
                    let fresh79 = b;
                    b = b.offset(1);
                    *fresh79 = (128 as libc::c_int as uint32_t)
                        .wrapping_add(Uc % 64 as libc::c_int as uint32_t)
                        as libc::c_char;
                    current_block_4 = 10879442775620481940;
                } else if Uc < 0x110000 as libc::c_int as uint32_t {
                    let fresh80 = b;
                    b = b.offset(1);
                    *fresh80 = (240 as libc::c_int as uint32_t)
                        .wrapping_add(Uc / 262144 as libc::c_int as uint32_t)
                        as libc::c_char;
                    let fresh81 = b;
                    b = b.offset(1);
                    *fresh81 = (128 as libc::c_int as uint32_t)
                        .wrapping_add(
                            Uc / 4096 as libc::c_int as uint32_t
                                % 64 as libc::c_int as uint32_t,
                        ) as libc::c_char;
                    let fresh82 = b;
                    b = b.offset(1);
                    *fresh82 = (128 as libc::c_int as uint32_t)
                        .wrapping_add(
                            Uc / 64 as libc::c_int as uint32_t
                                % 64 as libc::c_int as uint32_t,
                        ) as libc::c_char;
                    let fresh83 = b;
                    b = b.offset(1);
                    *fresh83 = (128 as libc::c_int as uint32_t)
                        .wrapping_add(Uc % 64 as libc::c_int as uint32_t)
                        as libc::c_char;
                    current_block_4 = 10879442775620481940;
                } else {
                    current_block_4 = 3450390502464577654;
                }
                match current_block_4 {
                    3450390502464577654 => {}
                    _ => {
                        break 's_37;
                    }
                }
            }
            _tcc_error(
                b"0x%x is not a valid universal character\0" as *const u8
                    as *const libc::c_char,
                Uc,
            );
        }
    }
    return b;
}
#[inline]
unsafe extern "C" fn cstr_u8cat(mut cstr: *mut CString, mut ch: libc::c_int) {
    let mut buf: [libc::c_char; 4] = [0; 4];
    let mut e: *mut libc::c_char = 0 as *mut libc::c_char;
    e = unicode_to_utf8(buf.as_mut_ptr(), ch as uint32_t);
    cstr_cat(
        cstr,
        buf.as_mut_ptr(),
        e.offset_from(buf.as_mut_ptr()) as libc::c_long as libc::c_int,
    );
}
unsafe extern "C" fn cstr_cat(
    mut cstr: *mut CString,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
) {
    let mut size: libc::c_int = 0;
    if len <= 0 as libc::c_int {
        len = (strlen(str))
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(len as libc::c_ulong) as libc::c_int;
    }
    size = (*cstr).size + len;
    if size > (*cstr).size_allocated {
        cstr_realloc(cstr, size);
    }
    memmove(
        ((*cstr).data).offset((*cstr).size as isize) as *mut libc::c_void,
        str as *const libc::c_void,
        len as libc::c_ulong,
    );
    (*cstr).size = size;
}
unsafe extern "C" fn cstr_wccat(mut cstr: *mut CString, mut ch: libc::c_int) {
    let mut size: libc::c_int = 0;
    size = ((*cstr).size as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<nwchar_t>() as libc::c_ulong)
        as libc::c_int;
    if size > (*cstr).size_allocated {
        cstr_realloc(cstr, size);
    }
    *(((*cstr).data)
        .offset(size as isize)
        .offset(-(::core::mem::size_of::<nwchar_t>() as libc::c_ulong as isize))
        as *mut nwchar_t) = ch;
    (*cstr).size = size;
}
unsafe extern "C" fn cstr_new(mut cstr: *mut CString) {
    memset(
        cstr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<CString>() as libc::c_ulong,
    );
}
unsafe extern "C" fn cstr_free(mut cstr: *mut CString) {
    tcc_free((*cstr).data as *mut libc::c_void);
}
unsafe extern "C" fn cstr_reset(mut cstr: *mut CString) {
    (*cstr).size = 0 as libc::c_int;
}
unsafe extern "C" fn cstr_vprintf(
    mut cstr: *mut CString,
    mut fmt: *const libc::c_char,
    mut ap: ::core::ffi::VaList,
) -> libc::c_int {
    let mut v: ::core::ffi::VaListImpl;
    let mut len: libc::c_int = 0;
    let mut size: libc::c_int = 80 as libc::c_int;
    loop {
        size += (*cstr).size;
        if size > (*cstr).size_allocated {
            cstr_realloc(cstr, size);
        }
        size = (*cstr).size_allocated - (*cstr).size;
        v = ap.clone();
        len = vsnprintf(
            ((*cstr).data).offset((*cstr).size as isize),
            size as libc::c_ulong,
            fmt,
            v.as_va_list(),
        );
        if len >= 0 as libc::c_int && len < size {
            break;
        }
        size *= 2 as libc::c_int;
    }
    (*cstr).size += len;
    return len;
}
unsafe extern "C" fn cstr_printf(
    mut cstr: *mut CString,
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    let mut len: libc::c_int = 0;
    ap = args.clone();
    len = cstr_vprintf(cstr, fmt, ap.as_va_list());
    return len;
}
unsafe extern "C" fn add_char(mut cstr: *mut CString, mut c: libc::c_int) {
    if c == '\'' as i32 || c == '"' as i32 || c == '\\' as i32 {
        cstr_ccat(cstr, '\\' as i32);
    }
    if c >= 32 as libc::c_int && c <= 126 as libc::c_int {
        cstr_ccat(cstr, c);
    } else {
        cstr_ccat(cstr, '\\' as i32);
        if c == '\n' as i32 {
            cstr_ccat(cstr, 'n' as i32);
        } else {
            cstr_ccat(cstr, '0' as i32 + (c >> 6 as libc::c_int & 7 as libc::c_int));
            cstr_ccat(cstr, '0' as i32 + (c >> 3 as libc::c_int & 7 as libc::c_int));
            cstr_ccat(cstr, '0' as i32 + (c & 7 as libc::c_int));
        }
    };
}
unsafe extern "C" fn tok_alloc_new(
    mut pts: *mut *mut TokenSym,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
) -> *mut TokenSym {
    let mut ts: *mut TokenSym = 0 as *mut TokenSym;
    let mut ptable: *mut *mut TokenSym = 0 as *mut *mut TokenSym;
    let mut i: libc::c_int = 0;
    if tok_ident >= 0x10000000 as libc::c_int {
        _tcc_error(b"memory full (symbols)\0" as *const u8 as *const libc::c_char);
    }
    i = tok_ident - 256 as libc::c_int;
    if i % 512 as libc::c_int == 0 as libc::c_int {
        ptable = tcc_realloc(
            table_ident as *mut libc::c_void,
            ((i + 512 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<*mut TokenSym>() as libc::c_ulong),
        ) as *mut *mut TokenSym;
        table_ident = ptable;
    }
    ts = tal_realloc_impl(
        &mut toksym_alloc,
        0 as *mut libc::c_void,
        (::core::mem::size_of::<TokenSym>() as libc::c_ulong)
            .wrapping_add(len as libc::c_ulong) as libc::c_uint,
    ) as *mut TokenSym;
    let ref mut fresh84 = *table_ident.offset(i as isize);
    *fresh84 = ts;
    let fresh85 = tok_ident;
    tok_ident = tok_ident + 1;
    (*ts).tok = fresh85;
    (*ts).sym_define = 0 as *mut Sym;
    (*ts).sym_label = 0 as *mut Sym;
    (*ts).sym_struct = 0 as *mut Sym;
    (*ts).sym_identifier = 0 as *mut Sym;
    (*ts).len = len;
    (*ts).hash_next = 0 as *mut TokenSym;
    memcpy(
        ((*ts).str_0).as_mut_ptr() as *mut libc::c_void,
        str as *const libc::c_void,
        len as libc::c_ulong,
    );
    *((*ts).str_0).as_mut_ptr().offset(len as isize) = '\0' as i32 as libc::c_char;
    *pts = ts;
    return ts;
}
unsafe extern "C" fn tok_alloc(
    mut str: *const libc::c_char,
    mut len: libc::c_int,
) -> *mut TokenSym {
    let mut ts: *mut TokenSym = 0 as *mut TokenSym;
    let mut pts: *mut *mut TokenSym = 0 as *mut *mut TokenSym;
    let mut i: libc::c_int = 0;
    let mut h: libc::c_uint = 0;
    h = 1 as libc::c_int as libc::c_uint;
    i = 0 as libc::c_int;
    while i < len {
        h = h
            .wrapping_add(h << 5 as libc::c_int)
            .wrapping_add(h >> 27 as libc::c_int)
            .wrapping_add(
                *(str as *mut libc::c_uchar).offset(i as isize) as libc::c_uint,
            );
        i += 1;
        i;
    }
    h &= (16384 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
    pts = &mut *hash_ident.as_mut_ptr().offset(h as isize) as *mut *mut TokenSym;
    loop {
        ts = *pts;
        if ts.is_null() {
            break;
        }
        if (*ts).len == len
            && memcmp(
                ((*ts).str_0).as_mut_ptr() as *const libc::c_void,
                str as *const libc::c_void,
                len as libc::c_ulong,
            ) == 0
        {
            return ts;
        }
        pts = &mut (*ts).hash_next;
    }
    return tok_alloc_new(pts, str, len);
}
unsafe extern "C" fn tok_alloc_const(mut str: *const libc::c_char) -> libc::c_int {
    return (*tok_alloc(str, strlen(str) as libc::c_int)).tok;
}
unsafe extern "C" fn get_tok_str(
    mut v: libc::c_int,
    mut cv: *mut CValue,
) -> *const libc::c_char {
    let mut q: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut current_block: u64;
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    cstr_reset(&mut cstr_buf);
    p = cstr_buf.data;
    match v {
        194 | 195 | 198 | 199 | 196 | 197 => {
            sprintf(
                p,
                b"%llu\0" as *const u8 as *const libc::c_char,
                (*cv).i as libc::c_ulonglong,
            );
            current_block = 1724319918354933278;
        }
        193 => {
            cstr_ccat(&mut cstr_buf, 'L' as i32);
            current_block = 12420411545379644137;
        }
        192 => {
            current_block = 12420411545379644137;
        }
        205 | 206 => return (*cv).str_0.data,
        201 => {
            cstr_ccat(&mut cstr_buf, 'L' as i32);
            current_block = 1502639228699010421;
        }
        200 => {
            current_block = 1502639228699010421;
        }
        202 => return strcpy(p, b"<float>\0" as *const u8 as *const libc::c_char),
        203 => return strcpy(p, b"<double>\0" as *const u8 as *const libc::c_char),
        204 => return strcpy(p, b"<long double>\0" as *const u8 as *const libc::c_char),
        207 => return strcpy(p, b"<linenumber>\0" as *const u8 as *const libc::c_char),
        156 => {
            v = '<' as i32;
            current_block = 8206821285407510798;
        }
        159 => {
            v = '>' as i32;
            current_block = 8206821285407510798;
        }
        161 => return strcpy(p, b"...\0" as *const u8 as *const libc::c_char),
        184 => return strcpy(p, b"<<=\0" as *const u8 as *const libc::c_char),
        185 => return strcpy(p, b">>=\0" as *const u8 as *const libc::c_char),
        -1 => return strcpy(p, b"<eof>\0" as *const u8 as *const libc::c_char),
        0 => return strcpy(p, b"<no name>\0" as *const u8 as *const libc::c_char),
        _ => {
            v &= !(0x20000000 as libc::c_int | 0x40000000 as libc::c_int);
            if v < 256 as libc::c_int {
                q = tok_two_chars.as_ptr();
                while *q != 0 {
                    if *q.offset(2 as libc::c_int as isize) as libc::c_int == v {
                        let fresh86 = p;
                        p = p.offset(1);
                        *fresh86 = *q.offset(0 as libc::c_int as isize) as libc::c_char;
                        let fresh87 = p;
                        p = p.offset(1);
                        *fresh87 = *q.offset(1 as libc::c_int as isize) as libc::c_char;
                        *p = '\0' as i32 as libc::c_char;
                        return cstr_buf.data;
                    }
                    q = q.offset(3 as libc::c_int as isize);
                }
                if v >= 127 as libc::c_int
                    || v < 32 as libc::c_int && is_space(v) == 0 && v != '\n' as i32
                {
                    sprintf(p, b"<\\x%02x>\0" as *const u8 as *const libc::c_char, v);
                    current_block = 1724319918354933278;
                } else {
                    current_block = 8206821285407510798;
                }
            } else {
                if v < tok_ident {
                    return ((**table_ident.offset((v - 256 as libc::c_int) as isize))
                        .str_0)
                        .as_mut_ptr()
                } else if v >= 0x10000000 as libc::c_int {
                    sprintf(
                        p,
                        b"L.%u\0" as *const u8 as *const libc::c_char,
                        v - 0x10000000 as libc::c_int,
                    );
                } else {
                    return 0 as *const libc::c_char
                }
                current_block = 1724319918354933278;
            }
        }
    }
    match current_block {
        1502639228699010421 => {
            cstr_ccat(&mut cstr_buf, '"' as i32);
            if v == 0xc8 as libc::c_int {
                len = (*cv).str_0.size - 1 as libc::c_int;
                i = 0 as libc::c_int;
                while i < len {
                    add_char(
                        &mut cstr_buf,
                        *((*cv).str_0.data as *mut libc::c_uchar).offset(i as isize)
                            as libc::c_int,
                    );
                    i += 1;
                    i;
                }
            } else {
                len = ((*cv).str_0.size as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<nwchar_t>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                i = 0 as libc::c_int;
                while i < len {
                    add_char(
                        &mut cstr_buf,
                        *((*cv).str_0.data as *mut nwchar_t).offset(i as isize),
                    );
                    i += 1;
                    i;
                }
            }
            cstr_ccat(&mut cstr_buf, '"' as i32);
            cstr_ccat(&mut cstr_buf, '\0' as i32);
        }
        12420411545379644137 => {
            cstr_ccat(&mut cstr_buf, '\'' as i32);
            add_char(&mut cstr_buf, (*cv).i as libc::c_int);
            cstr_ccat(&mut cstr_buf, '\'' as i32);
            cstr_ccat(&mut cstr_buf, '\0' as i32);
        }
        8206821285407510798 => {
            let fresh88 = p;
            p = p.offset(1);
            *fresh88 = v as libc::c_char;
            *p = '\0' as i32 as libc::c_char;
        }
        _ => {}
    }
    return cstr_buf.data;
}
unsafe extern "C" fn handle_eob() -> libc::c_int {
    let mut bf: *mut BufferedFile = file;
    let mut len: libc::c_int = 0;
    if (*bf).buf_ptr >= (*bf).buf_end {
        if (*bf).fd >= 0 as libc::c_int {
            len = 8192 as libc::c_int;
            len = read(
                (*bf).fd,
                ((*bf).buffer).as_mut_ptr() as *mut libc::c_void,
                len as size_t,
            ) as libc::c_int;
            if len < 0 as libc::c_int {
                len = 0 as libc::c_int;
            }
        } else {
            len = 0 as libc::c_int;
        }
        (*tcc_state)
            .total_bytes = ((*tcc_state).total_bytes).wrapping_add(len as libc::c_uint);
        (*bf).buf_ptr = ((*bf).buffer).as_mut_ptr();
        (*bf).buf_end = ((*bf).buffer).as_mut_ptr().offset(len as isize);
        *(*bf).buf_end = '\\' as i32 as uint8_t;
    }
    if (*bf).buf_ptr < (*bf).buf_end {
        return *((*bf).buf_ptr).offset(0 as libc::c_int as isize) as libc::c_int
    } else {
        (*bf).buf_ptr = (*bf).buf_end;
        return -(1 as libc::c_int);
    };
}
unsafe extern "C" fn next_c() -> libc::c_int {
    (*file).buf_ptr = ((*file).buf_ptr).offset(1);
    let mut ch: libc::c_int = *(*file).buf_ptr as libc::c_int;
    if ch == '\\' as i32 && (*file).buf_ptr >= (*file).buf_end {
        ch = handle_eob();
    }
    return ch;
}
unsafe extern "C" fn handle_stray_noerror(mut err: libc::c_int) -> libc::c_int {
    let mut ch: libc::c_int = 0;
    loop {
        ch = next_c();
        if !(ch == '\\' as i32) {
            break;
        }
        ch = next_c();
        let mut current_block_6: u64;
        if !(ch == '\n' as i32) {
            if ch == '\r' as i32 {
                ch = next_c();
                if ch == '\n' as i32 {
                    current_block_6 = 439850013131442826;
                } else {
                    (*file).buf_ptr = ((*file).buf_ptr).offset(-1);
                    *(*file).buf_ptr = '\r' as i32 as uint8_t;
                    current_block_6 = 7815301370352969686;
                }
            } else {
                current_block_6 = 7815301370352969686;
            }
            match current_block_6 {
                439850013131442826 => {}
                _ => {
                    if err != 0 {
                        _tcc_error(
                            b"stray '\\' in program\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    (*file).buf_ptr = ((*file).buf_ptr).offset(-1);
                    *(*file).buf_ptr = '\\' as i32 as uint8_t;
                    return *(*file).buf_ptr as libc::c_int;
                }
            }
        }
        (*file).line_num += 1;
        (*file).line_num;
    }
    return ch;
}
unsafe extern "C" fn handle_bs(mut p: *mut *mut uint8_t) -> libc::c_int {
    let mut c: libc::c_int = 0;
    (*file).buf_ptr = (*p).offset(-(1 as libc::c_int as isize));
    c = handle_stray_noerror(0 as libc::c_int);
    *p = (*file).buf_ptr;
    return c;
}
unsafe extern "C" fn handle_stray(mut p: *mut *mut uint8_t) -> libc::c_int {
    let mut c: libc::c_int = 0;
    (*file).buf_ptr = (*p).offset(-(1 as libc::c_int as isize));
    c = handle_stray_noerror((parse_flags & 0x20 as libc::c_int == 0) as libc::c_int);
    *p = (*file).buf_ptr;
    return c;
}
unsafe extern "C" fn skip_spaces() -> libc::c_int {
    let mut ch: libc::c_int = 0;
    (*file).buf_ptr = ((*file).buf_ptr).offset(-1);
    (*file).buf_ptr;
    loop {
        ch = handle_stray_noerror(0 as libc::c_int);
        if !(isidnum_table[(ch - -(1 as libc::c_int)) as usize] as libc::c_int
            & 1 as libc::c_int != 0)
        {
            break;
        }
    }
    return ch;
}
unsafe extern "C" fn parse_line_comment(mut p: *mut uint8_t) -> *mut uint8_t {
    let mut c: libc::c_int = 0;
    's_14: loop {
        p = p.offset(1);
        c = *p as libc::c_int;
        loop {
            if !(c == '\n' as i32 || c == '\\' as i32) {
                p = p.offset(1);
                c = *p as libc::c_int;
                if !(c == '\n' as i32 || c == '\\' as i32) {
                    break;
                }
            }
            if c == '\n' as i32 {
                break 's_14;
            }
            c = handle_bs(&mut p);
            if c == -(1 as libc::c_int) {
                break 's_14;
            }
            if !(c != '\\' as i32) {
                break;
            }
        }
    }
    return p;
}
unsafe extern "C" fn parse_comment(mut p: *mut uint8_t) -> *mut uint8_t {
    let mut c: libc::c_int = 0;
    's_14: loop {
        p = p.offset(1);
        c = *p as libc::c_int;
        loop {
            if !(c == '\n' as i32 || c == '*' as i32 || c == '\\' as i32) {
                p = p.offset(1);
                c = *p as libc::c_int;
                if !(c == '\n' as i32 || c == '*' as i32 || c == '\\' as i32) {
                    continue 's_14;
                }
            }
            if c == '\n' as i32 {
                break;
            }
            if c == '*' as i32 {
                loop {
                    p = p.offset(1);
                    c = *p as libc::c_int;
                    if !(c == '*' as i32) {
                        break;
                    }
                }
                if c == '\\' as i32 {
                    c = handle_bs(&mut p);
                }
                if c == '/' as i32 {
                    break 's_14;
                }
            } else {
                c = handle_bs(&mut p);
            }
            if c == -(1 as libc::c_int) {
                _tcc_error(
                    b"unexpected end of file in comment\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if !(c != '\\' as i32) {
                continue 's_14;
            }
        }
        (*file).line_num += 1;
        (*file).line_num;
    }
    return p.offset(1 as libc::c_int as isize);
}
unsafe extern "C" fn parse_pp_string(
    mut p: *mut uint8_t,
    mut sep: libc::c_int,
    mut str: *mut CString,
) -> *mut uint8_t {
    let mut current_block: u64;
    let mut c: libc::c_int = 0;
    's_8: loop {
        p = p.offset(1);
        c = *p as libc::c_int;
        loop {
            if c == sep {
                break 's_8;
            }
            if c == '\\' as i32 {
                c = handle_bs(&mut p);
                if c == -(1 as libc::c_int) {
                    current_block = 287971789587340874;
                    break;
                }
                if !(c == '\\' as i32) {
                    continue;
                }
                if !str.is_null() {
                    cstr_ccat(str, c);
                }
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    current_block = 2868539653012386629;
                    break;
                } else {
                    current_block = 6529837299657792981;
                    break;
                }
            } else {
                if c == '\n' as i32 {
                    current_block = 7149356873433890176;
                    break;
                }
                if !(c == '\r' as i32) {
                    current_block = 6529837299657792981;
                    break;
                }
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_bs(&mut p);
                }
                if c == '\n' as i32 {
                    current_block = 7149356873433890176;
                    break;
                }
                if c == -(1 as libc::c_int) {
                    current_block = 287971789587340874;
                    break;
                }
                if !str.is_null() {
                    cstr_ccat(str, '\r' as i32);
                }
            }
        }
        match current_block {
            2868539653012386629 => {
                c = handle_bs(&mut p);
                if c == -(1 as libc::c_int) {
                    current_block = 287971789587340874;
                } else {
                    current_block = 6529837299657792981;
                }
            }
            7149356873433890176 => {
                if !str.is_null() {
                    current_block = 287971789587340874;
                } else {
                    return p
                }
            }
            _ => {}
        }
        match current_block {
            6529837299657792981 => {
                if !str.is_null() {
                    cstr_ccat(str, c);
                }
            }
            _ => {
                tok_flags &= !(0x1 as libc::c_int);
                _tcc_error(
                    b"missing terminating %c character\0" as *const u8
                        as *const libc::c_char,
                    sep,
                );
            }
        }
    }
    p = p.offset(1);
    p;
    return p;
}
unsafe extern "C" fn preprocess_skip() {
    let mut current_block: u64;
    let mut a: libc::c_int = 0;
    let mut start_of_line: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut in_warn_or_error: libc::c_int = 0;
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    p = (*file).buf_ptr;
    a = 0 as libc::c_int;
    '_redo_start: loop {
        start_of_line = 1 as libc::c_int;
        in_warn_or_error = 0 as libc::c_int;
        loop {
            c = *p as libc::c_int;
            match c {
                32 | 9 | 12 | 11 | 13 => {
                    p = p.offset(1);
                    p;
                    continue;
                }
                10 => {
                    (*file).line_num += 1;
                    (*file).line_num;
                    p = p.offset(1);
                    p;
                    break;
                }
                92 => {
                    c = handle_bs(&mut p);
                    if c == -(1 as libc::c_int) {
                        expect(b"#endif\0" as *const u8 as *const libc::c_char);
                    }
                    if c == '\\' as i32 {
                        p = p.offset(1);
                        p;
                    }
                    continue;
                }
                34 | 39 => {
                    if in_warn_or_error != 0 {
                        current_block = 6426487487300176322;
                    } else {
                        tok_flags &= !(0x1 as libc::c_int);
                        p = parse_pp_string(p, c, 0 as *mut CString);
                        current_block = 721385680381463314;
                    }
                }
                47 => {
                    if in_warn_or_error != 0 {
                        current_block = 6426487487300176322;
                    } else {
                        p = p.offset(1);
                        p;
                        c = handle_bs(&mut p);
                        if c == '*' as i32 {
                            p = parse_comment(p);
                        } else if c == '/' as i32 {
                            p = parse_line_comment(p);
                        }
                        continue;
                    }
                }
                35 => {
                    p = p.offset(1);
                    p;
                    if start_of_line != 0 {
                        (*file).buf_ptr = p;
                        next_nomacro();
                        p = (*file).buf_ptr;
                        if a == 0 as libc::c_int
                            && (tok == TOK_ELSE as libc::c_int
                                || tok == TOK_ELIF as libc::c_int
                                || tok == TOK_ENDIF as libc::c_int)
                        {
                            break '_redo_start;
                        }
                        if tok == TOK_IF as libc::c_int
                            || tok == TOK_IFDEF as libc::c_int
                            || tok == TOK_IFNDEF as libc::c_int
                        {
                            a += 1;
                            a;
                        } else if tok == TOK_ENDIF as libc::c_int {
                            a -= 1;
                            a;
                        } else if tok == TOK_ERROR as libc::c_int
                            || tok == TOK_WARNING as libc::c_int
                        {
                            in_warn_or_error = 1 as libc::c_int;
                        } else {
                            if tok == 10 as libc::c_int {
                                break;
                            }
                            if parse_flags & 0x8 as libc::c_int != 0 {
                                p = parse_line_comment(
                                    p.offset(-(1 as libc::c_int as isize)),
                                );
                            }
                        }
                    } else if parse_flags & 0x8 as libc::c_int != 0 {
                        p = parse_line_comment(p.offset(-(1 as libc::c_int as isize)));
                    }
                    current_block = 721385680381463314;
                }
                _ => {
                    current_block = 6426487487300176322;
                }
            }
            match current_block {
                6426487487300176322 => {
                    p = p.offset(1);
                    p;
                }
                _ => {}
            }
            start_of_line = 0 as libc::c_int;
        }
    }
    (*file).buf_ptr = p;
}
#[inline]
unsafe extern "C" fn tok_str_new(mut s: *mut TokenString) {
    (*s).str_0 = 0 as *mut libc::c_int;
    (*s).need_spc = 0 as libc::c_int;
    (*s).len = (*s).need_spc;
    (*s).allocated_len = 0 as libc::c_int;
    (*s).last_line_num = -(1 as libc::c_int);
}
unsafe extern "C" fn tok_str_alloc() -> *mut TokenString {
    let mut str: *mut TokenString = tal_realloc_impl(
        &mut tokstr_alloc,
        0 as *mut libc::c_void,
        ::core::mem::size_of::<TokenString>() as libc::c_ulong as libc::c_uint,
    ) as *mut TokenString;
    tok_str_new(str);
    return str;
}
unsafe extern "C" fn tok_str_free_str(mut str: *mut libc::c_int) {
    tal_free_impl(tokstr_alloc, str as *mut libc::c_void);
}
unsafe extern "C" fn tok_str_free(mut str: *mut TokenString) {
    tok_str_free_str((*str).str_0);
    tal_free_impl(tokstr_alloc, str as *mut libc::c_void);
}
unsafe extern "C" fn tok_str_realloc(
    mut s: *mut TokenString,
    mut new_size: libc::c_int,
) -> *mut libc::c_int {
    let mut str: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut size: libc::c_int = 0;
    size = (*s).allocated_len;
    if size < 16 as libc::c_int {
        size = 16 as libc::c_int;
    }
    while size < new_size {
        size = size * 2 as libc::c_int;
    }
    if size > (*s).allocated_len {
        str = tal_realloc_impl(
            &mut tokstr_alloc,
            (*s).str_0 as *mut libc::c_void,
            (size as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                as libc::c_uint,
        ) as *mut libc::c_int;
        (*s).allocated_len = size;
        (*s).str_0 = str;
    }
    return (*s).str_0;
}
unsafe extern "C" fn tok_str_add(mut s: *mut TokenString, mut t: libc::c_int) {
    let mut len: libc::c_int = 0;
    let mut str: *mut libc::c_int = 0 as *mut libc::c_int;
    len = (*s).len;
    str = (*s).str_0;
    if len >= (*s).allocated_len {
        str = tok_str_realloc(s, len + 1 as libc::c_int);
    }
    let fresh89 = len;
    len = len + 1;
    *str.offset(fresh89 as isize) = t;
    (*s).len = len;
}
unsafe extern "C" fn begin_macro(mut str: *mut TokenString, mut alloc: libc::c_int) {
    (*str).alloc = alloc as libc::c_char;
    (*str).prev = macro_stack;
    (*str).prev_ptr = macro_ptr;
    (*str).save_line_num = (*file).line_num;
    macro_ptr = (*str).str_0;
    macro_stack = str;
}
unsafe extern "C" fn end_macro() {
    let mut str: *mut TokenString = macro_stack;
    macro_stack = (*str).prev;
    macro_ptr = (*str).prev_ptr;
    (*file).line_num = (*str).save_line_num;
    if (*str).alloc as libc::c_int == 0 as libc::c_int {
        (*str).need_spc = 0 as libc::c_int;
        (*str).len = (*str).need_spc;
    } else {
        if (*str).alloc as libc::c_int == 2 as libc::c_int {
            (*str).str_0 = 0 as *mut libc::c_int;
        }
        tok_str_free(str);
    };
}
unsafe extern "C" fn tok_str_add2(
    mut s: *mut TokenString,
    mut t: libc::c_int,
    mut cv: *mut CValue,
) {
    let mut len: libc::c_int = 0;
    let mut str: *mut libc::c_int = 0 as *mut libc::c_int;
    len = (*s).len;
    str = (*s).str_0;
    if len + 4 as libc::c_int >= (*s).allocated_len {
        str = tok_str_realloc(s, len + 4 as libc::c_int + 1 as libc::c_int);
    }
    let fresh90 = len;
    len = len + 1;
    *str.offset(fresh90 as isize) = t;
    match t {
        194 | 195 | 192 | 193 | 202 | 207 => {
            let fresh91 = len;
            len = len + 1;
            *str.offset(fresh91 as isize) = (*cv).tab[0 as libc::c_int as usize];
        }
        205 | 206 | 200 | 201 => {
            let mut nb_words: size_t = (1 as libc::c_int as libc::c_ulong)
                .wrapping_add(
                    ((*cv).str_0.size as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        )
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ),
                );
            if (len as size_t).wrapping_add(nb_words) >= (*s).allocated_len as size_t {
                str = tok_str_realloc(
                    s,
                    (len as size_t)
                        .wrapping_add(nb_words)
                        .wrapping_add(1 as libc::c_int as size_t) as libc::c_int,
                );
            }
            *str.offset(len as isize) = (*cv).str_0.size;
            memcpy(
                &mut *str.offset((len + 1 as libc::c_int) as isize) as *mut libc::c_int
                    as *mut libc::c_void,
                (*cv).str_0.data as *const libc::c_void,
                (*cv).str_0.size as libc::c_ulong,
            );
            len = (len as size_t).wrapping_add(nb_words) as libc::c_int as libc::c_int;
        }
        203 | 196 | 197 | 198 | 199 => {
            let fresh92 = len;
            len = len + 1;
            *str.offset(fresh92 as isize) = (*cv).tab[0 as libc::c_int as usize];
            let fresh93 = len;
            len = len + 1;
            *str.offset(fresh93 as isize) = (*cv).tab[1 as libc::c_int as usize];
        }
        204 => {
            let fresh94 = len;
            len = len + 1;
            *str.offset(fresh94 as isize) = (*cv).tab[0 as libc::c_int as usize];
            let fresh95 = len;
            len = len + 1;
            *str.offset(fresh95 as isize) = (*cv).tab[1 as libc::c_int as usize];
            let fresh96 = len;
            len = len + 1;
            *str.offset(fresh96 as isize) = (*cv).tab[2 as libc::c_int as usize];
            let fresh97 = len;
            len = len + 1;
            *str.offset(fresh97 as isize) = (*cv).tab[3 as libc::c_int as usize];
        }
        _ => {}
    }
    (*s).len = len;
}
unsafe extern "C" fn tok_str_add_tok(mut s: *mut TokenString) {
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    if (*file).line_num != (*s).last_line_num {
        (*s).last_line_num = (*file).line_num;
        cval.i = (*s).last_line_num as uint64_t;
        tok_str_add2(s, 0xcf as libc::c_int, &mut cval);
    }
    tok_str_add2(s, tok, &mut tokc);
}
unsafe extern "C" fn tok_str_add2_spc(
    mut s: *mut TokenString,
    mut t: libc::c_int,
    mut cv: *mut CValue,
) {
    if (*s).need_spc == 3 as libc::c_int {
        tok_str_add(s, ' ' as i32);
    }
    (*s).need_spc = 2 as libc::c_int;
    tok_str_add2(s, t, cv);
}
#[inline]
unsafe extern "C" fn tok_get(
    mut t: *mut libc::c_int,
    mut pp: *mut *const libc::c_int,
    mut cv: *mut CValue,
) {
    let mut p: *const libc::c_int = *pp;
    let mut n: libc::c_int = 0;
    let mut tab: *mut libc::c_int = 0 as *mut libc::c_int;
    tab = ((*cv).tab).as_mut_ptr();
    let mut current_block_10: u64;
    let fresh98 = p;
    p = p.offset(1);
    *t = *fresh98;
    match *t {
        194 | 192 | 193 | 207 => {
            let fresh99 = p;
            p = p.offset(1);
            (*cv).i = *fresh99 as uint64_t;
            current_block_10 = 5948590327928692120;
        }
        195 => {
            let fresh100 = p;
            p = p.offset(1);
            (*cv).i = *fresh100 as libc::c_uint as uint64_t;
            current_block_10 = 5948590327928692120;
        }
        202 => {
            let fresh101 = p;
            p = p.offset(1);
            *tab.offset(0 as libc::c_int as isize) = *fresh101;
            current_block_10 = 5948590327928692120;
        }
        200 | 201 | 205 | 206 => {
            let fresh102 = p;
            p = p.offset(1);
            (*cv).str_0.size = *fresh102;
            (*cv).str_0.data = p as *mut libc::c_char;
            p = p
                .offset(
                    ((*cv).str_0.size as libc::c_ulong)
                        .wrapping_add(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        )
                        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ) as isize,
                );
            current_block_10 = 5948590327928692120;
        }
        203 | 196 | 197 | 198 | 199 => {
            n = 2 as libc::c_int;
            current_block_10 = 1437690757048508557;
        }
        204 => {
            n = 4 as libc::c_int;
            current_block_10 = 1437690757048508557;
        }
        _ => {
            current_block_10 = 5948590327928692120;
        }
    }
    match current_block_10 {
        1437690757048508557 => {
            loop {
                let fresh103 = p;
                p = p.offset(1);
                let fresh104 = tab;
                tab = tab.offset(1);
                *fresh104 = *fresh103;
                n -= 1;
                if !(n != 0) {
                    break;
                }
            }
        }
        _ => {}
    }
    *pp = p;
}
unsafe extern "C" fn macro_is_equal(
    mut a: *const libc::c_int,
    mut b: *const libc::c_int,
) -> libc::c_int {
    let mut cv: CValue = CValue { ld: f128::f128::ZERO };
    let mut t: libc::c_int = 0;
    if a.is_null() || b.is_null() {
        return 1 as libc::c_int;
    }
    while *a != 0 && *b != 0 {
        cstr_reset(&mut tokcstr);
        let mut _t: libc::c_int = *a;
        if _t >= 0xc0 as libc::c_int && _t <= 0xcf as libc::c_int {
            tok_get(&mut t, &mut a, &mut cv);
        } else {
            t = _t;
            a = a.offset(1);
            a;
        }
        cstr_cat(&mut tokcstr, get_tok_str(t, &mut cv), 0 as libc::c_int);
        let mut _t_0: libc::c_int = *b;
        if _t_0 >= 0xc0 as libc::c_int && _t_0 <= 0xcf as libc::c_int {
            tok_get(&mut t, &mut b, &mut cv);
        } else {
            t = _t_0;
            b = b.offset(1);
            b;
        }
        if strcmp(tokcstr.data, get_tok_str(t, &mut cv)) != 0 {
            return 0 as libc::c_int;
        }
    }
    return !(*a != 0 || *b != 0) as libc::c_int;
}
#[inline]
unsafe extern "C" fn define_push(
    mut v: libc::c_int,
    mut macro_type: libc::c_int,
    mut str: *mut libc::c_int,
    mut first_arg: *mut Sym,
) {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut o_0: *mut Sym = 0 as *mut Sym;
    o_0 = define_find(v);
    s = sym_push2(&mut define_stack, v, macro_type, 0 as libc::c_int);
    (*s).c2rust_unnamed.d = str;
    (*s).c2rust_unnamed_0.next = first_arg;
    let ref mut fresh105 = (**table_ident.offset((v - 256 as libc::c_int) as isize))
        .sym_define;
    *fresh105 = s;
    if !o_0.is_null()
        && macro_is_equal((*o_0).c2rust_unnamed.d, (*s).c2rust_unnamed.d) == 0
    {
        _tcc_warning(
            b"%s redefined\0" as *const u8 as *const libc::c_char,
            get_tok_str(v, 0 as *mut CValue),
        );
    }
}
unsafe extern "C" fn define_undef(mut s: *mut Sym) {
    let mut v: libc::c_int = (*s).v;
    if v >= 256 as libc::c_int && v < tok_ident {
        let ref mut fresh106 = (**table_ident.offset((v - 256 as libc::c_int) as isize))
            .sym_define;
        *fresh106 = 0 as *mut Sym;
    }
}
#[inline]
unsafe extern "C" fn define_find(mut v: libc::c_int) -> *mut Sym {
    v -= 256 as libc::c_int;
    if v as libc::c_uint >= (tok_ident - 256 as libc::c_int) as libc::c_uint {
        return 0 as *mut Sym;
    }
    return (**table_ident.offset(v as isize)).sym_define;
}
unsafe extern "C" fn free_defines(mut b: *mut Sym) {
    while define_stack != b {
        let mut top: *mut Sym = define_stack;
        define_stack = (*top).prev;
        tok_str_free_str((*top).c2rust_unnamed.d);
        define_undef(top);
        sym_free(top);
    }
}
unsafe extern "C" fn maybe_run_test(mut s: *mut TCCState) {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    if (*s).include_stack_ptr != ((*s).include_stack).as_mut_ptr() {
        return;
    }
    p = get_tok_str(tok, 0 as *mut CValue);
    if 0 as libc::c_int
        != memcmp(
            p as *const libc::c_void,
            b"test_\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            5 as libc::c_int as libc::c_ulong,
        )
    {
        return;
    }
    (*s).run_test -= 1;
    if 0 as libc::c_int != (*s).run_test {
        return;
    }
    fprintf(
        (*s).ppfp,
        &*(b"\n[%s]\n\0" as *const u8 as *const libc::c_char)
            .offset(
                ((*s).dflag as libc::c_int & 32 as libc::c_int == 0) as libc::c_int
                    as isize,
            ) as *const libc::c_char,
        p,
    );
    fflush((*s).ppfp);
    define_push(tok, 0 as libc::c_int, 0 as *mut libc::c_int, 0 as *mut Sym);
}
unsafe extern "C" fn skip_to_eol(mut warn: libc::c_int) {
    if tok == 10 as libc::c_int {
        return;
    }
    if warn != 0 {
        _tcc_warning(
            b"extra tokens after directive\0" as *const u8 as *const libc::c_char,
        );
    }
    while !macro_stack.is_null() {
        end_macro();
    }
    (*file)
        .buf_ptr = parse_line_comment(
        ((*file).buf_ptr).offset(-(1 as libc::c_int as isize)),
    );
    next_nomacro();
}
unsafe extern "C" fn parse_include(
    mut s1: *mut TCCState,
    mut do_next: libc::c_int,
    mut test: libc::c_int,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut name: [libc::c_char; 1024] = [0; 1024];
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut e: *mut CachedInclude = 0 as *mut CachedInclude;
    c = skip_spaces();
    if c == '<' as i32 || c == '"' as i32 {
        cstr_reset(&mut tokcstr);
        (*file)
            .buf_ptr = parse_pp_string(
            (*file).buf_ptr,
            if c == '<' as i32 { '>' as i32 } else { c },
            &mut tokcstr,
        );
        i = tokcstr.size;
        pstrncpy(
            name.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            tokcstr.data,
            i as size_t,
        );
        next_nomacro();
    } else {
        parse_flags = 0x1 as libc::c_int | 0x4 as libc::c_int
            | parse_flags & 0x8 as libc::c_int;
        name[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        loop {
            next();
            p = name.as_mut_ptr();
            i = (strlen(p)).wrapping_sub(1 as libc::c_int as libc::c_ulong)
                as libc::c_int;
            if i > 0 as libc::c_int
                && (*p.offset(0 as libc::c_int as isize) as libc::c_int == '"' as i32
                    && *p.offset(i as isize) as libc::c_int == '"' as i32
                    || *p.offset(0 as libc::c_int as isize) as libc::c_int == '<' as i32
                        && *p.offset(i as isize) as libc::c_int == '>' as i32)
            {
                break;
            }
            if tok == 10 as libc::c_int {
                _tcc_error(
                    b"'#include' expects \"FILENAME\" or <FILENAME>\0" as *const u8
                        as *const libc::c_char,
                );
            }
            pstrcat(
                name.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                get_tok_str(tok, &mut tokc),
            );
        }
        c = *p.offset(0 as libc::c_int as isize) as libc::c_int;
        memmove(
            p as *mut libc::c_void,
            p.offset(1 as libc::c_int as isize) as *const libc::c_void,
            (i - 1 as libc::c_int) as libc::c_ulong,
        );
        *p.offset((i - 1 as libc::c_int) as isize) = 0 as libc::c_int as libc::c_char;
    }
    if test == 0 {
        skip_to_eol(1 as libc::c_int);
    }
    i = if do_next != 0 { (*file).include_next_index } else { -(1 as libc::c_int) };
    loop {
        i += 1;
        i;
        if i == 0 as libc::c_int {
            if !(name[0 as libc::c_int as usize] as libc::c_int == '/' as i32) {
                continue;
            }
            buf[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
        } else if i == 1 as libc::c_int {
            if c != '"' as i32 {
                continue;
            }
            p = (*file).true_filename;
            pstrncpy(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                p,
                (tcc_basename(p)).offset_from(p) as libc::c_long as size_t,
            );
        } else {
            let mut j: libc::c_int = i - 2 as libc::c_int;
            let mut k: libc::c_int = j - (*s1).nb_include_paths;
            if k < 0 as libc::c_int {
                p = *((*s1).include_paths).offset(j as isize);
            } else if k < (*s1).nb_sysinclude_paths {
                p = *((*s1).sysinclude_paths).offset(k as isize);
            } else if test != 0 {
                return 0 as libc::c_int
            } else {
                _tcc_error(
                    b"include file '%s' not found\0" as *const u8 as *const libc::c_char,
                    name.as_mut_ptr(),
                );
            }
            pstrcpy(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                p,
            );
            pstrcat(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
                b"/\0" as *const u8 as *const libc::c_char,
            );
        }
        pstrcat(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            name.as_mut_ptr(),
        );
        e = search_cached_include(s1, buf.as_mut_ptr(), 0 as libc::c_int);
        if !e.is_null()
            && (!(define_find((*e).ifndef_macro)).is_null() || (*e).once != 0)
        {
            return 1 as libc::c_int;
        }
        if tcc_open(s1, buf.as_mut_ptr()) >= 0 as libc::c_int {
            break;
        }
    }
    if test != 0 {
        tcc_close();
    } else {
        if (*s1).include_stack_ptr
            >= ((*s1).include_stack).as_mut_ptr().offset(32 as libc::c_int as isize)
        {
            _tcc_error(
                b"#include recursion too deep\0" as *const u8 as *const libc::c_char,
            );
        }
        let fresh107 = (*s1).include_stack_ptr;
        (*s1).include_stack_ptr = ((*s1).include_stack_ptr).offset(1);
        *fresh107 = (*file).prev;
        (*file).include_next_index = i;
        if (*s1).gen_deps != 0 {
            let mut bf: *mut BufferedFile = file;
            while i == 1 as libc::c_int
                && {
                    bf = (*bf).prev;
                    !bf.is_null()
                }
            {
                i = (*bf).include_next_index;
            }
            if (*s1).include_sys_deps as libc::c_int != 0
                || (i - 2 as libc::c_int) < (*s1).nb_include_paths
            {
                dynarray_add(
                    &mut (*s1).target_deps as *mut *mut *mut libc::c_char
                        as *mut libc::c_void,
                    &mut (*s1).nb_target_deps,
                    tcc_strdup(buf.as_mut_ptr()) as *mut libc::c_void,
                );
            }
        }
        tcc_debug_bincl(s1);
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn expr_preprocess(mut s1: *mut TCCState) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut t0: libc::c_int = tok;
    let mut str: *mut TokenString = 0 as *mut TokenString;
    str = tok_str_alloc();
    pp_expr = 1 as libc::c_int;
    loop {
        next();
        t = tok;
        if tok < 256 as libc::c_int {
            if tok == 10 as libc::c_int || tok == -(1 as libc::c_int) {
                break;
            }
            if tok >= 0xc8 as libc::c_int && tok <= 0xcc as libc::c_int {
                _tcc_error(
                    b"invalid constant in preprocessor expression\0" as *const u8
                        as *const libc::c_char,
                );
            }
        } else {
            if tok == TOK_DEFINED as libc::c_int {
                parse_flags &= !(0x1 as libc::c_int);
                next();
                t = tok;
                if t == '(' as i32 {
                    next();
                }
                parse_flags |= 0x1 as libc::c_int;
                if tok < 256 as libc::c_int {
                    expect(
                        b"identifier after 'defined'\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if (*s1).run_test != 0 {
                    maybe_run_test(s1);
                }
                c = 0 as libc::c_int;
                if !(define_find(tok)).is_null()
                    || tok == TOK___HAS_INCLUDE as libc::c_int
                    || tok == TOK___HAS_INCLUDE_NEXT as libc::c_int
                {
                    c = 1 as libc::c_int;
                }
                if t == '(' as i32 {
                    next();
                    if tok != ')' as i32 {
                        expect(b"')'\0" as *const u8 as *const libc::c_char);
                    }
                }
            } else if tok == TOK___HAS_INCLUDE as libc::c_int
                || tok == TOK___HAS_INCLUDE_NEXT as libc::c_int
            {
                t = tok;
                next();
                if tok != '(' as i32 {
                    expect(b"'('\0" as *const u8 as *const libc::c_char);
                }
                c = parse_include(
                    s1,
                    t - TOK___HAS_INCLUDE as libc::c_int,
                    1 as libc::c_int,
                );
                if tok != ')' as i32 {
                    expect(b"')'\0" as *const u8 as *const libc::c_char);
                }
            } else {
                c = 0 as libc::c_int;
            }
            tok = 0xc4 as libc::c_int;
            tokc.i = c as uint64_t;
        }
        tok_str_add_tok(str);
    }
    if 0 as libc::c_int == (*str).len {
        _tcc_error(
            b"#%s with no expression\0" as *const u8 as *const libc::c_char,
            get_tok_str(t0, 0 as *mut CValue),
        );
    }
    tok_str_add(str, -(1 as libc::c_int));
    pp_expr = t0;
    t = tok;
    begin_macro(str, 1 as libc::c_int);
    next();
    c = expr_const();
    if tok != -(1 as libc::c_int) {
        _tcc_error(b"...\0" as *const u8 as *const libc::c_char);
    }
    pp_expr = 0 as libc::c_int;
    end_macro();
    tok = t;
    return (c != 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn pp_error(mut cs: *mut CString) {
    cstr_printf(
        cs,
        b"bad preprocessor expression: #%s\0" as *const u8 as *const libc::c_char,
        get_tok_str(pp_expr, 0 as *mut CValue),
    );
    macro_ptr = (*macro_stack).str_0;
    loop {
        next();
        if !(tok != -(1 as libc::c_int)) {
            break;
        }
        cstr_printf(
            cs,
            b" %s\0" as *const u8 as *const libc::c_char,
            get_tok_str(tok, &mut tokc),
        );
    };
}
unsafe extern "C" fn parse_define() {
    let mut current_block: u64;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut first: *mut Sym = 0 as *mut Sym;
    let mut ps: *mut *mut Sym = 0 as *mut *mut Sym;
    let mut v: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut varg: libc::c_int = 0;
    let mut is_vaargs: libc::c_int = 0;
    let mut t0: libc::c_int = 0;
    let mut saved_parse_flags: libc::c_int = parse_flags;
    let mut str: TokenString = TokenString {
        str_0: 0 as *const libc::c_int as *mut libc::c_int,
        len: 0,
        need_spc: 0,
        allocated_len: 0,
        last_line_num: 0,
        save_line_num: 0,
        prev: 0 as *const TokenString as *mut TokenString,
        prev_ptr: 0 as *const libc::c_int,
        alloc: 0,
    };
    v = tok;
    if v < 256 as libc::c_int || v == TOK_DEFINED as libc::c_int {
        _tcc_error(
            b"invalid macro name '%s'\0" as *const u8 as *const libc::c_char,
            get_tok_str(tok, &mut tokc),
        );
    }
    first = 0 as *mut Sym;
    t = 0 as libc::c_int;
    parse_flags = parse_flags & !(0x8 as libc::c_int) | 0x10 as libc::c_int;
    next_nomacro();
    parse_flags &= !(0x10 as libc::c_int);
    is_vaargs = 0 as libc::c_int;
    if tok == '(' as i32 {
        let mut dotid: libc::c_int = set_idnum('.' as i32, 0 as libc::c_int);
        next_nomacro();
        ps = &mut first;
        if tok != ')' as i32 {
            loop {
                varg = tok;
                next_nomacro();
                is_vaargs = 0 as libc::c_int;
                if varg == 0xa1 as libc::c_int {
                    varg = TOK___VA_ARGS__ as libc::c_int;
                    is_vaargs = 1 as libc::c_int;
                } else if tok == 0xa1 as libc::c_int
                    && (*tcc_state).gnu_ext as libc::c_int != 0
                {
                    is_vaargs = 1 as libc::c_int;
                    next_nomacro();
                }
                if !(varg < 256 as libc::c_int) {
                    s = sym_push2(
                        &mut define_stack,
                        varg | 0x20000000 as libc::c_int,
                        is_vaargs,
                        0 as libc::c_int,
                    );
                    *ps = s;
                    ps = &mut (*s).c2rust_unnamed_0.next;
                    if tok == ')' as i32 {
                        break;
                    }
                    if !(tok != ',' as i32 || is_vaargs != 0) {
                        next_nomacro();
                        continue;
                    }
                }
                _tcc_error(
                    b"bad macro parameter list\0" as *const u8 as *const libc::c_char,
                );
            }
        }
        parse_flags |= 0x10 as libc::c_int;
        next_nomacro();
        t = 1 as libc::c_int;
        set_idnum('.' as i32, dotid);
    }
    parse_flags |= 0x20 as libc::c_int | 0x10 as libc::c_int | 0x4 as libc::c_int;
    tok_str_new(&mut str);
    t0 = 0 as libc::c_int;
    loop {
        if !(tok != 10 as libc::c_int && tok != -(1 as libc::c_int)) {
            current_block = 18435049525520518667;
            break;
        }
        if is_space(tok) != 0 {
            str.need_spc |= 1 as libc::c_int;
        } else {
            if 0xa3 as libc::c_int == tok {
                if 0 as libc::c_int == t0 {
                    current_block = 13340887467081731134;
                    break;
                }
                tok = 0xa3 as libc::c_int | 0x20000000 as libc::c_int;
                t |= 2 as libc::c_int;
            }
            tok_str_add2_spc(&mut str, tok, &mut tokc);
            t0 = tok;
        }
        next_nomacro();
    }
    match current_block {
        18435049525520518667 => {
            parse_flags = saved_parse_flags;
            tok_str_add(&mut str, 0 as libc::c_int);
            if !(t0 == 0xa3 as libc::c_int | 0x20000000 as libc::c_int) {
                define_push(v, t, str.str_0, first);
                return;
            }
        }
        _ => {}
    }
    _tcc_error(
        b"'##' cannot appear at either end of macro\0" as *const u8
            as *const libc::c_char,
    );
}
unsafe extern "C" fn search_cached_include(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
    mut add: libc::c_int,
) -> *mut CachedInclude {
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut basename: *const libc::c_char = 0 as *const libc::c_char;
    let mut h: libc::c_uint = 0;
    let mut e: *mut CachedInclude = 0 as *mut CachedInclude;
    let mut c: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    basename = tcc_basename(filename);
    s = basename;
    h = 1 as libc::c_int as libc::c_uint;
    loop {
        c = *s as libc::c_uchar as libc::c_int;
        if !(c != 0 as libc::c_int) {
            break;
        }
        h = h
            .wrapping_add(h << 5 as libc::c_int)
            .wrapping_add(h >> 27 as libc::c_int)
            .wrapping_add(c as libc::c_uint);
        s = s.offset(1);
        s;
    }
    h &= (32 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
    i = (*s1).cached_includes_hash[h as usize];
    while !(i == 0 as libc::c_int) {
        e = *((*s1).cached_includes).offset((i - 1 as libc::c_int) as isize);
        if 0 as libc::c_int == strcmp(filename, ((*e).filename).as_mut_ptr()) {
            return e;
        }
        if (*e).once != 0
            && 0 as libc::c_int
                == strcmp(basename, tcc_basename(((*e).filename).as_mut_ptr()))
            && 0 as libc::c_int
                == normalized_PATHCMP(filename, ((*e).filename).as_mut_ptr())
        {
            return e;
        }
        i = (*e).hash_next;
    }
    if add == 0 {
        return 0 as *mut CachedInclude;
    }
    len = strlen(filename) as libc::c_int;
    e = tcc_malloc(
        (::core::mem::size_of::<CachedInclude>() as libc::c_ulong)
            .wrapping_add(len as libc::c_ulong),
    ) as *mut CachedInclude;
    memcpy(
        ((*e).filename).as_mut_ptr() as *mut libc::c_void,
        filename as *const libc::c_void,
        (len + 1 as libc::c_int) as libc::c_ulong,
    );
    (*e).once = 0 as libc::c_int;
    (*e).ifndef_macro = (*e).once;
    dynarray_add(
        &mut (*s1).cached_includes as *mut *mut *mut CachedInclude as *mut libc::c_void,
        &mut (*s1).nb_cached_includes,
        e as *mut libc::c_void,
    );
    (*e).hash_next = (*s1).cached_includes_hash[h as usize];
    (*s1).cached_includes_hash[h as usize] = (*s1).nb_cached_includes;
    return e;
}
unsafe extern "C" fn pragma_parse(mut s1: *mut TCCState) -> libc::c_int {
    let mut current_block: u64;
    next_nomacro();
    if tok == TOK_push_macro as libc::c_int || tok == TOK_pop_macro as libc::c_int {
        let mut t: libc::c_int = tok;
        let mut v: libc::c_int = 0;
        let mut s: *mut Sym = 0 as *mut Sym;
        next();
        if tok != '(' as i32 {
            current_block = 17217517382727332676;
        } else {
            next();
            if tok != 0xc8 as libc::c_int {
                current_block = 17217517382727332676;
            } else {
                v = (*tok_alloc(tokc.str_0.data, tokc.str_0.size - 1 as libc::c_int))
                    .tok;
                next();
                if tok != ')' as i32 {
                    current_block = 17217517382727332676;
                } else {
                    if t == TOK_push_macro as libc::c_int {
                        loop {
                            s = define_find(v);
                            if !s.is_null() {
                                break;
                            }
                            define_push(
                                v,
                                0 as libc::c_int,
                                0 as *mut libc::c_int,
                                0 as *mut Sym,
                            );
                        }
                        (*s).type_0.ref_0 = s;
                    } else {
                        s = define_stack;
                        while !s.is_null() {
                            if (*s).v == v && (*s).type_0.ref_0 == s {
                                (*s).type_0.ref_0 = 0 as *mut Sym;
                                break;
                            } else {
                                s = (*s).prev;
                            }
                        }
                    }
                    if !s.is_null() {
                        let ref mut fresh108 = (**table_ident
                            .offset((v - 256 as libc::c_int) as isize))
                            .sym_define;
                        *fresh108 = if !((*s).c2rust_unnamed.d).is_null() {
                            s
                        } else {
                            0 as *mut Sym
                        };
                    } else {
                        _tcc_warning(
                            b"unbalanced #pragma pop_macro\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    pp_debug_tok = t;
                    pp_debug_symv = v;
                    current_block = 2706659501864706830;
                }
            }
        }
    } else if tok == TOK_once as libc::c_int {
        (*search_cached_include(s1, (*file).true_filename, 1 as libc::c_int))
            .once = 1 as libc::c_int;
        current_block = 2706659501864706830;
    } else if (*s1).output_type == 5 as libc::c_int {
        unget_tok(' ' as i32);
        unget_tok(TOK_PRAGMA as libc::c_int);
        unget_tok('#' as i32);
        unget_tok(10 as libc::c_int);
        return 1 as libc::c_int;
    } else if tok == TOK_pack as libc::c_int {
        next();
        skip('(' as i32);
        if tok == TOK_ASM_pop as libc::c_int {
            next();
            if (*s1).pack_stack_ptr <= ((*s1).pack_stack).as_mut_ptr() {
                current_block = 14960208650928893295;
            } else {
                (*s1).pack_stack_ptr = ((*s1).pack_stack_ptr).offset(-1);
                (*s1).pack_stack_ptr;
                current_block = 10758786907990354186;
            }
        } else {
            let mut val: libc::c_int = 0 as libc::c_int;
            if tok != ')' as i32 {
                if tok == TOK_ASM_push as libc::c_int {
                    next();
                    if (*s1).pack_stack_ptr
                        >= ((*s1).pack_stack)
                            .as_mut_ptr()
                            .offset(8 as libc::c_int as isize)
                            .offset(-(1 as libc::c_int as isize))
                    {
                        current_block = 14960208650928893295;
                    } else {
                        let fresh109 = (*s1).pack_stack_ptr;
                        (*s1).pack_stack_ptr = ((*s1).pack_stack_ptr).offset(1);
                        val = *fresh109;
                        if tok != ',' as i32 {
                            current_block = 9956893323142497207;
                        } else {
                            next();
                            current_block = 8180496224585318153;
                        }
                    }
                } else {
                    current_block = 8180496224585318153;
                }
                match current_block {
                    14960208650928893295 => {}
                    9956893323142497207 => {}
                    _ => {
                        if tok != 0xc2 as libc::c_int {
                            current_block = 17217517382727332676;
                        } else {
                            val = tokc.i as libc::c_int;
                            if val < 1 as libc::c_int || val > 16 as libc::c_int
                                || val & val - 1 as libc::c_int != 0 as libc::c_int
                            {
                                current_block = 17217517382727332676;
                            } else {
                                next();
                                current_block = 9956893323142497207;
                            }
                        }
                    }
                }
            } else {
                current_block = 9956893323142497207;
            }
            match current_block {
                17217517382727332676 => {}
                14960208650928893295 => {}
                _ => {
                    *(*s1).pack_stack_ptr = val;
                    current_block = 10758786907990354186;
                }
            }
        }
        match current_block {
            17217517382727332676 => {}
            _ => {
                match current_block {
                    14960208650928893295 => {
                        _tcc_error(
                            b"out of pack stack\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {
                        if tok != ')' as i32 {
                            current_block = 17217517382727332676;
                        } else {
                            current_block = 2706659501864706830;
                        }
                    }
                }
            }
        }
    } else if tok == TOK_comment as libc::c_int {
        let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut t_0: libc::c_int = 0;
        next();
        skip('(' as i32);
        t_0 = tok;
        next();
        skip(',' as i32);
        if tok != 0xc8 as libc::c_int {
            current_block = 17217517382727332676;
        } else {
            p = tcc_strdup(tokc.str_0.data);
            next();
            if tok != ')' as i32 {
                current_block = 17217517382727332676;
            } else {
                if t_0 == TOK_lib as libc::c_int {
                    dynarray_add(
                        &mut (*s1).pragma_libs as *mut *mut *mut libc::c_char
                            as *mut libc::c_void,
                        &mut (*s1).nb_pragma_libs,
                        p as *mut libc::c_void,
                    );
                } else {
                    if t_0 == TOK_option as libc::c_int {
                        tcc_set_options(s1, p);
                    }
                    tcc_free(p as *mut libc::c_void);
                }
                current_block = 2706659501864706830;
            }
        }
    } else {
        (*tcc_state)
            .warn_num = (&mut (*(0 as *mut TCCState)).warn_all as *mut libc::c_uchar
            as size_t)
            .wrapping_sub(
                &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar as size_t,
            ) as libc::c_uchar;
        (Some(_tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> ()))
            .expect(
                "non-null function pointer",
            )(
            b"#pragma %s ignored\0" as *const u8 as *const libc::c_char,
            get_tok_str(tok, &mut tokc),
        );
        return 0 as libc::c_int;
    }
    match current_block {
        17217517382727332676 => {
            _tcc_error(
                b"malformed #pragma directive\0" as *const u8 as *const libc::c_char,
            );
        }
        _ => {
            next();
            return 1 as libc::c_int;
        }
    };
}
unsafe extern "C" fn tccpp_putfile(mut filename: *const libc::c_char) {
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    buf[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if !(*filename.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32) {
        pstrcpy(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            (*file).true_filename,
        );
        *tcc_basename(buf.as_mut_ptr()) = 0 as libc::c_int as libc::c_char;
    }
    pstrcat(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        filename,
    );
    if 0 as libc::c_int == strcmp(((*file).filename).as_mut_ptr(), buf.as_mut_ptr()) {
        return;
    }
    if (*file).true_filename == ((*file).filename).as_mut_ptr() {
        (*file).true_filename = tcc_strdup(((*file).filename).as_mut_ptr());
    }
    pstrcpy(
        ((*file).filename).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        buf.as_mut_ptr(),
    );
    tcc_debug_newfile(tcc_state);
}
unsafe extern "C" fn preprocess(mut is_bof: libc::c_int) {
    let mut current_block: u64;
    let mut s1: *mut TCCState = tcc_state;
    let mut c: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut saved_parse_flags: libc::c_int = 0;
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: *mut Sym = 0 as *mut Sym;
    saved_parse_flags = parse_flags;
    parse_flags = 0x1 as libc::c_int | 0x2 as libc::c_int | 0x40 as libc::c_int
        | 0x4 as libc::c_int | parse_flags & 0x8 as libc::c_int;
    next_nomacro();
    loop {
        match tok {
            320 => {
                pp_debug_tok = tok;
                next_nomacro();
                pp_debug_symv = tok;
                parse_define();
                current_block = 3634396408142324656;
                break;
            }
            328 => {
                pp_debug_tok = tok;
                next_nomacro();
                pp_debug_symv = tok;
                s = define_find(tok);
                if !s.is_null() {
                    define_undef(s);
                }
                next_nomacro();
                current_block = 3634396408142324656;
                break;
            }
            321 | 322 => {
                parse_include(s1, tok - TOK_INCLUDE as libc::c_int, 0 as libc::c_int);
                current_block = 705818568528426509;
                break;
            }
            324 => {
                c = 1 as libc::c_int;
                current_block = 9101467697609984063;
            }
            256 => {
                c = expr_preprocess(s1);
                current_block = 11232989805313494956;
            }
            323 => {
                c = 0 as libc::c_int;
                current_block = 9101467697609984063;
            }
            257 => {
                next_nomacro();
                if (*s1).ifdef_stack_ptr == ((*s1).ifdef_stack).as_mut_ptr() {
                    _tcc_error(
                        b"#else without matching #if\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if *((*s1).ifdef_stack_ptr).offset(-(1 as libc::c_int) as isize)
                    & 2 as libc::c_int != 0
                {
                    _tcc_error(
                        b"#else after #else\0" as *const u8 as *const libc::c_char,
                    );
                }
                let ref mut fresh111 = *((*s1).ifdef_stack_ptr)
                    .offset(-(1 as libc::c_int) as isize);
                *fresh111 ^= 3 as libc::c_int;
                c = *fresh111;
                current_block = 8572534152877012356;
            }
            325 => {
                if (*s1).ifdef_stack_ptr == ((*s1).ifdef_stack).as_mut_ptr() {
                    _tcc_error(
                        b"#elif without matching #if\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                c = *((*s1).ifdef_stack_ptr).offset(-(1 as libc::c_int) as isize);
                if c > 1 as libc::c_int {
                    _tcc_error(
                        b"#elif after #else\0" as *const u8 as *const libc::c_char,
                    );
                }
                if c == 1 as libc::c_int {
                    skip_to_eol(0 as libc::c_int);
                    c = 0 as libc::c_int;
                } else {
                    c = expr_preprocess(s1);
                    *((*s1).ifdef_stack_ptr).offset(-(1 as libc::c_int) as isize) = c;
                }
                current_block = 8572534152877012356;
            }
            326 => {
                next_nomacro();
                if (*s1).ifdef_stack_ptr <= (*file).ifdef_stack_ptr {
                    _tcc_error(
                        b"#endif without matching #if\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                (*s1).ifdef_stack_ptr = ((*s1).ifdef_stack_ptr).offset(-1);
                (*s1).ifdef_stack_ptr;
                if (*file).ifndef_macro != 0
                    && (*s1).ifdef_stack_ptr == (*file).ifdef_stack_ptr
                {
                    (*file).ifndef_macro_saved = (*file).ifndef_macro;
                    (*file).ifndef_macro = 0 as libc::c_int;
                    tok_flags |= 0x4 as libc::c_int;
                }
                current_block = 3634396408142324656;
                break;
            }
            331 => {
                parse_flags &= !(0x2 as libc::c_int);
                next();
                if tok != 0xcd as libc::c_int {
                    current_block = 8078723241383300335;
                    break;
                } else {
                    current_block = 11441799814184323368;
                    break;
                }
            }
            205 => {
                if parse_flags & 0x8 as libc::c_int != 0 {
                    current_block = 3817974728768409026;
                    break;
                } else {
                    current_block = 3392087639489470149;
                    break;
                }
            }
            329 | 330 => {
                q = buf.as_mut_ptr();
                c = skip_spaces();
                while c != '\n' as i32 && c != -(1 as libc::c_int) {
                    if (q.offset_from(buf.as_mut_ptr()) as libc::c_long as libc::c_ulong)
                        < (::core::mem::size_of::<[libc::c_char; 1024]>()
                            as libc::c_ulong)
                            .wrapping_sub(1 as libc::c_int as libc::c_ulong)
                    {
                        let fresh112 = q;
                        q = q.offset(1);
                        *fresh112 = c as libc::c_char;
                    }
                    c = handle_stray_noerror(0 as libc::c_int);
                }
                *q = '\0' as i32 as libc::c_char;
                if tok == TOK_ERROR as libc::c_int {
                    _tcc_error(
                        b"#error %s\0" as *const u8 as *const libc::c_char,
                        buf.as_mut_ptr(),
                    );
                } else {
                    _tcc_warning(
                        b"#warning %s\0" as *const u8 as *const libc::c_char,
                        buf.as_mut_ptr(),
                    );
                }
                next_nomacro();
                current_block = 3634396408142324656;
                break;
            }
            332 => {
                if pragma_parse(s1) == 0 {
                    current_block = 3817974728768409026;
                    break;
                } else {
                    current_block = 3634396408142324656;
                    break;
                }
            }
            10 => {
                current_block = 705818568528426509;
                break;
            }
            _ => {
                if saved_parse_flags & 0x8 as libc::c_int != 0 {
                    current_block = 3817974728768409026;
                    break;
                } else {
                    current_block = 11869735117417356968;
                    break;
                }
            }
        }
        match current_block {
            9101467697609984063 => {
                next_nomacro();
                if tok < 256 as libc::c_int {
                    _tcc_error(
                        b"invalid argument for '#if%sdef'\0" as *const u8
                            as *const libc::c_char,
                        if c != 0 {
                            b"n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                if is_bof != 0 {
                    if c != 0 {
                        (*file).ifndef_macro = tok;
                    }
                }
                if !(define_find(tok)).is_null()
                    || tok == TOK___HAS_INCLUDE as libc::c_int
                    || tok == TOK___HAS_INCLUDE_NEXT as libc::c_int
                {
                    c ^= 1 as libc::c_int;
                }
                next_nomacro();
                current_block = 11232989805313494956;
            }
            8572534152877012356 => {
                if (*s1).ifdef_stack_ptr
                    == ((*file).ifdef_stack_ptr).offset(1 as libc::c_int as isize)
                {
                    (*file).ifndef_macro = 0 as libc::c_int;
                }
                current_block = 15065305748217041615;
            }
            _ => {}
        }
        match current_block {
            11232989805313494956 => {
                if (*s1).ifdef_stack_ptr
                    >= ((*s1).ifdef_stack)
                        .as_mut_ptr()
                        .offset(64 as libc::c_int as isize)
                {
                    _tcc_error(
                        b"memory full (ifdef)\0" as *const u8 as *const libc::c_char,
                    );
                }
                let fresh110 = (*s1).ifdef_stack_ptr;
                (*s1).ifdef_stack_ptr = ((*s1).ifdef_stack_ptr).offset(1);
                *fresh110 = c;
            }
            _ => {}
        }
        if !(c & 1 as libc::c_int == 0) {
            current_block = 3634396408142324656;
            break;
        }
        skip_to_eol(1 as libc::c_int);
        preprocess_skip();
        is_bof = 0 as libc::c_int;
    }
    match current_block {
        11869735117417356968 => {
            if tok == '!' as i32 && is_bof != 0 {
                current_block = 3817974728768409026;
            } else {
                _tcc_warning(
                    b"Ignoring unknown preprocessing directive #%s\0" as *const u8
                        as *const libc::c_char,
                    get_tok_str(tok, &mut tokc),
                );
                current_block = 3817974728768409026;
            }
        }
        3392087639489470149 => {
            c = 0 as libc::c_int;
            current_block = 15594603006322722090;
        }
        11441799814184323368 => {
            c = 1 as libc::c_int;
            current_block = 15594603006322722090;
        }
        _ => {}
    }
    match current_block {
        15594603006322722090 => {
            n = 0 as libc::c_int;
            q = tokc.str_0.data;
            loop {
                if !(*q != 0) {
                    current_block = 2631791190359682872;
                    break;
                }
                if isnum(*q as libc::c_int) == 0 {
                    current_block = 8078723241383300335;
                    break;
                }
                n = n * 10 as libc::c_int + *q as libc::c_int - '0' as i32;
                q = q.offset(1);
                q;
            }
            match current_block {
                8078723241383300335 => {}
                _ => {
                    parse_flags &= !(0x40 as libc::c_int);
                    next();
                    if tok != 10 as libc::c_int {
                        if tok != 0xce as libc::c_int
                            || *(tokc.str_0.data).offset(0 as libc::c_int as isize)
                                as libc::c_int != '"' as i32
                        {
                            current_block = 8078723241383300335;
                        } else {
                            *(tokc.str_0.data)
                                .offset(
                                    (tokc.str_0.size - 2 as libc::c_int) as isize,
                                ) = 0 as libc::c_int as libc::c_char;
                            tccpp_putfile(
                                (tokc.str_0.data).offset(1 as libc::c_int as isize),
                            );
                            next();
                            skip_to_eol(c);
                            current_block = 2723324002591448311;
                        }
                    } else {
                        current_block = 2723324002591448311;
                    }
                    match current_block {
                        8078723241383300335 => {}
                        _ => {
                            if (*file).fd > 0 as libc::c_int {
                                (*tcc_state).total_lines += (*file).line_num - n;
                            }
                            (*file).line_num = n;
                            current_block = 3634396408142324656;
                        }
                    }
                }
            }
        }
        3817974728768409026 => {
            skip_to_eol(0 as libc::c_int);
            current_block = 705818568528426509;
        }
        _ => {}
    }
    match current_block {
        3634396408142324656 => {
            skip_to_eol(1 as libc::c_int);
        }
        8078723241383300335 => {
            _tcc_error(b"wrong #line format\0" as *const u8 as *const libc::c_char);
        }
        _ => {}
    }
    parse_flags = saved_parse_flags;
}
unsafe extern "C" fn parse_escape_string(
    mut outstr: *mut CString,
    mut buf: *const uint8_t,
    mut is_long: libc::c_int,
) {
    let mut current_block: u64;
    let mut c: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut p: *const uint8_t = 0 as *const uint8_t;
    p = buf;
    loop {
        c = *p as libc::c_int;
        if c == '\0' as i32 {
            break;
        }
        if c == '\\' as i32 {
            p = p.offset(1);
            p;
            c = *p as libc::c_int;
            match c {
                48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 => {
                    current_block = 10593234660913827991;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                120 => {
                    current_block = 17910695824078092359;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                117 => {
                    current_block = 10894760681328814809;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                85 => {
                    current_block = 4512899061124712601;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                97 => {
                    current_block = 5518580808217764435;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                98 => {
                    current_block = 8383941124715176598;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                102 => {
                    current_block = 4374783160472978455;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                110 => {
                    current_block = 1865831165700863303;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                114 => {
                    current_block = 14069466093522752717;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                116 => {
                    current_block = 11010276459331751112;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                118 => {
                    current_block = 5397672549262219205;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                101 => {
                    current_block = 11927906626876583792;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
                39 | 34 | 92 | 63 => {
                    current_block = 10261677128829721533;
                }
                _ => {
                    current_block = 7355123355511227578;
                    match current_block {
                        10593234660913827991 => {
                            n = c - '0' as i32;
                            p = p.offset(1);
                            p;
                            c = *p as libc::c_int;
                            if isoct(c) != 0 {
                                n = n * 8 as libc::c_int + c - '0' as i32;
                                p = p.offset(1);
                                p;
                                c = *p as libc::c_int;
                                if isoct(c) != 0 {
                                    n = n * 8 as libc::c_int + c - '0' as i32;
                                    p = p.offset(1);
                                    p;
                                }
                            }
                            c = n;
                            current_block = 17909688311529435645;
                        }
                        11927906626876583792 => {
                            if (*tcc_state).gnu_ext == 0 {
                                current_block = 7355123355511227578;
                            } else {
                                c = 27 as libc::c_int;
                                current_block = 10261677128829721533;
                            }
                        }
                        17910695824078092359 => {
                            i = 0 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        10894760681328814809 => {
                            i = 4 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        4512899061124712601 => {
                            i = 8 as libc::c_int;
                            current_block = 3535484783305459008;
                        }
                        5518580808217764435 => {
                            c = '\u{7}' as i32;
                            current_block = 10261677128829721533;
                        }
                        8383941124715176598 => {
                            c = '\u{8}' as i32;
                            current_block = 10261677128829721533;
                        }
                        4374783160472978455 => {
                            c = '\u{c}' as i32;
                            current_block = 10261677128829721533;
                        }
                        1865831165700863303 => {
                            c = '\n' as i32;
                            current_block = 10261677128829721533;
                        }
                        14069466093522752717 => {
                            c = '\r' as i32;
                            current_block = 10261677128829721533;
                        }
                        11010276459331751112 => {
                            c = '\t' as i32;
                            current_block = 10261677128829721533;
                        }
                        5397672549262219205 => {
                            c = '\u{b}' as i32;
                            current_block = 10261677128829721533;
                        }
                        _ => {}
                    }
                    match current_block {
                        17909688311529435645 => {}
                        10261677128829721533 => {}
                        _ => {
                            match current_block {
                                7355123355511227578 => {
                                    if c >= '!' as i32 && c <= '~' as i32 {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\%c'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    } else {
                                        _tcc_warning(
                                            b"unknown escape sequence: '\\x%x'\0" as *const u8
                                                as *const libc::c_char,
                                            c,
                                        );
                                    }
                                    current_block = 10261677128829721533;
                                }
                                _ => {
                                    p = p.offset(1);
                                    p;
                                    n = 0 as libc::c_int;
                                    loop {
                                        c = *p as libc::c_int;
                                        if c >= 'a' as i32 && c <= 'f' as i32 {
                                            c = c - 'a' as i32 + 10 as libc::c_int;
                                        } else if c >= 'A' as i32 && c <= 'F' as i32 {
                                            c = c - 'A' as i32 + 10 as libc::c_int;
                                        } else if isnum(c) != 0 {
                                            c = c - '0' as i32;
                                        } else {
                                            if !(i >= 0 as libc::c_int) {
                                                current_block = 13185927907571448285;
                                                break;
                                            }
                                            expect(
                                                b"more hex digits in universal-character-name\0"
                                                    as *const u8 as *const libc::c_char,
                                            );
                                        }
                                        n = n * 16 as libc::c_int + c;
                                        p = p.offset(1);
                                        p;
                                        i -= 1;
                                        if !(i != 0) {
                                            current_block = 9520865839495247062;
                                            break;
                                        }
                                    }
                                    match current_block {
                                        9520865839495247062 => {
                                            if !(is_long != 0) {
                                                cstr_u8cat(outstr, n);
                                                continue;
                                            }
                                        }
                                        _ => {}
                                    }
                                    c = n;
                                    current_block = 17909688311529435645;
                                }
                            }
                        }
                    }
                }
            }
        } else if is_long != 0 && c >= 0x80 as libc::c_int {
            let mut cont: libc::c_int = 0;
            let mut skip_0: libc::c_int = 0;
            let mut i_0: libc::c_int = 0;
            if c < 0xc2 as libc::c_int {
                skip_0 = 1 as libc::c_int;
                current_block = 17175911579582969952;
            } else {
                if c <= 0xdf as libc::c_int {
                    cont = 1 as libc::c_int;
                    n = c & 0x1f as libc::c_int;
                    current_block = 7858101417678297991;
                } else if c <= 0xef as libc::c_int {
                    cont = 2 as libc::c_int;
                    n = c & 0xf as libc::c_int;
                    current_block = 7858101417678297991;
                } else if c <= 0xf4 as libc::c_int {
                    cont = 3 as libc::c_int;
                    n = c & 0x7 as libc::c_int;
                    current_block = 7858101417678297991;
                } else {
                    skip_0 = 1 as libc::c_int;
                    current_block = 17175911579582969952;
                }
                match current_block {
                    17175911579582969952 => {}
                    _ => {
                        i_0 = 1 as libc::c_int;
                        loop {
                            if !(i_0 <= cont) {
                                current_block = 6838274324784804404;
                                break;
                            }
                            let mut l: libc::c_int = 0x80 as libc::c_int;
                            let mut h: libc::c_int = 0xbf as libc::c_int;
                            if i_0 == 1 as libc::c_int {
                                match c {
                                    224 => {
                                        l = 0xa0 as libc::c_int;
                                    }
                                    237 => {
                                        h = 0x9f as libc::c_int;
                                    }
                                    240 => {
                                        l = 0x90 as libc::c_int;
                                    }
                                    244 => {
                                        h = 0x8f as libc::c_int;
                                    }
                                    _ => {}
                                }
                            }
                            if (*p.offset(i_0 as isize) as libc::c_int) < l
                                || *p.offset(i_0 as isize) as libc::c_int > h
                            {
                                skip_0 = i_0;
                                current_block = 17175911579582969952;
                                break;
                            } else {
                                n = n << 6 as libc::c_int
                                    | *p.offset(i_0 as isize) as libc::c_int
                                        & 0x3f as libc::c_int;
                                i_0 += 1;
                                i_0;
                            }
                        }
                        match current_block {
                            17175911579582969952 => {}
                            _ => {
                                p = p.offset((1 as libc::c_int + cont) as isize);
                                c = n;
                                current_block = 17909688311529435645;
                            }
                        }
                    }
                }
            }
            match current_block {
                17909688311529435645 => {}
                _ => {
                    _tcc_warning(
                        b"ill-formed UTF-8 subsequence starting with: '\\x%x'\0"
                            as *const u8 as *const libc::c_char,
                        c,
                    );
                    c = 0xfffd as libc::c_int;
                    p = p.offset(skip_0 as isize);
                    current_block = 17909688311529435645;
                }
            }
        } else {
            current_block = 10261677128829721533;
        }
        match current_block {
            10261677128829721533 => {
                p = p.offset(1);
                p;
            }
            _ => {}
        }
        if is_long == 0 {
            cstr_ccat(outstr, c);
        } else {
            cstr_wccat(outstr, c);
        }
    }
    if is_long == 0 {
        cstr_ccat(outstr, '\0' as i32);
    } else {
        cstr_wccat(outstr, '\0' as i32);
    };
}
unsafe extern "C" fn parse_string(mut s: *const libc::c_char, mut len: libc::c_int) {
    let mut buf: [uint8_t; 1000] = [0; 1000];
    let mut p: *mut uint8_t = buf.as_mut_ptr();
    let mut is_long: libc::c_int = 0;
    let mut sep: libc::c_int = 0;
    is_long = (*s as libc::c_int == 'L' as i32) as libc::c_int;
    if is_long != 0 {
        s = s.offset(1);
        s;
        len -= 1;
        len;
    }
    let fresh113 = s;
    s = s.offset(1);
    sep = *fresh113 as libc::c_int;
    len -= 2 as libc::c_int;
    if len as libc::c_ulong >= ::core::mem::size_of::<[uint8_t; 1000]>() as libc::c_ulong
    {
        p = tcc_malloc((len + 1 as libc::c_int) as libc::c_ulong) as *mut uint8_t;
    }
    memcpy(p as *mut libc::c_void, s as *const libc::c_void, len as libc::c_ulong);
    *p.offset(len as isize) = 0 as libc::c_int as uint8_t;
    cstr_reset(&mut tokcstr);
    parse_escape_string(&mut tokcstr, p, is_long);
    if p != buf.as_mut_ptr() {
        tcc_free(p as *mut libc::c_void);
    }
    if sep == '\'' as i32 {
        let mut char_size: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut n: libc::c_int = 0;
        let mut c: libc::c_int = 0;
        if is_long == 0 {
            tok = 0xc0 as libc::c_int;
            char_size = 1 as libc::c_int;
        } else {
            tok = 0xc1 as libc::c_int;
            char_size = ::core::mem::size_of::<nwchar_t>() as libc::c_ulong
                as libc::c_int;
        }
        n = tokcstr.size / char_size - 1 as libc::c_int;
        if n < 1 as libc::c_int {
            _tcc_error(
                b"empty character constant\0" as *const u8 as *const libc::c_char,
            );
        }
        if n > 1 as libc::c_int {
            (*tcc_state)
                .warn_num = (&mut (*(0 as *mut TCCState)).warn_all as *mut libc::c_uchar
                as size_t)
                .wrapping_sub(
                    &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                        as size_t,
                ) as libc::c_uchar;
            (Some(_tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> ()))
                .expect(
                    "non-null function pointer",
                )(
                b"multi-character character constant\0" as *const u8
                    as *const libc::c_char,
            );
        }
        i = 0 as libc::c_int;
        c = i;
        while i < n {
            if is_long != 0 {
                c = *(tokcstr.data as *mut nwchar_t).offset(i as isize);
            } else {
                c = c << 8 as libc::c_int
                    | *(tokcstr.data).offset(i as isize) as libc::c_int;
            }
            i += 1;
            i;
        }
        tokc.i = c as uint64_t;
    } else {
        tokc.str_0.size = tokcstr.size;
        tokc.str_0.data = tokcstr.data;
        if is_long == 0 {
            tok = 0xc8 as libc::c_int;
        } else {
            tok = 0xc9 as libc::c_int;
        }
    };
}
unsafe extern "C" fn bn_lshift(
    mut bn: *mut libc::c_uint,
    mut shift: libc::c_int,
    mut or_val: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut v: libc::c_uint = 0;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        v = *bn.offset(i as isize);
        *bn.offset(i as isize) = v << shift | or_val as libc::c_uint;
        or_val = (v >> 32 as libc::c_int - shift) as libc::c_int;
        i += 1;
        i;
    }
}
unsafe extern "C" fn bn_zero(mut bn: *mut libc::c_uint) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 2 as libc::c_int {
        *bn.offset(i as isize) = 0 as libc::c_int as libc::c_uint;
        i += 1;
        i;
    }
}
unsafe extern "C" fn parse_number(mut p: *const libc::c_char) {
    let mut current_block: u64;
    let mut b: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut shift: libc::c_int = 0;
    let mut frac_bits: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut exp_val: libc::c_int = 0;
    let mut ch: libc::c_int = 0;
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bn: [libc::c_uint; 2] = [0; 2];
    let mut d: libc::c_double = 0.;
    q = token_buf.as_mut_ptr();
    let fresh114 = p;
    p = p.offset(1);
    ch = *fresh114 as libc::c_int;
    t = ch;
    let fresh115 = p;
    p = p.offset(1);
    ch = *fresh115 as libc::c_int;
    let fresh116 = q;
    q = q.offset(1);
    *fresh116 = t as libc::c_char;
    b = 10 as libc::c_int;
    if t == '.' as i32 {
        current_block = 16791665189521845338;
    } else {
        if t == '0' as i32 {
            if ch == 'x' as i32 || ch == 'X' as i32 {
                q = q.offset(-1);
                q;
                let fresh117 = p;
                p = p.offset(1);
                ch = *fresh117 as libc::c_int;
                b = 16 as libc::c_int;
            } else if (*tcc_state).tcc_ext as libc::c_int != 0
                && (ch == 'b' as i32 || ch == 'B' as i32)
            {
                q = q.offset(-1);
                q;
                let fresh118 = p;
                p = p.offset(1);
                ch = *fresh118 as libc::c_int;
                b = 2 as libc::c_int;
            }
        }
        loop {
            if ch >= 'a' as i32 && ch <= 'f' as i32 {
                t = ch - 'a' as i32 + 10 as libc::c_int;
            } else if ch >= 'A' as i32 && ch <= 'F' as i32 {
                t = ch - 'A' as i32 + 10 as libc::c_int;
            } else {
                if !(isnum(ch) != 0) {
                    current_block = 4068382217303356765;
                    break;
                }
                t = ch - '0' as i32;
            }
            if t >= b {
                current_block = 4068382217303356765;
                break;
            }
            if q >= token_buf.as_mut_ptr().offset(1024 as libc::c_int as isize) {
                current_block = 4729119564522990522;
                break;
            }
            let fresh119 = q;
            q = q.offset(1);
            *fresh119 = ch as libc::c_char;
            let fresh120 = p;
            p = p.offset(1);
            ch = *fresh120 as libc::c_int;
        }
        match current_block {
            4729119564522990522 => {}
            _ => {
                if ch == '.' as i32
                    || (ch == 'e' as i32 || ch == 'E' as i32) && b == 10 as libc::c_int
                    || (ch == 'p' as i32 || ch == 'P' as i32)
                        && (b == 16 as libc::c_int || b == 2 as libc::c_int)
                {
                    if b != 10 as libc::c_int {
                        *q = '\0' as i32 as libc::c_char;
                        if b == 16 as libc::c_int {
                            shift = 4 as libc::c_int;
                        } else {
                            shift = 1 as libc::c_int;
                        }
                        bn_zero(bn.as_mut_ptr());
                        q = token_buf.as_mut_ptr();
                        loop {
                            let fresh121 = q;
                            q = q.offset(1);
                            t = *fresh121 as libc::c_int;
                            if t == '\0' as i32 {
                                break;
                            }
                            if t >= 'a' as i32 {
                                t = t - 'a' as i32 + 10 as libc::c_int;
                            } else if t >= 'A' as i32 {
                                t = t - 'A' as i32 + 10 as libc::c_int;
                            } else {
                                t = t - '0' as i32;
                            }
                            bn_lshift(bn.as_mut_ptr(), shift, t);
                        }
                        frac_bits = 0 as libc::c_int;
                        if ch == '.' as i32 {
                            let fresh122 = p;
                            p = p.offset(1);
                            ch = *fresh122 as libc::c_int;
                            loop {
                                t = ch;
                                if t >= 'a' as i32 && t <= 'f' as i32 {
                                    t = t - 'a' as i32 + 10 as libc::c_int;
                                } else if t >= 'A' as i32 && t <= 'F' as i32 {
                                    t = t - 'A' as i32 + 10 as libc::c_int;
                                } else {
                                    if !(t >= '0' as i32 && t <= '9' as i32) {
                                        break;
                                    }
                                    t = t - '0' as i32;
                                }
                                if t >= b {
                                    _tcc_error(
                                        b"invalid digit\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                bn_lshift(bn.as_mut_ptr(), shift, t);
                                frac_bits += shift;
                                let fresh123 = p;
                                p = p.offset(1);
                                ch = *fresh123 as libc::c_int;
                            }
                        }
                        if ch != 'p' as i32 && ch != 'P' as i32 {
                            expect(b"exponent\0" as *const u8 as *const libc::c_char);
                        }
                        let fresh124 = p;
                        p = p.offset(1);
                        ch = *fresh124 as libc::c_int;
                        s = 1 as libc::c_int;
                        exp_val = 0 as libc::c_int;
                        if ch == '+' as i32 {
                            let fresh125 = p;
                            p = p.offset(1);
                            ch = *fresh125 as libc::c_int;
                        } else if ch == '-' as i32 {
                            s = -(1 as libc::c_int);
                            let fresh126 = p;
                            p = p.offset(1);
                            ch = *fresh126 as libc::c_int;
                        }
                        if ch < '0' as i32 || ch > '9' as i32 {
                            expect(
                                b"exponent digits\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        while ch >= '0' as i32 && ch <= '9' as i32 {
                            exp_val = exp_val * 10 as libc::c_int + ch - '0' as i32;
                            let fresh127 = p;
                            p = p.offset(1);
                            ch = *fresh127 as libc::c_int;
                        }
                        exp_val = exp_val * s;
                        d = bn[1 as libc::c_int as usize] as libc::c_double
                            * 4294967296.0f64
                            + bn[0 as libc::c_int as usize] as libc::c_double;
                        d = ldexp(d, exp_val - frac_bits);
                        t = toup(ch);
                        if t == 'F' as i32 {
                            let fresh128 = p;
                            p = p.offset(1);
                            ch = *fresh128 as libc::c_int;
                            tok = 0xca as libc::c_int;
                            tokc.f = d as libc::c_float;
                        } else if t == 'L' as i32 {
                            let fresh129 = p;
                            p = p.offset(1);
                            ch = *fresh129 as libc::c_int;
                            tok = 0xcc as libc::c_int;
                            tokc.ld = f128::f128::new(d);
                        } else {
                            tok = 0xcb as libc::c_int;
                            tokc.d = d;
                        }
                        current_block = 15908231092227701503;
                    } else if ch == '.' as i32 {
                        if q
                            >= token_buf
                                .as_mut_ptr()
                                .offset(1024 as libc::c_int as isize)
                        {
                            current_block = 4729119564522990522;
                        } else {
                            let fresh130 = q;
                            q = q.offset(1);
                            *fresh130 = ch as libc::c_char;
                            let fresh131 = p;
                            p = p.offset(1);
                            ch = *fresh131 as libc::c_int;
                            current_block = 16791665189521845338;
                        }
                    } else {
                        current_block = 5023038348526654800;
                    }
                } else {
                    let mut n: libc::c_ulonglong = 0;
                    let mut n1: libc::c_ulonglong = 0;
                    let mut lcount: libc::c_int = 0;
                    let mut ucount: libc::c_int = 0;
                    let mut ov: libc::c_int = 0 as libc::c_int;
                    let mut p1: *const libc::c_char = 0 as *const libc::c_char;
                    *q = '\0' as i32 as libc::c_char;
                    q = token_buf.as_mut_ptr();
                    if b == 10 as libc::c_int && *q as libc::c_int == '0' as i32 {
                        b = 8 as libc::c_int;
                        q = q.offset(1);
                        q;
                    }
                    n = 0 as libc::c_int as libc::c_ulonglong;
                    loop {
                        let fresh142 = q;
                        q = q.offset(1);
                        t = *fresh142 as libc::c_int;
                        if t == '\0' as i32 {
                            break;
                        }
                        if t >= 'a' as i32 {
                            t = t - 'a' as i32 + 10 as libc::c_int;
                        } else if t >= 'A' as i32 {
                            t = t - 'A' as i32 + 10 as libc::c_int;
                        } else {
                            t = t - '0' as i32;
                        }
                        if t >= b {
                            _tcc_error(
                                b"invalid digit\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        n1 = n;
                        n = n
                            .wrapping_mul(b as libc::c_ulonglong)
                            .wrapping_add(t as libc::c_ulonglong);
                        if n1 >= 0x1000000000000000 as libc::c_ulonglong
                            && n.wrapping_div(b as libc::c_ulonglong) != n1
                        {
                            ov = 1 as libc::c_int;
                        }
                    }
                    ucount = 0 as libc::c_int;
                    lcount = ucount;
                    p1 = p;
                    loop {
                        t = toup(ch);
                        if t == 'L' as i32 {
                            if lcount >= 2 as libc::c_int {
                                _tcc_error(
                                    b"three 'l's in integer constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            if lcount != 0
                                && *p.offset(-(1 as libc::c_int as isize)) as libc::c_int
                                    != ch
                            {
                                _tcc_error(
                                    b"incorrect integer suffix: %s\0" as *const u8
                                        as *const libc::c_char,
                                    p1,
                                );
                            }
                            lcount += 1;
                            lcount;
                            let fresh143 = p;
                            p = p.offset(1);
                            ch = *fresh143 as libc::c_int;
                        } else {
                            if !(t == 'U' as i32) {
                                break;
                            }
                            if ucount >= 1 as libc::c_int {
                                _tcc_error(
                                    b"two 'u's in integer constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            ucount += 1;
                            ucount;
                            let fresh144 = p;
                            p = p.offset(1);
                            ch = *fresh144 as libc::c_int;
                        }
                    }
                    if pp_expr != 0 {
                        lcount = 2 as libc::c_int;
                    }
                    if ucount == 0 as libc::c_int && b == 10 as libc::c_int {
                        if lcount
                            <= (8 as libc::c_int == 4 as libc::c_int) as libc::c_int
                        {
                            if n >= 0x80000000 as libc::c_uint as libc::c_ulonglong {
                                lcount = (8 as libc::c_int == 4 as libc::c_int)
                                    as libc::c_int + 1 as libc::c_int;
                            }
                        }
                        if n >= 0x8000000000000000 as libc::c_ulonglong {
                            ov = 1 as libc::c_int;
                            ucount = 1 as libc::c_int;
                        }
                    } else {
                        if lcount
                            <= (8 as libc::c_int == 4 as libc::c_int) as libc::c_int
                        {
                            if n >= 0x100000000 as libc::c_ulonglong {
                                lcount = (8 as libc::c_int == 4 as libc::c_int)
                                    as libc::c_int + 1 as libc::c_int;
                            } else if n
                                >= 0x80000000 as libc::c_uint as libc::c_ulonglong
                            {
                                ucount = 1 as libc::c_int;
                            }
                        }
                        if n >= 0x8000000000000000 as libc::c_ulonglong {
                            ucount = 1 as libc::c_int;
                        }
                    }
                    if ov != 0 {
                        _tcc_warning(
                            b"integer constant overflow\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    tok = 0xc2 as libc::c_int;
                    if lcount != 0 {
                        tok = 0xc6 as libc::c_int;
                        if lcount == 2 as libc::c_int {
                            tok = 0xc4 as libc::c_int;
                        }
                    }
                    if ucount != 0 {
                        tok += 1;
                        tok;
                    }
                    tokc.i = n as uint64_t;
                    current_block = 15908231092227701503;
                }
            }
        }
    }
    's_446: loop {
        match current_block {
            4729119564522990522 => {
                _tcc_error(b"number too long\0" as *const u8 as *const libc::c_char);
            }
            16791665189521845338 => {
                if !(ch >= '0' as i32 && ch <= '9' as i32) {
                    current_block = 5023038348526654800;
                    continue;
                }
                if q >= token_buf.as_mut_ptr().offset(1024 as libc::c_int as isize) {
                    current_block = 4729119564522990522;
                    continue;
                }
                let fresh132 = q;
                q = q.offset(1);
                *fresh132 = ch as libc::c_char;
                let fresh133 = p;
                p = p.offset(1);
                ch = *fresh133 as libc::c_int;
                current_block = 16791665189521845338;
            }
            15908231092227701503 => {
                if ch != 0 {
                    _tcc_error(b"invalid number\0" as *const u8 as *const libc::c_char);
                }
                break;
            }
            _ => {
                if ch == 'e' as i32 || ch == 'E' as i32 {
                    if q >= token_buf.as_mut_ptr().offset(1024 as libc::c_int as isize) {
                        current_block = 4729119564522990522;
                        continue;
                    }
                    let fresh134 = q;
                    q = q.offset(1);
                    *fresh134 = ch as libc::c_char;
                    let fresh135 = p;
                    p = p.offset(1);
                    ch = *fresh135 as libc::c_int;
                    if ch == '-' as i32 || ch == '+' as i32 {
                        if q
                            >= token_buf
                                .as_mut_ptr()
                                .offset(1024 as libc::c_int as isize)
                        {
                            current_block = 4729119564522990522;
                            continue;
                        }
                        let fresh136 = q;
                        q = q.offset(1);
                        *fresh136 = ch as libc::c_char;
                        let fresh137 = p;
                        p = p.offset(1);
                        ch = *fresh137 as libc::c_int;
                    }
                    if ch < '0' as i32 || ch > '9' as i32 {
                        expect(b"exponent digits\0" as *const u8 as *const libc::c_char);
                    }
                    while ch >= '0' as i32 && ch <= '9' as i32 {
                        if q
                            >= token_buf
                                .as_mut_ptr()
                                .offset(1024 as libc::c_int as isize)
                        {
                            current_block = 4729119564522990522;
                            continue 's_446;
                        }
                        let fresh138 = q;
                        q = q.offset(1);
                        *fresh138 = ch as libc::c_char;
                        let fresh139 = p;
                        p = p.offset(1);
                        ch = *fresh139 as libc::c_int;
                    }
                }
                *q = '\0' as i32 as libc::c_char;
                t = toup(ch);
                *__errno_location() = 0 as libc::c_int;
                if t == 'F' as i32 {
                    let fresh140 = p;
                    p = p.offset(1);
                    ch = *fresh140 as libc::c_int;
                    tok = 0xca as libc::c_int;
                    tokc.f = strtof(token_buf.as_mut_ptr(), 0 as *mut *mut libc::c_char);
                } else if t == 'L' as i32 {
                    let fresh141 = p;
                    p = p.offset(1);
                    ch = *fresh141 as libc::c_int;
                    tok = 0xcc as libc::c_int;
                    tokc
                        .ld = strtold(
                        token_buf.as_mut_ptr(),
                        0 as *mut *mut libc::c_char,
                    );
                } else {
                    tok = 0xcb as libc::c_int;
                    tokc.d = strtod(token_buf.as_mut_ptr(), 0 as *mut *mut libc::c_char);
                }
                current_block = 15908231092227701503;
            }
        }
    };
}
unsafe extern "C" fn next_nomacro() {
    let mut current_block: u64;
    let mut t: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut is_long: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut ts: *mut TokenSym = 0 as *mut TokenSym;
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut p1: *mut uint8_t = 0 as *mut uint8_t;
    let mut h: libc::c_uint = 0;
    p = (*file).buf_ptr;
    loop {
        c = *p as libc::c_int;
        match c {
            32 | 9 => {
                tok = c;
                p = p.offset(1);
                p;
                current_block = 14208940611008299668;
            }
            12 | 11 | 13 => {
                p = p.offset(1);
                p;
                continue;
            }
            92 => {
                c = handle_stray(&mut p);
                if c == '\\' as i32 {
                    current_block = 16093331138581289701;
                    break;
                }
                if !(c == -(1 as libc::c_int)) {
                    continue;
                }
                let mut s1: *mut TCCState = tcc_state;
                if tok_flags & 0x1 as libc::c_int == 0 {
                    current_block = 17169066879710716812;
                } else {
                    if parse_flags & 0x1 as libc::c_int == 0 {
                        tok = -(1 as libc::c_int);
                        current_block = 16832022279197466268;
                        break;
                    } else if (*s1).ifdef_stack_ptr != (*file).ifdef_stack_ptr {
                        _tcc_error(
                            b"missing #endif\0" as *const u8 as *const libc::c_char,
                        );
                    } else if (*s1).include_stack_ptr
                        == ((*s1).include_stack).as_mut_ptr()
                    {
                        tok = -(1 as libc::c_int);
                        current_block = 16832022279197466268;
                        break;
                    } else {
                        if tok_flags & 0x4 as libc::c_int != 0 {
                            (*search_cached_include(
                                s1,
                                (*file).true_filename,
                                1 as libc::c_int,
                            ))
                                .ifndef_macro = (*file).ifndef_macro_saved;
                            tok_flags &= !(0x4 as libc::c_int);
                        }
                        tcc_debug_eincl(tcc_state);
                        tcc_close();
                        (*s1).include_stack_ptr = ((*s1).include_stack_ptr).offset(-1);
                        (*s1).include_stack_ptr;
                        p = (*file).buf_ptr;
                    }
                    current_block = 17169066879710716812;
                }
            }
            10 => {
                (*file).line_num += 1;
                (*file).line_num;
                p = p.offset(1);
                p;
                current_block = 17169066879710716812;
            }
            35 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if tok_flags & 0x1 as libc::c_int != 0
                    && parse_flags & 0x1 as libc::c_int != 0
                {
                    tok_flags &= !(0x1 as libc::c_int);
                    (*file).buf_ptr = p;
                    preprocess(tok_flags & 0x2 as libc::c_int);
                    p = (*file).buf_ptr;
                } else if c == '#' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xa3 as libc::c_int;
                    current_block = 16832022279197466268;
                    break;
                } else if parse_flags & 0x8 as libc::c_int != 0 {
                    p = parse_line_comment(p.offset(-(1 as libc::c_int as isize)));
                    continue;
                } else {
                    tok = '#' as i32;
                    current_block = 16832022279197466268;
                    break;
                }
                current_block = 17169066879710716812;
            }
            36 => {
                if isidnum_table[('$' as i32 - -(1 as libc::c_int)) as usize]
                    as libc::c_int & 2 as libc::c_int == 0
                    || parse_flags & 0x8 as libc::c_int != 0
                {
                    current_block = 16093331138581289701;
                    break;
                } else {
                    current_block = 6314069199431010941;
                    break;
                }
            }
            97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109
            | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122
            | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 77 | 78 | 79 | 80
            | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 95 => {
                current_block = 6314069199431010941;
                break;
            }
            76 => {
                t = *p.offset(1 as libc::c_int as isize) as libc::c_int;
                if t != '\\' as i32 && t != '\'' as i32 && t != '"' as i32 {
                    current_block = 6314069199431010941;
                    break;
                } else {
                    current_block = 7739940392431776979;
                    break;
                }
            }
            48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 => {
                t = c;
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                current_block = 11577436051762200818;
                break;
            }
            46 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if isnum(c) != 0 {
                    current_block = 15650704408606443395;
                    break;
                } else {
                    current_block = 18221534353613080499;
                    break;
                }
            }
            39 | 34 => {
                is_long = 0 as libc::c_int;
                current_block = 8041803011537668896;
                break;
            }
            60 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x9e as libc::c_int;
                } else if c == '<' as i32 {
                    p = p.offset(1);
                    c = *p as libc::c_int;
                    if c == '\\' as i32 {
                        c = handle_stray(&mut p);
                    }
                    if c == '=' as i32 {
                        p = p.offset(1);
                        p;
                        tok = 0xb8 as libc::c_int;
                    } else {
                        tok = '<' as i32;
                    }
                } else {
                    tok = 0x9c as libc::c_int;
                }
                current_block = 16832022279197466268;
                break;
            }
            62 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x9d as libc::c_int;
                } else if c == '>' as i32 {
                    p = p.offset(1);
                    c = *p as libc::c_int;
                    if c == '\\' as i32 {
                        c = handle_stray(&mut p);
                    }
                    if c == '=' as i32 {
                        p = p.offset(1);
                        p;
                        tok = 0xb9 as libc::c_int;
                    } else {
                        tok = '>' as i32;
                    }
                } else {
                    tok = 0x9f as libc::c_int;
                }
                current_block = 16832022279197466268;
                break;
            }
            38 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '&' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x90 as libc::c_int;
                } else if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb5 as libc::c_int;
                } else {
                    tok = '&' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            124 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '|' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x91 as libc::c_int;
                } else if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb6 as libc::c_int;
                } else {
                    tok = '|' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            43 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '+' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x82 as libc::c_int;
                } else if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb0 as libc::c_int;
                } else {
                    tok = '+' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            45 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '-' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x80 as libc::c_int;
                } else if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb1 as libc::c_int;
                } else if c == '>' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xa0 as libc::c_int;
                } else {
                    tok = '-' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            33 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x95 as libc::c_int;
                } else {
                    tok = '!' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            61 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0x94 as libc::c_int;
                } else {
                    tok = '=' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            42 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb2 as libc::c_int;
                } else {
                    tok = '*' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            37 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb4 as libc::c_int;
                } else {
                    tok = '%' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            94 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '=' as i32 {
                    p = p.offset(1);
                    p;
                    tok = 0xb7 as libc::c_int;
                } else {
                    tok = '^' as i32;
                }
                current_block = 16832022279197466268;
                break;
            }
            47 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '*' as i32 {
                    p = parse_comment(p);
                    tok = ' ' as i32;
                } else if c == '/' as i32 {
                    p = parse_line_comment(p);
                    tok = ' ' as i32;
                } else {
                    if c == '=' as i32 {
                        p = p.offset(1);
                        p;
                        tok = 0xb3 as libc::c_int;
                    } else {
                        tok = '/' as i32;
                    }
                    current_block = 16832022279197466268;
                    break;
                }
                current_block = 14208940611008299668;
            }
            64 | 40 | 41 | 91 | 93 | 123 | 125 | 44 | 59 | 58 | 63 | 126 => {
                current_block = 16093331138581289701;
                break;
            }
            _ => {
                if c >= 0x80 as libc::c_int && c <= 0xff as libc::c_int {
                    current_block = 6314069199431010941;
                    break;
                } else {
                    current_block = 11271090240167667812;
                    break;
                }
            }
        }
        match current_block {
            14208940611008299668 => {
                if parse_flags & 0x10 as libc::c_int != 0 {
                    current_block = 17907827097989281444;
                    break;
                }
                while isidnum_table[(*p as libc::c_int - -(1 as libc::c_int)) as usize]
                    as libc::c_int & 1 as libc::c_int != 0
                {
                    p = p.offset(1);
                    p;
                }
            }
            _ => {
                tok_flags |= 0x1 as libc::c_int;
                if 0 as libc::c_int == parse_flags & 0x4 as libc::c_int {
                    continue;
                }
                tok = 10 as libc::c_int;
                current_block = 17907827097989281444;
                break;
            }
        }
    }
    match current_block {
        18221534353613080499 => {
            if isidnum_table[('.' as i32 - -(1 as libc::c_int)) as usize] as libc::c_int
                & 2 as libc::c_int != 0
                && isidnum_table[(c - -(1 as libc::c_int)) as usize] as libc::c_int
                    & (2 as libc::c_int | 4 as libc::c_int) != 0
            {
                c = '.' as i32;
                p = p.offset(-1);
                *p = c as uint8_t;
                current_block = 6314069199431010941;
            } else {
                if c == '.' as i32 {
                    p = p.offset(1);
                    c = *p as libc::c_int;
                    if c == '\\' as i32 {
                        c = handle_stray(&mut p);
                    }
                    if c == '.' as i32 {
                        p = p.offset(1);
                        p;
                        tok = 0xa1 as libc::c_int;
                    } else {
                        p = p.offset(-1);
                        *p = '.' as i32 as uint8_t;
                        tok = '.' as i32;
                    }
                } else {
                    tok = '.' as i32;
                }
                current_block = 16832022279197466268;
            }
        }
        7739940392431776979 => {
            p = p.offset(1);
            c = *p as libc::c_int;
            if c == '\\' as i32 {
                c = handle_stray(&mut p);
            }
            if c == '\'' as i32 || c == '"' as i32 {
                is_long = 1 as libc::c_int;
                current_block = 8041803011537668896;
            } else {
                cstr_reset(&mut tokcstr);
                cstr_ccat(&mut tokcstr, 'L' as i32);
                current_block = 10593310789097482318;
            }
        }
        11271090240167667812 => {
            if parse_flags & 0x8 as libc::c_int != 0 {
                current_block = 16093331138581289701;
            } else {
                _tcc_error(
                    b"unrecognized character \\x%02x\0" as *const u8
                        as *const libc::c_char,
                    c,
                );
            }
        }
        15650704408606443395 => {
            t = '.' as i32;
            current_block = 11577436051762200818;
        }
        _ => {}
    }
    match current_block {
        8041803011537668896 => {
            cstr_reset(&mut tokcstr);
            if is_long != 0 {
                cstr_ccat(&mut tokcstr, 'L' as i32);
            }
            cstr_ccat(&mut tokcstr, c);
            p = parse_pp_string(p, c, &mut tokcstr);
            cstr_ccat(&mut tokcstr, c);
            cstr_ccat(&mut tokcstr, '\0' as i32);
            tokc.str_0.size = tokcstr.size;
            tokc.str_0.data = tokcstr.data;
            tok = 0xce as libc::c_int;
            current_block = 16832022279197466268;
        }
        11577436051762200818 => {
            cstr_reset(&mut tokcstr);
            loop {
                cstr_ccat(&mut tokcstr, t);
                if !(isidnum_table[(c - -(1 as libc::c_int)) as usize] as libc::c_int
                    & (2 as libc::c_int | 4 as libc::c_int) != 0 || c == '.' as i32
                    || (c == '+' as i32 || c == '-' as i32)
                        && ((t == 'e' as i32 || t == 'E' as i32)
                            && !(parse_flags & 0x8 as libc::c_int != 0
                                && *(tokcstr.data).offset(0 as libc::c_int as isize)
                                    as libc::c_int == '0' as i32
                                && toup(
                                    *(tokcstr.data).offset(1 as libc::c_int as isize)
                                        as libc::c_int,
                                ) == 'X' as i32) || t == 'p' as i32 || t == 'P' as i32))
                {
                    break;
                }
                t = c;
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
            }
            cstr_ccat(&mut tokcstr, '\0' as i32);
            tokc.str_0.size = tokcstr.size;
            tokc.str_0.data = tokcstr.data;
            tok = 0xcd as libc::c_int;
            current_block = 16832022279197466268;
        }
        16093331138581289701 => {
            tok = c;
            p = p.offset(1);
            p;
            current_block = 16832022279197466268;
        }
        6314069199431010941 => {
            p1 = p;
            h = 1 as libc::c_int as libc::c_uint;
            h = h
                .wrapping_add(h << 5 as libc::c_int)
                .wrapping_add(h >> 27 as libc::c_int)
                .wrapping_add(c as libc::c_uint);
            loop {
                p = p.offset(1);
                c = *p as libc::c_int;
                if !(isidnum_table[(c - -(1 as libc::c_int)) as usize] as libc::c_int
                    & (2 as libc::c_int | 4 as libc::c_int) != 0)
                {
                    break;
                }
                h = h
                    .wrapping_add(h << 5 as libc::c_int)
                    .wrapping_add(h >> 27 as libc::c_int)
                    .wrapping_add(c as libc::c_uint);
            }
            len = p.offset_from(p1) as libc::c_long as libc::c_int;
            if c != '\\' as i32 {
                let mut current_block_52: u64;
                let mut pts: *mut *mut TokenSym = 0 as *mut *mut TokenSym;
                h &= (16384 as libc::c_int - 1 as libc::c_int) as libc::c_uint;
                pts = &mut *hash_ident.as_mut_ptr().offset(h as isize)
                    as *mut *mut TokenSym;
                loop {
                    ts = *pts;
                    if ts.is_null() {
                        current_block_52 = 14329534724295951598;
                        break;
                    }
                    if (*ts).len == len
                        && memcmp(
                            ((*ts).str_0).as_mut_ptr() as *const libc::c_void,
                            p1 as *const libc::c_void,
                            len as libc::c_ulong,
                        ) == 0
                    {
                        current_block_52 = 8102658916883067714;
                        break;
                    }
                    pts = &mut (*ts).hash_next;
                }
                match current_block_52 {
                    14329534724295951598 => {
                        ts = tok_alloc_new(pts, p1 as *mut libc::c_char, len);
                    }
                    _ => {}
                }
                current_block = 15622658527355336244;
            } else {
                cstr_reset(&mut tokcstr);
                cstr_cat(&mut tokcstr, p1 as *mut libc::c_char, len);
                p = p.offset(-1);
                p;
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                current_block = 10593310789097482318;
            }
        }
        _ => {}
    }
    match current_block {
        10593310789097482318 => {
            while isidnum_table[(c - -(1 as libc::c_int)) as usize] as libc::c_int
                & (2 as libc::c_int | 4 as libc::c_int) != 0
            {
                cstr_ccat(&mut tokcstr, c);
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
            }
            ts = tok_alloc(tokcstr.data, tokcstr.size);
            current_block = 15622658527355336244;
        }
        _ => {}
    }
    match current_block {
        15622658527355336244 => {
            tok = (*ts).tok;
            current_block = 16832022279197466268;
        }
        _ => {}
    }
    match current_block {
        16832022279197466268 => {
            tok_flags = 0 as libc::c_int;
        }
        _ => {}
    }
    (*file).buf_ptr = p;
}
unsafe extern "C" fn macro_arg_subst(
    mut nested_list: *mut *mut Sym,
    mut macro_str: *const libc::c_int,
    mut args: *mut Sym,
) -> *mut libc::c_int {
    let mut t: libc::c_int = 0;
    let mut t0: libc::c_int = 0;
    let mut t1: libc::c_int = 0;
    let mut t2: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut st: *const libc::c_int = 0 as *const libc::c_int;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    let mut str: TokenString = TokenString {
        str_0: 0 as *const libc::c_int as *mut libc::c_int,
        len: 0,
        need_spc: 0,
        allocated_len: 0,
        last_line_num: 0,
        save_line_num: 0,
        prev: 0 as *const TokenString as *mut TokenString,
        prev_ptr: 0 as *const libc::c_int,
        alloc: 0,
    };
    tok_str_new(&mut str);
    t1 = 0 as libc::c_int;
    t0 = t1;
    loop {
        let mut _t: libc::c_int = *macro_str;
        if _t >= 0xc0 as libc::c_int && _t <= 0xcf as libc::c_int {
            tok_get(&mut t, &mut macro_str, &mut cval);
        } else {
            t = _t;
            macro_str = macro_str.offset(1);
            macro_str;
        }
        if t == 0 {
            break;
        }
        if t == '#' as i32 {
            loop {
                let fresh145 = macro_str;
                macro_str = macro_str.offset(1);
                t = *fresh145;
                if !(t == ' ' as i32) {
                    break;
                }
            }
            s = sym_find2(args, t);
            if !s.is_null() {
                cstr_reset(&mut tokcstr);
                cstr_ccat(&mut tokcstr, '"' as i32);
                st = (*s).c2rust_unnamed.d;
                while *st != -(1 as libc::c_int) {
                    let mut s_0: *const libc::c_char = 0 as *const libc::c_char;
                    let mut _t_0: libc::c_int = *st;
                    if _t_0 >= 0xc0 as libc::c_int && _t_0 <= 0xcf as libc::c_int {
                        tok_get(&mut t, &mut st, &mut cval);
                    } else {
                        t = _t_0;
                        st = st.offset(1);
                        st;
                    }
                    s_0 = get_tok_str(t, &mut cval);
                    while *s_0 != 0 {
                        if t == 0xce as libc::c_int && *s_0 as libc::c_int != '\'' as i32
                        {
                            add_char(&mut tokcstr, *s_0 as libc::c_int);
                        } else {
                            cstr_ccat(&mut tokcstr, *s_0 as libc::c_int);
                        }
                        s_0 = s_0.offset(1);
                        s_0;
                    }
                }
                cstr_ccat(&mut tokcstr, '"' as i32);
                cstr_ccat(&mut tokcstr, '\0' as i32);
                cval.str_0.size = tokcstr.size;
                cval.str_0.data = tokcstr.data;
                tok_str_add2(&mut str, 0xce as libc::c_int, &mut cval);
            } else {
                expect(
                    b"macro parameter after '#'\0" as *const u8 as *const libc::c_char,
                );
            }
        } else if t >= 256 as libc::c_int {
            s = sym_find2(args, t);
            if !s.is_null() {
                st = (*s).c2rust_unnamed.d;
                n = 0 as libc::c_int;
                loop {
                    t2 = *macro_str.offset(n as isize);
                    if !(t2 == ' ' as i32) {
                        break;
                    }
                    n += 1;
                    n;
                }
                let mut current_block_57: u64;
                if t2 == 0xa3 as libc::c_int | 0x20000000 as libc::c_int
                    || t1 == 0xa3 as libc::c_int | 0x20000000 as libc::c_int
                {
                    if t1 == 0xa3 as libc::c_int | 0x20000000 as libc::c_int
                        && t0 == ',' as i32 && (*tcc_state).gnu_ext as libc::c_int != 0
                        && (*s).type_0.t != 0
                    {
                        let mut c: libc::c_int = *(str.str_0)
                            .offset((str.len - 1 as libc::c_int) as isize);
                        loop {
                            str.len -= 1;
                            if !(*(str.str_0).offset(str.len as isize) != ',' as i32) {
                                break;
                            }
                        }
                        if *st == -(1 as libc::c_int) {
                            current_block_57 = 2520131295878969859;
                        } else {
                            str.len += 1;
                            str.len;
                            if c == ' ' as i32 {
                                let fresh146 = str.len;
                                str.len = str.len + 1;
                                *(str.str_0).offset(fresh146 as isize) = c;
                            }
                            current_block_57 = 9681136488564688445;
                        }
                    } else {
                        if *st == -(1 as libc::c_int) {
                            tok_str_add(&mut str, 0xa4 as libc::c_int);
                        }
                        current_block_57 = 2520131295878969859;
                    }
                } else {
                    current_block_57 = 9681136488564688445;
                }
                match current_block_57 {
                    9681136488564688445 => {
                        if ((*s).c2rust_unnamed_0.e).is_null() {
                            let mut str2: TokenString = TokenString {
                                str_0: 0 as *const libc::c_int as *mut libc::c_int,
                                len: 0,
                                need_spc: 0,
                                allocated_len: 0,
                                last_line_num: 0,
                                save_line_num: 0,
                                prev: 0 as *const TokenString as *mut TokenString,
                                prev_ptr: 0 as *const libc::c_int,
                                alloc: 0,
                            };
                            tok_str_new(&mut str2);
                            macro_subst(&mut str2, nested_list, st);
                            tok_str_add(&mut str2, -(1 as libc::c_int));
                            (*s).c2rust_unnamed_0.e = str2.str_0;
                        }
                        st = (*s).c2rust_unnamed_0.e;
                    }
                    _ => {}
                }
                while *st != -(1 as libc::c_int) {
                    let mut _t_1: libc::c_int = *st;
                    if _t_1 >= 0xc0 as libc::c_int && _t_1 <= 0xcf as libc::c_int {
                        tok_get(&mut t2, &mut st, &mut cval);
                    } else {
                        t2 = _t_1;
                        st = st.offset(1);
                        st;
                    }
                    tok_str_add2(&mut str, t2, &mut cval);
                }
            } else {
                tok_str_add(&mut str, t);
            }
        } else {
            tok_str_add2(&mut str, t, &mut cval);
        }
        if t != ' ' as i32 {
            t0 = t1;
            t1 = t;
        }
    }
    tok_str_add(&mut str, 0 as libc::c_int);
    return str.str_0;
}
#[inline]
unsafe extern "C" fn macro_twosharps(mut ptr0: *const libc::c_int) -> *mut libc::c_int {
    let mut t1: libc::c_int = 0;
    let mut t2: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut cv1: CValue = CValue { ld: f128::f128::ZERO };
    let mut cv2: CValue = CValue { ld: f128::f128::ZERO };
    let mut macro_str1: TokenString = TokenString {
        str_0: 0 as *const libc::c_int as *mut libc::c_int,
        len: 0,
        need_spc: 0,
        allocated_len: 0,
        last_line_num: 0,
        save_line_num: 0,
        prev: 0 as *const TokenString as *mut TokenString,
        prev_ptr: 0 as *const libc::c_int,
        alloc: 0,
    };
    let mut ptr: *const libc::c_int = 0 as *const libc::c_int;
    tok_str_new(&mut macro_str1);
    cstr_reset(&mut tokcstr);
    ptr = ptr0;
    loop {
        let mut _t: libc::c_int = *ptr;
        if _t >= 0xc0 as libc::c_int && _t <= 0xcf as libc::c_int {
            tok_get(&mut t1, &mut ptr, &mut cv1);
        } else {
            t1 = _t;
            ptr = ptr.offset(1);
            ptr;
        }
        if t1 == 0 as libc::c_int {
            break;
        }
        loop {
            n = 0 as libc::c_int;
            loop {
                t2 = *ptr.offset(n as isize);
                if !(t2 == ' ' as i32) {
                    break;
                }
                n += 1;
                n;
            }
            if t2 != 0xa3 as libc::c_int | 0x20000000 as libc::c_int {
                break;
            }
            ptr = ptr.offset(n as isize);
            loop {
                ptr = ptr.offset(1);
                t2 = *ptr;
                if !(t2 == ' ' as i32
                    || t2 == 0xa3 as libc::c_int | 0x20000000 as libc::c_int)
                {
                    break;
                }
            }
            let mut _t_0: libc::c_int = *ptr;
            if _t_0 >= 0xc0 as libc::c_int && _t_0 <= 0xcf as libc::c_int {
                tok_get(&mut t2, &mut ptr, &mut cv2);
            } else {
                t2 = _t_0;
                ptr = ptr.offset(1);
                ptr;
            }
            if t2 == 0xa4 as libc::c_int {
                continue;
            }
            if t1 != 0xa4 as libc::c_int {
                cstr_cat(&mut tokcstr, get_tok_str(t1, &mut cv1), -(1 as libc::c_int));
                t1 = 0xa4 as libc::c_int;
            }
            cstr_cat(&mut tokcstr, get_tok_str(t2, &mut cv2), -(1 as libc::c_int));
        }
        if tokcstr.size != 0 {
            cstr_ccat(&mut tokcstr, 0 as libc::c_int);
            tcc_open_bf(
                tcc_state,
                b":paste:\0" as *const u8 as *const libc::c_char,
                tokcstr.size,
            );
            memcpy(
                ((*file).buffer).as_mut_ptr() as *mut libc::c_void,
                tokcstr.data as *const libc::c_void,
                tokcstr.size as libc::c_ulong,
            );
            tok_flags = 0 as libc::c_int;
            n = 0 as libc::c_int;
            loop {
                next_nomacro();
                tok_str_add2(&mut macro_str1, tok, &mut tokc);
                if *(*file).buf_ptr as libc::c_int == 0 as libc::c_int {
                    break;
                }
                tok_str_add(&mut macro_str1, ' ' as i32);
                l = ((*file).buf_ptr).offset_from(((*file).buffer).as_mut_ptr())
                    as libc::c_long as libc::c_int;
                _tcc_warning(
                    b"pasting \"%.*s\" and \"%s\" does not give a valid preprocessing token\0"
                        as *const u8 as *const libc::c_char,
                    l - n,
                    ((*file).buffer).as_mut_ptr().offset(n as isize),
                    (*file).buf_ptr,
                );
                n = l;
            }
            tcc_close();
            cstr_reset(&mut tokcstr);
        }
        if t1 != 0xa4 as libc::c_int {
            tok_str_add2(&mut macro_str1, t1, &mut cv1);
        }
    }
    tok_str_add(&mut macro_str1, 0 as libc::c_int);
    return macro_str1.str_0;
}
unsafe extern "C" fn peek_file(mut ws_str: *mut TokenString) -> libc::c_int {
    let mut p: *mut uint8_t = ((*file).buf_ptr).offset(-(1 as libc::c_int as isize));
    let mut c: libc::c_int = 0;
    let mut current_block_18: u64;
    loop {
        p = p.offset(1);
        c = *p as libc::c_int;
        if c == '\\' as i32 {
            c = handle_stray(&mut p);
        }
        match c {
            47 => {
                p = p.offset(1);
                c = *p as libc::c_int;
                if c == '\\' as i32 {
                    c = handle_stray(&mut p);
                }
                if c == '*' as i32 {
                    p = parse_comment(p);
                    current_block_18 = 12349973810996921269;
                } else if c == '/' as i32 {
                    p = parse_line_comment(p);
                    current_block_18 = 12349973810996921269;
                } else {
                    p = p.offset(-1);
                    *p = '/' as i32 as uint8_t;
                    c = *p as libc::c_int;
                    current_block_18 = 10527770572382849953;
                }
                match current_block_18 {
                    10527770572382849953 => {}
                    _ => {
                        p = p.offset(-1);
                        p;
                        c = ' ' as i32;
                        current_block_18 = 224731115979188411;
                    }
                }
            }
            32 | 9 => {
                current_block_18 = 224731115979188411;
            }
            12 | 11 | 13 => {
                continue;
            }
            10 => {
                (*file).line_num += 1;
                (*file).line_num;
                tok_flags |= 0x1 as libc::c_int;
                current_block_18 = 224731115979188411;
            }
            _ => {
                current_block_18 = 10527770572382849953;
            }
        }
        match current_block_18 {
            224731115979188411 => {
                if !ws_str.is_null() {
                    tok_str_add(ws_str, c);
                }
            }
            _ => {
                (*file).buf_ptr = p;
                return c;
            }
        }
    };
}
unsafe extern "C" fn next_argstream(
    mut nested_list: *mut *mut Sym,
    mut ws_str: *mut TokenString,
) -> libc::c_int {
    let mut t: libc::c_int = 0;
    let mut sa: *mut Sym = 0 as *mut Sym;
    while !macro_ptr.is_null() {
        let mut m: *const libc::c_int = macro_ptr;
        loop {
            t = *m;
            if !(t != 0 as libc::c_int) {
                break;
            }
            if !ws_str.is_null() {
                if t != ' ' as i32 {
                    return t;
                }
                m = m.offset(1);
                m;
            } else {
                let mut _t: libc::c_int = *macro_ptr;
                if _t >= 0xc0 as libc::c_int && _t <= 0xcf as libc::c_int {
                    tok_get(&mut tok, &mut macro_ptr, &mut tokc);
                } else {
                    tok = _t;
                    macro_ptr = macro_ptr.offset(1);
                    macro_ptr;
                }
                return tok;
            }
        }
        end_macro();
        sa = *nested_list;
        if !sa.is_null() {
            *nested_list = (*sa).prev;
            sym_free(sa);
        }
    }
    if !ws_str.is_null() {
        return peek_file(ws_str)
    } else {
        next_nomacro();
        if tok == '\t' as i32 || tok == 10 as libc::c_int {
            tok = ' ' as i32;
        }
        return tok;
    };
}
unsafe extern "C" fn macro_subst_tok(
    mut tok_str: *mut TokenString,
    mut nested_list: *mut *mut Sym,
    mut s: *mut Sym,
) -> libc::c_int {
    let mut t: libc::c_int = 0;
    let mut v: libc::c_int = (*s).v;
    if !((*s).c2rust_unnamed.d).is_null() {
        let mut mstr: *mut libc::c_int = (*s).c2rust_unnamed.d;
        let mut jstr: *mut libc::c_int = 0 as *mut libc::c_int;
        let mut sa: *mut Sym = 0 as *mut Sym;
        let mut ret: libc::c_int = 0;
        if (*s).type_0.t & 1 as libc::c_int != 0 {
            let mut saved_parse_flags: libc::c_int = parse_flags;
            let mut str: TokenString = TokenString {
                str_0: 0 as *const libc::c_int as *mut libc::c_int,
                len: 0,
                need_spc: 0,
                allocated_len: 0,
                last_line_num: 0,
                save_line_num: 0,
                prev: 0 as *const TokenString as *mut TokenString,
                prev_ptr: 0 as *const libc::c_int,
                alloc: 0,
            };
            let mut parlevel: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            let mut sa1: *mut Sym = 0 as *mut Sym;
            let mut args: *mut Sym = 0 as *mut Sym;
            parse_flags
                |= 0x10 as libc::c_int | 0x4 as libc::c_int | 0x20 as libc::c_int;
            tok_str_new(&mut str);
            t = next_argstream(nested_list, &mut str);
            if t != '(' as i32 {
                parse_flags = saved_parse_flags;
                tok_str_add2_spc(tok_str, v, 0 as *mut CValue);
                if parse_flags & 0x10 as libc::c_int != 0 {
                    i = 0 as libc::c_int;
                    while i < str.len {
                        tok_str_add(tok_str, *(str.str_0).offset(i as isize));
                        i += 1;
                        i;
                    }
                }
                tok_str_free_str(str.str_0);
                return 0 as libc::c_int;
            } else {
                tok_str_free_str(str.str_0);
            }
            args = 0 as *mut Sym;
            sa = (*s).c2rust_unnamed_0.next;
            i = 2 as libc::c_int;
            's_100: loop {
                loop {
                    t = next_argstream(nested_list, 0 as *mut TokenString);
                    if !(t == ' ' as i32
                        || {
                            i -= 1;
                            i != 0
                        })
                    {
                        break;
                    }
                }
                if sa.is_null() {
                    if t == ')' as i32 {
                        break;
                    }
                    _tcc_error(
                        b"macro '%s' used with too many args\0" as *const u8
                            as *const libc::c_char,
                        get_tok_str(v, 0 as *mut CValue),
                    );
                } else {
                    loop {
                        tok_str_new(&mut str);
                        parlevel = 0 as libc::c_int;
                        while parlevel > 0 as libc::c_int
                            || t != ')' as i32
                                && (t != ',' as i32 || (*sa).type_0.t != 0)
                        {
                            if t == -(1 as libc::c_int) {
                                _tcc_error(
                                    b"EOF in invocation of macro '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            }
                            if t == '(' as i32 {
                                parlevel += 1;
                                parlevel;
                            }
                            if t == ')' as i32 {
                                parlevel -= 1;
                                parlevel;
                            }
                            if t == ' ' as i32 {
                                str.need_spc |= 1 as libc::c_int;
                            } else {
                                tok_str_add2_spc(&mut str, t, &mut tokc);
                            }
                            t = next_argstream(nested_list, 0 as *mut TokenString);
                        }
                        tok_str_add(&mut str, -(1 as libc::c_int));
                        sa1 = sym_push2(
                            &mut args,
                            (*sa).v & !(0x20000000 as libc::c_int),
                            (*sa).type_0.t,
                            0 as libc::c_int,
                        );
                        (*sa1).c2rust_unnamed.d = str.str_0;
                        sa = (*sa).c2rust_unnamed_0.next;
                        if t == ')' as i32 {
                            if sa.is_null() {
                                break 's_100;
                            }
                            if (*sa).type_0.t != 0
                                && (*tcc_state).gnu_ext as libc::c_int != 0
                            {
                                continue;
                            }
                            _tcc_error(
                                b"macro '%s' used with too few args\0" as *const u8
                                    as *const libc::c_char,
                                get_tok_str(v, 0 as *mut CValue),
                            );
                        } else {
                            i = 1 as libc::c_int;
                            break;
                        }
                    }
                }
            }
            mstr = macro_arg_subst(nested_list, mstr, args);
            sa = args;
            while !sa.is_null() {
                sa1 = (*sa).prev;
                tok_str_free_str((*sa).c2rust_unnamed.d);
                tok_str_free_str((*sa).c2rust_unnamed_0.e);
                sym_free(sa);
                sa = sa1;
            }
            parse_flags = saved_parse_flags;
        }
        jstr = mstr;
        if (*s).type_0.t & 2 as libc::c_int != 0 {
            jstr = macro_twosharps(mstr);
        }
        sa = sym_push2(nested_list, v, 0 as libc::c_int, 0 as libc::c_int);
        ret = macro_subst(tok_str, nested_list, jstr);
        if sa == *nested_list {
            *nested_list = (*sa).prev;
            sym_free(sa);
        }
        if jstr != mstr {
            tok_str_free_str(jstr);
        }
        if mstr != (*s).c2rust_unnamed.d {
            tok_str_free_str(mstr);
        }
        return ret;
    } else {
        let mut cval: CValue = CValue { ld: f128::f128::ZERO };
        let mut buf: [libc::c_char; 32] = [0; 32];
        let mut cstrval: *mut libc::c_char = buf.as_mut_ptr();
        let mut ti: time_t = 0;
        let mut tm: *mut tm = 0 as *mut tm;
        let mut current_block_83: u64;
        if v == TOK___LINE__ as libc::c_int || v == TOK___COUNTER__ as libc::c_int {
            t = if v == TOK___LINE__ as libc::c_int {
                (*file).line_num
            } else {
                let fresh147 = pp_counter;
                pp_counter = pp_counter + 1;
                fresh147
            };
            snprintf(
                buf.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                b"%d\0" as *const u8 as *const libc::c_char,
                t,
            );
            t = 0xcd as libc::c_int;
            current_block_83 = 13443717535703310074;
        } else {
            if v == TOK___FILE__ as libc::c_int {
                cstrval = ((*file).filename).as_mut_ptr();
                current_block_83 = 5583506874842280204;
            } else if v == TOK___DATE__ as libc::c_int
                || v == TOK___TIME__ as libc::c_int
            {
                ti = 0;
                tm = 0 as *mut tm;
                time(&mut ti);
                tm = localtime(&mut ti);
                if v == TOK___DATE__ as libc::c_int {
                    static mut ab_month_name: [[libc::c_char; 4]; 12] = unsafe {
                        [
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Jan\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Feb\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Mar\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Apr\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"May\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Jun\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Jul\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Aug\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Sep\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Oct\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Nov\0"),
                            *::core::mem::transmute::<
                                &[u8; 4],
                                &[libc::c_char; 4],
                            >(b"Dec\0"),
                        ]
                    };
                    snprintf(
                        buf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                        b"%s %2d %d\0" as *const u8 as *const libc::c_char,
                        (ab_month_name[(*tm).tm_mon as usize]).as_ptr(),
                        (*tm).tm_mday,
                        (*tm).tm_year + 1900 as libc::c_int,
                    );
                } else {
                    snprintf(
                        buf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 32]>() as libc::c_ulong,
                        b"%02d:%02d:%02d\0" as *const u8 as *const libc::c_char,
                        (*tm).tm_hour,
                        (*tm).tm_min,
                        (*tm).tm_sec,
                    );
                }
                current_block_83 = 5583506874842280204;
            } else {
                current_block_83 = 479107131381816815;
            }
            match current_block_83 {
                479107131381816815 => {}
                _ => {
                    t = 0xc8 as libc::c_int;
                    current_block_83 = 13443717535703310074;
                }
            }
        }
        match current_block_83 {
            13443717535703310074 => {
                cval
                    .str_0
                    .size = (strlen(cstrval))
                    .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
                cval.str_0.data = cstrval;
                tok_str_add2_spc(tok_str, t, &mut cval);
            }
            _ => {}
        }
        return 0 as libc::c_int;
    };
}
unsafe extern "C" fn macro_subst(
    mut tok_str: *mut TokenString,
    mut nested_list: *mut *mut Sym,
    mut macro_str: *const libc::c_int,
) -> libc::c_int {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut t: libc::c_int = 0;
    let mut nosubst: libc::c_int = 0 as libc::c_int;
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    let mut str: *mut TokenString = 0 as *mut TokenString;
    loop {
        let mut _t: libc::c_int = *macro_str;
        if _t >= 0xc0 as libc::c_int && _t <= 0xcf as libc::c_int {
            tok_get(&mut t, &mut macro_str, &mut cval);
        } else {
            t = _t;
            macro_str = macro_str.offset(1);
            macro_str;
        }
        if t == 0 as libc::c_int || t == -(1 as libc::c_int) {
            break;
        }
        if t >= 256 as libc::c_int {
            s = define_find(t);
            if !(s.is_null() || nosubst != 0) {
                if !(sym_find2(*nested_list, t)).is_null() {
                    t |= 0x20000000 as libc::c_int;
                } else {
                    str = tok_str_alloc();
                    (*str).str_0 = macro_str as *mut libc::c_int;
                    begin_macro(str, 2 as libc::c_int);
                    nosubst = macro_subst_tok(tok_str, nested_list, s);
                    if macro_stack != str {
                        break;
                    }
                    macro_str = macro_ptr;
                    end_macro();
                    continue;
                }
            }
        } else if t == ' ' as i32 {
            if parse_flags & 0x10 as libc::c_int != 0 {
                (*tok_str).need_spc |= 1 as libc::c_int;
            }
            continue;
        }
        tok_str_add2_spc(tok_str, t, &mut cval);
        if nosubst != 0 && t != '(' as i32 {
            nosubst = 0 as libc::c_int;
        }
        if t == TOK_DEFINED as libc::c_int && pp_expr != 0 {
            nosubst = 1 as libc::c_int;
        }
    }
    return nosubst;
}
unsafe extern "C" fn next() {
    let mut t: libc::c_int = 0;
    's_3: loop {
        if macro_ptr.is_null() {
            next_nomacro();
            t = tok;
            if !(t >= 256 as libc::c_int && parse_flags & 0x1 as libc::c_int != 0) {
                break;
            }
            let mut s: *mut Sym = define_find(t);
            if !s.is_null() {
                let mut nested_list: *mut Sym = 0 as *mut Sym;
                macro_subst_tok(&mut tokstr_buf, &mut nested_list, s);
                tok_str_add(&mut tokstr_buf, 0 as libc::c_int);
                begin_macro(&mut tokstr_buf, 0 as libc::c_int);
            } else {
                return
            }
        }
        loop {
            t = *macro_ptr;
            if !(t >= 0xc0 as libc::c_int && t <= 0xcf as libc::c_int) {
                break;
            }
            tok_get(&mut tok, &mut macro_ptr, &mut tokc);
            if !(t == 0xcf as libc::c_int) {
                break 's_3;
            }
            (*file).line_num = tokc.i as libc::c_int;
        }
        if t == 0 as libc::c_int {
            end_macro();
        } else {
            if !(t == -(1 as libc::c_int)) {
                macro_ptr = macro_ptr.offset(1);
                macro_ptr;
                t &= !(0x20000000 as libc::c_int);
                if t == '\\' as i32 {
                    if parse_flags & 0x20 as libc::c_int == 0 {
                        _tcc_error(
                            b"stray '\\' in program\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
            }
            tok = t;
            return;
        }
    }
    if t == 0xcd as libc::c_int {
        if parse_flags & 0x2 as libc::c_int != 0 {
            parse_number(tokc.str_0.data);
        }
    } else if t == 0xce as libc::c_int {
        if parse_flags & 0x40 as libc::c_int != 0 {
            parse_string(tokc.str_0.data, tokc.str_0.size - 1 as libc::c_int);
        }
    }
}
#[inline]
unsafe extern "C" fn unget_tok(mut last_tok: libc::c_int) {
    let mut str: *mut TokenString = &mut unget_buf;
    let mut alloc: libc::c_int = 0 as libc::c_int;
    if (*str).len != 0 {
        str = tok_str_alloc();
        alloc = 1 as libc::c_int;
    }
    if tok != -(1 as libc::c_int) {
        tok_str_add2(str, tok, &mut tokc);
    }
    tok_str_add(str, 0 as libc::c_int);
    begin_macro(str, alloc);
    tok = last_tok;
}
static mut target_os_defs: *const libc::c_char = b"__linux__\0__linux\0__unix__\0__unix\0\0"
    as *const u8 as *const libc::c_char;
unsafe extern "C" fn putdef(mut cs: *mut CString, mut p: *const libc::c_char) {
    cstr_printf(
        cs,
        b"#define %s%s\n\0" as *const u8 as *const libc::c_char,
        p,
        &*(b" 1\0" as *const u8 as *const libc::c_char)
            .offset(
                (!((strchr
                    as unsafe extern "C" fn(
                        *const libc::c_char,
                        libc::c_int,
                    ) -> *mut libc::c_char)(p, ' ' as i32))
                    .is_null() as libc::c_int * 2 as libc::c_int) as isize,
            ) as *const libc::c_char,
    );
}
unsafe extern "C" fn putdefs(mut cs: *mut CString, mut p: *const libc::c_char) {
    while *p != 0 {
        putdef(cs, p);
        p = (strchr(p, 0 as libc::c_int)).offset(1 as libc::c_int as isize);
    }
}
unsafe extern "C" fn tcc_predefs(
    mut s1: *mut TCCState,
    mut cs: *mut CString,
    mut is_asm: libc::c_int,
) {
    cstr_printf(
        cs,
        b"#define __TINYC__ 9%.2s\n\0" as *const u8 as *const libc::c_char,
        (*::core::mem::transmute::<&[u8; 9], &[libc::c_char; 9]>(b"0.9.28rc\0"))
            .as_ptr()
            .offset(4 as libc::c_int as isize),
    );
    putdefs(cs, target_machine_defs);
    putdefs(cs, target_os_defs);
    if is_asm != 0 {
        putdef(cs, b"__ASSEMBLER__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).output_type == 5 as libc::c_int {
        putdef(cs, b"__TCC_PP__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).output_type == 1 as libc::c_int {
        putdef(cs, b"__TCC_RUN__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).do_backtrace != 0 {
        putdef(cs, b"__TCC_BACKTRACE__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).do_bounds_check != 0 {
        putdef(cs, b"__TCC_BCHECK__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).char_is_unsigned != 0 {
        putdef(cs, b"__CHAR_UNSIGNED__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).optimize as libc::c_int > 0 as libc::c_int {
        putdef(cs, b"__OPTIMIZE__\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).option_pthread != 0 {
        putdef(cs, b"_REENTRANT\0" as *const u8 as *const libc::c_char);
    }
    if (*s1).leading_underscore != 0 {
        putdef(cs, b"__leading_underscore\0" as *const u8 as *const libc::c_char);
    }
    cstr_printf(
        cs,
        b"#define __SIZEOF_POINTER__ %d\n\0" as *const u8 as *const libc::c_char,
        8 as libc::c_int,
    );
    cstr_printf(
        cs,
        b"#define __SIZEOF_LONG__ %d\n\0" as *const u8 as *const libc::c_char,
        8 as libc::c_int,
    );
    if is_asm == 0 {
        putdef(cs, b"__STDC__\0" as *const u8 as *const libc::c_char);
        cstr_printf(
            cs,
            b"#define __STDC_VERSION__ %dL\n\0" as *const u8 as *const libc::c_char,
            (*s1).cversion,
        );
        cstr_cat(
            cs,
            b"#define __SIZE_TYPE__ unsigned long\n#define __PTRDIFF_TYPE__ long\n#define __LP64__ 1\n#define __INT64_TYPE__ long\n#define __SIZEOF_INT__ 4\n#define __INT_MAX__ 0x7fffffff\n#define __LONG_MAX__ 0x7fffffffffffffffL\n#define __SIZEOF_LONG_LONG__ 8\n#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL\n#define __CHAR_BIT__ 8\n#define __ORDER_LITTLE_ENDIAN__ 1234\n#define __ORDER_BIG_ENDIAN__ 4321\n#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__\n#define __WCHAR_TYPE__ int\n#define __WINT_TYPE__ unsigned int\n#if __STDC_VERSION__>=201112L\n#define __STDC_NO_ATOMICS__ 1\n#define __STDC_NO_COMPLEX__ 1\n#define __STDC_NO_THREADS__ 1\n#define __STDC_UTF_16__ 1\n#define __STDC_UTF_32__ 1\n#endif\n#define __UINTPTR_TYPE__ unsigned __PTRDIFF_TYPE__\n#define __INTPTR_TYPE__ __PTRDIFF_TYPE__\n#define __INT32_TYPE__ int\n#define __REDIRECT(name,proto,alias) name proto __asm__(#alias)\n#define __REDIRECT_NTH(name,proto,alias) name proto __asm__(#alias)__THROW\n#define __REDIRECT_NTHNL(name,proto,alias) name proto __asm__(#alias)__THROWNL\n#define __PRETTY_FUNCTION__ __FUNCTION__\n#define __has_builtin(x) 0\n#define __has_feature(x) 0\n#define __has_attribute(x) 0\n#define _Nonnull\n#define _Nullable\n#define _Nullable_result\n#define _Null_unspecified\n#ifndef __TCC_PP__\n#define __builtin_offsetof(type,field) ((__SIZE_TYPE__)&((type*)0)->field)\n#define __builtin_extract_return_addr(x) x\ntypedef struct{\nunsigned gp_offset,fp_offset;\nunion{\nunsigned overflow_offset;\nchar*overflow_arg_area;\n};\nchar*reg_save_area;\n}__builtin_va_list[1];\nvoid*__va_arg(__builtin_va_list ap,int arg_type,int size,int align);\n#define __builtin_va_start(ap,last) (*(ap)=*(__builtin_va_list)((char*)__builtin_frame_address(0)-24))\n#define __builtin_va_arg(ap,t) (*(t*)(__va_arg(ap,__builtin_va_arg_types(t),sizeof(t),__alignof__(t))))\n#define __builtin_va_copy(dest,src) (*(dest)=*(src))\n#define __builtin_va_end(ap) (void)(ap)\n#ifndef __builtin_va_copy\n#define __builtin_va_copy(dest,src) (dest)=(src)\n#endif\n#ifdef __leading_underscore\n#define __RENAME(X) __asm__(\"_\"X)\n#else\n#define __RENAME(X) __asm__(X)\n#endif\n#ifdef __TCC_BCHECK__\n#define __BUILTINBC(ret,name,params) ret __builtin_##name params __RENAME(\"__bound_\"#name);\n#define __BOUND(ret,name,params) ret name params __RENAME(\"__bound_\"#name);\n#else\n#define __BUILTINBC(ret,name,params) ret __builtin_##name params __RENAME(#name);\n#define __BOUND(ret,name,params)\n#endif\n#define __BOTH(ret,name,params) __BUILTINBC(ret,name,params)__BOUND(ret,name,params)\n#define __BUILTIN(ret,name,params) ret __builtin_##name params __RENAME(#name);\n__BOTH(void*,memcpy,(void*,const void*,__SIZE_TYPE__))\n__BOTH(void*,memmove,(void*,const void*,__SIZE_TYPE__))\n__BOTH(void*,memset,(void*,int,__SIZE_TYPE__))\n__BOTH(int,memcmp,(const void*,const void*,__SIZE_TYPE__))\n__BOTH(__SIZE_TYPE__,strlen,(const char*))\n__BOTH(char*,strcpy,(char*,const char*))\n__BOTH(char*,strncpy,(char*,const char*,__SIZE_TYPE__))\n__BOTH(int,strcmp,(const char*,const char*))\n__BOTH(int,strncmp,(const char*,const char*,__SIZE_TYPE__))\n__BOTH(char*,strcat,(char*,const char*))\n__BOTH(char*,strncat,(char*,const char*,__SIZE_TYPE__))\n__BOTH(char*,strchr,(const char*,int))\n__BOTH(char*,strrchr,(const char*,int))\n__BOTH(char*,strdup,(const char*))\n#define __MAYBE_REDIR __BUILTIN\n__MAYBE_REDIR(void*,malloc,(__SIZE_TYPE__))\n__MAYBE_REDIR(void*,realloc,(void*,__SIZE_TYPE__))\n__MAYBE_REDIR(void*,calloc,(__SIZE_TYPE__,__SIZE_TYPE__))\n__MAYBE_REDIR(void*,memalign,(__SIZE_TYPE__,__SIZE_TYPE__))\n__MAYBE_REDIR(void,free,(void*))\n__BOTH(void*,alloca,(__SIZE_TYPE__))\n__BUILTIN(void,abort,(void))\n__BOUND(void,longjmp,())\n__BOUND(void*,mmap,())\n__BOUND(int,munmap,())\n#undef __BUILTINBC\n#undef __BUILTIN\n#undef __BOUND\n#undef __BOTH\n#undef __MAYBE_REDIR\n#undef __RENAME\n#define __BUILTIN_EXTERN(name,u) int __builtin_##name(u int);int __builtin_##name##l(u long);int __builtin_##name##ll(u long long);\n__BUILTIN_EXTERN(ffs,)\n__BUILTIN_EXTERN(clz,unsigned)\n__BUILTIN_EXTERN(ctz,unsigned)\n__BUILTIN_EXTERN(clrsb,)\n__BUILTIN_EXTERN(popcount,unsigned)\n__BUILTIN_EXTERN(parity,unsigned)\n#undef __BUILTIN_EXTERN\n#endif\n\0"
                as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
    }
    cstr_printf(
        cs,
        b"#define __BASE_FILE__ \"%s\"\n\0" as *const u8 as *const libc::c_char,
        ((*file).filename).as_mut_ptr(),
    );
}
unsafe extern "C" fn preprocess_start(mut s1: *mut TCCState, mut filetype: libc::c_int) {
    let mut is_asm: libc::c_int = (filetype & (2 as libc::c_int | 4 as libc::c_int) != 0)
        as libc::c_int;
    tccpp_new(s1);
    (*s1).include_stack_ptr = ((*s1).include_stack).as_mut_ptr();
    (*s1).ifdef_stack_ptr = ((*s1).ifdef_stack).as_mut_ptr();
    (*file).ifdef_stack_ptr = (*s1).ifdef_stack_ptr;
    pp_expr = 0 as libc::c_int;
    pp_counter = 0 as libc::c_int;
    pp_debug_symv = 0 as libc::c_int;
    pp_debug_tok = pp_debug_symv;
    (*s1).pack_stack[0 as libc::c_int as usize] = 0 as libc::c_int;
    (*s1).pack_stack_ptr = ((*s1).pack_stack).as_mut_ptr();
    set_idnum(
        '$' as i32,
        if is_asm == 0 && (*s1).dollars_in_identifiers as libc::c_int != 0 {
            2 as libc::c_int
        } else {
            0 as libc::c_int
        },
    );
    set_idnum('.' as i32, if is_asm != 0 { 2 as libc::c_int } else { 0 as libc::c_int });
    if filetype & 2 as libc::c_int == 0 {
        let mut cstr: CString = CString {
            size: 0,
            size_allocated: 0,
            data: 0 as *mut libc::c_char,
        };
        cstr_new(&mut cstr);
        tcc_predefs(s1, &mut cstr, is_asm);
        if (*s1).cmdline_defs.size != 0 {
            cstr_cat(&mut cstr, (*s1).cmdline_defs.data, (*s1).cmdline_defs.size);
        }
        if (*s1).cmdline_incl.size != 0 {
            cstr_cat(&mut cstr, (*s1).cmdline_incl.data, (*s1).cmdline_incl.size);
        }
        let fresh148 = (*s1).include_stack_ptr;
        (*s1).include_stack_ptr = ((*s1).include_stack_ptr).offset(1);
        *fresh148 = file;
        tcc_open_bf(
            s1,
            b"<command line>\0" as *const u8 as *const libc::c_char,
            cstr.size,
        );
        memcpy(
            ((*file).buffer).as_mut_ptr() as *mut libc::c_void,
            cstr.data as *const libc::c_void,
            cstr.size as libc::c_ulong,
        );
        cstr_free(&mut cstr);
    }
    parse_flags = if is_asm != 0 { 0x8 as libc::c_int } else { 0 as libc::c_int };
}
unsafe extern "C" fn preprocess_end(mut s1: *mut TCCState) {
    while !macro_stack.is_null() {
        end_macro();
    }
    macro_ptr = 0 as *const libc::c_int;
    while !file.is_null() {
        tcc_close();
    }
    tccpp_delete(s1);
}
unsafe extern "C" fn set_idnum(mut c: libc::c_int, mut val: libc::c_int) -> libc::c_int {
    let mut prev: libc::c_int = isidnum_table[(c - -(1 as libc::c_int)) as usize]
        as libc::c_int;
    isidnum_table[(c - -(1 as libc::c_int)) as usize] = val as libc::c_uchar;
    return prev;
}
unsafe extern "C" fn tccpp_new(mut s: *mut TCCState) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut r: *const libc::c_char = 0 as *const libc::c_char;
    i = -(1 as libc::c_int);
    while i < 128 as libc::c_int {
        set_idnum(
            i,
            if is_space(i) != 0 {
                1 as libc::c_int
            } else if isid(i) != 0 {
                2 as libc::c_int
            } else if isnum(i) != 0 {
                4 as libc::c_int
            } else {
                0 as libc::c_int
            },
        );
        i += 1;
        i;
    }
    i = 128 as libc::c_int;
    while i < 256 as libc::c_int {
        set_idnum(i, 2 as libc::c_int);
        i += 1;
        i;
    }
    tal_new(
        &mut toksym_alloc,
        256 as libc::c_int as libc::c_uint,
        (768 as libc::c_int * 1024 as libc::c_int) as libc::c_uint,
    );
    tal_new(
        &mut tokstr_alloc,
        1024 as libc::c_int as libc::c_uint,
        (768 as libc::c_int * 1024 as libc::c_int) as libc::c_uint,
    );
    memset(
        hash_ident.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        (16384 as libc::c_int as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut TokenSym>() as libc::c_ulong),
    );
    memset(
        ((*s).cached_includes_hash).as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[libc::c_int; 32]>() as libc::c_ulong,
    );
    cstr_new(&mut tokcstr);
    cstr_new(&mut cstr_buf);
    cstr_realloc(&mut cstr_buf, 1024 as libc::c_int);
    tok_str_new(&mut tokstr_buf);
    tok_str_realloc(&mut tokstr_buf, 256 as libc::c_int);
    tok_str_new(&mut unget_buf);
    tok_ident = 256 as libc::c_int;
    p = tcc_keywords.as_ptr();
    while *p != 0 {
        r = p;
        loop {
            let fresh149 = r;
            r = r.offset(1);
            c = *fresh149 as libc::c_int;
            if c == '\0' as i32 {
                break;
            }
        }
        tok_alloc(
            p,
            (r.offset_from(p) as libc::c_long - 1 as libc::c_int as libc::c_long)
                as libc::c_int,
        );
        p = r;
    }
    define_push(
        TOK___LINE__ as libc::c_int,
        0 as libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut Sym,
    );
    define_push(
        TOK___FILE__ as libc::c_int,
        0 as libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut Sym,
    );
    define_push(
        TOK___DATE__ as libc::c_int,
        0 as libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut Sym,
    );
    define_push(
        TOK___TIME__ as libc::c_int,
        0 as libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut Sym,
    );
    define_push(
        TOK___COUNTER__ as libc::c_int,
        0 as libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut Sym,
    );
}
unsafe extern "C" fn tccpp_delete(mut s: *mut TCCState) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    dynarray_reset(
        &mut (*s).cached_includes as *mut *mut *mut CachedInclude as *mut libc::c_void,
        &mut (*s).nb_cached_includes,
    );
    n = tok_ident - 256 as libc::c_int;
    if n > (*tcc_state).total_idents {
        (*tcc_state).total_idents = n;
    }
    i = 0 as libc::c_int;
    while i < n {
        tal_free_impl(
            toksym_alloc,
            *table_ident.offset(i as isize) as *mut libc::c_void,
        );
        i += 1;
        i;
    }
    tcc_free(table_ident as *mut libc::c_void);
    table_ident = 0 as *mut *mut TokenSym;
    cstr_free(&mut tokcstr);
    cstr_free(&mut cstr_buf);
    tok_str_free_str(tokstr_buf.str_0);
    tok_str_free_str(unget_buf.str_0);
    tal_delete(toksym_alloc);
    toksym_alloc = 0 as *mut TinyAlloc;
    tal_delete(tokstr_alloc);
    tokstr_alloc = 0 as *mut TinyAlloc;
}
unsafe extern "C" fn tok_print(
    mut str: *const libc::c_int,
    mut msg: *const libc::c_char,
    mut args: ...
) {
    let mut fp: *mut FILE = (*tcc_state).ppfp;
    let mut ap: ::core::ffi::VaListImpl;
    let mut t: libc::c_int = 0;
    let mut t0: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    ap = args.clone();
    vfprintf(fp, msg, ap.as_va_list());
    t0 = 0 as libc::c_int;
    s = t0;
    while !str.is_null() {
        let mut _t: libc::c_int = *str;
        if _t >= 0xc0 as libc::c_int && _t <= 0xcf as libc::c_int {
            tok_get(&mut t, &mut str, &mut cval);
        } else {
            t = _t;
            str = str.offset(1);
            str;
        }
        if t == 0 as libc::c_int || t == -(1 as libc::c_int) {
            break;
        }
        if pp_need_space(t0, t) != 0 {
            s = 0 as libc::c_int;
        }
        fprintf(
            fp,
            &*(b" %s\0" as *const u8 as *const libc::c_char).offset(s as isize)
                as *const libc::c_char,
            if t == 0xa4 as libc::c_int {
                b"<>\0" as *const u8 as *const libc::c_char
            } else {
                get_tok_str(t, &mut cval)
            },
        );
        s = 1 as libc::c_int;
        t0 = t;
    }
    fprintf(fp, b"\n\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn pp_line(
    mut s1: *mut TCCState,
    mut f: *mut BufferedFile,
    mut level: libc::c_int,
) {
    let mut d: libc::c_int = (*f).line_num - (*f).line_ref;
    if (*s1).dflag as libc::c_int & 4 as libc::c_int != 0 {
        return;
    }
    if !((*s1).Pflag as libc::c_int == LINE_MACRO_OUTPUT_FORMAT_NONE as libc::c_int) {
        if level == 0 as libc::c_int && (*f).line_ref != 0 && d < 8 as libc::c_int {
            while d > 0 as libc::c_int {
                fputs(b"\n\0" as *const u8 as *const libc::c_char, (*s1).ppfp);
                d -= 1;
                d;
            }
        } else if (*s1).Pflag as libc::c_int
            == LINE_MACRO_OUTPUT_FORMAT_STD as libc::c_int
        {
            fprintf(
                (*s1).ppfp,
                b"#line %d \"%s\"\n\0" as *const u8 as *const libc::c_char,
                (*f).line_num,
                ((*f).filename).as_mut_ptr(),
            );
        } else {
            fprintf(
                (*s1).ppfp,
                b"# %d \"%s\"%s\n\0" as *const u8 as *const libc::c_char,
                (*f).line_num,
                ((*f).filename).as_mut_ptr(),
                if level > 0 as libc::c_int {
                    b" 1\0" as *const u8 as *const libc::c_char
                } else if level < 0 as libc::c_int {
                    b" 2\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
        }
    }
    (*f).line_ref = (*f).line_num;
}
unsafe extern "C" fn define_print(mut s1: *mut TCCState, mut v: libc::c_int) {
    let mut fp: *mut FILE = 0 as *mut FILE;
    let mut s: *mut Sym = 0 as *mut Sym;
    s = define_find(v);
    if s.is_null() || ((*s).c2rust_unnamed.d).is_null() {
        return;
    }
    fp = (*s1).ppfp;
    fprintf(
        fp,
        b"#define %s\0" as *const u8 as *const libc::c_char,
        get_tok_str(v, 0 as *mut CValue),
    );
    if (*s).type_0.t & 1 as libc::c_int != 0 {
        let mut a: *mut Sym = (*s).c2rust_unnamed_0.next;
        fprintf(fp, b"(\0" as *const u8 as *const libc::c_char);
        if !a.is_null() {
            loop {
                fprintf(
                    fp,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    get_tok_str((*a).v, 0 as *mut CValue),
                );
                a = (*a).c2rust_unnamed_0.next;
                if a.is_null() {
                    break;
                }
                fprintf(fp, b",\0" as *const u8 as *const libc::c_char);
            }
        }
        fprintf(fp, b")\0" as *const u8 as *const libc::c_char);
    }
    tok_print((*s).c2rust_unnamed.d, b"\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn pp_debug_defines(mut s1: *mut TCCState) {
    let mut v: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut vs: *const libc::c_char = 0 as *const libc::c_char;
    let mut fp: *mut FILE = 0 as *mut FILE;
    t = pp_debug_tok;
    if t == 0 as libc::c_int {
        return;
    }
    (*file).line_num -= 1;
    (*file).line_num;
    pp_line(s1, file, 0 as libc::c_int);
    (*file).line_num += 1;
    (*file).line_ref = (*file).line_num;
    fp = (*s1).ppfp;
    v = pp_debug_symv;
    vs = get_tok_str(v, 0 as *mut CValue);
    if t == TOK_DEFINE as libc::c_int {
        define_print(s1, v);
    } else if t == TOK_UNDEF as libc::c_int {
        fprintf(fp, b"#undef %s\n\0" as *const u8 as *const libc::c_char, vs);
    } else if t == TOK_push_macro as libc::c_int {
        fprintf(
            fp,
            b"#pragma push_macro(\"%s\")\n\0" as *const u8 as *const libc::c_char,
            vs,
        );
    } else if t == TOK_pop_macro as libc::c_int {
        fprintf(
            fp,
            b"#pragma pop_macro(\"%s\")\n\0" as *const u8 as *const libc::c_char,
            vs,
        );
    }
    pp_debug_tok = 0 as libc::c_int;
}
unsafe extern "C" fn pp_need_space(
    mut a: libc::c_int,
    mut b: libc::c_int,
) -> libc::c_int {
    return if 'E' as i32 == a {
        ('+' as i32 == b || '-' as i32 == b) as libc::c_int
    } else if '+' as i32 == a {
        (0x82 as libc::c_int == b || '+' as i32 == b) as libc::c_int
    } else if '-' as i32 == a {
        (0x80 as libc::c_int == b || '-' as i32 == b) as libc::c_int
    } else if a >= 256 as libc::c_int || a == 0xcd as libc::c_int {
        (b >= 256 as libc::c_int || b == 0xcd as libc::c_int) as libc::c_int
    } else {
        0 as libc::c_int
    };
}
unsafe extern "C" fn pp_check_he0xE(
    mut t: libc::c_int,
    mut p: *const libc::c_char,
) -> libc::c_int {
    if t == 0xcd as libc::c_int
        && toup(
            *(strchr(p, 0 as libc::c_int)).offset(-(1 as libc::c_int) as isize)
                as libc::c_int,
        ) == 'E' as i32
    {
        return 'E' as i32;
    }
    return t;
}
unsafe extern "C" fn tcc_preprocess(mut s1: *mut TCCState) -> libc::c_int {
    let mut iptr: *mut *mut BufferedFile = 0 as *mut *mut BufferedFile;
    let mut token_seen: libc::c_int = 0;
    let mut spcs: libc::c_int = 0;
    let mut level: libc::c_int = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut white: [libc::c_char; 400] = [0; 400];
    parse_flags = 0x1 as libc::c_int | parse_flags & 0x8 as libc::c_int
        | 0x4 as libc::c_int | 0x10 as libc::c_int | 0x20 as libc::c_int;
    if (*s1).Pflag as libc::c_int == LINE_MACRO_OUTPUT_FORMAT_P10 as libc::c_int {
        parse_flags |= 0x2 as libc::c_int;
        (*s1).Pflag = 1 as libc::c_int as libc::c_uchar;
    }
    if (*s1).do_bench != 0 {
        loop {
            next();
            if !(tok != -(1 as libc::c_int)) {
                break;
            }
        }
        return 0 as libc::c_int;
    }
    token_seen = 10 as libc::c_int;
    spcs = 0 as libc::c_int;
    level = 0 as libc::c_int;
    if !((*file).prev).is_null() {
        let fresh150 = level;
        level = level + 1;
        pp_line(s1, (*file).prev, fresh150);
    }
    pp_line(s1, file, level);
    loop {
        iptr = (*s1).include_stack_ptr;
        next();
        if tok == -(1 as libc::c_int) {
            break;
        }
        level = ((*s1).include_stack_ptr).offset_from(iptr) as libc::c_long
            as libc::c_int;
        if level != 0 {
            if level > 0 as libc::c_int {
                pp_line(s1, *iptr, 0 as libc::c_int);
            }
            pp_line(s1, file, level);
        }
        if (*s1).dflag as libc::c_int & 7 as libc::c_int != 0 {
            pp_debug_defines(s1);
            if (*s1).dflag as libc::c_int & 4 as libc::c_int != 0 {
                continue;
            }
        }
        if is_space(tok) != 0 {
            if (spcs as libc::c_ulong)
                < (::core::mem::size_of::<[libc::c_char; 400]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong)
            {
                let fresh151 = spcs;
                spcs = spcs + 1;
                white[fresh151 as usize] = tok as libc::c_char;
            }
        } else {
            if tok == 10 as libc::c_int {
                spcs = 0 as libc::c_int;
                if token_seen == 10 as libc::c_int {
                    continue;
                }
                (*file).line_ref += 1;
                (*file).line_ref;
            } else if token_seen == 10 as libc::c_int {
                pp_line(s1, file, 0 as libc::c_int);
            } else if spcs == 0 as libc::c_int && pp_need_space(token_seen, tok) != 0 {
                let fresh152 = spcs;
                spcs = spcs + 1;
                white[fresh152 as usize] = ' ' as i32 as libc::c_char;
            }
            white[spcs as usize] = 0 as libc::c_int as libc::c_char;
            fputs(white.as_mut_ptr(), (*s1).ppfp);
            spcs = 0 as libc::c_int;
            p = get_tok_str(tok, &mut tokc);
            fputs(p, (*s1).ppfp);
            token_seen = pp_check_he0xE(tok, p);
        }
    }
    return 0 as libc::c_int;
}
static mut rsym: libc::c_int = 0;
static mut anon_sym: libc::c_int = 0;
static mut ind: libc::c_int = 0;
static mut loc: libc::c_int = 0;
static mut global_stack: *mut Sym = 0 as *const Sym as *mut Sym;
static mut local_stack: *mut Sym = 0 as *const Sym as *mut Sym;
static mut define_stack: *mut Sym = 0 as *const Sym as *mut Sym;
static mut global_label_stack: *mut Sym = 0 as *const Sym as *mut Sym;
static mut local_label_stack: *mut Sym = 0 as *const Sym as *mut Sym;
static mut sym_free_first: *mut Sym = 0 as *const Sym as *mut Sym;
static mut sym_pools: *mut *mut libc::c_void = 0 as *const *mut libc::c_void
    as *mut *mut libc::c_void;
static mut nb_sym_pools: libc::c_int = 0;
static mut all_cleanups: *mut Sym = 0 as *const Sym as *mut Sym;
static mut pending_gotos: *mut Sym = 0 as *const Sym as *mut Sym;
static mut local_scope: libc::c_int = 0;
static mut debug_modes: libc::c_char = 0;
static mut vtop: *mut SValue = 0 as *const SValue as *mut SValue;
static mut _vstack: [SValue; 513] = [SValue {
    type_0: CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    },
    r: 0,
    r2: 0,
    c2rust_unnamed: C2RustUnnamed_15 {
        c2rust_unnamed: C2RustUnnamed_16 {
            jtrue: 0,
            jfalse: 0,
        },
    },
    c2rust_unnamed_0: C2RustUnnamed_13 {
        c2rust_unnamed: C2RustUnnamed_14 {
            cmp_op: 0,
            cmp_r: 0,
        },
    },
}; 513];
static mut nocode_wanted: libc::c_int = 0;
static mut global_expr: libc::c_int = 0;
static mut func_vt: CType = CType {
    t: 0,
    ref_0: 0 as *mut Sym,
};
static mut func_var: libc::c_int = 0;
static mut func_vc: libc::c_int = 0;
static mut func_ind: libc::c_int = 0;
static mut funcname: *const libc::c_char = 0 as *const libc::c_char;
static mut int_type: CType = CType {
    t: 0,
    ref_0: 0 as *mut Sym,
};
static mut func_old_type: CType = CType {
    t: 0,
    ref_0: 0 as *mut Sym,
};
static mut char_type: CType = CType {
    t: 0,
    ref_0: 0 as *mut Sym,
};
static mut char_pointer_type: CType = CType {
    t: 0,
    ref_0: 0 as *mut Sym,
};
static mut initstr: CString = CString {
    size: 0,
    size_allocated: 0,
    data: 0 as *mut libc::c_char,
};
static mut cur_switch: *mut switch_t = 0 as *const switch_t as *mut switch_t;
static mut arr_temp_local_vars: [temp_local_variable; 8] = [temp_local_variable {
    location: 0,
    size: 0,
    align: 0,
}; 8];
static mut nb_temp_local_vars: libc::c_int = 0;
static mut cur_scope: *mut scope = 0 as *const scope as *mut scope;
static mut loop_scope: *mut scope = 0 as *const scope as *mut scope;
static mut root_scope: *mut scope = 0 as *const scope as *mut scope;
unsafe extern "C" fn gsym(mut t: libc::c_int) {
    if t != 0 {
        gsym_addr(t, ind);
        nocode_wanted &= !(0x20000000 as libc::c_int);
    }
}
unsafe extern "C" fn gind() -> libc::c_int {
    let mut t: libc::c_int = ind;
    nocode_wanted &= !(0x20000000 as libc::c_int);
    if debug_modes != 0 {
        tcc_tcov_block_begin(tcc_state);
    }
    return t;
}
unsafe extern "C" fn gjmp_addr_acs(mut t: libc::c_int) {
    gjmp_addr(t);
    if nocode_wanted == 0 {
        nocode_wanted |= 0x20000000 as libc::c_int;
    }
}
unsafe extern "C" fn gjmp_acs(mut t: libc::c_int) -> libc::c_int {
    t = gjmp(t);
    if nocode_wanted == 0 {
        nocode_wanted |= 0x20000000 as libc::c_int;
    }
    return t;
}
#[inline]
unsafe extern "C" fn is_float(mut t: libc::c_int) -> libc::c_int {
    let mut bt: libc::c_int = t & 0xf as libc::c_int;
    return (bt == 10 as libc::c_int || bt == 9 as libc::c_int || bt == 8 as libc::c_int
        || bt == 14 as libc::c_int) as libc::c_int;
}
#[inline]
unsafe extern "C" fn is_integer_btype(mut bt: libc::c_int) -> libc::c_int {
    return (bt == 1 as libc::c_int || bt == 11 as libc::c_int || bt == 2 as libc::c_int
        || bt == 3 as libc::c_int || bt == 4 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn btype_size(mut bt: libc::c_int) -> libc::c_int {
    return if bt == 1 as libc::c_int || bt == 11 as libc::c_int {
        1 as libc::c_int
    } else if bt == 2 as libc::c_int {
        2 as libc::c_int
    } else if bt == 3 as libc::c_int {
        4 as libc::c_int
    } else if bt == 4 as libc::c_int {
        8 as libc::c_int
    } else if bt == 5 as libc::c_int {
        8 as libc::c_int
    } else {
        0 as libc::c_int
    };
}
unsafe extern "C" fn R_RET(mut t: libc::c_int) -> libc::c_int {
    if is_float(t) == 0 {
        return TREG_RAX as libc::c_int;
    }
    if t & 0xf as libc::c_int == 10 as libc::c_int {
        return TREG_ST0 as libc::c_int;
    }
    return TREG_XMM0 as libc::c_int;
}
unsafe extern "C" fn R2_RET(mut t: libc::c_int) -> libc::c_int {
    t &= 0xf as libc::c_int;
    if t == 13 as libc::c_int {
        return TREG_RDX as libc::c_int;
    }
    if t == 14 as libc::c_int {
        return TREG_XMM1 as libc::c_int;
    }
    return 0x30 as libc::c_int;
}
unsafe extern "C" fn PUT_R_RET(mut sv: *mut SValue, mut t: libc::c_int) {
    (*sv).r = R_RET(t) as libc::c_ushort;
    (*sv).r2 = R2_RET(t) as libc::c_ushort;
}
unsafe extern "C" fn RC_RET(mut t: libc::c_int) -> libc::c_int {
    return reg_classes[R_RET(t) as usize] & !(0x2 as libc::c_int | 0x1 as libc::c_int);
}
unsafe extern "C" fn RC_TYPE(mut t: libc::c_int) -> libc::c_int {
    if is_float(t) == 0 {
        return 0x1 as libc::c_int;
    }
    if t & 0xf as libc::c_int == 10 as libc::c_int {
        return 0x80 as libc::c_int;
    }
    if t & 0xf as libc::c_int == 14 as libc::c_int {
        return 0x1000 as libc::c_int;
    }
    return 0x2 as libc::c_int;
}
unsafe extern "C" fn RC2_TYPE(mut t: libc::c_int, mut rc: libc::c_int) -> libc::c_int {
    if !(R2_RET(t) != 0x30 as libc::c_int) {
        return 0 as libc::c_int;
    }
    if rc == 0x4 as libc::c_int {
        return 0x8 as libc::c_int;
    }
    if rc == 0x1000 as libc::c_int {
        return 0x2000 as libc::c_int;
    }
    if rc & 0x2 as libc::c_int != 0 {
        return 0x2 as libc::c_int;
    }
    return 0x1 as libc::c_int;
}
unsafe extern "C" fn ieee_finite(mut d: libc::c_double) -> libc::c_int {
    let mut p: [libc::c_int; 4] = [0; 4];
    memcpy(
        p.as_mut_ptr() as *mut libc::c_void,
        &mut d as *mut libc::c_double as *const libc::c_void,
        ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
    );
    return ((p[1 as libc::c_int as usize] as libc::c_uint | 0x800fffff as libc::c_uint)
        .wrapping_add(1 as libc::c_int as libc::c_uint) >> 31 as libc::c_int)
        as libc::c_int;
}
unsafe extern "C" fn test_lvalue() {
    if (*vtop).r as libc::c_int & 0x100 as libc::c_int == 0 {
        expect(b"lvalue\0" as *const u8 as *const libc::c_char);
    }
}
unsafe extern "C" fn check_vstack() {
    if vtop
        != _vstack
            .as_mut_ptr()
            .offset(1 as libc::c_int as isize)
            .offset(-(1 as libc::c_int as isize))
    {
        _tcc_error(
            b"internal compiler error: vstack leak (%d)\0" as *const u8
                as *const libc::c_char,
            (vtop.offset_from(_vstack.as_mut_ptr().offset(1 as libc::c_int as isize))
                as libc::c_long + 1 as libc::c_int as libc::c_long) as libc::c_int,
        );
    }
}
unsafe extern "C" fn tccgen_init(mut s1: *mut TCCState) {
    vtop = _vstack
        .as_mut_ptr()
        .offset(1 as libc::c_int as isize)
        .offset(-(1 as libc::c_int as isize));
    memset(
        vtop as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<SValue>() as libc::c_ulong,
    );
    int_type.t = 3 as libc::c_int;
    char_type.t = 1 as libc::c_int;
    if (*s1).char_is_unsigned != 0 {
        char_type.t |= 0x10 as libc::c_int;
    }
    char_pointer_type = char_type;
    mk_pointer(&mut char_pointer_type);
    func_old_type.t = 6 as libc::c_int;
    func_old_type
        .ref_0 = sym_push(
        0x20000000 as libc::c_int,
        &mut int_type,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    ((*func_old_type.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
        .set_func_call(0 as libc::c_int as libc::c_uint);
    ((*func_old_type.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
        .set_func_type(2 as libc::c_int as libc::c_uint);
    init_prec();
    cstr_new(&mut initstr);
}
unsafe extern "C" fn tccgen_compile(mut s1: *mut TCCState) -> libc::c_int {
    funcname = b"\0" as *const u8 as *const libc::c_char;
    func_ind = -(1 as libc::c_int);
    anon_sym = 0x10000000 as libc::c_int;
    nocode_wanted = 0x80000000 as libc::c_uint as libc::c_int;
    debug_modes = ((if (*s1).do_debug as libc::c_int != 0 {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    }) | ((*s1).test_coverage as libc::c_int) << 1 as libc::c_int) as libc::c_char;
    tcc_debug_start(s1);
    tcc_tcov_start(s1);
    parse_flags = 0x1 as libc::c_int | 0x2 as libc::c_int | 0x40 as libc::c_int;
    next();
    decl(0x30 as libc::c_int);
    gen_inline_functions(s1);
    check_vstack();
    tcc_eh_frame_end(s1);
    tcc_debug_end(s1);
    tcc_tcov_end(s1);
    return 0 as libc::c_int;
}
unsafe extern "C" fn tccgen_finish(mut s1: *mut TCCState) {
    tcc_debug_end(s1);
    free_inline_functions(s1);
    sym_pop(&mut global_stack, 0 as *mut Sym, 0 as libc::c_int);
    sym_pop(&mut local_stack, 0 as *mut Sym, 0 as libc::c_int);
    free_defines(0 as *mut Sym);
    dynarray_reset(
        &mut sym_pools as *mut *mut *mut libc::c_void as *mut libc::c_void,
        &mut nb_sym_pools,
    );
    cstr_free(&mut initstr);
    dynarray_reset(
        &mut stk_data as *mut *mut *mut libc::c_void as *mut libc::c_void,
        &mut nb_stk_data,
    );
    while !cur_switch.is_null() {
        end_switch();
    }
    local_scope = 0 as libc::c_int;
    loop_scope = 0 as *mut scope;
    all_cleanups = 0 as *mut Sym;
    pending_gotos = 0 as *mut Sym;
    nb_temp_local_vars = 0 as libc::c_int;
    global_label_stack = 0 as *mut Sym;
    local_label_stack = 0 as *mut Sym;
    (*tcc_state).cur_text_section = 0 as *mut Section;
    sym_free_first = 0 as *mut Sym;
}
unsafe extern "C" fn elfsym(mut s: *mut Sym) -> *mut Elf64_Sym {
    if s.is_null() || (*s).c2rust_unnamed.c2rust_unnamed.c == 0 {
        return 0 as *mut Elf64_Sym;
    }
    return &mut *((*(*tcc_state).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
        .offset((*s).c2rust_unnamed.c2rust_unnamed.c as isize) as *mut Elf64_Sym;
}
unsafe extern "C" fn update_storage(mut sym: *mut Sym) {
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut sym_bind: libc::c_int = 0;
    let mut old_sym_bind: libc::c_int = 0;
    esym = elfsym(sym);
    if esym.is_null() {
        return;
    }
    if ((*sym).a).visibility() != 0 {
        (*esym)
            .st_other = ((*esym).st_other as libc::c_int
            & !(-(1 as libc::c_int) & 0x3 as libc::c_int)
            | ((*sym).a).visibility() as libc::c_int) as libc::c_uchar;
    }
    if (*sym).type_0.t & (0x2000 as libc::c_int | 0x8000 as libc::c_int) != 0 {
        sym_bind = 0 as libc::c_int;
    } else if ((*sym).a).weak() != 0 {
        sym_bind = 2 as libc::c_int;
    } else {
        sym_bind = 1 as libc::c_int;
    }
    old_sym_bind = (*esym).st_info as libc::c_int >> 4 as libc::c_int;
    if sym_bind != old_sym_bind {
        (*esym)
            .st_info = ((sym_bind << 4 as libc::c_int)
            + ((*esym).st_info as libc::c_int & 0xf as libc::c_int & 0xf as libc::c_int))
            as libc::c_uchar;
    }
}
unsafe extern "C" fn put_extern_sym2(
    mut sym: *mut Sym,
    mut sh_num: libc::c_int,
    mut value: Elf64_Addr,
    mut size: libc::c_ulong,
    mut can_add_underscore: libc::c_int,
) {
    let mut sym_type: libc::c_int = 0;
    let mut sym_bind: libc::c_int = 0;
    let mut info: libc::c_int = 0;
    let mut other: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    let mut buf1: [libc::c_char; 256] = [0; 256];
    if (*sym).c2rust_unnamed.c2rust_unnamed.c == 0 {
        name = get_tok_str((*sym).v, 0 as *mut CValue);
        t = (*sym).type_0.t;
        if t & 0xf as libc::c_int == 6 as libc::c_int {
            sym_type = 2 as libc::c_int;
        } else if t & 0xf as libc::c_int == 0 as libc::c_int {
            sym_type = 0 as libc::c_int;
            if t
                & (0xf as libc::c_int
                    | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
                        | (2 as libc::c_int) << 20 as libc::c_int))
                == 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
                    | (2 as libc::c_int) << 20 as libc::c_int
            {
                sym_type = 2 as libc::c_int;
            }
        } else {
            sym_type = 1 as libc::c_int;
        }
        if t & (0x2000 as libc::c_int | 0x8000 as libc::c_int) != 0 {
            sym_bind = 0 as libc::c_int;
        } else {
            sym_bind = 1 as libc::c_int;
        }
        other = 0 as libc::c_int;
        if (*sym).c2rust_unnamed_0.asm_label != 0 {
            name = get_tok_str((*sym).c2rust_unnamed_0.asm_label, 0 as *mut CValue);
            can_add_underscore = 0 as libc::c_int;
        }
        if (*tcc_state).leading_underscore as libc::c_int != 0 && can_add_underscore != 0
        {
            buf1[0 as libc::c_int as usize] = '_' as i32 as libc::c_char;
            pstrcpy(
                buf1.as_mut_ptr().offset(1 as libc::c_int as isize),
                (::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong)
                    .wrapping_sub(1 as libc::c_int as libc::c_ulong),
                name,
            );
            name = buf1.as_mut_ptr();
        }
        info = (sym_bind << 4 as libc::c_int) + (sym_type & 0xf as libc::c_int);
        (*sym)
            .c2rust_unnamed
            .c2rust_unnamed
            .c = put_elf_sym(
            (*tcc_state).c2rust_unnamed.symtab_section,
            value,
            size,
            info,
            other,
            sh_num,
            name,
        );
        if debug_modes != 0 {
            tcc_debug_extern_sym(tcc_state, sym, sh_num, sym_bind, sym_type);
        }
    } else {
        esym = elfsym(sym);
        (*esym).st_value = value;
        (*esym).st_size = size;
        (*esym).st_shndx = sh_num as Elf64_Section;
    }
    update_storage(sym);
}
unsafe extern "C" fn put_extern_sym(
    mut sym: *mut Sym,
    mut s: *mut Section,
    mut value: Elf64_Addr,
    mut size: libc::c_ulong,
) {
    if nocode_wanted != 0
        && (nocode_wanted > 0 as libc::c_int
            || !s.is_null() && s == (*tcc_state).cur_text_section)
    {
        return;
    }
    put_extern_sym2(
        sym,
        if !s.is_null() { (*s).sh_num } else { 0 as libc::c_int },
        value,
        size,
        1 as libc::c_int,
    );
}
unsafe extern "C" fn greloca(
    mut s: *mut Section,
    mut sym: *mut Sym,
    mut offset: libc::c_ulong,
    mut type_0: libc::c_int,
    mut addend: Elf64_Addr,
) {
    let mut c: libc::c_int = 0 as libc::c_int;
    if nocode_wanted != 0 && s == (*tcc_state).cur_text_section {
        return;
    }
    if !sym.is_null() {
        if 0 as libc::c_int == (*sym).c2rust_unnamed.c2rust_unnamed.c {
            put_extern_sym(
                sym,
                0 as *mut Section,
                0 as libc::c_int as Elf64_Addr,
                0 as libc::c_int as libc::c_ulong,
            );
        }
        c = (*sym).c2rust_unnamed.c2rust_unnamed.c;
    }
    put_elf_reloca(
        (*tcc_state).c2rust_unnamed.symtab_section,
        s,
        offset,
        type_0,
        c,
        addend,
    );
}
unsafe extern "C" fn __sym_malloc() -> *mut Sym {
    let mut sym_pool: *mut Sym = 0 as *mut Sym;
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut last_sym: *mut Sym = 0 as *mut Sym;
    let mut i: libc::c_int = 0;
    sym_pool = tcc_malloc(
        (8192 as libc::c_int as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<Sym>() as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<Sym>() as libc::c_ulong),
    ) as *mut Sym;
    dynarray_add(
        &mut sym_pools as *mut *mut *mut libc::c_void as *mut libc::c_void,
        &mut nb_sym_pools,
        sym_pool as *mut libc::c_void,
    );
    last_sym = sym_free_first;
    sym = sym_pool;
    i = 0 as libc::c_int;
    while (i as libc::c_ulong)
        < (8192 as libc::c_int as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<Sym>() as libc::c_ulong)
    {
        (*sym).c2rust_unnamed_0.next = last_sym;
        last_sym = sym;
        sym = sym.offset(1);
        sym;
        i += 1;
        i;
    }
    sym_free_first = last_sym;
    return last_sym;
}
#[inline]
unsafe extern "C" fn sym_malloc() -> *mut Sym {
    let mut sym: *mut Sym = 0 as *mut Sym;
    sym = sym_free_first;
    if sym.is_null() {
        sym = __sym_malloc();
    }
    sym_free_first = (*sym).c2rust_unnamed_0.next;
    return sym;
}
#[inline]
unsafe extern "C" fn sym_free(mut sym: *mut Sym) {
    (*sym).c2rust_unnamed_0.next = sym_free_first;
    sym_free_first = sym;
}
unsafe extern "C" fn sym_push2(
    mut ps: *mut *mut Sym,
    mut v: libc::c_int,
    mut t: libc::c_int,
    mut c: libc::c_int,
) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    s = sym_malloc();
    memset(
        s as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<Sym>() as libc::c_ulong,
    );
    (*s).v = v;
    (*s).type_0.t = t;
    (*s).c2rust_unnamed.c2rust_unnamed.c = c;
    (*s).prev = *ps;
    *ps = s;
    return s;
}
unsafe extern "C" fn sym_find2(mut s: *mut Sym, mut v: libc::c_int) -> *mut Sym {
    while !s.is_null() {
        if (*s).v == v {
            return s;
        }
        s = (*s).prev;
    }
    return 0 as *mut Sym;
}
#[inline]
unsafe extern "C" fn struct_find(mut v: libc::c_int) -> *mut Sym {
    v -= 256 as libc::c_int;
    if v as libc::c_uint >= (tok_ident - 256 as libc::c_int) as libc::c_uint {
        return 0 as *mut Sym;
    }
    return (**table_ident.offset(v as isize)).sym_struct;
}
#[inline]
unsafe extern "C" fn sym_find(mut v: libc::c_int) -> *mut Sym {
    v -= 256 as libc::c_int;
    if v as libc::c_uint >= (tok_ident - 256 as libc::c_int) as libc::c_uint {
        return 0 as *mut Sym;
    }
    return (**table_ident.offset(v as isize)).sym_identifier;
}
unsafe extern "C" fn sym_scope(mut s: *mut Sym) -> libc::c_int {
    if (*s).type_0.t as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((3 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
    {
        return (*(*s).type_0.ref_0)
            .c2rust_unnamed
            .c2rust_unnamed
            .c2rust_unnamed
            .sym_scope
    } else {
        return (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope
    };
}
unsafe extern "C" fn sym_push(
    mut v: libc::c_int,
    mut type_0: *mut CType,
    mut r: libc::c_int,
    mut c: libc::c_int,
) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut ps: *mut *mut Sym = 0 as *mut *mut Sym;
    let mut ts: *mut TokenSym = 0 as *mut TokenSym;
    if !local_stack.is_null() {
        ps = &mut local_stack;
    } else {
        ps = &mut global_stack;
    }
    s = sym_push2(ps, v, (*type_0).t, c);
    (*s).type_0.ref_0 = (*type_0).ref_0;
    (*s).r = r as libc::c_ushort;
    if v & 0x20000000 as libc::c_int == 0
        && v & !(0x40000000 as libc::c_int) < 0x10000000 as libc::c_int
    {
        ts = *table_ident
            .offset(((v & !(0x40000000 as libc::c_int)) - 256 as libc::c_int) as isize);
        if v & 0x40000000 as libc::c_int != 0 {
            ps = &mut (*ts).sym_struct;
        } else {
            ps = &mut (*ts).sym_identifier;
        }
        (*s).prev_tok = *ps;
        *ps = s;
        (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope = local_scope;
        if !((*s).prev_tok).is_null()
            && sym_scope((*s).prev_tok)
                == (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope
        {
            _tcc_error(
                b"redeclaration of '%s'\0" as *const u8 as *const libc::c_char,
                get_tok_str(v & !(0x40000000 as libc::c_int), 0 as *mut CValue),
            );
        }
    }
    return s;
}
unsafe extern "C" fn global_identifier_push(
    mut v: libc::c_int,
    mut t: libc::c_int,
    mut c: libc::c_int,
) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut ps: *mut *mut Sym = 0 as *mut *mut Sym;
    s = sym_push2(&mut global_stack, v, t, c);
    (*s).r = (0x30 as libc::c_int | 0x200 as libc::c_int) as libc::c_ushort;
    if v < 0x10000000 as libc::c_int {
        ps = &mut (**table_ident.offset((v - 256 as libc::c_int) as isize))
            .sym_identifier;
        while !(*ps).is_null()
            && (**ps).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope != 0
        {
            ps = &mut (**ps).prev_tok;
        }
        (*s).prev_tok = *ps;
        *ps = s;
    }
    return s;
}
unsafe extern "C" fn sym_pop(
    mut ptop: *mut *mut Sym,
    mut b: *mut Sym,
    mut keep: libc::c_int,
) {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut ss: *mut Sym = 0 as *mut Sym;
    let mut ps: *mut *mut Sym = 0 as *mut *mut Sym;
    let mut ts: *mut TokenSym = 0 as *mut TokenSym;
    let mut v: libc::c_int = 0;
    s = *ptop;
    while s != b {
        ss = (*s).prev;
        v = (*s).v;
        if v & 0x20000000 as libc::c_int == 0
            && v & !(0x40000000 as libc::c_int) < 0x10000000 as libc::c_int
        {
            ts = *table_ident
                .offset(
                    ((v & !(0x40000000 as libc::c_int)) - 256 as libc::c_int) as isize,
                );
            if v & 0x40000000 as libc::c_int != 0 {
                ps = &mut (*ts).sym_struct;
            } else {
                ps = &mut (*ts).sym_identifier;
            }
            *ps = (*s).prev_tok;
        }
        if keep == 0 {
            sym_free(s);
        }
        s = ss;
    }
    if keep == 0 {
        *ptop = b;
    }
}
unsafe extern "C" fn label_find(mut v: libc::c_int) -> *mut Sym {
    v -= 256 as libc::c_int;
    if v as libc::c_uint >= (tok_ident - 256 as libc::c_int) as libc::c_uint {
        return 0 as *mut Sym;
    }
    return (**table_ident.offset(v as isize)).sym_label;
}
unsafe extern "C" fn label_push(
    mut ptop: *mut *mut Sym,
    mut v: libc::c_int,
    mut flags: libc::c_int,
) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut ps: *mut *mut Sym = 0 as *mut *mut Sym;
    s = sym_push2(ptop, v, 0x2000 as libc::c_int, 0 as libc::c_int);
    (*s).r = flags as libc::c_ushort;
    ps = &mut (**table_ident.offset((v - 256 as libc::c_int) as isize)).sym_label;
    if ptop == &mut global_label_stack as *mut *mut Sym {
        while !(*ps).is_null() {
            ps = &mut (**ps).prev_tok;
        }
    }
    (*s).prev_tok = *ps;
    *ps = s;
    return s;
}
unsafe extern "C" fn label_pop(
    mut ptop: *mut *mut Sym,
    mut slast: *mut Sym,
    mut keep: libc::c_int,
) {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut s1: *mut Sym = 0 as *mut Sym;
    s = *ptop;
    while s != slast {
        s1 = (*s).prev;
        if (*s).r as libc::c_int == 2 as libc::c_int {
            (*tcc_state)
                .warn_num = (&mut (*(0 as *mut TCCState)).warn_all as *mut libc::c_uchar
                as size_t)
                .wrapping_sub(
                    &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                        as size_t,
                ) as libc::c_uchar;
            (Some(_tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> ()))
                .expect(
                    "non-null function pointer",
                )(
                b"label '%s' declared but not used\0" as *const u8
                    as *const libc::c_char,
                get_tok_str((*s).v, 0 as *mut CValue),
            );
        } else if (*s).r as libc::c_int == 1 as libc::c_int {
            _tcc_error(
                b"label '%s' used but not defined\0" as *const u8 as *const libc::c_char,
                get_tok_str((*s).v, 0 as *mut CValue),
            );
        } else if (*s).c2rust_unnamed.c2rust_unnamed.c != 0 {
            put_extern_sym(
                s,
                (*tcc_state).cur_text_section,
                (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jnext as Elf64_Addr,
                1 as libc::c_int as libc::c_ulong,
            );
        }
        if (*s).r as libc::c_int != 3 as libc::c_int {
            let ref mut fresh153 = (**table_ident
                .offset(((*s).v - 256 as libc::c_int) as isize))
                .sym_label;
            *fresh153 = (*s).prev_tok;
        }
        if keep == 0 {
            sym_free(s);
        } else {
            (*s).r = 3 as libc::c_int as libc::c_ushort;
        }
        s = s1;
    }
    if keep == 0 {
        *ptop = slast;
    }
}
unsafe extern "C" fn vcheck_cmp() {
    if (*vtop).r as libc::c_int == 0x33 as libc::c_int
        && 0 as libc::c_int == nocode_wanted & !(0x20000000 as libc::c_int)
    {
        gv(0x1 as libc::c_int);
    }
}
unsafe extern "C" fn vsetc(
    mut type_0: *mut CType,
    mut r: libc::c_int,
    mut vc: *mut CValue,
) {
    if vtop
        >= _vstack
            .as_mut_ptr()
            .offset(1 as libc::c_int as isize)
            .offset((512 as libc::c_int - 1 as libc::c_int) as isize)
    {
        _tcc_error(b"memory full (vstack)\0" as *const u8 as *const libc::c_char);
    }
    vcheck_cmp();
    vtop = vtop.offset(1);
    vtop;
    (*vtop).type_0 = *type_0;
    (*vtop).r = r as libc::c_ushort;
    (*vtop).r2 = 0x30 as libc::c_int as libc::c_ushort;
    (*vtop).c2rust_unnamed.c = *vc;
    (*vtop).c2rust_unnamed_0.sym = 0 as *mut Sym;
}
unsafe extern "C" fn vswap() {
    let mut tmp: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    vcheck_cmp();
    tmp = *vtop.offset(0 as libc::c_int as isize);
    *vtop.offset(0 as libc::c_int as isize) = *vtop.offset(-(1 as libc::c_int) as isize);
    *vtop.offset(-(1 as libc::c_int) as isize) = tmp;
}
unsafe extern "C" fn vpop() {
    let mut v: libc::c_int = 0;
    v = (*vtop).r as libc::c_int & 0x3f as libc::c_int;
    if v == TREG_ST0 as libc::c_int {
        o(0xd8dd as libc::c_int as libc::c_uint);
    } else if v == 0x33 as libc::c_int {
        gsym((*vtop).c2rust_unnamed.c2rust_unnamed.jtrue);
        gsym((*vtop).c2rust_unnamed.c2rust_unnamed.jfalse);
    }
    vtop = vtop.offset(-1);
    vtop;
}
unsafe extern "C" fn vpush(mut type_0: *mut CType) {
    vset(type_0, 0x30 as libc::c_int, 0 as libc::c_int);
}
unsafe extern "C" fn vpush64(mut ty: libc::c_int, mut v: libc::c_ulonglong) {
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    let mut ctype: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    ctype.t = ty;
    ctype.ref_0 = 0 as *mut Sym;
    cval.i = v as uint64_t;
    vsetc(&mut ctype, 0x30 as libc::c_int, &mut cval);
}
unsafe extern "C" fn vpushi(mut v: libc::c_int) {
    vpush64(3 as libc::c_int, v as libc::c_ulonglong);
}
unsafe extern "C" fn vpushs(mut v: Elf64_Addr) {
    vpush64(
        0x800 as libc::c_int | 4 as libc::c_int | 0x10 as libc::c_int,
        v as libc::c_ulonglong,
    );
}
#[inline]
unsafe extern "C" fn vpushll(mut v: libc::c_longlong) {
    vpush64(4 as libc::c_int, v as libc::c_ulonglong);
}
unsafe extern "C" fn vset(
    mut type_0: *mut CType,
    mut r: libc::c_int,
    mut v: libc::c_int,
) {
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    cval.i = v as uint64_t;
    vsetc(type_0, r, &mut cval);
}
unsafe extern "C" fn vseti(mut r: libc::c_int, mut v: libc::c_int) {
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    type_0.t = 3 as libc::c_int;
    type_0.ref_0 = 0 as *mut Sym;
    vset(&mut type_0, r, v);
}
unsafe extern "C" fn vpushv(mut v: *mut SValue) {
    if vtop
        >= _vstack
            .as_mut_ptr()
            .offset(1 as libc::c_int as isize)
            .offset((512 as libc::c_int - 1 as libc::c_int) as isize)
    {
        _tcc_error(b"memory full (vstack)\0" as *const u8 as *const libc::c_char);
    }
    vtop = vtop.offset(1);
    vtop;
    *vtop = *v;
}
unsafe extern "C" fn vdup() {
    vpushv(vtop);
}
unsafe extern "C" fn vrotb(mut n: libc::c_int) {
    let mut tmp: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    n -= 1;
    if n < 1 as libc::c_int {
        return;
    }
    vcheck_cmp();
    tmp = *vtop.offset(-n as isize);
    memmove(
        vtop.offset(-(n as isize)) as *mut libc::c_void,
        vtop.offset(-(n as isize)).offset(1 as libc::c_int as isize)
            as *const libc::c_void,
        (::core::mem::size_of::<SValue>() as libc::c_ulong)
            .wrapping_mul(n as libc::c_ulong),
    );
    *vtop.offset(0 as libc::c_int as isize) = tmp;
}
unsafe extern "C" fn vrott(mut n: libc::c_int) {
    let mut tmp: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    n -= 1;
    if n < 1 as libc::c_int {
        return;
    }
    vcheck_cmp();
    tmp = *vtop.offset(0 as libc::c_int as isize);
    memmove(
        vtop.offset(-(n as isize)).offset(1 as libc::c_int as isize)
            as *mut libc::c_void,
        vtop.offset(-(n as isize)) as *const libc::c_void,
        (::core::mem::size_of::<SValue>() as libc::c_ulong)
            .wrapping_mul(n as libc::c_ulong),
    );
    *vtop.offset(-n as isize) = tmp;
}
unsafe extern "C" fn vrev(mut n: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut tmp: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    vcheck_cmp();
    i = 0 as libc::c_int;
    n = -n;
    loop {
        n += 1;
        if !(i > n) {
            break;
        }
        tmp = *vtop.offset(i as isize);
        *vtop.offset(i as isize) = *vtop.offset(n as isize);
        *vtop.offset(n as isize) = tmp;
        i -= 1;
        i;
    };
}
unsafe extern "C" fn vset_VT_CMP(mut op: libc::c_int) {
    (*vtop).r = 0x33 as libc::c_int as libc::c_ushort;
    (*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_op = op as libc::c_ushort;
    (*vtop).c2rust_unnamed.c2rust_unnamed.jfalse = 0 as libc::c_int;
    (*vtop).c2rust_unnamed.c2rust_unnamed.jtrue = 0 as libc::c_int;
}
unsafe extern "C" fn vset_VT_JMP() {
    let mut op: libc::c_int = (*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_op
        as libc::c_int;
    if (*vtop).c2rust_unnamed.c2rust_unnamed.jtrue != 0
        || (*vtop).c2rust_unnamed.c2rust_unnamed.jfalse != 0
    {
        let mut origt: libc::c_int = (*vtop).type_0.t;
        let mut inv: libc::c_int = op & (op < 2 as libc::c_int) as libc::c_int;
        vseti(0x34 as libc::c_int + inv, gvtst(inv, 0 as libc::c_int));
        (*vtop).type_0.t |= origt & (0x10 as libc::c_int | 0x20 as libc::c_int);
    } else {
        (*vtop).c2rust_unnamed.c.i = op as uint64_t;
        if op < 2 as libc::c_int {
            (*vtop).r = 0x30 as libc::c_int as libc::c_ushort;
        }
    };
}
unsafe extern "C" fn gvtst_set(mut inv: libc::c_int, mut t: libc::c_int) {
    let mut p: *mut libc::c_int = 0 as *mut libc::c_int;
    if (*vtop).r as libc::c_int != 0x33 as libc::c_int {
        vpushi(0 as libc::c_int);
        gen_op(0x95 as libc::c_int);
        if (*vtop).r as libc::c_int != 0x33 as libc::c_int {
            vset_VT_CMP(
                ((*vtop).c2rust_unnamed.c.i != 0 as libc::c_int as uint64_t)
                    as libc::c_int,
            );
        }
    }
    p = if inv != 0 {
        &mut (*vtop).c2rust_unnamed.c2rust_unnamed.jfalse
    } else {
        &mut (*vtop).c2rust_unnamed.c2rust_unnamed.jtrue
    };
    *p = gjmp_append(*p, t);
}
unsafe extern "C" fn gvtst(mut inv: libc::c_int, mut t: libc::c_int) -> libc::c_int {
    let mut op: libc::c_int = 0;
    let mut x: libc::c_int = 0;
    let mut u: libc::c_int = 0;
    gvtst_set(inv, t);
    t = (*vtop).c2rust_unnamed.c2rust_unnamed.jtrue;
    u = (*vtop).c2rust_unnamed.c2rust_unnamed.jfalse;
    if inv != 0 {
        x = u;
        u = t;
        t = x;
    }
    op = (*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_op as libc::c_int;
    if op > 1 as libc::c_int {
        t = gjmp_cond(op ^ inv, t);
    } else if op != inv {
        t = gjmp_acs(t);
    }
    gsym(u);
    vtop = vtop.offset(-1);
    vtop;
    return t;
}
unsafe extern "C" fn gen_test_zero(mut op: libc::c_int) {
    if (*vtop).r as libc::c_int == 0x33 as libc::c_int {
        let mut j: libc::c_int = 0;
        if op == 0x94 as libc::c_int {
            j = (*vtop).c2rust_unnamed.c2rust_unnamed.jfalse;
            (*vtop)
                .c2rust_unnamed
                .c2rust_unnamed
                .jfalse = (*vtop).c2rust_unnamed.c2rust_unnamed.jtrue;
            (*vtop).c2rust_unnamed.c2rust_unnamed.jtrue = j;
            (*vtop)
                .c2rust_unnamed_0
                .c2rust_unnamed
                .cmp_op = ((*vtop).c2rust_unnamed_0.c2rust_unnamed.cmp_op as libc::c_int
                ^ 1 as libc::c_int) as libc::c_ushort;
        }
    } else {
        vpushi(0 as libc::c_int);
        gen_op(op);
    };
}
unsafe extern "C" fn vpushsym(mut type_0: *mut CType, mut sym: *mut Sym) {
    let mut cval: CValue = CValue { ld: f128::f128::ZERO };
    cval.i = 0 as libc::c_int as uint64_t;
    vsetc(type_0, 0x30 as libc::c_int | 0x200 as libc::c_int, &mut cval);
    (*vtop).c2rust_unnamed_0.sym = sym;
}
unsafe extern "C" fn get_sym_ref(
    mut type_0: *mut CType,
    mut sec: *mut Section,
    mut offset: libc::c_ulong,
    mut size: libc::c_ulong,
) -> *mut Sym {
    let mut v: libc::c_int = 0;
    let mut sym: *mut Sym = 0 as *mut Sym;
    let fresh154 = anon_sym;
    anon_sym = anon_sym + 1;
    v = fresh154;
    sym = sym_push(
        v,
        type_0,
        0x30 as libc::c_int | 0x200 as libc::c_int,
        0 as libc::c_int,
    );
    (*sym).type_0.t |= 0x2000 as libc::c_int;
    put_extern_sym(sym, sec, offset, size);
    return sym;
}
unsafe extern "C" fn vpush_ref(
    mut type_0: *mut CType,
    mut sec: *mut Section,
    mut offset: libc::c_ulong,
    mut size: libc::c_ulong,
) {
    vpushsym(type_0, get_sym_ref(type_0, sec, offset, size));
}
unsafe extern "C" fn external_global_sym(
    mut v: libc::c_int,
    mut type_0: *mut CType,
) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    s = sym_find(v);
    if s.is_null() {
        s = global_identifier_push(
            v,
            (*type_0).t | 0x1000 as libc::c_int,
            0 as libc::c_int,
        );
        (*s).type_0.ref_0 = (*type_0).ref_0;
    } else if (*s).type_0.t
        & (0xf as libc::c_int
            | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int))
        == 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
    {
        (*s).type_0.t = (*type_0).t | (*s).type_0.t & 0x1000 as libc::c_int;
        (*s).type_0.ref_0 = (*type_0).ref_0;
        update_storage(s);
    }
    return s;
}
unsafe extern "C" fn external_helper_sym(mut v: libc::c_int) -> *mut Sym {
    let mut ct: CType = {
        let mut init = CType {
            t: 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
                | (2 as libc::c_int) << 20 as libc::c_int,
            ref_0: 0 as *mut Sym,
        };
        init
    };
    return external_global_sym(v, &mut ct);
}
unsafe extern "C" fn vpush_helper_func(mut v: libc::c_int) {
    vpushsym(&mut func_old_type, external_helper_sym(v));
}
unsafe extern "C" fn merge_symattr(mut sa: *mut SymAttr, mut sa1: *mut SymAttr) {
    if (*sa1).aligned() as libc::c_int != 0 && (*sa).aligned() == 0 {
        (*sa).set_aligned((*sa1).aligned());
    }
    (*sa).set_packed((*sa).packed() | (*sa1).packed() as libc::c_int as libc::c_ushort);
    (*sa).set_weak((*sa).weak() | (*sa1).weak() as libc::c_int as libc::c_ushort);
    (*sa)
        .set_nodebug(
            (*sa).nodebug() | (*sa1).nodebug() as libc::c_int as libc::c_ushort,
        );
    if (*sa1).visibility() as libc::c_int != 0 as libc::c_int {
        let mut vis: libc::c_int = (*sa).visibility() as libc::c_int;
        if vis == 0 as libc::c_int || vis > (*sa1).visibility() as libc::c_int {
            vis = (*sa1).visibility() as libc::c_int;
        }
        (*sa).set_visibility(vis as libc::c_ushort);
    }
    (*sa)
        .set_dllexport(
            (*sa).dllexport() | (*sa1).dllexport() as libc::c_int as libc::c_ushort,
        );
    (*sa)
        .set_nodecorate(
            (*sa).nodecorate() | (*sa1).nodecorate() as libc::c_int as libc::c_ushort,
        );
    (*sa)
        .set_dllimport(
            (*sa).dllimport() | (*sa1).dllimport() as libc::c_int as libc::c_ushort,
        );
}
unsafe extern "C" fn merge_funcattr(mut fa: *mut FuncAttr, mut fa1: *mut FuncAttr) {
    if (*fa1).func_call() as libc::c_int != 0 && (*fa).func_call() == 0 {
        (*fa).set_func_call((*fa1).func_call());
    }
    if (*fa1).func_type() as libc::c_int != 0 && (*fa).func_type() == 0 {
        (*fa).set_func_type((*fa1).func_type());
    }
    if (*fa1).func_args() as libc::c_int != 0 && (*fa).func_args() == 0 {
        (*fa).set_func_args((*fa1).func_args());
    }
    if (*fa1).func_noreturn() != 0 {
        (*fa).set_func_noreturn(1 as libc::c_int as libc::c_uint);
    }
    if (*fa1).func_ctor() != 0 {
        (*fa).set_func_ctor(1 as libc::c_int as libc::c_uint);
    }
    if (*fa1).func_dtor() != 0 {
        (*fa).set_func_dtor(1 as libc::c_int as libc::c_uint);
    }
}
unsafe extern "C" fn merge_attr(mut ad: *mut AttributeDef, mut ad1: *mut AttributeDef) {
    merge_symattr(&mut (*ad).a, &mut (*ad1).a);
    merge_funcattr(&mut (*ad).f, &mut (*ad1).f);
    if !((*ad1).section).is_null() {
        (*ad).section = (*ad1).section;
    }
    if (*ad1).alias_target != 0 {
        (*ad).alias_target = (*ad1).alias_target;
    }
    if (*ad1).asm_label != 0 {
        (*ad).asm_label = (*ad1).asm_label;
    }
    if (*ad1).attr_mode != 0 {
        (*ad).attr_mode = (*ad1).attr_mode;
    }
}
unsafe extern "C" fn patch_type(mut sym: *mut Sym, mut type_0: *mut CType) {
    if (*type_0).t & 0x1000 as libc::c_int == 0
        || (*sym).type_0.t as libc::c_uint
            & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint)
            == ((3 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
    {
        if (*sym).type_0.t & 0x1000 as libc::c_int == 0 {
            _tcc_error(
                b"redefinition of '%s'\0" as *const u8 as *const libc::c_char,
                get_tok_str((*sym).v, 0 as *mut CValue),
            );
        }
        (*sym).type_0.t &= !(0x1000 as libc::c_int);
    }
    if (*sym).type_0.t
        & (0xf as libc::c_int
            | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int))
        == 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
    {
        (*sym).type_0.t = (*type_0).t & ((*sym).type_0.t | !(0x2000 as libc::c_int));
        (*sym).type_0.ref_0 = (*type_0).ref_0;
        if (*type_0).t & 0xf as libc::c_int != 6 as libc::c_int
            && (*type_0).t & 0x40 as libc::c_int == 0
        {
            (*sym)
                .r = ((*sym).r as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
        }
    }
    if is_compatible_types(&mut (*sym).type_0, type_0) == 0 {
        _tcc_error(
            b"incompatible types for redefinition of '%s'\0" as *const u8
                as *const libc::c_char,
            get_tok_str((*sym).v, 0 as *mut CValue),
        );
    } else if (*sym).type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
        let mut static_proto: libc::c_int = (*sym).type_0.t & 0x2000 as libc::c_int;
        if (*type_0).t & 0x2000 as libc::c_int != 0 && static_proto == 0
            && ((*type_0).t | (*sym).type_0.t) & 0x8000 as libc::c_int == 0
        {
            _tcc_warning(
                b"static storage ignored for redefinition of '%s'\0" as *const u8
                    as *const libc::c_char,
                get_tok_str((*sym).v, 0 as *mut CValue),
            );
        }
        if ((*type_0).t | (*sym).type_0.t) & 0x8000 as libc::c_int != 0 {
            if ((*type_0).t ^ (*sym).type_0.t) & 0x8000 as libc::c_int == 0
                || ((*type_0).t | (*sym).type_0.t) & 0x2000 as libc::c_int != 0
            {
                static_proto |= 0x8000 as libc::c_int;
            }
        }
        if 0 as libc::c_int == (*type_0).t & 0x1000 as libc::c_int {
            let mut f: FuncAttr = (*(*sym).type_0.ref_0)
                .c2rust_unnamed
                .c2rust_unnamed
                .c2rust_unnamed
                .f;
            (*sym)
                .type_0
                .t = (*type_0).t & !(0x2000 as libc::c_int | 0x8000 as libc::c_int)
                | static_proto;
            (*sym).type_0.ref_0 = (*type_0).ref_0;
            merge_funcattr(
                &mut (*(*sym).type_0.ref_0)
                    .c2rust_unnamed
                    .c2rust_unnamed
                    .c2rust_unnamed
                    .f,
                &mut f,
            );
        } else {
            (*sym).type_0.t &= !(0x8000 as libc::c_int) | static_proto;
        }
        if ((*(*sym).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
            .func_type() as libc::c_int == 2 as libc::c_int
            && ((*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
                .func_type() as libc::c_int != 2 as libc::c_int
        {
            (*sym).type_0.ref_0 = (*type_0).ref_0;
        }
    } else {
        if (*sym).type_0.t & 0x40 as libc::c_int != 0
            && (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c >= 0 as libc::c_int
        {
            (*(*sym).type_0.ref_0)
                .c2rust_unnamed
                .c2rust_unnamed
                .c = (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c;
        }
        if ((*type_0).t ^ (*sym).type_0.t) & 0x2000 as libc::c_int != 0 {
            _tcc_warning(
                b"storage mismatch for redefinition of '%s'\0" as *const u8
                    as *const libc::c_char,
                get_tok_str((*sym).v, 0 as *mut CValue),
            );
        }
    };
}
unsafe extern "C" fn patch_storage(
    mut sym: *mut Sym,
    mut ad: *mut AttributeDef,
    mut type_0: *mut CType,
) {
    if !type_0.is_null() {
        patch_type(sym, type_0);
    }
    merge_symattr(&mut (*sym).a, &mut (*ad).a);
    if (*ad).asm_label != 0 {
        (*sym).c2rust_unnamed_0.asm_label = (*ad).asm_label;
    }
    update_storage(sym);
}
unsafe extern "C" fn sym_copy(mut s0: *mut Sym, mut ps: *mut *mut Sym) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    s = sym_malloc();
    *s = *s0;
    (*s).prev = *ps;
    *ps = s;
    if (*s).v < 0x10000000 as libc::c_int {
        ps = &mut (**table_ident.offset(((*s).v - 256 as libc::c_int) as isize))
            .sym_identifier;
        (*s).prev_tok = *ps;
        *ps = s;
    }
    return s;
}
unsafe extern "C" fn sym_copy_ref(mut s: *mut Sym, mut ps: *mut *mut Sym) {
    let mut bt: libc::c_int = (*s).type_0.t & 0xf as libc::c_int;
    if bt == 6 as libc::c_int || bt == 5 as libc::c_int
        || bt == 7 as libc::c_int
            && (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope != 0
    {
        let mut sp: *mut *mut Sym = &mut (*s).type_0.ref_0;
        s = *sp;
        *sp = 0 as *mut Sym;
        while !s.is_null() {
            let mut s2: *mut Sym = sym_copy(s, ps);
            *sp = s2;
            sp = &mut (**sp).c2rust_unnamed_0.next;
            sym_copy_ref(s2, ps);
            s = (*s).c2rust_unnamed_0.next;
        }
    }
}
unsafe extern "C" fn external_sym(
    mut v: libc::c_int,
    mut type_0: *mut CType,
    mut r: libc::c_int,
    mut ad: *mut AttributeDef,
) -> *mut Sym {
    let mut s: *mut Sym = 0 as *mut Sym;
    s = sym_find(v);
    while !s.is_null()
        && (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope != 0
    {
        s = (*s).prev_tok;
    }
    if s.is_null() {
        s = global_identifier_push(v, (*type_0).t, 0 as libc::c_int);
        (*s).r = ((*s).r as libc::c_int | r) as libc::c_ushort;
        (*s).a = (*ad).a;
        (*s).c2rust_unnamed_0.asm_label = (*ad).asm_label;
        (*s).type_0.ref_0 = (*type_0).ref_0;
        if !local_stack.is_null() {
            sym_copy_ref(s, &mut global_stack);
        }
    } else {
        patch_storage(s, ad, type_0);
    }
    if !local_stack.is_null() && (*s).type_0.t & 0xf as libc::c_int != 6 as libc::c_int {
        s = sym_copy(s, &mut local_stack);
    }
    return s;
}
unsafe extern "C" fn save_regs(mut n: libc::c_int) {
    let mut p: *mut SValue = 0 as *mut SValue;
    let mut p1: *mut SValue = 0 as *mut SValue;
    p = _vstack.as_mut_ptr().offset(1 as libc::c_int as isize);
    p1 = vtop.offset(-(n as isize));
    while p <= p1 {
        save_reg((*p).r as libc::c_int);
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn save_reg(mut r: libc::c_int) {
    save_reg_upstack(r, 0 as libc::c_int);
}
unsafe extern "C" fn save_reg_upstack(mut r: libc::c_int, mut n: libc::c_int) {
    let mut l: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut r2: libc::c_int = 0;
    let mut p: *mut SValue = 0 as *mut SValue;
    let mut p1: *mut SValue = 0 as *mut SValue;
    let mut sv: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    r &= 0x3f as libc::c_int;
    if r >= 0x30 as libc::c_int {
        return;
    }
    if nocode_wanted != 0 {
        return;
    }
    r2 = 0 as libc::c_int;
    l = r2;
    let mut current_block_30: u64;
    p = _vstack.as_mut_ptr().offset(1 as libc::c_int as isize);
    p1 = vtop.offset(-(n as isize));
    while p <= p1 {
        if (*p).r as libc::c_int & 0x3f as libc::c_int == r
            || (*p).r2 as libc::c_int == r
        {
            if l == 0 {
                bt = (*p).type_0.t & 0xf as libc::c_int;
                if bt == 0 as libc::c_int {
                    current_block_30 = 7502529970979898288;
                } else {
                    if (*p).r as libc::c_int & 0x100 as libc::c_int != 0
                        || bt == 6 as libc::c_int
                    {
                        bt = 5 as libc::c_int;
                    }
                    sv.type_0.t = bt;
                    size = type_size(&mut sv.type_0, &mut align);
                    l = get_temp_local_var(size, align, &mut r2);
                    sv
                        .r = (0x32 as libc::c_int | 0x100 as libc::c_int)
                        as libc::c_ushort;
                    sv.c2rust_unnamed.c.i = l as uint64_t;
                    store((*p).r as libc::c_int & 0x3f as libc::c_int, &mut sv);
                    if r == TREG_ST0 as libc::c_int {
                        o(0xd8dd as libc::c_int as libc::c_uint);
                    }
                    if ((*p).r2 as libc::c_int) < 0x30 as libc::c_int
                        && R2_RET(bt) != 0x30 as libc::c_int
                    {
                        sv
                            .c2rust_unnamed
                            .c
                            .i = (sv.c2rust_unnamed.c.i)
                            .wrapping_add(8 as libc::c_int as uint64_t);
                        store((*p).r2 as libc::c_int, &mut sv);
                    }
                    current_block_30 = 13797916685926291137;
                }
            } else {
                current_block_30 = 13797916685926291137;
            }
            match current_block_30 {
                7502529970979898288 => {}
                _ => {
                    if (*p).r as libc::c_int & 0x100 as libc::c_int != 0 {
                        (*p)
                            .r = ((*p).r as libc::c_int
                            & !(0x3f as libc::c_int | 0x8000 as libc::c_int)
                            | 0x31 as libc::c_int) as libc::c_ushort;
                    } else {
                        (*p)
                            .r = (0x100 as libc::c_int | 0x32 as libc::c_int)
                            as libc::c_ushort;
                        (*p).type_0.t &= !(0x40 as libc::c_int);
                    }
                    (*p).c2rust_unnamed_0.sym = 0 as *mut Sym;
                    (*p).r2 = r2 as libc::c_ushort;
                    (*p).c2rust_unnamed.c.i = l as uint64_t;
                }
            }
        }
        p = p.offset(1);
        p;
    }
}
unsafe extern "C" fn get_reg(mut rc: libc::c_int) -> libc::c_int {
    let mut r: libc::c_int = 0;
    let mut p: *mut SValue = 0 as *mut SValue;
    r = 0 as libc::c_int;
    while r < 25 as libc::c_int {
        let mut current_block_5: u64;
        if reg_classes[r as usize] & rc != 0 {
            if nocode_wanted != 0 {
                return r;
            }
            p = _vstack.as_mut_ptr().offset(1 as libc::c_int as isize);
            loop {
                if !(p <= vtop) {
                    current_block_5 = 10886091980245723256;
                    break;
                }
                if (*p).r as libc::c_int & 0x3f as libc::c_int == r
                    || (*p).r2 as libc::c_int == r
                {
                    current_block_5 = 1917311967535052937;
                    break;
                }
                p = p.offset(1);
                p;
            }
            match current_block_5 {
                1917311967535052937 => {}
                _ => return r,
            }
        }
        r += 1;
        r;
    }
    p = _vstack.as_mut_ptr().offset(1 as libc::c_int as isize);
    while p <= vtop {
        's_92: {
            r = (*p).r2 as libc::c_int;
            if !(r < 0x30 as libc::c_int && reg_classes[r as usize] & rc != 0) {
                r = (*p).r as libc::c_int & 0x3f as libc::c_int;
                if !(r < 0x30 as libc::c_int && reg_classes[r as usize] & rc != 0) {
                    break 's_92;
                }
            }
            save_reg(r);
            return r;
        }
        p = p.offset(1);
        p;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn get_temp_local_var(
    mut size: libc::c_int,
    mut align: libc::c_int,
    mut r2: *mut libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut temp_var: *mut temp_local_variable = 0 as *mut temp_local_variable;
    let mut p: *mut SValue = 0 as *mut SValue;
    let mut r: libc::c_int = 0;
    let mut used: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    p = _vstack.as_mut_ptr().offset(1 as libc::c_int as isize);
    while p <= vtop {
        r = (*p).r as libc::c_int & 0x3f as libc::c_int;
        if r == 0x32 as libc::c_int || r == 0x31 as libc::c_int {
            r = (*p).r2 as libc::c_int - (0x30 as libc::c_int + 1 as libc::c_int);
            if r >= 0 as libc::c_int && r < 8 as libc::c_int {
                used |= ((1 as libc::c_int) << r) as libc::c_uint;
            }
        }
        p = p.offset(1);
        p;
    }
    i = 0 as libc::c_int;
    loop {
        if i < nb_temp_local_vars {
            temp_var = &mut *arr_temp_local_vars.as_mut_ptr().offset(i as isize)
                as *mut temp_local_variable;
            if used & ((1 as libc::c_int) << i) as libc::c_uint == 0
                && (*temp_var).size as libc::c_int >= size
                && (*temp_var).align as libc::c_int >= align
            {
                current_block = 17026858683489660939;
                break;
            }
            i += 1;
            i;
        } else {
            loc = loc - size & -align;
            if nb_temp_local_vars < 8 as libc::c_int {
                current_block = 12039483399334584727;
                break;
            } else {
                current_block = 4808432441040389987;
                break;
            }
        }
    }
    match current_block {
        12039483399334584727 => {
            temp_var = &mut *arr_temp_local_vars.as_mut_ptr().offset(i as isize)
                as *mut temp_local_variable;
            (*temp_var).location = loc;
            (*temp_var).size = size as libc::c_short;
            (*temp_var).align = align as libc::c_short;
            nb_temp_local_vars += 1;
            nb_temp_local_vars;
        }
        4808432441040389987 => {
            *r2 = 0x30 as libc::c_int;
            return loc;
        }
        _ => {}
    }
    *r2 = 0x30 as libc::c_int + 1 as libc::c_int + i;
    return (*temp_var).location;
}
unsafe extern "C" fn move_reg(
    mut r: libc::c_int,
    mut s: libc::c_int,
    mut t: libc::c_int,
) {
    let mut sv: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    if r != s {
        save_reg(r);
        sv.type_0.t = t;
        sv.type_0.ref_0 = 0 as *mut Sym;
        sv.r = s as libc::c_ushort;
        sv.c2rust_unnamed.c.i = 0 as libc::c_int as uint64_t;
        load(r, &mut sv);
    }
}
unsafe extern "C" fn gaddrof() {
    (*vtop).r = ((*vtop).r as libc::c_int & !(0x100 as libc::c_int)) as libc::c_ushort;
    if (*vtop).r as libc::c_int & 0x3f as libc::c_int == 0x31 as libc::c_int {
        (*vtop)
            .r = ((*vtop).r as libc::c_int & !(0x3f as libc::c_int) | 0x32 as libc::c_int
            | 0x100 as libc::c_int) as libc::c_ushort;
    }
}
unsafe extern "C" fn gen_bounded_ptr_add() {
    let mut save: libc::c_int = ((*vtop.offset(-(1 as libc::c_int) as isize)).r
        as libc::c_int & 0x3f as libc::c_int == 0x32 as libc::c_int) as libc::c_int;
    if save != 0 {
        vpushv(&mut *vtop.offset(-(1 as libc::c_int) as isize));
        vrott(3 as libc::c_int);
    }
    vpush_helper_func(TOK___bound_ptr_add as libc::c_int);
    vrott(3 as libc::c_int);
    gfunc_call(2 as libc::c_int);
    vtop = vtop.offset(-(save as isize));
    vpushi(0 as libc::c_int);
    (*vtop).r = (TREG_RAX as libc::c_int | 0x8000 as libc::c_int) as libc::c_ushort;
    if nocode_wanted != 0 {
        return;
    }
    (*vtop)
        .c2rust_unnamed
        .c
        .i = ((*(*(*tcc_state).cur_text_section).reloc).data_offset)
        .wrapping_sub(::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong);
}
unsafe extern "C" fn gen_bounded_ptr_deref() {
    let mut func: Elf64_Addr = 0;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut sym: *mut Sym = 0 as *mut Sym;
    if nocode_wanted != 0 {
        return;
    }
    size = type_size(&mut (*vtop).type_0, &mut align);
    match size {
        1 => {
            func = TOK___bound_ptr_indir1 as libc::c_int as Elf64_Addr;
        }
        2 => {
            func = TOK___bound_ptr_indir2 as libc::c_int as Elf64_Addr;
        }
        4 => {
            func = TOK___bound_ptr_indir4 as libc::c_int as Elf64_Addr;
        }
        8 => {
            func = TOK___bound_ptr_indir8 as libc::c_int as Elf64_Addr;
        }
        12 => {
            func = TOK___bound_ptr_indir12 as libc::c_int as Elf64_Addr;
        }
        16 => {
            func = TOK___bound_ptr_indir16 as libc::c_int as Elf64_Addr;
        }
        _ => return,
    }
    sym = external_helper_sym(func as libc::c_int);
    if (*sym).c2rust_unnamed.c2rust_unnamed.c == 0 {
        put_extern_sym(
            sym,
            0 as *mut Section,
            0 as libc::c_int as Elf64_Addr,
            0 as libc::c_int as libc::c_ulong,
        );
    }
    rel = ((*(*(*tcc_state).cur_text_section).reloc).data)
        .offset((*vtop).c2rust_unnamed.c.i as isize) as *mut Elf64_Rela;
    (*rel)
        .r_info = (((*sym).c2rust_unnamed.c2rust_unnamed.c as Elf64_Xword)
        << 32 as libc::c_int)
        .wrapping_add((*rel).r_info & 0xffffffff as libc::c_uint as Elf64_Xword);
}
unsafe extern "C" fn gbound() {
    let mut type1: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    (*vtop).r = ((*vtop).r as libc::c_int & !(0x4000 as libc::c_int)) as libc::c_ushort;
    if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {
        if (*vtop).r as libc::c_int & 0x8000 as libc::c_int == 0 {
            type1 = (*vtop).type_0;
            (*vtop).type_0.t = 5 as libc::c_int;
            gaddrof();
            vpushi(0 as libc::c_int);
            gen_bounded_ptr_add();
            (*vtop)
                .r = ((*vtop).r as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
            (*vtop).type_0 = type1;
        }
        gen_bounded_ptr_deref();
    }
}
unsafe extern "C" fn gbound_args(mut nb_args: libc::c_int) {
    let mut i: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut sv: *mut SValue = 0 as *mut SValue;
    i = 1 as libc::c_int;
    while i <= nb_args {
        if (*vtop.offset((1 as libc::c_int - i) as isize)).r as libc::c_int
            & 0x4000 as libc::c_int != 0
        {
            vrotb(i);
            gbound();
            vrott(i);
        }
        i += 1;
        i;
    }
    sv = vtop.offset(-(nb_args as isize));
    if (*sv).r as libc::c_int & 0x200 as libc::c_int != 0 {
        v = (*(*sv).c2rust_unnamed_0.sym).v;
        if v == TOK_setjmp as libc::c_int || v == TOK__setjmp as libc::c_int
            || v == TOK_sigsetjmp as libc::c_int || v == TOK___sigsetjmp as libc::c_int
        {
            vpush_helper_func(TOK___bound_setjmp as libc::c_int);
            vpushv(sv.offset(1 as libc::c_int as isize));
            gfunc_call(1 as libc::c_int);
            func_bound_add_epilog = 1 as libc::c_int;
        }
        if v == TOK_alloca as libc::c_int {
            func_bound_add_epilog = 1 as libc::c_int;
        }
    }
}
unsafe extern "C" fn add_local_bounds(mut s: *mut Sym, mut e: *mut Sym) {
    while s != e {
        if !((*s).v == 0
            || (*s).r as libc::c_int & 0x3f as libc::c_int != 0x32 as libc::c_int)
        {
            if (*s).type_0.t & 0x40 as libc::c_int != 0
                || (*s).type_0.t & 0xf as libc::c_int == 7 as libc::c_int
                || ((*s).a).addrtaken() as libc::c_int != 0
            {
                let mut align: libc::c_int = 0;
                let mut size: libc::c_int = type_size(&mut (*s).type_0, &mut align);
                let mut bounds_ptr: *mut Elf64_Addr = section_ptr_add(
                    (*tcc_state).lbounds_section,
                    (2 as libc::c_int as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<Elf64_Addr>() as libc::c_ulong,
                        ),
                ) as *mut Elf64_Addr;
                *bounds_ptr
                    .offset(
                        0 as libc::c_int as isize,
                    ) = (*s).c2rust_unnamed.c2rust_unnamed.c as Elf64_Addr;
                *bounds_ptr.offset(1 as libc::c_int as isize) = size as Elf64_Addr;
            }
        }
        s = (*s).prev;
    }
}
unsafe extern "C" fn pop_local_syms(mut b: *mut Sym, mut keep: libc::c_int) {
    if (*tcc_state).do_bounds_check as libc::c_int != 0 && keep == 0
        && (local_scope != 0 || func_var == 0)
    {
        add_local_bounds(local_stack, b);
    }
    if debug_modes != 0 {
        tcc_add_debug_info(tcc_state, (local_scope == 0) as libc::c_int, local_stack, b);
    }
    sym_pop(&mut local_stack, b, keep);
}
unsafe extern "C" fn incr_offset(mut offset: libc::c_int) {
    let mut t: libc::c_int = (*vtop).type_0.t;
    gaddrof();
    (*vtop).type_0.t = 0x800 as libc::c_int | 4 as libc::c_int;
    vpushs(offset as Elf64_Addr);
    gen_op('+' as i32);
    (*vtop).r = ((*vtop).r as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
    (*vtop).type_0.t = t;
}
unsafe extern "C" fn incr_bf_adr(mut o_0: libc::c_int) {
    (*vtop).type_0.t = 1 as libc::c_int | 0x10 as libc::c_int;
    incr_offset(o_0);
}
unsafe extern "C" fn load_packed_bf(
    mut type_0: *mut CType,
    mut bit_pos: libc::c_int,
    mut bit_size: libc::c_int,
) {
    let mut n: libc::c_int = 0;
    let mut o_0: libc::c_int = 0;
    let mut bits: libc::c_int = 0;
    save_reg_upstack((*vtop).r as libc::c_int, 1 as libc::c_int);
    vpush64((*type_0).t & 0xf as libc::c_int, 0 as libc::c_int as libc::c_ulonglong);
    bits = 0 as libc::c_int;
    o_0 = bit_pos >> 3 as libc::c_int;
    bit_pos &= 7 as libc::c_int;
    loop {
        vswap();
        incr_bf_adr(o_0);
        vdup();
        n = 8 as libc::c_int - bit_pos;
        if n > bit_size {
            n = bit_size;
        }
        if bit_pos != 0 {
            vpushi(bit_pos);
            gen_op(0x8b as libc::c_int);
            bit_pos = 0 as libc::c_int;
        }
        if n < 8 as libc::c_int {
            vpushi(((1 as libc::c_int) << n) - 1 as libc::c_int);
            gen_op('&' as i32);
        }
        gen_cast(type_0);
        if bits != 0 {
            vpushi(bits);
            gen_op('<' as i32);
        }
        vrotb(3 as libc::c_int);
        gen_op('|' as i32);
        bits += n;
        bit_size -= n;
        o_0 = 1 as libc::c_int;
        if !(bit_size != 0) {
            break;
        }
    }
    vswap();
    vpop();
    if (*type_0).t & 0x10 as libc::c_int == 0 {
        n = (if (*type_0).t & 0xf as libc::c_int == 4 as libc::c_int {
            64 as libc::c_int
        } else {
            32 as libc::c_int
        }) - bits;
        vpushi(n);
        gen_op('<' as i32);
        vpushi(n);
        gen_op('>' as i32);
    }
}
unsafe extern "C" fn store_packed_bf(
    mut bit_pos: libc::c_int,
    mut bit_size: libc::c_int,
) {
    let mut bits: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut o_0: libc::c_int = 0;
    let mut m: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    c = ((*vtop).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int) as libc::c_int;
    vswap();
    save_reg_upstack((*vtop).r as libc::c_int, 1 as libc::c_int);
    bits = 0 as libc::c_int;
    o_0 = bit_pos >> 3 as libc::c_int;
    bit_pos &= 7 as libc::c_int;
    loop {
        incr_bf_adr(o_0);
        vswap();
        if c != 0 {
            vdup();
        } else {
            gv_dup();
        };
        vrott(3 as libc::c_int);
        if bits != 0 {
            vpushi(bits);
            gen_op(0x8b as libc::c_int);
        }
        if bit_pos != 0 {
            vpushi(bit_pos);
            gen_op('<' as i32);
        }
        n = 8 as libc::c_int - bit_pos;
        if n > bit_size {
            n = bit_size;
        }
        if n < 8 as libc::c_int {
            m = (((1 as libc::c_int) << n) - 1 as libc::c_int) << bit_pos;
            vpushi(m);
            gen_op('&' as i32);
            vpushv(vtop.offset(-(1 as libc::c_int as isize)));
            vpushi(
                if m & 0x80 as libc::c_int != 0 { !m & 0x7f as libc::c_int } else { !m },
            );
            gen_op('&' as i32);
            gen_op('|' as i32);
        }
        vdup();
        *vtop
            .offset(
                -(1 as libc::c_int) as isize,
            ) = *vtop.offset(-(2 as libc::c_int) as isize);
        vstore();
        vpop();
        bits += n;
        bit_size -= n;
        bit_pos = 0 as libc::c_int;
        o_0 = 1 as libc::c_int;
        if !(bit_size != 0) {
            break;
        }
    }
    vpop();
    vpop();
}
unsafe extern "C" fn adjust_bf(
    mut sv: *mut SValue,
    mut bit_pos: libc::c_int,
    mut bit_size: libc::c_int,
) -> libc::c_int {
    let mut t: libc::c_int = 0;
    if ((*sv).type_0.ref_0).is_null() {
        return 0 as libc::c_int;
    }
    t = (*(*sv).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.auxtype;
    if t != -(1 as libc::c_int) && t != 7 as libc::c_int {
        (*sv)
            .type_0
            .t = (*sv).type_0.t & !(0xf as libc::c_int | 0x800 as libc::c_int) | t;
        (*sv).r = ((*sv).r as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
    }
    return t;
}
unsafe extern "C" fn gv(mut rc: libc::c_int) -> libc::c_int {
    let mut r: libc::c_int = 0;
    let mut r2: libc::c_int = 0;
    let mut r_ok: libc::c_int = 0;
    let mut r2_ok: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut bit_pos: libc::c_int = 0;
    let mut bit_size: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    if (*vtop).type_0.t & 0x80 as libc::c_int != 0 {
        let mut type_0: CType = CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        };
        bit_pos = (*vtop).type_0.t >> 20 as libc::c_int & 0x3f as libc::c_int;
        bit_size = (*vtop).type_0.t >> 20 as libc::c_int + 6 as libc::c_int
            & 0x3f as libc::c_int;
        (*vtop)
            .type_0
            .t = ((*vtop).type_0.t as libc::c_uint
            & !(((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint)) as libc::c_int;
        type_0.ref_0 = 0 as *mut Sym;
        type_0.t = (*vtop).type_0.t & 0x10 as libc::c_int;
        if (*vtop).type_0.t & 0xf as libc::c_int == 11 as libc::c_int {
            type_0.t |= 0x10 as libc::c_int;
        }
        r = adjust_bf(vtop, bit_pos, bit_size);
        if (*vtop).type_0.t & 0xf as libc::c_int == 4 as libc::c_int {
            type_0.t |= 4 as libc::c_int;
        } else {
            type_0.t |= 3 as libc::c_int;
        }
        if r == 7 as libc::c_int {
            load_packed_bf(&mut type_0, bit_pos, bit_size);
        } else {
            let mut bits: libc::c_int = if type_0.t & 0xf as libc::c_int
                == 4 as libc::c_int
            {
                64 as libc::c_int
            } else {
                32 as libc::c_int
            };
            gen_cast(&mut type_0);
            vpushi(bits - (bit_pos + bit_size));
            gen_op('<' as i32);
            vpushi(bits - bit_size);
            gen_op('>' as i32);
        }
        r = gv(rc);
    } else {
        if is_float((*vtop).type_0.t) != 0
            && (*vtop).r as libc::c_int & (0x3f as libc::c_int | 0x100 as libc::c_int)
                == 0x30 as libc::c_int
        {
            let mut p: init_params = {
                let mut init = init_params {
                    sec: (*tcc_state).rodata_section,
                    local_offset: 0,
                    flex_array_ref: 0 as *mut Sym,
                };
                init
            };
            let mut offset: libc::c_ulong = 0;
            size = type_size(&mut (*vtop).type_0, &mut align);
            if nocode_wanted > 0 as libc::c_int {
                size = 0 as libc::c_int;
                align = 1 as libc::c_int;
            }
            offset = section_add(p.sec, size as Elf64_Addr, align);
            vpush_ref(&mut (*vtop).type_0, p.sec, offset, size as libc::c_ulong);
            vswap();
            init_putv(&mut p, &mut (*vtop).type_0, offset);
            (*vtop)
                .r = ((*vtop).r as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
        }
        if (*vtop).r as libc::c_int & 0x4000 as libc::c_int != 0 {
            gbound();
        }
        bt = (*vtop).type_0.t & 0xf as libc::c_int;
        rc2 = RC2_TYPE(bt, rc);
        r = (*vtop).r as libc::c_int & 0x3f as libc::c_int;
        r_ok = ((*vtop).r as libc::c_int & 0x100 as libc::c_int == 0
            && r < 0x30 as libc::c_int && reg_classes[r as usize] & rc != 0)
            as libc::c_int;
        r2_ok = (rc2 == 0
            || ((*vtop).r2 as libc::c_int) < 0x30 as libc::c_int
                && reg_classes[(*vtop).r2 as usize] & rc2 != 0) as libc::c_int;
        if r_ok == 0 || r2_ok == 0 {
            if r_ok == 0 {
                if 1 as libc::c_int != 0 && r < 0x30 as libc::c_int
                    && reg_classes[r as usize] & rc != 0 && rc2 == 0
                {
                    save_reg_upstack(r, 1 as libc::c_int);
                } else {
                    r = get_reg(rc);
                }
            }
            if rc2 != 0 {
                let mut current_block_65: u64;
                let mut load_type: libc::c_int = if bt == 14 as libc::c_int {
                    9 as libc::c_int
                } else {
                    0x800 as libc::c_int | 4 as libc::c_int
                };
                let mut original_type: libc::c_int = (*vtop).type_0.t;
                if (*vtop).r as libc::c_int
                    & (0x3f as libc::c_int | 0x100 as libc::c_int) == 0x30 as libc::c_int
                {
                    let mut ll: libc::c_ulonglong = (*vtop).c2rust_unnamed.c.i
                        as libc::c_ulonglong;
                    (*vtop).c2rust_unnamed.c.i = ll as uint64_t;
                    load(r, vtop);
                    (*vtop).r = r as libc::c_ushort;
                    vpushi((ll >> 32 as libc::c_int) as libc::c_int);
                    current_block_65 = 7990025728955927862;
                } else if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {
                    save_reg_upstack((*vtop).r as libc::c_int, 1 as libc::c_int);
                    (*vtop).type_0.t = load_type;
                    load(r, vtop);
                    vdup();
                    (*vtop.offset(-(1 as libc::c_int) as isize)).r = r as libc::c_ushort;
                    incr_offset(8 as libc::c_int);
                    current_block_65 = 7990025728955927862;
                } else {
                    if r_ok == 0 {
                        load(r, vtop);
                    }
                    if r2_ok != 0 && ((*vtop).r2 as libc::c_int) < 0x30 as libc::c_int {
                        current_block_65 = 1285924927343906915;
                    } else {
                        vdup();
                        (*vtop.offset(-(1 as libc::c_int) as isize))
                            .r = r as libc::c_ushort;
                        (*vtop).r = (*vtop.offset(-(1 as libc::c_int) as isize)).r2;
                        current_block_65 = 7990025728955927862;
                    }
                }
                match current_block_65 {
                    7990025728955927862 => {
                        r2 = get_reg(rc2);
                        load(r2, vtop);
                        vpop();
                        (*vtop).r2 = r2 as libc::c_ushort;
                    }
                    _ => {}
                }
                (*vtop).type_0.t = original_type;
            } else {
                if (*vtop).r as libc::c_int == 0x33 as libc::c_int {
                    vset_VT_JMP();
                }
                load(r, vtop);
            }
        }
        (*vtop).r = r as libc::c_ushort;
    }
    return r;
}
unsafe extern "C" fn gv2(mut rc1: libc::c_int, mut rc2: libc::c_int) {
    if (*vtop).r as libc::c_int != 0x33 as libc::c_int && rc1 <= rc2 {
        vswap();
        gv(rc1);
        vswap();
        gv(rc2);
        if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
            & 0x3f as libc::c_int >= 0x30 as libc::c_int
        {
            vswap();
            gv(rc1);
            vswap();
        }
    } else {
        gv(rc2);
        vswap();
        gv(rc1);
        vswap();
        if (*vtop.offset(0 as libc::c_int as isize)).r as libc::c_int
            & 0x3f as libc::c_int >= 0x30 as libc::c_int
        {
            gv(rc2);
        }
    };
}
unsafe extern "C" fn gv_dup() {
    let mut t: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    t = (*vtop).type_0.t;
    rc = RC_TYPE(t);
    gv(rc);
    r = get_reg(rc);
    vdup();
    load(r, vtop);
    (*vtop).r = r as libc::c_ushort;
}
unsafe extern "C" fn value64(mut l1: uint64_t, mut t: libc::c_int) -> uint64_t {
    if t & 0xf as libc::c_int == 4 as libc::c_int
        || 8 as libc::c_int == 8 as libc::c_int
            && t & 0xf as libc::c_int == 5 as libc::c_int
    {
        return l1
    } else if t & 0x10 as libc::c_int != 0 {
        return l1 as uint32_t as uint64_t
    } else {
        return l1 as uint32_t as uint64_t
            | (l1 & 0x80000000 as libc::c_uint as uint64_t).wrapping_neg()
    };
}
unsafe extern "C" fn gen_opic_sdiv(mut a: uint64_t, mut b: uint64_t) -> uint64_t {
    let mut x: uint64_t = (if a >> 63 as libc::c_int != 0 {
        a.wrapping_neg()
    } else {
        a
    }) / (if b >> 63 as libc::c_int != 0 { b.wrapping_neg() } else { b });
    return if (a ^ b) >> 63 as libc::c_int != 0 { x.wrapping_neg() } else { x };
}
unsafe extern "C" fn gen_opic_lt(mut a: uint64_t, mut b: uint64_t) -> libc::c_int {
    return ((a ^ (1 as libc::c_int as uint64_t) << 63 as libc::c_int)
        < b ^ (1 as libc::c_int as uint64_t) << 63 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn gen_opic(mut op: libc::c_int) {
    let mut current_block: u64;
    let mut v1: *mut SValue = vtop.offset(-(1 as libc::c_int as isize));
    let mut v2: *mut SValue = vtop;
    let mut t1: libc::c_int = (*v1).type_0.t & 0xf as libc::c_int;
    let mut t2: libc::c_int = (*v2).type_0.t & 0xf as libc::c_int;
    let mut c1: libc::c_int = ((*v1).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int) as libc::c_int;
    let mut c2: libc::c_int = ((*v2).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int) as libc::c_int;
    let mut l1: uint64_t = if c1 != 0 {
        value64((*v1).c2rust_unnamed.c.i, (*v1).type_0.t)
    } else {
        0 as libc::c_int as uint64_t
    };
    let mut l2: uint64_t = if c2 != 0 {
        value64((*v2).c2rust_unnamed.c.i, (*v2).type_0.t)
    } else {
        0 as libc::c_int as uint64_t
    };
    let mut shm: libc::c_int = if t1 == 4 as libc::c_int {
        63 as libc::c_int
    } else {
        31 as libc::c_int
    };
    let mut r: libc::c_int = 0;
    if c1 != 0 && c2 != 0 {
        match op {
            43 => {
                current_block = 1270086279342086474;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            45 => {
                current_block = 6359923284441280657;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            38 => {
                current_block = 6775526729684020346;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            94 => {
                current_block = 15784311549739738238;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            124 => {
                current_block = 14660402569372243852;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            42 => {
                current_block = 10643279784861675122;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            133 | 47 | 37 | 131 | 132 => {
                current_block = 13816824220683421388;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            60 => {
                current_block = 14124249700859881979;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            139 => {
                current_block = 4510163431762934494;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            62 => {
                current_block = 11772444952625553839;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            146 => {
                current_block = 3174553280570582454;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            147 => {
                current_block = 1454858814923020442;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            148 => {
                current_block = 9079719342209406860;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            149 => {
                current_block = 9936170433551825612;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            150 => {
                current_block = 7280396493743894783;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            151 => {
                current_block = 18051250799729408252;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            156 => {
                current_block = 9991113203896008483;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            157 => {
                current_block = 1439770758739916730;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            158 => {
                current_block = 15378834542373135322;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            159 => {
                current_block = 17963658911341773653;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            144 => {
                current_block = 4192679977448942890;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            145 => {
                current_block = 2357894281553585152;
                match current_block {
                    2357894281553585152 => {
                        l1 = (l1 != 0 || l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1270086279342086474 => {
                        l1 = l1.wrapping_add(l2);
                        current_block = 10150597327160359210;
                    }
                    6359923284441280657 => {
                        l1 = l1.wrapping_sub(l2);
                        current_block = 10150597327160359210;
                    }
                    6775526729684020346 => {
                        l1 &= l2;
                        current_block = 10150597327160359210;
                    }
                    15784311549739738238 => {
                        l1 ^= l2;
                        current_block = 10150597327160359210;
                    }
                    14660402569372243852 => {
                        l1 |= l2;
                        current_block = 10150597327160359210;
                    }
                    10643279784861675122 => {
                        l1 = l1 * l2;
                        current_block = 10150597327160359210;
                    }
                    14124249700859881979 => {
                        l1 <<= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4510163431762934494 => {
                        l1 >>= l2 & shm as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    11772444952625553839 => {
                        l1 = if l1 >> 63 as libc::c_int != 0 {
                            !(!l1 >> (l2 & shm as uint64_t))
                        } else {
                            l1 >> (l2 & shm as uint64_t)
                        };
                        current_block = 10150597327160359210;
                    }
                    3174553280570582454 => {
                        l1 = (l1 < l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1454858814923020442 => {
                        l1 = (l1 >= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9079719342209406860 => {
                        l1 = (l1 == l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9936170433551825612 => {
                        l1 = (l1 != l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    7280396493743894783 => {
                        l1 = (l1 <= l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    18051250799729408252 => {
                        l1 = (l1 > l2) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    9991113203896008483 => {
                        l1 = gen_opic_lt(l1, l2) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    1439770758739916730 => {
                        l1 = (gen_opic_lt(l1, l2) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    15378834542373135322 => {
                        l1 = (gen_opic_lt(l2, l1) == 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    17963658911341773653 => {
                        l1 = gen_opic_lt(l2, l1) as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    4192679977448942890 => {
                        l1 = (l1 != 0 && l2 != 0) as libc::c_int as uint64_t;
                        current_block = 10150597327160359210;
                    }
                    _ => {
                        if l2 == 0 as libc::c_int as uint64_t {
                            if nocode_wanted & 0xfff0000 as libc::c_int != 0
                                && nocode_wanted & 0xffff as libc::c_int == 0
                            {
                                _tcc_error(
                                    b"division by zero in constant\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            current_block = 6714867217697563200;
                        } else {
                            match op {
                                37 => {
                                    l1 = l1.wrapping_sub(l2 * gen_opic_sdiv(l1, l2));
                                }
                                131 => {
                                    l1 = l1 / l2;
                                }
                                132 => {
                                    l1 = l1 % l2;
                                }
                                _ => {
                                    l1 = gen_opic_sdiv(l1, l2);
                                }
                            }
                            current_block = 10150597327160359210;
                        }
                    }
                }
                match current_block {
                    6714867217697563200 => {}
                    _ => {
                        (*v1).c2rust_unnamed.c.i = value64(l1, (*v1).type_0.t);
                        (*v1)
                            .r = ((*v1).r as libc::c_int
                            | (*v2).r as libc::c_int & 0x1000 as libc::c_int)
                            as libc::c_ushort;
                        vtop = vtop.offset(-1);
                        vtop;
                        current_block = 1852451392920375136;
                    }
                }
            }
            _ => {
                current_block = 6714867217697563200;
            }
        }
    } else {
        if c1 != 0
            && (op == '+' as i32 || op == '&' as i32 || op == '^' as i32
                || op == '|' as i32 || op == '*' as i32 || op == 0x94 as libc::c_int
                || op == 0x95 as libc::c_int)
        {
            vswap();
            c2 = c1;
            l2 = l1;
        }
        if c1 != 0
            && (l1 == 0 as libc::c_int as uint64_t
                && (op == '<' as i32 || op == 0x8b as libc::c_int || op == '>' as i32)
                || l1 == -(1 as libc::c_int) as uint64_t && op == '>' as i32)
        {
            vpop();
            current_block = 10213293998891106930;
        } else if c2 != 0
            && (l2 == 0 as libc::c_int as uint64_t
                && (op == '&' as i32 || op == '*' as i32)
                || op == '|' as i32
                    && (l2 == -(1 as libc::c_int) as uint64_t
                        || l2 == 0xffffffff as libc::c_uint as uint64_t
                            && t2 != 4 as libc::c_int)
                || l2 == 1 as libc::c_int as uint64_t
                    && (op == '%' as i32 || op == 0x84 as libc::c_int))
        {
            if l2 == 1 as libc::c_int as uint64_t {
                (*vtop).c2rust_unnamed.c.i = 0 as libc::c_int as uint64_t;
            }
            vswap();
            vtop = vtop.offset(-1);
            vtop;
            current_block = 10213293998891106930;
        } else if c2 != 0
            && ((op == '*' as i32 || op == '/' as i32 || op == 0x83 as libc::c_int
                || op == 0x85 as libc::c_int) && l2 == 1 as libc::c_int as uint64_t
                || (op == '+' as i32 || op == '-' as i32 || op == '|' as i32
                    || op == '^' as i32 || op == '<' as i32 || op == 0x8b as libc::c_int
                    || op == '>' as i32) && l2 == 0 as libc::c_int as uint64_t
                || op == '&' as i32
                    && (l2 == -(1 as libc::c_int) as uint64_t
                        || l2 == 0xffffffff as libc::c_uint as uint64_t
                            && t2 != 4 as libc::c_int))
        {
            vtop = vtop.offset(-1);
            vtop;
            current_block = 10213293998891106930;
        } else if c2 != 0
            && (op == '*' as i32 || op == 0x85 as libc::c_int
                || op == 0x83 as libc::c_int || op == 0x84 as libc::c_int)
        {
            if l2 > 0 as libc::c_int as uint64_t
                && l2 & l2.wrapping_sub(1 as libc::c_int as uint64_t)
                    == 0 as libc::c_int as uint64_t
            {
                let mut n: libc::c_int = -(1 as libc::c_int);
                if op == 0x84 as libc::c_int {
                    (*vtop)
                        .c2rust_unnamed
                        .c
                        .i = l2.wrapping_sub(1 as libc::c_int as uint64_t);
                    op = '&' as i32;
                } else {
                    while l2 != 0 {
                        l2 >>= 1 as libc::c_int;
                        n += 1;
                        n;
                    }
                    (*vtop).c2rust_unnamed.c.i = n as uint64_t;
                    if op == '*' as i32 {
                        op = '<' as i32;
                    } else if op == 0x85 as libc::c_int {
                        op = '>' as i32;
                    } else {
                        op = 0x8b as libc::c_int;
                    }
                }
                current_block = 6714867217697563200;
            } else {
                current_block = 6714867217697563200;
            }
        } else if c2 != 0 && (op == '+' as i32 || op == '-' as i32)
            && {
                r = (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
                    & (0x3f as libc::c_int | 0x100 as libc::c_int
                        | 0x200 as libc::c_int);
                r == 0x30 as libc::c_int | 0x200 as libc::c_int
                    || r == 0x32 as libc::c_int
            }
        {
            if op == '-' as i32 {
                l2 = l2.wrapping_neg();
            }
            l2 = l2
                .wrapping_add(
                    (*vtop.offset(-(1 as libc::c_int) as isize)).c2rust_unnamed.c.i,
                );
            if l2 as libc::c_int as uint64_t != l2 {
                current_block = 6714867217697563200;
            } else {
                vtop = vtop.offset(-1);
                vtop;
                (*vtop).c2rust_unnamed.c.i = l2;
                current_block = 10213293998891106930;
            }
        } else {
            current_block = 6714867217697563200;
        }
    }
    match current_block {
        6714867217697563200 => {
            if t1 == 4 as libc::c_int || t2 == 4 as libc::c_int
                || 8 as libc::c_int == 8 as libc::c_int
                    && (t1 == 5 as libc::c_int || t2 == 5 as libc::c_int)
            {
                gen_opl(op);
            } else {
                gen_opi(op);
            }
            current_block = 10213293998891106930;
        }
        _ => {}
    }
    match current_block {
        10213293998891106930 => {
            if (*vtop).r as libc::c_int == 0x30 as libc::c_int {
                (*vtop)
                    .r = ((*vtop).r as libc::c_int | 0x1000 as libc::c_int)
                    as libc::c_ushort;
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn gen_opif(mut op: libc::c_int) {
    let mut current_block: u64;
    let mut c1: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut v1: *mut SValue = 0 as *mut SValue;
    let mut v2: *mut SValue = 0 as *mut SValue;
    let mut f1: f128::f128 = f128::f128::ZERO;
    let mut f2: f128::f128 = f128::f128::ZERO;
    v1 = vtop.offset(-(1 as libc::c_int as isize));
    v2 = vtop;
    if op == 0x81 as libc::c_int {
        v1 = v2;
    }
    bt = (*v1).type_0.t & 0xf as libc::c_int;
    c1 = ((*v1).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int) as libc::c_int;
    c2 = ((*v2).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int) as libc::c_int;
    if c1 != 0 && c2 != 0 {
        if bt == 8 as libc::c_int {
            f1 = f128::f128::new((*v1).c2rust_unnamed.c.f);
            f2 = f128::f128::new((*v2).c2rust_unnamed.c.f);
        } else if bt == 9 as libc::c_int {
            f1 = f128::f128::new((*v1).c2rust_unnamed.c.d);
            f2 = f128::f128::new((*v2).c2rust_unnamed.c.d);
        } else {
            f1 = (*v1).c2rust_unnamed.c.ld;
            f2 = (*v2).c2rust_unnamed.c.ld;
        }
        if !(ieee_finite(f1.to_f64().unwrap()) != 0
            || ieee_finite(f2.to_f64().unwrap()) == 0)
            && nocode_wanted & 0xfff0000 as libc::c_int == 0
        {
            current_block = 9528562218628459977;
        } else {
            match op {
                43 => {
                    current_block = 5908820377990457906;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                45 => {
                    current_block = 9615076064119754226;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                42 => {
                    current_block = 8113730133192094477;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                47 => {
                    current_block = 5518658535958134327;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                129 => {
                    current_block = 16618238642332616363;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                148 => {
                    current_block = 15962991163190434385;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                149 => {
                    current_block = 5461401632850924832;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                156 => {
                    current_block = 16045742901904307896;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                157 => {
                    current_block = 13726190844705790867;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                158 => {
                    current_block = 6749082531808122945;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                159 => {
                    current_block = 11177695857853962701;
                    match current_block {
                        11177695857853962701 => {
                            i = (f1 > f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5908820377990457906 => {
                            f1 += f2;
                            current_block = 18435049525520518667;
                        }
                        9615076064119754226 => {
                            f1 -= f2;
                            current_block = 18435049525520518667;
                        }
                        8113730133192094477 => {
                            f1 *= f2;
                            current_block = 18435049525520518667;
                        }
                        16618238642332616363 => {
                            f1 = -f1;
                            current_block = 2875824339383253992;
                        }
                        15962991163190434385 => {
                            i = (f1 == f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        5461401632850924832 => {
                            i = (f1 != f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        16045742901904307896 => {
                            i = (f1 < f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        13726190844705790867 => {
                            i = (f1 >= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        6749082531808122945 => {
                            i = (f1 <= f2) as libc::c_int;
                            current_block = 17391382657916417147;
                        }
                        _ => {
                            if f2 == f128::f128::new(0.0f64) {
                                let mut x1: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut x2: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                let mut y: C2RustUnnamed_18 = C2RustUnnamed_18 { f: 0. };
                                if nocode_wanted & 0xfff0000 as libc::c_int == 0 {
                                    current_block = 9528562218628459977;
                                } else {
                                    x1.f = f1.to_f32().unwrap();
                                    x2.f = f2.to_f32().unwrap();
                                    if f1 == f128::f128::new(0.0f64) {
                                        y.u = 0x7fc00000 as libc::c_int as libc::c_uint;
                                    } else {
                                        y.u = 0x7f800000 as libc::c_int as libc::c_uint;
                                    }
                                    y.u |= (x1.u ^ x2.u) & 0x80000000 as libc::c_uint;
                                    f1 = f128::f128::new(y.f);
                                    current_block = 18435049525520518667;
                                }
                            } else {
                                f1 /= f2;
                                current_block = 18435049525520518667;
                            }
                        }
                    }
                    match current_block {
                        9528562218628459977 => {}
                        _ => {
                            match current_block {
                                17391382657916417147 => {
                                    vtop = vtop.offset(-(2 as libc::c_int as isize));
                                    vpushi(i);
                                    return;
                                }
                                18435049525520518667 => {
                                    vtop = vtop.offset(-1);
                                    vtop;
                                }
                                _ => {}
                            }
                            if bt == 8 as libc::c_int {
                                (*v1).c2rust_unnamed.c.f = f1.to_f32().unwrap();
                            } else if bt == 9 as libc::c_int {
                                (*v1).c2rust_unnamed.c.d = f1.to_f64().unwrap();
                            } else {
                                (*v1).c2rust_unnamed.c.ld = f1;
                            }
                            current_block = 9353995356876505083;
                        }
                    }
                }
                _ => {
                    current_block = 9528562218628459977;
                }
            }
        }
    } else {
        current_block = 9528562218628459977;
    }
    match current_block {
        9528562218628459977 => {
            if op == 0x81 as libc::c_int {
                gen_opf(op);
            } else {
                gen_opf(op);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn type_to_str(
    mut buf: *mut libc::c_char,
    mut buf_size: libc::c_int,
    mut type_0: *mut CType,
    mut varstr: *const libc::c_char,
) {
    let mut current_block: u64;
    let mut bt: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut sa: *mut Sym = 0 as *mut Sym;
    let mut buf1: [libc::c_char; 256] = [0; 256];
    let mut tstr: *const libc::c_char = 0 as *const libc::c_char;
    t = (*type_0).t;
    bt = t & 0xf as libc::c_int;
    *buf.offset(0 as libc::c_int as isize) = '\0' as i32 as libc::c_char;
    if t & 0x1000 as libc::c_int != 0 {
        pstrcat(
            buf,
            buf_size as size_t,
            b"extern \0" as *const u8 as *const libc::c_char,
        );
    }
    if t & 0x2000 as libc::c_int != 0 {
        pstrcat(
            buf,
            buf_size as size_t,
            b"static \0" as *const u8 as *const libc::c_char,
        );
    }
    if t & 0x4000 as libc::c_int != 0 {
        pstrcat(
            buf,
            buf_size as size_t,
            b"typedef \0" as *const u8 as *const libc::c_char,
        );
    }
    if t & 0x8000 as libc::c_int != 0 {
        pstrcat(
            buf,
            buf_size as size_t,
            b"inline \0" as *const u8 as *const libc::c_char,
        );
    }
    if bt != 5 as libc::c_int {
        if t & 0x200 as libc::c_int != 0 {
            pstrcat(
                buf,
                buf_size as size_t,
                b"volatile \0" as *const u8 as *const libc::c_char,
            );
        }
        if t & 0x100 as libc::c_int != 0 {
            pstrcat(
                buf,
                buf_size as size_t,
                b"const \0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if t & 0x20 as libc::c_int != 0 && bt == 1 as libc::c_int
        || t & 0x10 as libc::c_int != 0
            && (bt == 2 as libc::c_int || bt == 3 as libc::c_int
                || bt == 4 as libc::c_int)
            && !(t as libc::c_uint
                & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint)
                == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint)
    {
        pstrcat(
            buf,
            buf_size as size_t,
            if t & 0x10 as libc::c_int != 0 {
                b"unsigned \0" as *const u8 as *const libc::c_char
            } else {
                b"signed \0" as *const u8 as *const libc::c_char
            },
        );
    }
    buf_size = (buf_size as libc::c_ulong).wrapping_sub(strlen(buf)) as libc::c_int
        as libc::c_int;
    buf = buf.offset(strlen(buf) as isize);
    match bt {
        0 => {
            tstr = b"void\0" as *const u8 as *const libc::c_char;
            current_block = 18028604105018118156;
        }
        11 => {
            tstr = b"_Bool\0" as *const u8 as *const libc::c_char;
            current_block = 18028604105018118156;
        }
        1 => {
            tstr = b"char\0" as *const u8 as *const libc::c_char;
            current_block = 18028604105018118156;
        }
        2 => {
            tstr = b"short\0" as *const u8 as *const libc::c_char;
            current_block = 18028604105018118156;
        }
        3 => {
            tstr = b"int\0" as *const u8 as *const libc::c_char;
            current_block = 7380003061280721588;
        }
        4 => {
            tstr = b"long long\0" as *const u8 as *const libc::c_char;
            current_block = 7380003061280721588;
        }
        8 => {
            tstr = b"float\0" as *const u8 as *const libc::c_char;
            current_block = 18028604105018118156;
        }
        9 => {
            tstr = b"double\0" as *const u8 as *const libc::c_char;
            if t & 0x800 as libc::c_int == 0 {
                current_block = 18028604105018118156;
            } else {
                current_block = 7289522646950323767;
            }
        }
        10 => {
            current_block = 7289522646950323767;
        }
        7 => {
            tstr = b"struct \0" as *const u8 as *const libc::c_char;
            if t as libc::c_uint
                & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint
                    | 0xf as libc::c_int as libc::c_uint)
                == ((1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int)
                    as libc::c_uint
            {
                tstr = b"union \0" as *const u8 as *const libc::c_char;
            }
            current_block = 1009701978849775220;
        }
        6 => {
            s = (*type_0).ref_0;
            buf1[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
            if !varstr.is_null() && '*' as i32 == *varstr as libc::c_int {
                pstrcat(
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    b"(\0" as *const u8 as *const libc::c_char,
                );
                pstrcat(
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    varstr,
                );
                pstrcat(
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    b")\0" as *const u8 as *const libc::c_char,
                );
            }
            pstrcat(
                buf1.as_mut_ptr(),
                buf_size as size_t,
                b"(\0" as *const u8 as *const libc::c_char,
            );
            sa = (*s).c2rust_unnamed_0.next;
            while !sa.is_null() {
                let mut buf2: [libc::c_char; 256] = [0; 256];
                type_to_str(
                    buf2.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong
                        as libc::c_int,
                    &mut (*sa).type_0,
                    0 as *const libc::c_char,
                );
                pstrcat(
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    buf2.as_mut_ptr(),
                );
                sa = (*sa).c2rust_unnamed_0.next;
                if !sa.is_null() {
                    pstrcat(
                        buf1.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        b", \0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            if ((*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
                as libc::c_int == 3 as libc::c_int
            {
                pstrcat(
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    b", ...\0" as *const u8 as *const libc::c_char,
                );
            }
            pstrcat(
                buf1.as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                b")\0" as *const u8 as *const libc::c_char,
            );
            type_to_str(buf, buf_size, &mut (*s).type_0, buf1.as_mut_ptr());
            current_block = 17239133558811367971;
        }
        5 => {
            s = (*type_0).ref_0;
            if t & (0x40 as libc::c_int | 0x400 as libc::c_int) != 0 {
                if !varstr.is_null() && '*' as i32 == *varstr as libc::c_int {
                    snprintf(
                        buf1.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        b"(%s)[%d]\0" as *const u8 as *const libc::c_char,
                        varstr,
                        (*s).c2rust_unnamed.c2rust_unnamed.c,
                    );
                } else {
                    snprintf(
                        buf1.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        b"%s[%d]\0" as *const u8 as *const libc::c_char,
                        if !varstr.is_null() {
                            varstr
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                        (*s).c2rust_unnamed.c2rust_unnamed.c,
                    );
                }
                type_to_str(buf, buf_size, &mut (*s).type_0, buf1.as_mut_ptr());
            } else {
                pstrcpy(
                    buf1.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    b"*\0" as *const u8 as *const libc::c_char,
                );
                if t & 0x100 as libc::c_int != 0 {
                    pstrcat(
                        buf1.as_mut_ptr(),
                        buf_size as size_t,
                        b"const \0" as *const u8 as *const libc::c_char,
                    );
                }
                if t & 0x200 as libc::c_int != 0 {
                    pstrcat(
                        buf1.as_mut_ptr(),
                        buf_size as size_t,
                        b"volatile \0" as *const u8 as *const libc::c_char,
                    );
                }
                if !varstr.is_null() {
                    pstrcat(
                        buf1.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        varstr,
                    );
                }
                type_to_str(buf, buf_size, &mut (*s).type_0, buf1.as_mut_ptr());
            }
            current_block = 17239133558811367971;
        }
        _ => {
            current_block = 7858101417678297991;
        }
    }
    match current_block {
        7380003061280721588 => {
            if t & 0x800 as libc::c_int != 0 {
                tstr = b"long\0" as *const u8 as *const libc::c_char;
            }
            if !(t as libc::c_uint
                & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint)
                == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint)
            {
                current_block = 18028604105018118156;
            } else {
                tstr = b"enum \0" as *const u8 as *const libc::c_char;
                current_block = 1009701978849775220;
            }
        }
        7289522646950323767 => {
            tstr = b"long double\0" as *const u8 as *const libc::c_char;
            current_block = 18028604105018118156;
        }
        _ => {}
    }
    match current_block {
        1009701978849775220 => {
            pstrcat(buf, buf_size as size_t, tstr);
            v = (*(*type_0).ref_0).v & !(0x40000000 as libc::c_int);
            if v >= 0x10000000 as libc::c_int {
                pstrcat(
                    buf,
                    buf_size as size_t,
                    b"<anonymous>\0" as *const u8 as *const libc::c_char,
                );
            } else {
                pstrcat(buf, buf_size as size_t, get_tok_str(v, 0 as *mut CValue));
            }
            current_block = 7858101417678297991;
        }
        18028604105018118156 => {
            pstrcat(buf, buf_size as size_t, tstr);
            current_block = 7858101417678297991;
        }
        _ => {}
    }
    match current_block {
        7858101417678297991 => {
            if !varstr.is_null() {
                pstrcat(
                    buf,
                    buf_size as size_t,
                    b" \0" as *const u8 as *const libc::c_char,
                );
                pstrcat(buf, buf_size as size_t, varstr);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn type_incompatibility_error(
    mut st: *mut CType,
    mut dt: *mut CType,
    mut fmt: *const libc::c_char,
) {
    let mut buf1: [libc::c_char; 256] = [0; 256];
    let mut buf2: [libc::c_char; 256] = [0; 256];
    type_to_str(
        buf1.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong as libc::c_int,
        st,
        0 as *const libc::c_char,
    );
    type_to_str(
        buf2.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong as libc::c_int,
        dt,
        0 as *const libc::c_char,
    );
    _tcc_error(fmt, buf1.as_mut_ptr(), buf2.as_mut_ptr());
}
unsafe extern "C" fn type_incompatibility_warning(
    mut st: *mut CType,
    mut dt: *mut CType,
    mut fmt: *const libc::c_char,
) {
    let mut buf1: [libc::c_char; 256] = [0; 256];
    let mut buf2: [libc::c_char; 256] = [0; 256];
    type_to_str(
        buf1.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong as libc::c_int,
        st,
        0 as *const libc::c_char,
    );
    type_to_str(
        buf2.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong as libc::c_int,
        dt,
        0 as *const libc::c_char,
    );
    _tcc_warning(fmt, buf1.as_mut_ptr(), buf2.as_mut_ptr());
}
unsafe extern "C" fn pointed_size(mut type_0: *mut CType) -> libc::c_int {
    let mut align: libc::c_int = 0;
    return type_size(pointed_type(type_0), &mut align);
}
#[inline]
unsafe extern "C" fn is_null_pointer(mut p: *mut SValue) -> libc::c_int {
    if (*p).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int
            | 0x1000 as libc::c_int) != 0x30 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    return ((*p).type_0.t & 0xf as libc::c_int == 3 as libc::c_int
        && (*p).c2rust_unnamed.c.i as uint32_t == 0 as libc::c_int as uint32_t
        || (*p).type_0.t & 0xf as libc::c_int == 4 as libc::c_int
            && (*p).c2rust_unnamed.c.i == 0 as libc::c_int as uint64_t
        || (*p).type_0.t & 0xf as libc::c_int == 5 as libc::c_int
            && (if 8 as libc::c_int == 4 as libc::c_int {
                ((*p).c2rust_unnamed.c.i as uint32_t == 0 as libc::c_int as uint32_t)
                    as libc::c_int
            } else {
                ((*p).c2rust_unnamed.c.i == 0 as libc::c_int as uint64_t) as libc::c_int
            }) != 0
            && (*pointed_type(&mut (*p).type_0)).t & 0xf as libc::c_int
                == 0 as libc::c_int
            && 0 as libc::c_int
                == (*pointed_type(&mut (*p).type_0)).t
                    & (0x100 as libc::c_int | 0x200 as libc::c_int)) as libc::c_int;
}
unsafe extern "C" fn is_compatible_func(
    mut type1: *mut CType,
    mut type2: *mut CType,
) -> libc::c_int {
    let mut s1: *mut Sym = 0 as *mut Sym;
    let mut s2: *mut Sym = 0 as *mut Sym;
    s1 = (*type1).ref_0;
    s2 = (*type2).ref_0;
    if ((*s1).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_call() as libc::c_int
        != ((*s2).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_call()
            as libc::c_int
    {
        return 0 as libc::c_int;
    }
    if ((*s1).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type() as libc::c_int
        != ((*s2).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
            as libc::c_int
        && ((*s1).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
            as libc::c_int != 2 as libc::c_int
        && ((*s2).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
            as libc::c_int != 2 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    loop {
        if is_compatible_unqualified_types(&mut (*s1).type_0, &mut (*s2).type_0) == 0 {
            return 0 as libc::c_int;
        }
        if ((*s1).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
            as libc::c_int == 2 as libc::c_int
            || ((*s2).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
                as libc::c_int == 2 as libc::c_int
        {
            return 1 as libc::c_int;
        }
        s1 = (*s1).c2rust_unnamed_0.next;
        s2 = (*s2).c2rust_unnamed_0.next;
        if s1.is_null() {
            return s2.is_null() as libc::c_int;
        }
        if s2.is_null() {
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn compare_types(
    mut type1: *mut CType,
    mut type2: *mut CType,
    mut unqualified: libc::c_int,
) -> libc::c_int {
    let mut bt1: libc::c_int = 0;
    let mut t1: libc::c_int = 0;
    let mut t2: libc::c_int = 0;
    if (*type1).t as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
    {
        if (*type2).t as libc::c_uint
            & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint)
            == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
        {
            return ((*type1).ref_0 == (*type2).ref_0) as libc::c_int;
        }
        type1 = &mut (*(*type1).ref_0).type_0;
    } else if (*type2).t as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
    {
        type2 = &mut (*(*type2).ref_0).type_0;
    }
    t1 = ((*type1).t as libc::c_uint
        & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
            | 0x8000 as libc::c_int) as libc::c_uint
            | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint))) as libc::c_int;
    t2 = ((*type2).t as libc::c_uint
        & !((0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
            | 0x8000 as libc::c_int) as libc::c_uint
            | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint))) as libc::c_int;
    if unqualified != 0 {
        t1 &= !(0x100 as libc::c_int | 0x200 as libc::c_int);
        t2 &= !(0x100 as libc::c_int | 0x200 as libc::c_int);
    }
    if t1 & 0xf as libc::c_int != 1 as libc::c_int {
        t1 &= !(0x20 as libc::c_int);
        t2 &= !(0x20 as libc::c_int);
    }
    if t1 != t2 {
        return 0 as libc::c_int;
    }
    if t1 & 0x40 as libc::c_int != 0
        && !((*(*type1).ref_0).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int
            || (*(*type2).ref_0).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int
            || (*(*type1).ref_0).c2rust_unnamed.c2rust_unnamed.c
                == (*(*type2).ref_0).c2rust_unnamed.c2rust_unnamed.c)
    {
        return 0 as libc::c_int;
    }
    bt1 = t1 & 0xf as libc::c_int;
    if bt1 == 5 as libc::c_int {
        type1 = pointed_type(type1);
        type2 = pointed_type(type2);
        return is_compatible_types(type1, type2);
    } else if bt1 == 7 as libc::c_int {
        return ((*type1).ref_0 == (*type2).ref_0) as libc::c_int
    } else if bt1 == 6 as libc::c_int {
        return is_compatible_func(type1, type2)
    } else {
        return 1 as libc::c_int
    };
}
unsafe extern "C" fn combine_types(
    mut dest: *mut CType,
    mut op1: *mut SValue,
    mut op2: *mut SValue,
    mut op: libc::c_int,
) -> libc::c_int {
    let mut type1: *mut CType = 0 as *mut CType;
    let mut type2: *mut CType = 0 as *mut CType;
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut t1: libc::c_int = 0;
    let mut t2: libc::c_int = 0;
    let mut bt1: libc::c_int = 0;
    let mut bt2: libc::c_int = 0;
    let mut ret: libc::c_int = 1 as libc::c_int;
    if op == 'S' as i32 {
        op2 = op1;
    }
    type1 = &mut (*op1).type_0;
    type2 = &mut (*op2).type_0;
    t1 = (*type1).t;
    t2 = (*type2).t;
    bt1 = t1 & 0xf as libc::c_int;
    bt2 = t2 & 0xf as libc::c_int;
    type_0.t = 0 as libc::c_int;
    type_0.ref_0 = 0 as *mut Sym;
    if bt1 == 0 as libc::c_int || bt2 == 0 as libc::c_int {
        ret = if op == '?' as i32 { 1 as libc::c_int } else { 0 as libc::c_int };
        type_0.t = 0 as libc::c_int;
    } else if bt1 == 5 as libc::c_int || bt2 == 5 as libc::c_int {
        if op == '+' as i32 {
            if is_integer_btype(if bt1 == 5 as libc::c_int { bt2 } else { bt1 }) == 0 {
                ret = 0 as libc::c_int;
            }
        } else if is_null_pointer(op2) != 0 {
            type_0 = *type1;
        } else if is_null_pointer(op1) != 0 {
            type_0 = *type2;
        } else if bt1 != bt2 {
            if (op == '?' as i32 || op == 'C' as i32)
                && (is_integer_btype(bt1) != 0 || is_integer_btype(bt2) != 0)
            {
                _tcc_warning(
                    b"pointer/integer mismatch in %s\0" as *const u8
                        as *const libc::c_char,
                    if op == '?' as i32 {
                        b"conditional expression\0" as *const u8 as *const libc::c_char
                    } else {
                        b"comparison\0" as *const u8 as *const libc::c_char
                    },
                );
            } else if op != '-' as i32 || is_integer_btype(bt2) == 0 {
                ret = 0 as libc::c_int;
            }
            type_0 = *if bt1 == 5 as libc::c_int { type1 } else { type2 };
        } else {
            let mut pt1: *mut CType = pointed_type(type1);
            let mut pt2: *mut CType = pointed_type(type2);
            let mut pbt1: libc::c_int = (*pt1).t & 0xf as libc::c_int;
            let mut pbt2: libc::c_int = (*pt2).t & 0xf as libc::c_int;
            let mut newquals: libc::c_int = 0;
            let mut copied: libc::c_int = 0 as libc::c_int;
            if pbt1 != 0 as libc::c_int && pbt2 != 0 as libc::c_int
                && compare_types(pt1, pt2, 1 as libc::c_int) == 0
            {
                if op != '?' as i32 && op != 'C' as i32 {
                    ret = 0 as libc::c_int;
                } else {
                    type_incompatibility_warning(
                        type1,
                        type2,
                        if op == '?' as i32 {
                            b"pointer type mismatch in conditional expression ('%s' and '%s')\0"
                                as *const u8 as *const libc::c_char
                        } else {
                            b"pointer type mismatch in comparison('%s' and '%s')\0"
                                as *const u8 as *const libc::c_char
                        },
                    );
                }
            }
            if op == '?' as i32 {
                type_0 = *if pbt1 == 0 as libc::c_int { type1 } else { type2 };
                newquals = ((*pt1).t | (*pt2).t)
                    & (0x100 as libc::c_int | 0x200 as libc::c_int);
                if !(*pointed_type(&mut type_0)).t
                    & (0x100 as libc::c_int | 0x200 as libc::c_int) & newquals != 0
                {
                    type_0
                        .ref_0 = sym_push(
                        0x20000000 as libc::c_int,
                        &mut (*type_0.ref_0).type_0,
                        0 as libc::c_int,
                        (*type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c,
                    );
                    copied = 1 as libc::c_int;
                    (*pointed_type(&mut type_0)).t |= newquals;
                }
                if (*pt1).t & 0x40 as libc::c_int != 0
                    && (*pt2).t & 0x40 as libc::c_int != 0
                    && (*(*pointed_type(&mut type_0)).ref_0)
                        .c2rust_unnamed
                        .c2rust_unnamed
                        .c < 0 as libc::c_int
                    && ((*(*pt1).ref_0).c2rust_unnamed.c2rust_unnamed.c
                        > 0 as libc::c_int
                        || (*(*pt2).ref_0).c2rust_unnamed.c2rust_unnamed.c
                            > 0 as libc::c_int)
                {
                    if copied == 0 {
                        type_0
                            .ref_0 = sym_push(
                            0x20000000 as libc::c_int,
                            &mut (*type_0.ref_0).type_0,
                            0 as libc::c_int,
                            (*type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c,
                        );
                    }
                    let ref mut fresh155 = (*pointed_type(&mut type_0)).ref_0;
                    *fresh155 = sym_push(
                        0x20000000 as libc::c_int,
                        &mut (*(*(pointed_type
                            as unsafe extern "C" fn(
                                *mut CType,
                            ) -> *mut CType)(&mut type_0))
                            .ref_0)
                            .type_0,
                        0 as libc::c_int,
                        (*(*pointed_type(&mut type_0)).ref_0)
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .c,
                    );
                    (*(*pointed_type(&mut type_0)).ref_0)
                        .c2rust_unnamed
                        .c2rust_unnamed
                        .c = if (0 as libc::c_int)
                        < (*(*pt1).ref_0).c2rust_unnamed.c2rust_unnamed.c
                    {
                        (*(*pt1).ref_0).c2rust_unnamed.c2rust_unnamed.c
                    } else {
                        (*(*pt2).ref_0).c2rust_unnamed.c2rust_unnamed.c
                    };
                }
            }
        }
        if op == 'C' as i32 {
            type_0.t = 0x800 as libc::c_int | 4 as libc::c_int | 0x10 as libc::c_int;
        }
    } else if bt1 == 7 as libc::c_int || bt2 == 7 as libc::c_int {
        if op != '?' as i32 || compare_types(type1, type2, 1 as libc::c_int) == 0 {
            ret = 0 as libc::c_int;
        }
        type_0 = *type1;
    } else if is_float(bt1) != 0 || is_float(bt2) != 0 {
        if bt1 == 10 as libc::c_int || bt2 == 10 as libc::c_int {
            type_0.t = 10 as libc::c_int;
        } else if bt1 == 9 as libc::c_int || bt2 == 9 as libc::c_int {
            type_0.t = 9 as libc::c_int;
        } else {
            type_0.t = 8 as libc::c_int;
        }
    } else if bt1 == 4 as libc::c_int || bt2 == 4 as libc::c_int {
        type_0.t = 4 as libc::c_int | 0x800 as libc::c_int;
        if bt1 == 4 as libc::c_int {
            type_0.t &= t1;
        }
        if bt2 == 4 as libc::c_int {
            type_0.t &= t2;
        }
        if t1 & (0xf as libc::c_int | 0x10 as libc::c_int | 0x80 as libc::c_int)
            == 4 as libc::c_int | 0x10 as libc::c_int
            || t2 & (0xf as libc::c_int | 0x10 as libc::c_int | 0x80 as libc::c_int)
                == 4 as libc::c_int | 0x10 as libc::c_int
        {
            type_0.t |= 0x10 as libc::c_int;
        }
    } else {
        type_0.t = 3 as libc::c_int | 0x800 as libc::c_int & (t1 | t2);
        if t1 & (0xf as libc::c_int | 0x10 as libc::c_int | 0x80 as libc::c_int)
            == 3 as libc::c_int | 0x10 as libc::c_int
            || t2 & (0xf as libc::c_int | 0x10 as libc::c_int | 0x80 as libc::c_int)
                == 3 as libc::c_int | 0x10 as libc::c_int
        {
            type_0.t |= 0x10 as libc::c_int;
        }
    }
    if !dest.is_null() {
        *dest = type_0;
    }
    return ret;
}
unsafe extern "C" fn gen_op(mut op: libc::c_int) {
    let mut current_block: u64;
    let mut t1: libc::c_int = 0;
    let mut t2: libc::c_int = 0;
    let mut bt1: libc::c_int = 0;
    let mut bt2: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut type1: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut combtype: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut op_class: libc::c_int = op;
    if op == 0x8b as libc::c_int || op == '>' as i32 || op == '<' as i32 {
        op_class = 'S' as i32;
    } else if op >= 0x90 as libc::c_int && op <= 0x9f as libc::c_int {
        op_class = 'C' as i32;
    }
    loop {
        t1 = (*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t;
        t2 = (*vtop.offset(0 as libc::c_int as isize)).type_0.t;
        bt1 = t1 & 0xf as libc::c_int;
        bt2 = t2 & 0xf as libc::c_int;
        if !(bt1 == 6 as libc::c_int || bt2 == 6 as libc::c_int) {
            break;
        }
        if bt2 == 6 as libc::c_int {
            mk_pointer(&mut (*vtop).type_0);
            gaddrof();
        }
        if bt1 == 6 as libc::c_int {
            vswap();
            mk_pointer(&mut (*vtop).type_0);
            gaddrof();
            vswap();
        }
    }
    if !(combine_types(
        &mut combtype,
        vtop.offset(-(1 as libc::c_int as isize)),
        vtop,
        op_class,
    ) == 0)
    {
        if bt1 == 5 as libc::c_int || bt2 == 5 as libc::c_int {
            let mut align: libc::c_int = 0;
            if op_class == 'C' as i32 {
                current_block = 5395682698947429986;
            } else if bt1 == 5 as libc::c_int && bt2 == 5 as libc::c_int {
                if op != '-' as i32 {
                    current_block = 14184010247391948510;
                } else {
                    vpush_type_size(
                        pointed_type(
                            &mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0,
                        ),
                        &mut align,
                    );
                    (*vtop).type_0.t &= !(0x10 as libc::c_int);
                    vrott(3 as libc::c_int);
                    gen_opic(op);
                    (*vtop).type_0.t = 0x800 as libc::c_int | 4 as libc::c_int;
                    vswap();
                    gen_op(0x85 as libc::c_int);
                    current_block = 15462640364611497761;
                }
            } else if op != '-' as i32 && op != '+' as i32 {
                current_block = 14184010247391948510;
            } else {
                if bt2 == 5 as libc::c_int {
                    vswap();
                    t = t1;
                    t1 = t2;
                    t2 = t;
                    bt2 = bt1;
                }
                type1 = (*vtop.offset(-(1 as libc::c_int) as isize)).type_0;
                vpush_type_size(
                    pointed_type(
                        &mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0,
                    ),
                    &mut align,
                );
                gen_op('*' as i32);
                if (*tcc_state).do_bounds_check as libc::c_int != 0
                    && nocode_wanted & 0xfff0000 as libc::c_int == 0
                {
                    if op == '-' as i32 {
                        vpushi(0 as libc::c_int);
                        vswap();
                        gen_op('-' as i32);
                    }
                    gen_bounded_ptr_add();
                } else {
                    gen_opic(op);
                }
                type1.t &= !(0x40 as libc::c_int | 0x400 as libc::c_int);
                (*vtop).type_0 = type1;
                current_block = 15462640364611497761;
            }
        } else if is_float(combtype.t) != 0 && op != '+' as i32 && op != '-' as i32
            && op != '*' as i32 && op != '/' as i32 && op_class != 'C' as i32
        {
            current_block = 14184010247391948510;
        } else {
            current_block = 5395682698947429986;
        }
        match current_block {
            14184010247391948510 => {}
            _ => {
                match current_block {
                    5395682698947429986 => {
                        t2 = combtype.t;
                        t = t2;
                        if op_class == 'S' as i32 {
                            t2 = 3 as libc::c_int;
                        }
                        if t & 0x10 as libc::c_int != 0 {
                            if op == '>' as i32 {
                                op = 0x8b as libc::c_int;
                            } else if op == '/' as i32 {
                                op = 0x83 as libc::c_int;
                            } else if op == '%' as i32 {
                                op = 0x84 as libc::c_int;
                            } else if op == 0x9c as libc::c_int {
                                op = 0x92 as libc::c_int;
                            } else if op == 0x9f as libc::c_int {
                                op = 0x97 as libc::c_int;
                            } else if op == 0x9e as libc::c_int {
                                op = 0x96 as libc::c_int;
                            } else if op == 0x9d as libc::c_int {
                                op = 0x93 as libc::c_int;
                            }
                        }
                        vswap();
                        gen_cast_s(t);
                        vswap();
                        gen_cast_s(t2);
                        if is_float(t) != 0 {
                            gen_opif(op);
                        } else {
                            gen_opic(op);
                        }
                        if op_class == 'C' as i32 {
                            (*vtop).type_0.t = 3 as libc::c_int;
                        } else {
                            (*vtop).type_0.t = t;
                        }
                    }
                    _ => {}
                }
                if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {
                    gv(
                        if is_float((*vtop).type_0.t & 0xf as libc::c_int) != 0 {
                            0x2 as libc::c_int
                        } else {
                            0x1 as libc::c_int
                        },
                    );
                }
                return;
            }
        }
    }
    _tcc_error(
        b"invalid operand types for binary operation\0" as *const u8
            as *const libc::c_char,
    );
}
unsafe extern "C" fn gen_cvt_itof1(mut t: libc::c_int) {
    if (*vtop).type_0.t & (0xf as libc::c_int | 0x10 as libc::c_int)
        == 4 as libc::c_int | 0x10 as libc::c_int
    {
        if t == 8 as libc::c_int {
            vpush_helper_func(TOK___floatundisf as libc::c_int);
        } else if t == 10 as libc::c_int {
            vpush_helper_func(TOK___floatundixf as libc::c_int);
        } else {
            vpush_helper_func(TOK___floatundidf as libc::c_int);
        }
        vrott(2 as libc::c_int);
        gfunc_call(1 as libc::c_int);
        vpushi(0 as libc::c_int);
        PUT_R_RET(vtop, t);
    } else {
        gen_cvt_itof(t);
    };
}
unsafe extern "C" fn gen_cvt_ftoi1(mut t: libc::c_int) {
    let mut st: libc::c_int = 0;
    if t == 4 as libc::c_int | 0x10 as libc::c_int {
        st = (*vtop).type_0.t & 0xf as libc::c_int;
        if st == 8 as libc::c_int {
            vpush_helper_func(TOK___fixunssfdi as libc::c_int);
        } else if st == 10 as libc::c_int {
            vpush_helper_func(TOK___fixunsxfdi as libc::c_int);
        } else {
            vpush_helper_func(TOK___fixunsdfdi as libc::c_int);
        }
        vrott(2 as libc::c_int);
        gfunc_call(1 as libc::c_int);
        vpushi(0 as libc::c_int);
        PUT_R_RET(vtop, t);
    } else {
        gen_cvt_ftoi(t);
    };
}
unsafe extern "C" fn force_charshort_cast() {
    let mut sbt: libc::c_int = if (((*vtop).r as libc::c_int & 0xc00 as libc::c_int)
        as libc::c_uint)
        .wrapping_div(
            ((0xc00 as libc::c_int & !((0xc00 as libc::c_int) << 1 as libc::c_int))
                as libc::c_uint)
                .wrapping_mul(1 as libc::c_int as libc::c_uint),
        ) == 2 as libc::c_int as libc::c_uint
    {
        4 as libc::c_int
    } else {
        3 as libc::c_int
    };
    let mut dbt: libc::c_int = (*vtop).type_0.t;
    (*vtop).r = ((*vtop).r as libc::c_int & !(0xc00 as libc::c_int)) as libc::c_ushort;
    (*vtop).type_0.t = sbt;
    gen_cast_s(
        if dbt == 11 as libc::c_int {
            1 as libc::c_int | 0x10 as libc::c_int
        } else {
            dbt
        },
    );
    (*vtop).type_0.t = dbt;
}
unsafe extern "C" fn gen_cast_s(mut t: libc::c_int) {
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    type_0.t = t;
    type_0.ref_0 = 0 as *mut Sym;
    gen_cast(&mut type_0);
}
unsafe extern "C" fn gen_cast(mut type_0: *mut CType) {
    let mut current_block: u64;
    let mut sbt: libc::c_int = 0;
    let mut dbt: libc::c_int = 0;
    let mut sf: libc::c_int = 0;
    let mut df: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut dbt_bt: libc::c_int = 0;
    let mut sbt_bt: libc::c_int = 0;
    let mut ds: libc::c_int = 0;
    let mut ss: libc::c_int = 0;
    let mut bits: libc::c_int = 0;
    let mut trunc: libc::c_int = 0;
    if (*vtop).r as libc::c_int & 0xc00 as libc::c_int != 0 {
        force_charshort_cast();
    }
    if (*vtop).type_0.t & 0x80 as libc::c_int != 0 {
        gv(0x1 as libc::c_int);
    }
    if (*type_0).t as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
        && (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int
    {
        _tcc_error(b"cast to incomplete type\0" as *const u8 as *const libc::c_char);
    }
    dbt = (*type_0).t & (0xf as libc::c_int | 0x10 as libc::c_int);
    sbt = (*vtop).type_0.t & (0xf as libc::c_int | 0x10 as libc::c_int);
    if sbt == 6 as libc::c_int {
        sbt = 5 as libc::c_int;
    }
    '_again: loop {
        if !(sbt != dbt) {
            current_block = 13137471335432333940;
            break;
        }
        sf = is_float(sbt);
        df = is_float(dbt);
        dbt_bt = dbt & 0xf as libc::c_int;
        sbt_bt = sbt & 0xf as libc::c_int;
        if dbt_bt == 0 as libc::c_int {
            current_block = 13137471335432333940;
            break;
        }
        if sbt_bt == 0 as libc::c_int {
            current_block = 1133626470450480376;
        } else {
            current_block = 12349973810996921269;
        }
        loop {
            match current_block {
                1133626470450480376 => {
                    cast_error(&mut (*vtop).type_0, type_0);
                    current_block = 12349973810996921269;
                }
                _ => {
                    c = ((*vtop).r as libc::c_int
                        & (0x3f as libc::c_int | 0x100 as libc::c_int
                            | 0x200 as libc::c_int) == 0x30 as libc::c_int)
                        as libc::c_int;
                    if c != 0 {
                        if sbt == 8 as libc::c_int {
                            (*vtop)
                                .c2rust_unnamed
                                .c
                                .ld = f128::f128::new((*vtop).c2rust_unnamed.c.f);
                        } else if sbt == 9 as libc::c_int {
                            (*vtop)
                                .c2rust_unnamed
                                .c
                                .ld = f128::f128::new((*vtop).c2rust_unnamed.c.d);
                        }
                        if df != 0 {
                            if sbt_bt == 4 as libc::c_int {
                                if sbt & 0x10 as libc::c_int != 0
                                    || (*vtop).c2rust_unnamed.c.i >> 63 as libc::c_int == 0
                                {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .ld = f128::f128::new((*vtop).c2rust_unnamed.c.i);
                                } else {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .ld = -f128::f128::new(
                                        ((*vtop).c2rust_unnamed.c.i).wrapping_neg(),
                                    );
                                }
                            } else if sf == 0 {
                                if sbt & 0x10 as libc::c_int != 0
                                    || (*vtop).c2rust_unnamed.c.i >> 31 as libc::c_int == 0
                                {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .ld = f128::f128::new(
                                        (*vtop).c2rust_unnamed.c.i as uint32_t,
                                    );
                                } else {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .ld = -f128::f128::new(
                                        ((*vtop).c2rust_unnamed.c.i as uint32_t).wrapping_neg(),
                                    );
                                }
                            }
                            if dbt == 8 as libc::c_int {
                                (*vtop)
                                    .c2rust_unnamed
                                    .c
                                    .f = ((*vtop).c2rust_unnamed.c.ld).to_f32().unwrap();
                            } else if dbt == 9 as libc::c_int {
                                (*vtop)
                                    .c2rust_unnamed
                                    .c
                                    .d = ((*vtop).c2rust_unnamed.c.ld).to_f64().unwrap();
                            }
                        } else if sf != 0 && dbt == 11 as libc::c_int {
                            (*vtop)
                                .c2rust_unnamed
                                .c
                                .i = ((*vtop).c2rust_unnamed.c.ld
                                != f128::f128::new(0 as libc::c_int)) as libc::c_int
                                as uint64_t;
                        } else {
                            if sf != 0 {
                                if dbt & 0x10 as libc::c_int != 0 {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .i = ((*vtop).c2rust_unnamed.c.ld).to_u64().unwrap();
                                } else {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .i = ((*vtop).c2rust_unnamed.c.ld).to_i64().unwrap()
                                        as uint64_t;
                                }
                            } else if !(sbt_bt == 4 as libc::c_int
                                || 8 as libc::c_int == 8 as libc::c_int
                                    && sbt == 5 as libc::c_int)
                            {
                                if sbt & 0x10 as libc::c_int != 0 {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .i = (*vtop).c2rust_unnamed.c.i as uint32_t as uint64_t;
                                } else {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .i = (*vtop).c2rust_unnamed.c.i as uint32_t as uint64_t
                                        | ((*vtop).c2rust_unnamed.c.i
                                            & 0x80000000 as libc::c_uint as uint64_t)
                                            .wrapping_neg();
                                }
                            }
                            if !(dbt_bt == 4 as libc::c_int
                                || 8 as libc::c_int == 8 as libc::c_int
                                    && dbt == 5 as libc::c_int)
                            {
                                if dbt == 11 as libc::c_int {
                                    (*vtop)
                                        .c2rust_unnamed
                                        .c
                                        .i = ((*vtop).c2rust_unnamed.c.i
                                        != 0 as libc::c_int as uint64_t) as libc::c_int as uint64_t;
                                } else {
                                    let mut m: uint32_t = if dbt_bt == 1 as libc::c_int {
                                        0xff as libc::c_int as libc::c_uint
                                    } else if dbt_bt == 2 as libc::c_int {
                                        0xffff as libc::c_int as libc::c_uint
                                    } else {
                                        0xffffffff as libc::c_uint
                                    };
                                    (*vtop).c2rust_unnamed.c.i &= m as uint64_t;
                                    if dbt & 0x10 as libc::c_int == 0 {
                                        (*vtop).c2rust_unnamed.c.i
                                            |= ((*vtop).c2rust_unnamed.c.i
                                                & (m >> 1 as libc::c_int)
                                                    .wrapping_add(1 as libc::c_int as uint32_t) as uint64_t)
                                                .wrapping_neg();
                                    }
                                }
                            }
                        }
                        current_block = 13137471335432333940;
                        break '_again;
                    } else if dbt == 11 as libc::c_int
                        && (*vtop).r as libc::c_int
                            & (0x3f as libc::c_int | 0x100 as libc::c_int
                                | 0x200 as libc::c_int)
                            == 0x30 as libc::c_int | 0x200 as libc::c_int
                    {
                        (*vtop).r = 0x30 as libc::c_int as libc::c_ushort;
                        (*vtop).c2rust_unnamed.c.i = 1 as libc::c_int as uint64_t;
                        current_block = 13137471335432333940;
                        break '_again;
                    } else {
                        if nocode_wanted as libc::c_uint & 0x80000000 as libc::c_uint
                            != 0
                        {
                            current_block = 13137471335432333940;
                            break '_again;
                        }
                        if dbt == 11 as libc::c_int {
                            gen_test_zero(0x95 as libc::c_int);
                            current_block = 13137471335432333940;
                            break '_again;
                        } else if sf != 0 || df != 0 {
                            if sf != 0 && df != 0 {
                                current_block = 4741994311446740739;
                                break;
                            } else {
                                current_block = 11441799814184323368;
                                break;
                            }
                        } else {
                            ds = btype_size(dbt_bt);
                            ss = btype_size(sbt_bt);
                            if ds == 0 as libc::c_int || ss == 0 as libc::c_int {
                                current_block = 1133626470450480376;
                                continue;
                            }
                            if ds == ss && ds >= 4 as libc::c_int {
                                current_block = 13137471335432333940;
                                break '_again;
                            } else {
                                current_block = 5684854171168229155;
                                break '_again;
                            }
                        }
                    }
                }
            }
        }
        match current_block {
            4741994311446740739 => {
                gen_cvt_ftof(dbt);
                current_block = 13137471335432333940;
                break;
            }
            _ => {
                if df != 0 {
                    gen_cvt_itof1(dbt);
                    current_block = 13137471335432333940;
                    break;
                } else {
                    sbt = dbt;
                    if dbt_bt != 4 as libc::c_int && dbt_bt != 3 as libc::c_int {
                        sbt = 3 as libc::c_int;
                    }
                    gen_cvt_ftoi1(sbt);
                }
            }
        }
    }
    match current_block {
        5684854171168229155 => {
            if dbt_bt == 5 as libc::c_int || sbt_bt == 5 as libc::c_int {
                _tcc_warning(
                    b"cast between pointer and integer of different size\0" as *const u8
                        as *const libc::c_char,
                );
                if sbt_bt == 5 as libc::c_int {
                    (*vtop)
                        .type_0
                        .t = if 8 as libc::c_int == 8 as libc::c_int {
                        4 as libc::c_int
                    } else {
                        3 as libc::c_int
                    };
                }
            }
            if 1 as libc::c_int != 0
                && (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0
            {
                if ds <= ss {
                    current_block = 13137471335432333940;
                } else if ds <= 4 as libc::c_int
                    && !(dbt == 2 as libc::c_int | 0x10 as libc::c_int
                        && sbt == 1 as libc::c_int)
                {
                    gv(0x1 as libc::c_int);
                    current_block = 13137471335432333940;
                } else {
                    current_block = 993425571616822999;
                }
            } else {
                current_block = 993425571616822999;
            }
            match current_block {
                13137471335432333940 => {}
                _ => {
                    gv(0x1 as libc::c_int);
                    trunc = 0 as libc::c_int;
                    if ds == 8 as libc::c_int {
                        if !(sbt & 0x10 as libc::c_int != 0) {
                            gen_cvt_sxtw();
                        }
                    } else {
                        if ss == 8 as libc::c_int {
                            trunc = 32 as libc::c_int;
                        } else {
                            ss = 4 as libc::c_int;
                        }
                        if !(ds >= ss) {
                            if ss == 4 as libc::c_int {
                                gen_cvt_csti(dbt);
                            } else {
                                bits = (ss - ds) * 8 as libc::c_int;
                                (*vtop)
                                    .type_0
                                    .t = (if ss == 8 as libc::c_int {
                                    4 as libc::c_int
                                } else {
                                    3 as libc::c_int
                                }) | dbt & 0x10 as libc::c_int;
                                vpushi(bits);
                                gen_op('<' as i32);
                                vpushi(bits - trunc);
                                gen_op('>' as i32);
                                vpushi(trunc);
                                gen_op(0x8b as libc::c_int);
                            }
                        }
                    }
                }
            }
        }
        _ => {}
    }
    (*vtop).type_0 = *type_0;
    (*vtop).type_0.t
        &= !(0x100 as libc::c_int | 0x200 as libc::c_int | 0x40 as libc::c_int);
}
unsafe extern "C" fn type_size(
    mut type_0: *mut CType,
    mut a: *mut libc::c_int,
) -> libc::c_int {
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut bt: libc::c_int = 0;
    bt = (*type_0).t & 0xf as libc::c_int;
    if bt == 7 as libc::c_int {
        s = (*type_0).ref_0;
        *a = (*s).r as libc::c_int;
        return (*s).c2rust_unnamed.c2rust_unnamed.c;
    } else if bt == 5 as libc::c_int {
        if (*type_0).t & 0x40 as libc::c_int != 0 {
            let mut ts: libc::c_int = 0;
            s = (*type_0).ref_0;
            ts = type_size(&mut (*s).type_0, a);
            if ts < 0 as libc::c_int
                && (*s).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int
            {
                ts = -ts;
            }
            return ts * (*s).c2rust_unnamed.c2rust_unnamed.c;
        } else {
            *a = 8 as libc::c_int;
            return 8 as libc::c_int;
        }
    } else if (*type_0).t as libc::c_uint
        & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
            .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
            | 0x80 as libc::c_int as libc::c_uint)
        == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
        && (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int
    {
        *a = 0 as libc::c_int;
        return -(1 as libc::c_int);
    } else if bt == 10 as libc::c_int {
        *a = 16 as libc::c_int;
        return 16 as libc::c_int;
    } else if bt == 9 as libc::c_int || bt == 4 as libc::c_int {
        *a = 8 as libc::c_int;
        return 8 as libc::c_int;
    } else if bt == 3 as libc::c_int || bt == 8 as libc::c_int {
        *a = 4 as libc::c_int;
        return 4 as libc::c_int;
    } else if bt == 2 as libc::c_int {
        *a = 2 as libc::c_int;
        return 2 as libc::c_int;
    } else if bt == 13 as libc::c_int || bt == 14 as libc::c_int {
        *a = 8 as libc::c_int;
        return 16 as libc::c_int;
    } else {
        *a = 1 as libc::c_int;
        return 1 as libc::c_int;
    };
}
unsafe extern "C" fn vpush_type_size(mut type_0: *mut CType, mut a: *mut libc::c_int) {
    if (*type_0).t & 0x400 as libc::c_int != 0 {
        type_size(&mut (*(*type_0).ref_0).type_0, a);
        vset(
            &mut int_type,
            0x32 as libc::c_int | 0x100 as libc::c_int,
            (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c,
        );
    } else {
        let mut size: libc::c_int = type_size(type_0, a);
        if size < 0 as libc::c_int {
            _tcc_error(b"unknown type size\0" as *const u8 as *const libc::c_char);
        }
        vpushs(size as Elf64_Addr);
    };
}
#[inline]
unsafe extern "C" fn pointed_type(mut type_0: *mut CType) -> *mut CType {
    return &mut (*(*type_0).ref_0).type_0;
}
unsafe extern "C" fn mk_pointer(mut type_0: *mut CType) {
    let mut s: *mut Sym = 0 as *mut Sym;
    s = sym_push(
        0x20000000 as libc::c_int,
        type_0,
        0 as libc::c_int,
        -(1 as libc::c_int),
    );
    (*type_0)
        .t = 5 as libc::c_int
        | (*type_0).t
            & (0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
                | 0x8000 as libc::c_int);
    (*type_0).ref_0 = s;
}
unsafe extern "C" fn is_compatible_types(
    mut type1: *mut CType,
    mut type2: *mut CType,
) -> libc::c_int {
    return compare_types(type1, type2, 0 as libc::c_int);
}
unsafe extern "C" fn is_compatible_unqualified_types(
    mut type1: *mut CType,
    mut type2: *mut CType,
) -> libc::c_int {
    return compare_types(type1, type2, 1 as libc::c_int);
}
unsafe extern "C" fn cast_error(mut st: *mut CType, mut dt: *mut CType) {
    type_incompatibility_error(
        st,
        dt,
        b"cannot convert '%s' to '%s'\0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn verify_assign_cast(mut dt: *mut CType) {
    let mut st: *mut CType = 0 as *mut CType;
    let mut type1: *mut CType = 0 as *mut CType;
    let mut type2: *mut CType = 0 as *mut CType;
    let mut dbt: libc::c_int = 0;
    let mut sbt: libc::c_int = 0;
    let mut qualwarn: libc::c_int = 0;
    let mut lvl: libc::c_int = 0;
    st = &mut (*vtop).type_0;
    dbt = (*dt).t & 0xf as libc::c_int;
    sbt = (*st).t & 0xf as libc::c_int;
    if (*dt).t & 0x100 as libc::c_int != 0 {
        _tcc_warning(
            b"assignment of read-only location\0" as *const u8 as *const libc::c_char,
        );
    }
    let mut current_block_26: u64;
    match dbt {
        0 => {
            if sbt != dbt {
                _tcc_error(
                    b"assignment to void expression\0" as *const u8
                        as *const libc::c_char,
                );
            }
            current_block_26 = 7427571413727699167;
        }
        5 => {
            if is_null_pointer(vtop) != 0 {
                current_block_26 = 7427571413727699167;
            } else if is_integer_btype(sbt) != 0 {
                _tcc_warning(
                    b"assignment makes pointer from integer without a cast\0"
                        as *const u8 as *const libc::c_char,
                );
                current_block_26 = 7427571413727699167;
            } else {
                type1 = pointed_type(dt);
                if sbt == 5 as libc::c_int {
                    type2 = pointed_type(st);
                    current_block_26 = 12599329904712511516;
                } else if sbt == 6 as libc::c_int {
                    type2 = st;
                    current_block_26 = 12599329904712511516;
                } else {
                    current_block_26 = 10182502753655253934;
                }
                match current_block_26 {
                    10182502753655253934 => {}
                    _ => {
                        if is_compatible_types(type1, type2) != 0 {
                            current_block_26 = 7427571413727699167;
                        } else {
                            lvl = 0 as libc::c_int;
                            qualwarn = lvl;
                            loop {
                                if (*type2).t & 0x100 as libc::c_int != 0
                                    && (*type1).t & 0x100 as libc::c_int == 0
                                    || (*type2).t & 0x200 as libc::c_int != 0
                                        && (*type1).t & 0x200 as libc::c_int == 0
                                {
                                    qualwarn = 1 as libc::c_int;
                                }
                                dbt = (*type1).t
                                    & (0xf as libc::c_int | 0x800 as libc::c_int);
                                sbt = (*type2).t
                                    & (0xf as libc::c_int | 0x800 as libc::c_int);
                                if dbt != 5 as libc::c_int || sbt != 5 as libc::c_int {
                                    break;
                                }
                                type1 = pointed_type(type1);
                                type2 = pointed_type(type2);
                                lvl += 1;
                                lvl;
                            }
                            if is_compatible_unqualified_types(type1, type2) == 0 {
                                if (dbt == 0 as libc::c_int || sbt == 0 as libc::c_int)
                                    && lvl == 0 as libc::c_int
                                {
                                    current_block_26 = 4775909272756257391;
                                } else if dbt == sbt
                                    && is_integer_btype(sbt & 0xf as libc::c_int) != 0
                                    && (((*type1).t as libc::c_uint
                                        & (((1 as libc::c_uint)
                                            << 6 as libc::c_int + 6 as libc::c_int)
                                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint)
                                        == ((2 as libc::c_int) << 20 as libc::c_int)
                                            as libc::c_uint) as libc::c_int
                                        + ((*type2).t as libc::c_uint
                                            & (((1 as libc::c_uint)
                                                << 6 as libc::c_int + 6 as libc::c_int)
                                                .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                                << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint)
                                            == ((2 as libc::c_int) << 20 as libc::c_int)
                                                as libc::c_uint) as libc::c_int
                                        + (((*type1).t ^ (*type2).t) & 0x10 as libc::c_int != 0)
                                            as libc::c_int) < 2 as libc::c_int
                                {
                                    current_block_26 = 4775909272756257391;
                                } else {
                                    _tcc_warning(
                                        b"assignment from incompatible pointer type\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                    current_block_26 = 7427571413727699167;
                                }
                            } else {
                                current_block_26 = 4775909272756257391;
                            }
                            match current_block_26 {
                                7427571413727699167 => {}
                                _ => {
                                    if qualwarn != 0 {
                                        (*tcc_state)
                                            .warn_num = (&mut (*(0 as *mut TCCState))
                                            .warn_discarded_qualifiers as *mut libc::c_uchar as size_t)
                                            .wrapping_sub(
                                                &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                                                    as size_t,
                                            ) as libc::c_uchar;
                                        (Some(
                                            _tcc_warning
                                                as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                                        ))
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            b"assignment discards qualifiers from pointer target type\0"
                                                as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    current_block_26 = 7427571413727699167;
                                }
                            }
                        }
                    }
                }
            }
        }
        1 | 2 | 3 | 4 => {
            if sbt == 5 as libc::c_int || sbt == 6 as libc::c_int {
                _tcc_warning(
                    b"assignment makes integer from pointer without a cast\0"
                        as *const u8 as *const libc::c_char,
                );
                current_block_26 = 7427571413727699167;
            } else if sbt == 7 as libc::c_int {
                current_block_26 = 6803059737688579307;
            } else {
                current_block_26 = 7427571413727699167;
            }
        }
        7 => {
            current_block_26 = 6803059737688579307;
        }
        _ => {
            current_block_26 = 7427571413727699167;
        }
    }
    match current_block_26 {
        6803059737688579307 => {
            if is_compatible_unqualified_types(dt, st) == 0 {
                current_block_26 = 10182502753655253934;
            } else {
                current_block_26 = 7427571413727699167;
            }
        }
        _ => {}
    }
    match current_block_26 {
        10182502753655253934 => {
            cast_error(st, dt);
        }
        _ => {}
    };
}
unsafe extern "C" fn gen_assign_cast(mut dt: *mut CType) {
    verify_assign_cast(dt);
    gen_cast(dt);
}
unsafe extern "C" fn vstore() {
    let mut sbt: libc::c_int = 0;
    let mut dbt: libc::c_int = 0;
    let mut ft: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut bit_size: libc::c_int = 0;
    let mut bit_pos: libc::c_int = 0;
    let mut delayed_cast: libc::c_int = 0;
    ft = (*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t;
    sbt = (*vtop).type_0.t & 0xf as libc::c_int;
    dbt = ft & 0xf as libc::c_int;
    verify_assign_cast(&mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0);
    if sbt == 7 as libc::c_int {
        size = type_size(&mut (*vtop).type_0, &mut align);
        vpushv(vtop.offset(-(1 as libc::c_int as isize)));
        if (*vtop).r as libc::c_int & 0x4000 as libc::c_int != 0 {
            gbound();
        }
        (*vtop).type_0.t = 5 as libc::c_int;
        gaddrof();
        vswap();
        if (*vtop).r as libc::c_int & 0x4000 as libc::c_int != 0 {
            gbound();
        }
        (*vtop).type_0.t = 5 as libc::c_int;
        gaddrof();
        if 1 as libc::c_int != 0 && (*tcc_state).do_bounds_check == 0 {
            gen_struct_copy(size);
        } else {
            vpushi(size);
            vpush_helper_func(TOK_memmove as libc::c_int);
            vrott(4 as libc::c_int);
            gfunc_call(3 as libc::c_int);
        }
    } else if ft & 0x80 as libc::c_int != 0 {
        vdup();
        *vtop
            .offset(
                -(1 as libc::c_int) as isize,
            ) = *vtop.offset(-(2 as libc::c_int) as isize);
        bit_pos = ft >> 20 as libc::c_int & 0x3f as libc::c_int;
        bit_size = ft >> 20 as libc::c_int + 6 as libc::c_int & 0x3f as libc::c_int;
        (*vtop.offset(-(1 as libc::c_int) as isize))
            .type_0
            .t = (ft as libc::c_uint
            & !(((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                | 0x80 as libc::c_int as libc::c_uint)) as libc::c_int;
        if dbt == 11 as libc::c_int {
            gen_cast(&mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0);
            (*vtop.offset(-(1 as libc::c_int) as isize))
                .type_0
                .t = (*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t
                & !(0xf as libc::c_int) | (1 as libc::c_int | 0x10 as libc::c_int);
        }
        r = adjust_bf(vtop.offset(-(1 as libc::c_int as isize)), bit_pos, bit_size);
        if dbt != 11 as libc::c_int {
            gen_cast(&mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0);
            dbt = (*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t
                & 0xf as libc::c_int;
        }
        if r == 7 as libc::c_int {
            store_packed_bf(bit_pos, bit_size);
        } else {
            let mut mask: libc::c_ulonglong = ((1 as libc::c_ulonglong) << bit_size)
                .wrapping_sub(1 as libc::c_int as libc::c_ulonglong);
            if dbt != 11 as libc::c_int {
                if dbt == 4 as libc::c_int {
                    vpushll(mask as libc::c_longlong);
                } else {
                    vpushi(mask as libc::c_uint as libc::c_int);
                }
                gen_op('&' as i32);
            }
            vpushi(bit_pos);
            gen_op('<' as i32);
            vswap();
            vdup();
            vrott(3 as libc::c_int);
            if dbt == 4 as libc::c_int {
                vpushll(!(mask << bit_pos) as libc::c_longlong);
            } else {
                vpushi(!((mask as libc::c_uint) << bit_pos) as libc::c_int);
            }
            gen_op('&' as i32);
            gen_op('|' as i32);
            vstore();
            vpop();
        }
    } else if dbt == 0 as libc::c_int {
        vtop = vtop.offset(-1);
        vtop;
    } else {
        delayed_cast = 0 as libc::c_int;
        if (dbt == 1 as libc::c_int || dbt == 2 as libc::c_int)
            && is_integer_btype(sbt) != 0
        {
            if (*vtop).r as libc::c_int & 0xc00 as libc::c_int != 0
                && btype_size(dbt) > btype_size(sbt)
            {
                force_charshort_cast();
            }
            delayed_cast = 1 as libc::c_int;
        } else {
            gen_cast(&mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0);
        }
        if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
            & 0x4000 as libc::c_int != 0
        {
            vswap();
            gbound();
            vswap();
        }
        gv(RC_TYPE(dbt));
        if delayed_cast != 0 {
            (*vtop)
                .r = ((*vtop).r as libc::c_uint
                | ((0xc00 as libc::c_int & !((0xc00 as libc::c_int) << 1 as libc::c_int))
                    as libc::c_uint)
                    .wrapping_mul(
                        ((sbt == 4 as libc::c_int) as libc::c_int + 1 as libc::c_int)
                            as libc::c_uint,
                    )) as libc::c_ushort;
            (*vtop)
                .type_0
                .t = (ft as libc::c_uint
                & !((0x1000 as libc::c_int | 0x2000 as libc::c_int
                    | 0x4000 as libc::c_int | 0x8000 as libc::c_int) as libc::c_uint
                    | (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint)))
                as libc::c_int;
        }
        if (*vtop.offset(-(1 as libc::c_int) as isize)).r as libc::c_int
            & 0x3f as libc::c_int == 0x31 as libc::c_int
        {
            let mut sv: SValue = SValue {
                type_0: CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                },
                r: 0,
                r2: 0,
                c2rust_unnamed: C2RustUnnamed_15 {
                    c2rust_unnamed: C2RustUnnamed_16 {
                        jtrue: 0,
                        jfalse: 0,
                    },
                },
                c2rust_unnamed_0: C2RustUnnamed_13 {
                    c2rust_unnamed: C2RustUnnamed_14 {
                        cmp_op: 0,
                        cmp_r: 0,
                    },
                },
            };
            r = get_reg(0x1 as libc::c_int);
            sv.type_0.t = 0x800 as libc::c_int | 4 as libc::c_int;
            sv.r = (0x32 as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
            sv
                .c2rust_unnamed
                .c
                .i = (*vtop.offset(-(1 as libc::c_int) as isize)).c2rust_unnamed.c.i;
            load(r, &mut sv);
            (*vtop.offset(-(1 as libc::c_int) as isize))
                .r = (r | 0x100 as libc::c_int) as libc::c_ushort;
        }
        r = (*vtop).r as libc::c_int & 0x3f as libc::c_int;
        if R2_RET(dbt) != 0x30 as libc::c_int {
            let mut load_type: libc::c_int = if dbt == 14 as libc::c_int {
                9 as libc::c_int
            } else {
                0x800 as libc::c_int | 4 as libc::c_int
            };
            (*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t = load_type;
            store(r, vtop.offset(-(1 as libc::c_int as isize)));
            vswap();
            incr_offset(8 as libc::c_int);
            vswap();
            store((*vtop).r2 as libc::c_int, vtop.offset(-(1 as libc::c_int as isize)));
        } else {
            store(r, vtop.offset(-(1 as libc::c_int as isize)));
        }
        vswap();
        vtop = vtop.offset(-1);
        vtop;
    };
}
unsafe extern "C" fn inc(mut post: libc::c_int, mut c: libc::c_int) {
    test_lvalue();
    vdup();
    if post != 0 {
        gv_dup();
        vrotb(3 as libc::c_int);
        vrotb(3 as libc::c_int);
    }
    vpushi(c - 0x81 as libc::c_int);
    gen_op('+' as i32);
    vstore();
    if post != 0 {
        vpop();
    }
}
unsafe extern "C" fn parse_mult_str(mut msg: *const libc::c_char) -> *mut CString {
    if tok != 0xc8 as libc::c_int {
        expect(msg);
    }
    cstr_reset(&mut initstr);
    while tok == 0xc8 as libc::c_int {
        cstr_cat(&mut initstr, tokc.str_0.data, -(1 as libc::c_int));
        next();
    }
    cstr_ccat(&mut initstr, '\0' as i32);
    return &mut initstr;
}
unsafe extern "C" fn exact_log2p1(mut i: libc::c_int) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    if i == 0 {
        return 0 as libc::c_int;
    }
    ret = 1 as libc::c_int;
    while i >= (1 as libc::c_int) << 8 as libc::c_int {
        i >>= 8 as libc::c_int;
        ret += 8 as libc::c_int;
    }
    if i >= (1 as libc::c_int) << 4 as libc::c_int {
        ret += 4 as libc::c_int;
        i >>= 4 as libc::c_int;
    }
    if i >= (1 as libc::c_int) << 2 as libc::c_int {
        ret += 2 as libc::c_int;
        i >>= 2 as libc::c_int;
    }
    if i >= (1 as libc::c_int) << 1 as libc::c_int {
        ret += 1;
        ret;
    }
    return ret;
}
unsafe extern "C" fn parse_attribute(mut ad: *mut AttributeDef) {
    let mut t: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut astr: *mut libc::c_char = 0 as *mut libc::c_char;
    loop {
        if tok != TOK_ATTRIBUTE1 as libc::c_int && tok != TOK_ATTRIBUTE2 as libc::c_int {
            return;
        }
        next();
        skip('(' as i32);
        skip('(' as i32);
        while tok != ')' as i32 {
            if tok < 256 as libc::c_int {
                expect(b"attribute name\0" as *const u8 as *const libc::c_char);
            }
            t = tok;
            next();
            match t {
                374 | 375 => {
                    let mut s: *mut Sym = 0 as *mut Sym;
                    skip('(' as i32);
                    s = sym_find(tok);
                    if s.is_null() {
                        (*tcc_state)
                            .warn_num = (&mut (*(0 as *mut TCCState))
                            .warn_implicit_function_declaration as *mut libc::c_uchar
                            as size_t)
                            .wrapping_sub(
                                &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                                    as size_t,
                            ) as libc::c_uchar;
                        (Some(
                            _tcc_warning
                                as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                        ))
                            .expect(
                                "non-null function pointer",
                            )(
                            b"implicit declaration of function '%s'\0" as *const u8
                                as *const libc::c_char,
                            get_tok_str(tok, &mut tokc),
                        );
                        s = external_global_sym(tok, &mut func_old_type);
                    } else if (*s).type_0.t & 0xf as libc::c_int != 6 as libc::c_int {
                        _tcc_error(
                            b"'%s' is not declared as function\0" as *const u8
                                as *const libc::c_char,
                            get_tok_str(tok, &mut tokc),
                        );
                    }
                    (*ad).cleanup_func = s;
                    next();
                    skip(')' as i32);
                }
                376 | 377 => {
                    ((*ad).f).set_func_ctor(1 as libc::c_int as libc::c_uint);
                }
                378 | 379 => {
                    ((*ad).f).set_func_dtor(1 as libc::c_int as libc::c_uint);
                }
                380 | 381 => {
                    ((*ad).f).set_func_alwinl(1 as libc::c_int as libc::c_uint);
                }
                346 | 347 => {
                    skip('(' as i32);
                    astr = (*parse_mult_str(
                        b"section name\0" as *const u8 as *const libc::c_char,
                    ))
                        .data;
                    (*ad).section = find_section(tcc_state, astr);
                    skip(')' as i32);
                }
                354 | 355 => {
                    skip('(' as i32);
                    astr = (*parse_mult_str(
                        b"alias(\"target\")\0" as *const u8 as *const libc::c_char,
                    ))
                        .data;
                    (*ad).alias_target = tok_alloc_const(astr);
                    skip(')' as i32);
                }
                394 | 395 => {
                    skip('(' as i32);
                    astr = (*parse_mult_str(
                        b"visibility(\"default|hidden|internal|protected\")\0"
                            as *const u8 as *const libc::c_char,
                    ))
                        .data;
                    if strcmp(astr, b"default\0" as *const u8 as *const libc::c_char)
                        == 0
                    {
                        ((*ad).a).set_visibility(0 as libc::c_int as libc::c_ushort);
                    } else if strcmp(
                        astr,
                        b"hidden\0" as *const u8 as *const libc::c_char,
                    ) == 0
                    {
                        ((*ad).a).set_visibility(2 as libc::c_int as libc::c_ushort);
                    } else if strcmp(
                        astr,
                        b"internal\0" as *const u8 as *const libc::c_char,
                    ) == 0
                    {
                        ((*ad).a).set_visibility(1 as libc::c_int as libc::c_ushort);
                    } else if strcmp(
                        astr,
                        b"protected\0" as *const u8 as *const libc::c_char,
                    ) == 0
                    {
                        ((*ad).a).set_visibility(3 as libc::c_int as libc::c_ushort);
                    } else {
                        expect(
                            b"visibility(\"default|hidden|internal|protected\")\0"
                                as *const u8 as *const libc::c_char,
                        );
                    }
                    skip(')' as i32);
                }
                348 | 349 => {
                    if tok == '(' as i32 {
                        next();
                        n = expr_const();
                        if n <= 0 as libc::c_int
                            || n & n - 1 as libc::c_int != 0 as libc::c_int
                        {
                            _tcc_error(
                                b"alignment must be a positive power of two\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        skip(')' as i32);
                    } else {
                        n = 16 as libc::c_int;
                    }
                    ((*ad).a).set_aligned(exact_log2p1(n) as libc::c_ushort);
                    if n
                        != (1 as libc::c_int)
                            << ((*ad).a).aligned() as libc::c_int - 1 as libc::c_int
                    {
                        _tcc_error(
                            b"alignment of %d is larger than implemented\0" as *const u8
                                as *const libc::c_char,
                            n,
                        );
                    }
                }
                350 | 351 => {
                    ((*ad).a).set_packed(1 as libc::c_int as libc::c_ushort);
                }
                352 | 353 => {
                    ((*ad).a).set_weak(1 as libc::c_int as libc::c_ushort);
                }
                358 | 359 => {
                    ((*ad).a).set_nodebug(1 as libc::c_int as libc::c_ushort);
                }
                356 | 357 => {}
                391 | 392 => {
                    ((*ad).f).set_func_noreturn(1 as libc::c_int as libc::c_uint);
                }
                360 | 361 | 362 => {
                    ((*ad).f).set_func_call(0 as libc::c_int as libc::c_uint);
                }
                363 | 364 | 365 => {
                    ((*ad).f).set_func_call(1 as libc::c_int as libc::c_uint);
                }
                382 => {
                    skip('(' as i32);
                    match tok {
                        384 => {
                            (*ad)
                                .attr_mode = (4 as libc::c_int + 1 as libc::c_int)
                                as libc::c_char;
                        }
                        383 => {
                            (*ad)
                                .attr_mode = (1 as libc::c_int + 1 as libc::c_int)
                                as libc::c_char;
                        }
                        385 => {
                            (*ad)
                                .attr_mode = (2 as libc::c_int + 1 as libc::c_int)
                                as libc::c_char;
                        }
                        386 | 387 => {
                            (*ad)
                                .attr_mode = (3 as libc::c_int + 1 as libc::c_int)
                                as libc::c_char;
                        }
                        _ => {
                            _tcc_warning(
                                b"__mode__(%s) not supported\n\0" as *const u8
                                    as *const libc::c_char,
                                get_tok_str(tok, 0 as *mut CValue),
                            );
                        }
                    }
                    next();
                    skip(')' as i32);
                }
                388 => {
                    ((*ad).a).set_dllexport(1 as libc::c_int as libc::c_ushort);
                }
                390 => {
                    ((*ad).a).set_nodecorate(1 as libc::c_int as libc::c_ushort);
                }
                389 => {
                    ((*ad).a).set_dllimport(1 as libc::c_int as libc::c_ushort);
                }
                _ => {
                    (*tcc_state)
                        .warn_num = (&mut (*(0 as *mut TCCState)).warn_unsupported
                        as *mut libc::c_uchar as size_t)
                        .wrapping_sub(
                            &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                                as size_t,
                        ) as libc::c_uchar;
                    (Some(
                        _tcc_warning
                            as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        b"'%s' attribute ignored\0" as *const u8 as *const libc::c_char,
                        get_tok_str(t, 0 as *mut CValue),
                    );
                    if tok == '(' as i32 {
                        let mut parenthesis: libc::c_int = 0 as libc::c_int;
                        loop {
                            if tok == '(' as i32 {
                                parenthesis += 1;
                                parenthesis;
                            } else if tok == ')' as i32 {
                                parenthesis -= 1;
                                parenthesis;
                            }
                            next();
                            if !(parenthesis != 0 && tok != -(1 as libc::c_int)) {
                                break;
                            }
                        }
                    }
                }
            }
            if tok != ',' as i32 {
                break;
            }
            next();
        }
        skip(')' as i32);
        skip(')' as i32);
    };
}
unsafe extern "C" fn find_field(
    mut type_0: *mut CType,
    mut v: libc::c_int,
    mut cumofs: *mut libc::c_int,
) -> *mut Sym {
    let mut s: *mut Sym = (*type_0).ref_0;
    let mut v1: libc::c_int = v | 0x20000000 as libc::c_int;
    if v & 0x20000000 as libc::c_int == 0 {
        if (*type_0).t & 0xf as libc::c_int != 7 as libc::c_int {
            expect(b"struct or union\0" as *const u8 as *const libc::c_char);
        }
        if v < TOK_DEFINE as libc::c_int {
            expect(b"field name\0" as *const u8 as *const libc::c_char);
        }
        if (*s).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int {
            _tcc_error(
                b"dereferencing incomplete type '%s'\0" as *const u8
                    as *const libc::c_char,
                get_tok_str((*s).v & !(0x40000000 as libc::c_int), 0 as *mut CValue),
            );
        }
    }
    loop {
        s = (*s).c2rust_unnamed_0.next;
        if s.is_null() {
            break;
        }
        if (*s).v == v1 {
            *cumofs = (*s).c2rust_unnamed.c2rust_unnamed.c;
            return s;
        }
        if (*s).type_0.t & 0xf as libc::c_int == 7 as libc::c_int
            && (*s).v >= 0x10000000 as libc::c_int | 0x20000000 as libc::c_int
        {
            let mut ret: *mut Sym = find_field(&mut (*s).type_0, v1, cumofs);
            if !ret.is_null() {
                *cumofs += (*s).c2rust_unnamed.c2rust_unnamed.c;
                return ret;
            }
        }
    }
    if v & 0x20000000 as libc::c_int == 0 {
        _tcc_error(
            b"field not found: %s\0" as *const u8 as *const libc::c_char,
            get_tok_str(v, 0 as *mut CValue),
        );
    }
    return s;
}
unsafe extern "C" fn check_fields(mut type_0: *mut CType, mut check: libc::c_int) {
    let mut s: *mut Sym = (*type_0).ref_0;
    loop {
        s = (*s).c2rust_unnamed_0.next;
        if s.is_null() {
            break;
        }
        let mut v: libc::c_int = (*s).v & !(0x20000000 as libc::c_int);
        if v < 0x10000000 as libc::c_int {
            let mut ts: *mut TokenSym = *table_ident
                .offset((v - 256 as libc::c_int) as isize);
            if check != 0 && (*ts).tok & 0x20000000 as libc::c_int != 0 {
                _tcc_error(
                    b"duplicate member '%s'\0" as *const u8 as *const libc::c_char,
                    get_tok_str(v, 0 as *mut CValue),
                );
            }
            (*ts).tok ^= 0x20000000 as libc::c_int;
        } else if (*s).type_0.t & 0xf as libc::c_int == 7 as libc::c_int {
            check_fields(&mut (*s).type_0, check);
        }
    };
}
unsafe extern "C" fn struct_layout(mut type_0: *mut CType, mut ad: *mut AttributeDef) {
    let mut current_block: u64;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut maxalign: libc::c_int = 0;
    let mut offset: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut bit_pos: libc::c_int = 0;
    let mut bit_size: libc::c_int = 0;
    let mut packed: libc::c_int = 0;
    let mut a: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut prevbt: libc::c_int = 0;
    let mut prev_bit_size: libc::c_int = 0;
    let mut pcc: libc::c_int = ((*tcc_state).ms_bitfields == 0) as libc::c_int;
    let mut pragma_pack: libc::c_int = *(*tcc_state).pack_stack_ptr;
    let mut f: *mut Sym = 0 as *mut Sym;
    maxalign = 1 as libc::c_int;
    offset = 0 as libc::c_int;
    c = 0 as libc::c_int;
    bit_pos = 0 as libc::c_int;
    prevbt = 7 as libc::c_int;
    prev_bit_size = 0 as libc::c_int;
    f = (*(*type_0).ref_0).c2rust_unnamed_0.next;
    while !f.is_null() {
        if (*f).type_0.t & 0x80 as libc::c_int != 0 {
            bit_size = (*f).type_0.t >> 20 as libc::c_int + 6 as libc::c_int
                & 0x3f as libc::c_int;
        } else {
            bit_size = -(1 as libc::c_int);
        }
        size = type_size(&mut (*f).type_0, &mut align);
        a = if ((*f).a).aligned() as libc::c_int != 0 {
            (1 as libc::c_int) << ((*f).a).aligned() as libc::c_int - 1 as libc::c_int
        } else {
            0 as libc::c_int
        };
        packed = 0 as libc::c_int;
        if !(pcc != 0 && bit_size == 0 as libc::c_int) {
            if pcc != 0
                && (((*f).a).packed() as libc::c_int != 0
                    || ((*ad).a).packed() as libc::c_int != 0)
            {
                packed = 1 as libc::c_int;
                align = packed;
            }
            if pragma_pack != 0 {
                packed = 1 as libc::c_int;
                if pragma_pack < align {
                    align = pragma_pack;
                }
                if pcc != 0 && pragma_pack < a {
                    a = 0 as libc::c_int;
                }
            }
        }
        if a != 0 {
            align = a;
        }
        if (*(*type_0).ref_0).type_0.t
            == (1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int
        {
            if pcc != 0 && bit_size >= 0 as libc::c_int {
                size = bit_size + 7 as libc::c_int >> 3 as libc::c_int;
            }
            offset = 0 as libc::c_int;
            if size > c {
                c = size;
            }
        } else if bit_size < 0 as libc::c_int {
            if pcc != 0 {
                c += bit_pos + 7 as libc::c_int >> 3 as libc::c_int;
            }
            c = c + align - 1 as libc::c_int & -align;
            offset = c;
            if size > 0 as libc::c_int {
                c += size;
            }
            bit_pos = 0 as libc::c_int;
            prevbt = 7 as libc::c_int;
            prev_bit_size = 0 as libc::c_int;
        } else {
            if pcc != 0 {
                if bit_size == 0 as libc::c_int {
                    current_block = 13426335267379191562;
                } else if ((*f).a).aligned() != 0 {
                    current_block = 13426335267379191562;
                } else if packed == 0 {
                    let mut a8: libc::c_int = align * 8 as libc::c_int;
                    let mut ofs: libc::c_int = ((c * 8 as libc::c_int + bit_pos) % a8
                        + bit_size + a8 - 1 as libc::c_int) / a8;
                    if ofs > size / align {
                        current_block = 13426335267379191562;
                    } else {
                        current_block = 15004371738079956865;
                    }
                } else {
                    current_block = 15004371738079956865;
                }
                match current_block {
                    13426335267379191562 => {
                        c = c + (bit_pos + 7 as libc::c_int >> 3 as libc::c_int) + align
                            - 1 as libc::c_int & -align;
                        bit_pos = 0 as libc::c_int;
                    }
                    _ => {}
                }
                if size == 8 as libc::c_int && bit_size <= 32 as libc::c_int {
                    (*f)
                        .type_0
                        .t = (*f).type_0.t & !(0xf as libc::c_int) | 3 as libc::c_int;
                    size = 4 as libc::c_int;
                }
                while bit_pos >= align * 8 as libc::c_int {
                    c += align;
                    bit_pos -= align * 8 as libc::c_int;
                }
                offset = c;
                if (*f).v & 0x10000000 as libc::c_int != 0 {
                    align = 1 as libc::c_int;
                }
            } else {
                bt = (*f).type_0.t & 0xf as libc::c_int;
                if bit_pos + bit_size > size * 8 as libc::c_int
                    || (bit_size > 0 as libc::c_int) as libc::c_int
                        == (bt != prevbt) as libc::c_int
                {
                    c = c + align - 1 as libc::c_int & -align;
                    offset = c;
                    bit_pos = 0 as libc::c_int;
                    if bit_size != 0 || prev_bit_size != 0 {
                        c += size;
                    }
                }
                if bit_size == 0 as libc::c_int && prevbt != bt {
                    align = 1 as libc::c_int;
                }
                prevbt = bt;
                prev_bit_size = bit_size;
            }
            (*f)
                .type_0
                .t = (*f).type_0.t & !((0x3f as libc::c_int) << 20 as libc::c_int)
                | bit_pos << 20 as libc::c_int;
            bit_pos += bit_size;
        }
        if align > maxalign {
            maxalign = align;
        }
        (*f).c2rust_unnamed.c2rust_unnamed.c = offset;
        (*f).r = 0 as libc::c_int as libc::c_ushort;
        f = (*f).c2rust_unnamed_0.next;
    }
    if pcc != 0 {
        c += bit_pos + 7 as libc::c_int >> 3 as libc::c_int;
    }
    bt = if ((*ad).a).aligned() as libc::c_int != 0 {
        (1 as libc::c_int) << ((*ad).a).aligned() as libc::c_int - 1 as libc::c_int
    } else {
        1 as libc::c_int
    };
    a = bt;
    if a < maxalign {
        a = maxalign;
    }
    (*(*type_0).ref_0).r = a as libc::c_ushort;
    if pragma_pack != 0 && pragma_pack < maxalign && 0 as libc::c_int == pcc {
        a = pragma_pack;
        if a < bt {
            a = bt;
        }
    }
    c = c + a - 1 as libc::c_int & -a;
    (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c = c;
    f = (*(*type_0).ref_0).c2rust_unnamed_0.next;
    while !f.is_null() {
        let mut s: libc::c_int = 0;
        let mut px: libc::c_int = 0;
        let mut cx: libc::c_int = 0;
        let mut c0: libc::c_int = 0;
        let mut t: CType = CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        };
        if !(0 as libc::c_int == (*f).type_0.t & 0x80 as libc::c_int) {
            (*f).type_0.ref_0 = f;
            (*f)
                .c2rust_unnamed
                .c2rust_unnamed
                .c2rust_unnamed
                .auxtype = -(1 as libc::c_int);
            bit_size = (*f).type_0.t >> 20 as libc::c_int + 6 as libc::c_int
                & 0x3f as libc::c_int;
            if !(bit_size == 0 as libc::c_int) {
                bit_pos = (*f).type_0.t >> 20 as libc::c_int & 0x3f as libc::c_int;
                size = type_size(&mut (*f).type_0, &mut align);
                if !(bit_pos + bit_size <= size * 8 as libc::c_int
                    && (*f).c2rust_unnamed.c2rust_unnamed.c + size <= c)
                {
                    c0 = -(1 as libc::c_int);
                    align = 1 as libc::c_int;
                    s = align;
                    t.t = 1 as libc::c_int;
                    loop {
                        px = (*f).c2rust_unnamed.c2rust_unnamed.c * 8 as libc::c_int
                            + bit_pos;
                        cx = px >> 3 as libc::c_int & -align;
                        px = px - (cx << 3 as libc::c_int);
                        if c0 == cx {
                            break;
                        }
                        s = px + bit_size + 7 as libc::c_int >> 3 as libc::c_int;
                        if s > 4 as libc::c_int {
                            t.t = 4 as libc::c_int;
                        } else if s > 2 as libc::c_int {
                            t.t = 3 as libc::c_int;
                        } else if s > 1 as libc::c_int {
                            t.t = 2 as libc::c_int;
                        } else {
                            t.t = 1 as libc::c_int;
                        }
                        s = type_size(&mut t, &mut align);
                        c0 = cx;
                    }
                    if px + bit_size <= s * 8 as libc::c_int && cx + s <= c {
                        (*f).c2rust_unnamed.c2rust_unnamed.c = cx;
                        bit_pos = px;
                        (*f)
                            .type_0
                            .t = (*f).type_0.t
                            & !((0x3f as libc::c_int) << 20 as libc::c_int)
                            | bit_pos << 20 as libc::c_int;
                        if s != size {
                            (*f)
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .auxtype = t.t;
                        }
                    } else {
                        (*f)
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .auxtype = 7 as libc::c_int;
                    }
                }
            }
        }
        f = (*f).c2rust_unnamed_0.next;
    }
}
unsafe extern "C" fn struct_decl(mut type_0: *mut CType, mut u: libc::c_int) {
    let mut current_block: u64;
    let mut v: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut flexible: libc::c_int = 0;
    let mut bit_size: libc::c_int = 0;
    let mut bsize: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut ut: libc::c_int = 0;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut ss: *mut Sym = 0 as *mut Sym;
    let mut ps: *mut *mut Sym = 0 as *mut *mut Sym;
    let mut ad: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    let mut ad1: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    let mut type1: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut btype: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    memset(
        &mut ad as *mut AttributeDef as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<AttributeDef>() as libc::c_ulong,
    );
    next();
    parse_attribute(&mut ad);
    v = 0 as libc::c_int;
    if tok >= 256 as libc::c_int {
        v = tok;
        next();
    }
    ut = 0 as libc::c_int;
    bt = ut;
    if u == (2 as libc::c_int) << 20 as libc::c_int {
        ut = 3 as libc::c_int;
        if tok == ':' as i32 {
            next();
            if parse_btype(&mut btype, &mut ad1, 0 as libc::c_int) == 0
                || is_integer_btype(btype.t & 0xf as libc::c_int) == 0
            {
                expect(b"enum type\0" as *const u8 as *const libc::c_char);
            }
            ut = btype.t
                & (0xf as libc::c_int | 0x800 as libc::c_int | 0x10 as libc::c_int
                    | 0x20 as libc::c_int);
            bt = ut;
        }
    }
    if v != 0 {
        s = struct_find(v);
        if !s.is_null()
            && ((*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope
                == local_scope || tok != '{' as i32 && tok != ';' as i32)
        {
            if u == (*s).type_0.t {
                current_block = 4843358007846534060;
            } else if u == (2 as libc::c_int) << 20 as libc::c_int
                && (*s).type_0.t as libc::c_uint
                    & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint)
                    == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
            {
                current_block = 4843358007846534060;
            } else {
                _tcc_error(
                    b"redeclaration of '%s'\0" as *const u8 as *const libc::c_char,
                    get_tok_str(v, 0 as *mut CValue),
                );
            }
        } else {
            current_block = 5783071609795492627;
        }
    } else {
        if tok != '{' as i32 {
            expect(b"struct/union/enum name\0" as *const u8 as *const libc::c_char);
        }
        let fresh156 = anon_sym;
        anon_sym = anon_sym + 1;
        v = fresh156;
        current_block = 5783071609795492627;
    }
    match current_block {
        5783071609795492627 => {
            type1.t = u | ut;
            type1.ref_0 = 0 as *mut Sym;
            s = sym_push(
                v | 0x40000000 as libc::c_int,
                &mut type1,
                0 as libc::c_int,
                if bt != 0 { 0 as libc::c_int } else { -(1 as libc::c_int) },
            );
            (*s).r = 0 as libc::c_int as libc::c_ushort;
        }
        _ => {}
    }
    (*type_0).t = (*s).type_0.t;
    (*type_0).ref_0 = s;
    if tok == '{' as i32 {
        next();
        if (*s).c2rust_unnamed.c2rust_unnamed.c != -(1 as libc::c_int)
            && !(u == (2 as libc::c_int) << 20 as libc::c_int
                && (*s).c2rust_unnamed.c2rust_unnamed.c == 0 as libc::c_int)
        {
            _tcc_error(
                b"struct/union/enum already defined\0" as *const u8
                    as *const libc::c_char,
            );
        }
        (*s).c2rust_unnamed.c2rust_unnamed.c = -(2 as libc::c_int);
        ps = &mut (*s).c2rust_unnamed_0.next;
        if u == (2 as libc::c_int) << 20 as libc::c_int {
            let mut ll: libc::c_longlong = 0 as libc::c_int as libc::c_longlong;
            let mut pl: libc::c_longlong = 0 as libc::c_int as libc::c_longlong;
            let mut nl: libc::c_longlong = 0 as libc::c_int as libc::c_longlong;
            let mut t: CType = CType {
                t: 0,
                ref_0: 0 as *mut Sym,
            };
            t.ref_0 = s;
            t
                .t = 3 as libc::c_int | 0x2000 as libc::c_int
                | (3 as libc::c_int) << 20 as libc::c_int;
            if bt != 0 {
                t
                    .t = bt | 0x2000 as libc::c_int
                    | (3 as libc::c_int) << 20 as libc::c_int;
            }
            loop {
                v = tok;
                if v < TOK_DEFINE as libc::c_int {
                    expect(b"identifier\0" as *const u8 as *const libc::c_char);
                }
                ss = sym_find(v);
                if !ss.is_null() && local_stack.is_null() {
                    _tcc_error(
                        b"redefinition of enumerator '%s'\0" as *const u8
                            as *const libc::c_char,
                        get_tok_str(v, 0 as *mut CValue),
                    );
                }
                next();
                if tok == '=' as i32 {
                    next();
                    ll = expr_const64() as libc::c_longlong;
                }
                ss = sym_push(v, &mut t, 0x30 as libc::c_int, 0 as libc::c_int);
                (*ss).c2rust_unnamed.enum_val = ll;
                *ps = ss;
                ps = &mut (*ss).c2rust_unnamed_0.next;
                if ll < nl {
                    nl = ll;
                }
                if ll > pl {
                    pl = ll;
                }
                if tok != ',' as i32 {
                    break;
                }
                next();
                ll += 1;
                ll;
                if tok == '}' as i32 {
                    break;
                }
            }
            skip('}' as i32);
            if bt != 0 {
                t.t = bt;
                (*s).c2rust_unnamed.c2rust_unnamed.c = 2 as libc::c_int;
            } else {
                t.t = 3 as libc::c_int;
                if nl >= 0 as libc::c_int as libc::c_longlong {
                    if pl != pl as libc::c_uint as libc::c_longlong {
                        t
                            .t = if 8 as libc::c_int == 8 as libc::c_int {
                            4 as libc::c_int | 0x800 as libc::c_int
                        } else {
                            4 as libc::c_int
                        };
                    }
                    t.t |= 0x10 as libc::c_int;
                } else if pl != pl as libc::c_int as libc::c_longlong
                    || nl != nl as libc::c_int as libc::c_longlong
                {
                    t
                        .t = if 8 as libc::c_int == 8 as libc::c_int {
                        4 as libc::c_int | 0x800 as libc::c_int
                    } else {
                        4 as libc::c_int
                    };
                }
                let mut current_block_72: u64;
                ss = (*s).c2rust_unnamed_0.next;
                while !ss.is_null() {
                    ll = (*ss).c2rust_unnamed.enum_val;
                    if !(ll == ll as libc::c_int as libc::c_longlong) {
                        if t.t & 0x10 as libc::c_int != 0 {
                            (*ss).type_0.t |= 0x10 as libc::c_int;
                            if ll == ll as libc::c_uint as libc::c_longlong {
                                current_block_72 = 17075014677070940716;
                            } else {
                                current_block_72 = 16779030619667747692;
                            }
                        } else {
                            current_block_72 = 16779030619667747692;
                        }
                        match current_block_72 {
                            17075014677070940716 => {}
                            _ => {
                                (*ss)
                                    .type_0
                                    .t = (*ss).type_0.t & !(0xf as libc::c_int)
                                    | (if 8 as libc::c_int == 8 as libc::c_int {
                                        4 as libc::c_int | 0x800 as libc::c_int
                                    } else {
                                        4 as libc::c_int
                                    });
                            }
                        }
                    }
                    ss = (*ss).c2rust_unnamed_0.next;
                }
                (*s).c2rust_unnamed.c2rust_unnamed.c = 1 as libc::c_int;
            }
            (*type_0).t = t.t | (2 as libc::c_int) << 20 as libc::c_int;
            (*s).type_0.t = (*type_0).t;
        } else {
            c = 0 as libc::c_int;
            flexible = 0 as libc::c_int;
            while tok != '}' as i32 {
                if parse_btype(&mut btype, &mut ad1, 0 as libc::c_int) == 0 {
                    if tok == TOK_STATIC_ASSERT as libc::c_int {
                        do_Static_assert();
                    } else {
                        skip(';' as i32);
                    }
                } else {
                    loop {
                        if flexible != 0 {
                            _tcc_error(
                                b"flexible array member '%s' not at the end of struct\0"
                                    as *const u8 as *const libc::c_char,
                                get_tok_str(v, 0 as *mut CValue),
                            );
                        }
                        bit_size = -(1 as libc::c_int);
                        v = 0 as libc::c_int;
                        type1 = btype;
                        if tok != ':' as i32 {
                            if tok != ';' as i32 {
                                type_decl(&mut type1, &mut ad1, &mut v, 2 as libc::c_int);
                            }
                            if v == 0 as libc::c_int {
                                if type1.t & 0xf as libc::c_int != 7 as libc::c_int {
                                    expect(b"identifier\0" as *const u8 as *const libc::c_char);
                                } else {
                                    let mut v_0: libc::c_int = (*btype.ref_0).v;
                                    if v_0 & 0x20000000 as libc::c_int == 0
                                        && v_0 & !(0x40000000 as libc::c_int)
                                            < 0x10000000 as libc::c_int
                                    {
                                        if (*tcc_state).ms_extensions as libc::c_int
                                            == 0 as libc::c_int
                                        {
                                            expect(b"identifier\0" as *const u8 as *const libc::c_char);
                                        }
                                    }
                                }
                            }
                            if type_size(&mut type1, &mut align) < 0 as libc::c_int {
                                if u == 7 as libc::c_int
                                    && type1.t & 0x40 as libc::c_int != 0 && c != 0
                                {
                                    flexible = 1 as libc::c_int;
                                } else {
                                    _tcc_error(
                                        b"field '%s' has incomplete type\0" as *const u8
                                            as *const libc::c_char,
                                        get_tok_str(v, 0 as *mut CValue),
                                    );
                                }
                            }
                            if type1.t & 0xf as libc::c_int == 6 as libc::c_int
                                || type1.t & 0xf as libc::c_int == 0 as libc::c_int
                                || type1.t
                                    & (0x1000 as libc::c_int | 0x2000 as libc::c_int
                                        | 0x4000 as libc::c_int | 0x8000 as libc::c_int) != 0
                            {
                                _tcc_error(
                                    b"invalid type for '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            }
                        }
                        if tok == ':' as i32 {
                            next();
                            bit_size = expr_const();
                            if bit_size < 0 as libc::c_int {
                                _tcc_error(
                                    b"negative width in bit-field '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            }
                            if v != 0 && bit_size == 0 as libc::c_int {
                                _tcc_error(
                                    b"zero width for bit-field '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            }
                            parse_attribute(&mut ad1);
                        }
                        size = type_size(&mut type1, &mut align);
                        if bit_size >= 0 as libc::c_int {
                            bt = type1.t & 0xf as libc::c_int;
                            if bt != 3 as libc::c_int && bt != 1 as libc::c_int
                                && bt != 2 as libc::c_int && bt != 11 as libc::c_int
                                && bt != 4 as libc::c_int
                            {
                                _tcc_error(
                                    b"bitfields must have scalar type\0" as *const u8
                                        as *const libc::c_char,
                                );
                            }
                            bsize = size * 8 as libc::c_int;
                            if bit_size > bsize {
                                _tcc_error(
                                    b"width of '%s' exceeds its type\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            } else if !(bit_size == bsize && (ad.a).packed() == 0
                                && (ad1.a).packed() == 0)
                            {
                                if bit_size == 64 as libc::c_int {
                                    _tcc_error(
                                        b"field width 64 not implemented\0" as *const u8
                                            as *const libc::c_char,
                                    );
                                } else {
                                    type1
                                        .t = (type1.t as libc::c_uint
                                        & !(((1 as libc::c_uint)
                                            << 6 as libc::c_int + 6 as libc::c_int)
                                            .wrapping_sub(1 as libc::c_int as libc::c_uint)
                                            << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint)
                                        | 0x80 as libc::c_int as libc::c_uint
                                        | (bit_size << 20 as libc::c_int + 6 as libc::c_int)
                                            as libc::c_uint) as libc::c_int;
                                }
                            }
                        }
                        if v != 0 as libc::c_int
                            || type1.t & 0xf as libc::c_int == 7 as libc::c_int
                        {
                            c = 1 as libc::c_int;
                        }
                        if v == 0 as libc::c_int
                            && (type1.t & 0xf as libc::c_int == 7 as libc::c_int
                                || bit_size >= 0 as libc::c_int)
                        {
                            let fresh157 = anon_sym;
                            anon_sym = anon_sym + 1;
                            v = fresh157;
                        }
                        if v != 0 {
                            ss = sym_push(
                                v | 0x20000000 as libc::c_int,
                                &mut type1,
                                0 as libc::c_int,
                                0 as libc::c_int,
                            );
                            (*ss).a = ad1.a;
                            *ps = ss;
                            ps = &mut (*ss).c2rust_unnamed_0.next;
                        }
                        if tok == ';' as i32 || tok == -(1 as libc::c_int) {
                            break;
                        }
                        skip(',' as i32);
                    }
                    skip(';' as i32);
                }
            }
            skip('}' as i32);
            parse_attribute(&mut ad);
            if !(ad.cleanup_func).is_null() {
                _tcc_warning(
                    b"attribute '__cleanup__' ignored on type\0" as *const u8
                        as *const libc::c_char,
                );
            }
            check_fields(type_0, 1 as libc::c_int);
            check_fields(type_0, 0 as libc::c_int);
            struct_layout(type_0, &mut ad);
            if debug_modes != 0 {
                tcc_debug_fix_anon(tcc_state, type_0);
            }
        }
    }
}
unsafe extern "C" fn sym_to_attr(mut ad: *mut AttributeDef, mut s: *mut Sym) {
    merge_symattr(&mut (*ad).a, &mut (*s).a);
    merge_funcattr(
        &mut (*ad).f,
        &mut (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f,
    );
}
unsafe extern "C" fn parse_btype_qualify(
    mut type_0: *mut CType,
    mut qualifiers: libc::c_int,
) {
    while (*type_0).t & 0x40 as libc::c_int != 0 {
        (*type_0)
            .ref_0 = sym_push(
            0x20000000 as libc::c_int,
            &mut (*(*type_0).ref_0).type_0,
            0 as libc::c_int,
            (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c,
        );
        type_0 = &mut (*(*type_0).ref_0).type_0;
    }
    (*type_0).t |= qualifiers;
}
unsafe extern "C" fn parse_btype(
    mut type_0: *mut CType,
    mut ad: *mut AttributeDef,
    mut ignore_label: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut t: libc::c_int = 0;
    let mut u: libc::c_int = 0;
    let mut bt: libc::c_int = 0;
    let mut st: libc::c_int = 0;
    let mut type_found: libc::c_int = 0;
    let mut typespec_found: libc::c_int = 0;
    let mut g_0: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut type1: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    memset(
        ad as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<AttributeDef>() as libc::c_ulong,
    );
    type_found = 0 as libc::c_int;
    typespec_found = 0 as libc::c_int;
    t = 3 as libc::c_int;
    st = -(1 as libc::c_int);
    bt = st;
    (*type_0).ref_0 = 0 as *mut Sym;
    loop {
        match tok {
            292 => {
                next();
                continue;
            }
            297 => {
                u = 1 as libc::c_int;
                current_block = 13750505205840536323;
            }
            296 => {
                u = 0 as libc::c_int;
                current_block = 13750505205840536323;
            }
            303 => {
                u = 2 as libc::c_int;
                current_block = 13750505205840536323;
            }
            298 => {
                u = 3 as libc::c_int;
                current_block = 13750505205840536323;
            }
            315 => {
                let mut n_0: libc::c_int = 0;
                let mut ad1: AttributeDef = AttributeDef {
                    a: SymAttr {
                        aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                    },
                    f: FuncAttr {
                        func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
                    },
                    section: 0 as *mut Section,
                    cleanup_func: 0 as *mut Sym,
                    alias_target: 0,
                    asm_label: 0,
                    attr_mode: 0,
                };
                next();
                skip('(' as i32);
                memset(
                    &mut ad1 as *mut AttributeDef as *mut libc::c_void,
                    0 as libc::c_int,
                    ::core::mem::size_of::<AttributeDef>() as libc::c_ulong,
                );
                if parse_btype(&mut type1, &mut ad1, 0 as libc::c_int) != 0 {
                    type_decl(&mut type1, &mut ad1, &mut n_0, 1 as libc::c_int);
                    if (ad1.a).aligned() != 0 {
                        n_0 = (1 as libc::c_int)
                            << (ad1.a).aligned() as libc::c_int - 1 as libc::c_int;
                    } else {
                        type_size(&mut type1, &mut n_0);
                    }
                } else {
                    n_0 = expr_const();
                    if n_0 < 0 as libc::c_int
                        || n_0 & n_0 - 1 as libc::c_int != 0 as libc::c_int
                    {
                        _tcc_error(
                            b"alignment must be a positive power of two\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
                skip(')' as i32);
                ((*ad).a).set_aligned(exact_log2p1(n_0) as libc::c_ushort);
                continue;
            }
            304 => {
                if t & 0xf as libc::c_int == 9 as libc::c_int {
                    t = t & !(0xf as libc::c_int | 0x800 as libc::c_int)
                        | 10 as libc::c_int;
                    current_block = 5330834795799507926;
                } else if t & (0xf as libc::c_int | 0x800 as libc::c_int)
                    == 0x800 as libc::c_int
                {
                    t = t & !(0xf as libc::c_int | 0x800 as libc::c_int)
                        | 4 as libc::c_int;
                    current_block = 5330834795799507926;
                } else {
                    u = 0x800 as libc::c_int;
                    current_block = 13750505205840536323;
                }
                match current_block {
                    13750505205840536323 => {}
                    _ => {
                        next();
                        current_block = 9073771928613846474;
                    }
                }
            }
            301 => {
                u = 11 as libc::c_int;
                current_block = 13750505205840536323;
            }
            302 => {
                _tcc_error(
                    b"_Complex is not yet supported\0" as *const u8
                        as *const libc::c_char,
                );
            }
            299 => {
                u = 8 as libc::c_int;
                current_block = 13750505205840536323;
            }
            300 => {
                if t & (0xf as libc::c_int | 0x800 as libc::c_int)
                    == 0x800 as libc::c_int
                {
                    t = t & !(0xf as libc::c_int | 0x800 as libc::c_int)
                        | 10 as libc::c_int;
                    next();
                    current_block = 9073771928613846474;
                } else {
                    u = 9 as libc::c_int;
                    current_block = 13750505205840536323;
                }
            }
            308 => {
                struct_decl(&mut type1, (2 as libc::c_int) << 20 as libc::c_int);
                current_block = 9634104160613015667;
            }
            305 => {
                struct_decl(&mut type1, 7 as libc::c_int);
                current_block = 9634104160613015667;
            }
            306 => {
                struct_decl(
                    &mut type1,
                    (1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int,
                );
                current_block = 9634104160613015667;
            }
            274 => {
                next();
                (*type_0).t = t;
                parse_btype_qualify(type_0, 0x200 as libc::c_int);
                t = (*type_0).t;
                if tok == '(' as i32 {
                    parse_expr_type(&mut type1);
                    type1.t
                        &= !((0x1000 as libc::c_int | 0x2000 as libc::c_int
                            | 0x4000 as libc::c_int | 0x8000 as libc::c_int)
                            & !(0x4000 as libc::c_int));
                    if !(type1.ref_0).is_null() {
                        sym_to_attr(ad, type1.ref_0);
                    }
                    current_block = 9634104160613015667;
                } else {
                    current_block = 9073771928613846474;
                }
            }
            275 | 276 | 277 => {
                (*type_0).t = t;
                parse_btype_qualify(type_0, 0x100 as libc::c_int);
                t = (*type_0).t;
                next();
                current_block = 9073771928613846474;
            }
            278 | 279 | 280 => {
                (*type_0).t = t;
                parse_btype_qualify(type_0, 0x200 as libc::c_int);
                t = (*type_0).t;
                next();
                current_block = 9073771928613846474;
            }
            282 | 283 | 284 => {
                if t & (0x20 as libc::c_int | 0x10 as libc::c_int)
                    == 0x20 as libc::c_int | 0x10 as libc::c_int
                {
                    _tcc_error(
                        b"signed and unsigned modifier\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                t |= 0x20 as libc::c_int;
                next();
                typespec_found = 1 as libc::c_int;
                current_block = 9073771928613846474;
            }
            281 | 285 | 289 | 290 | 291 => {
                next();
                current_block = 9073771928613846474;
            }
            273 => {
                if t & (0x20 as libc::c_int | 0x10 as libc::c_int) == 0x20 as libc::c_int
                {
                    _tcc_error(
                        b"signed and unsigned modifier\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                t |= 0x20 as libc::c_int | 0x10 as libc::c_int;
                next();
                typespec_found = 1 as libc::c_int;
                current_block = 9073771928613846474;
            }
            271 => {
                g_0 = 0x1000 as libc::c_int;
                current_block = 8388244633353270428;
            }
            272 => {
                g_0 = 0x2000 as libc::c_int;
                current_block = 8388244633353270428;
            }
            307 => {
                g_0 = 0x4000 as libc::c_int;
                current_block = 8388244633353270428;
            }
            286 | 287 | 288 => {
                t |= 0x8000 as libc::c_int;
                next();
                current_block = 9073771928613846474;
            }
            393 => {
                next();
                ((*ad).f).set_func_noreturn(1 as libc::c_int as libc::c_uint);
                current_block = 9073771928613846474;
            }
            310 | 311 => {
                parse_attribute(ad);
                if (*ad).attr_mode != 0 {
                    u = (*ad).attr_mode as libc::c_int - 1 as libc::c_int;
                    t = t & !(0xf as libc::c_int | 0x800 as libc::c_int) | u;
                }
                continue;
            }
            316 | 317 | 318 => {
                next();
                parse_expr_type(&mut type1);
                type1.t
                    &= !((0x1000 as libc::c_int | 0x2000 as libc::c_int
                        | 0x4000 as libc::c_int | 0x8000 as libc::c_int)
                        & !(0x4000 as libc::c_int));
                if !(type1.ref_0).is_null() {
                    sym_to_attr(ad, type1.ref_0);
                }
                current_block = 9634104160613015667;
            }
            293 => {
                _tcc_error(
                    b"_Thread_local is not implemented\0" as *const u8
                        as *const libc::c_char,
                );
            }
            _ => {
                if typespec_found != 0 {
                    break;
                }
                s = sym_find(tok);
                if s.is_null() || (*s).type_0.t & 0x4000 as libc::c_int == 0 {
                    break;
                }
                n = tok;
                next();
                if tok == ':' as i32 && ignore_label != 0 {
                    unget_tok(n);
                    break;
                } else {
                    t &= !(0xf as libc::c_int | 0x800 as libc::c_int);
                    u = t & !(0x100 as libc::c_int | 0x200 as libc::c_int);
                    t ^= u;
                    (*type_0).t = (*s).type_0.t & !(0x4000 as libc::c_int) | u;
                    (*type_0).ref_0 = (*s).type_0.ref_0;
                    if t != 0 {
                        parse_btype_qualify(type_0, t);
                    }
                    t = (*type_0).t;
                    sym_to_attr(ad, s);
                    typespec_found = 1 as libc::c_int;
                    bt = -(2 as libc::c_int);
                    st = bt;
                }
                current_block = 9073771928613846474;
            }
        }
        match current_block {
            8388244633353270428 => {
                if t
                    & (0x1000 as libc::c_int | 0x2000 as libc::c_int
                        | 0x4000 as libc::c_int) & !g_0 != 0
                {
                    _tcc_error(
                        b"multiple storage classes\0" as *const u8 as *const libc::c_char,
                    );
                }
                t |= g_0;
                next();
                current_block = 9073771928613846474;
            }
            9634104160613015667 => {
                u = type1.t;
                (*type_0).ref_0 = type1.ref_0;
                current_block = 10778933045724332881;
            }
            13750505205840536323 => {
                next();
                current_block = 10778933045724332881;
            }
            _ => {}
        }
        match current_block {
            10778933045724332881 => {
                let mut current_block_11: u64;
                if u == 2 as libc::c_int || u == 0x800 as libc::c_int {
                    if st != -(1 as libc::c_int)
                        || bt != -(1 as libc::c_int) && bt != 3 as libc::c_int
                    {
                        current_block_11 = 15139984216645929692;
                    } else {
                        st = u;
                        current_block_11 = 17860125682698302841;
                    }
                } else if bt != -(1 as libc::c_int)
                    || st != -(1 as libc::c_int) && u != 3 as libc::c_int
                {
                    current_block_11 = 15139984216645929692;
                } else {
                    bt = u;
                    current_block_11 = 17860125682698302841;
                }
                match current_block_11 {
                    17860125682698302841 => {}
                    _ => {
                        _tcc_error(
                            b"too many basic types\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                if u != 3 as libc::c_int {
                    t = t & !(0xf as libc::c_int | 0x800 as libc::c_int) | u;
                }
                typespec_found = 1 as libc::c_int;
            }
            _ => {}
        }
        type_found = 1 as libc::c_int;
    }
    if (*tcc_state).char_is_unsigned != 0 {
        if t & (0x20 as libc::c_int | 0xf as libc::c_int) == 1 as libc::c_int {
            t |= 0x10 as libc::c_int;
        }
    }
    bt = t & (0xf as libc::c_int | 0x800 as libc::c_int);
    if bt == 0x800 as libc::c_int {
        t
            |= if 8 as libc::c_int == 8 as libc::c_int {
                4 as libc::c_int
            } else {
                3 as libc::c_int
            };
    }
    (*type_0).t = t;
    return type_found;
}
#[inline]
unsafe extern "C" fn convert_parameter_type(mut pt: *mut CType) {
    (*pt).t &= !(0x100 as libc::c_int | 0x200 as libc::c_int);
    (*pt).t &= !(0x40 as libc::c_int | 0x400 as libc::c_int);
    if (*pt).t & 0xf as libc::c_int == 6 as libc::c_int {
        mk_pointer(pt);
    }
}
unsafe extern "C" fn parse_asm_str() -> *mut CString {
    skip('(' as i32);
    return parse_mult_str(b"string constant\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn asm_label_instr() -> libc::c_int {
    let mut v: libc::c_int = 0;
    let mut astr: *mut libc::c_char = 0 as *mut libc::c_char;
    next();
    astr = (*parse_asm_str()).data;
    skip(')' as i32);
    v = tok_alloc_const(astr);
    return v;
}
unsafe extern "C" fn post_type(
    mut type_0: *mut CType,
    mut ad: *mut AttributeDef,
    mut storage: libc::c_int,
    mut td: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut t1: libc::c_int = 0;
    let mut arg_size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut plast: *mut *mut Sym = 0 as *mut *mut Sym;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut first: *mut Sym = 0 as *mut Sym;
    let mut ad1: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    let mut pt: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut vla_array_tok: *mut TokenString = 0 as *mut TokenString;
    let mut vla_array_str: *mut libc::c_int = 0 as *mut libc::c_int;
    if tok == '(' as i32 {
        next();
        if 2 as libc::c_int == td & (2 as libc::c_int | 1 as libc::c_int) {
            return 0 as libc::c_int;
        }
        if tok == ')' as i32 {
            l = 0 as libc::c_int;
        } else if parse_btype(&mut pt, &mut ad1, 0 as libc::c_int) != 0 {
            l = 1 as libc::c_int;
        } else if td & (2 as libc::c_int | 1 as libc::c_int) != 0 {
            merge_attr(ad, &mut ad1);
            return 0 as libc::c_int;
        } else {
            l = 2 as libc::c_int;
        }
        first = 0 as *mut Sym;
        plast = &mut first;
        arg_size = 0 as libc::c_int;
        local_scope += 1;
        local_scope;
        if l != 0 {
            loop {
                if l != 2 as libc::c_int {
                    if pt.t & 0xf as libc::c_int == 0 as libc::c_int && tok == ')' as i32
                    {
                        break;
                    }
                    type_decl(
                        &mut pt,
                        &mut ad1,
                        &mut n,
                        2 as libc::c_int | 1 as libc::c_int | 4 as libc::c_int,
                    );
                    if pt.t & 0xf as libc::c_int == 0 as libc::c_int {
                        _tcc_error(
                            b"parameter declared as void\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    if n == 0 as libc::c_int {
                        n = 0x20000000 as libc::c_int;
                    }
                } else {
                    n = tok;
                    pt.t = 0 as libc::c_int;
                    pt.ref_0 = 0 as *mut Sym;
                    next();
                }
                if n < TOK_DEFINE as libc::c_int {
                    expect(b"identifier\0" as *const u8 as *const libc::c_char);
                }
                convert_parameter_type(&mut pt);
                arg_size
                    += (type_size(&mut pt, &mut align) + 8 as libc::c_int
                        - 1 as libc::c_int) / 8 as libc::c_int;
                s = sym_push(
                    n,
                    &mut pt,
                    0x32 as libc::c_int | 0x100 as libc::c_int,
                    0 as libc::c_int,
                );
                *plast = s;
                plast = &mut (*s).c2rust_unnamed_0.next;
                if tok == ')' as i32 {
                    break;
                }
                skip(',' as i32);
                if l == 1 as libc::c_int && tok == 0xa1 as libc::c_int {
                    l = 3 as libc::c_int;
                    next();
                    break;
                } else if l == 1 as libc::c_int
                    && parse_btype(&mut pt, &mut ad1, 0 as libc::c_int) == 0
                {
                    _tcc_error(b"invalid type\0" as *const u8 as *const libc::c_char);
                }
            }
        } else {
            l = 2 as libc::c_int;
        }
        skip(')' as i32);
        if !first.is_null() {
            sym_pop(
                if !local_stack.is_null() {
                    &mut local_stack
                } else {
                    &mut global_stack
                },
                (*first).prev,
                1 as libc::c_int,
            );
            s = first;
            while !s.is_null() {
                (*s).v |= 0x20000000 as libc::c_int;
                s = (*s).c2rust_unnamed_0.next;
            }
        }
        local_scope -= 1;
        local_scope;
        (*type_0).t &= !(0x100 as libc::c_int);
        if tok == '[' as i32 {
            next();
            skip(']' as i32);
            mk_pointer(type_0);
        }
        ((*ad).f).set_func_args(arg_size as libc::c_uint);
        ((*ad).f).set_func_type(l as libc::c_uint);
        s = sym_push(
            0x20000000 as libc::c_int,
            type_0,
            0 as libc::c_int,
            0 as libc::c_int,
        );
        (*s).a = (*ad).a;
        (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f = (*ad).f;
        (*s).c2rust_unnamed_0.next = first;
        (*type_0).t = 6 as libc::c_int;
        (*type_0).ref_0 = s;
    } else if tok == '[' as i32 {
        let mut saved_nocode_wanted: libc::c_int = nocode_wanted;
        next();
        n = -(1 as libc::c_int);
        t1 = 0 as libc::c_int;
        let mut current_block_92: u64;
        if td & 4 as libc::c_int != 0 {
            loop {
                match tok {
                    289 | 290 | 291 | 275 | 278 | 272 | 42 => {
                        next();
                    }
                    _ => {
                        if !(tok != ']' as i32) {
                            current_block_92 = 2310077433060450808;
                            break;
                        }
                        nocode_wanted = 1 as libc::c_int;
                        skip_or_save_block(&mut vla_array_tok);
                        unget_tok(0 as libc::c_int);
                        vla_array_str = (*vla_array_tok).str_0;
                        begin_macro(vla_array_tok, 2 as libc::c_int);
                        next();
                        gexpr();
                        end_macro();
                        next();
                        current_block_92 = 17106206872673765657;
                        break;
                    }
                }
            }
        } else if tok != ']' as i32 {
            if local_stack.is_null() || storage & 0x2000 as libc::c_int != 0 {
                vpushi(expr_const());
            } else {
                nocode_wanted = 0 as libc::c_int;
                gexpr();
            }
            current_block_92 = 17106206872673765657;
        } else {
            current_block_92 = 2310077433060450808;
        }
        match current_block_92 {
            17106206872673765657 => {
                if (*vtop).r as libc::c_int
                    & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
                    == 0x30 as libc::c_int
                {
                    n = (*vtop).c2rust_unnamed.c.i as libc::c_int;
                    if n < 0 as libc::c_int {
                        _tcc_error(
                            b"invalid array size\0" as *const u8 as *const libc::c_char,
                        );
                    }
                } else {
                    if is_integer_btype((*vtop).type_0.t & 0xf as libc::c_int) == 0 {
                        _tcc_error(
                            b"size of variable length array should be an integer\0"
                                as *const u8 as *const libc::c_char,
                        );
                    }
                    n = 0 as libc::c_int;
                    t1 = 0x400 as libc::c_int;
                }
            }
            _ => {}
        }
        skip(']' as i32);
        post_type(
            type_0,
            ad,
            storage,
            td & !(2 as libc::c_int | 1 as libc::c_int) | 8 as libc::c_int,
        );
        if (*type_0).t & 0xf as libc::c_int == 6 as libc::c_int {
            _tcc_error(
                b"declaration of an array of functions\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if (*type_0).t & 0xf as libc::c_int == 0 as libc::c_int
            || type_size(type_0, &mut align) < 0 as libc::c_int
        {
            _tcc_error(
                b"declaration of an array of incomplete type elements\0" as *const u8
                    as *const libc::c_char,
            );
        }
        t1 |= (*type_0).t & 0x400 as libc::c_int;
        if t1 & 0x400 as libc::c_int != 0 {
            if n < 0 as libc::c_int {
                if td & 8 as libc::c_int != 0 {
                    _tcc_error(
                        b"need explicit inner array size in VLAs\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            } else {
                loc -= type_size(&mut int_type, &mut align);
                loc &= -align;
                n = loc;
                vpush_type_size(type_0, &mut align);
                gen_op('*' as i32);
                vset(&mut int_type, 0x32 as libc::c_int | 0x100 as libc::c_int, n);
                vswap();
                vstore();
            }
        }
        if n != -(1 as libc::c_int) {
            vpop();
        }
        nocode_wanted = saved_nocode_wanted;
        s = sym_push(0x20000000 as libc::c_int, type_0, 0 as libc::c_int, n);
        (*type_0)
            .t = (if t1 != 0 { 0x400 as libc::c_int } else { 0x40 as libc::c_int })
            | 5 as libc::c_int;
        (*type_0).ref_0 = s;
        if !vla_array_str.is_null() {
            if t1 & 0x400 as libc::c_int != 0 && td & 8 as libc::c_int != 0 {
                (*s).c2rust_unnamed_0.vla_array_str = vla_array_str;
            } else {
                tok_str_free_str(vla_array_str);
            }
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn type_decl(
    mut type_0: *mut CType,
    mut ad: *mut AttributeDef,
    mut v: *mut libc::c_int,
    mut td: libc::c_int,
) -> *mut CType {
    let mut post: *mut CType = 0 as *mut CType;
    let mut ret: *mut CType = 0 as *mut CType;
    let mut qualifiers: libc::c_int = 0;
    let mut storage: libc::c_int = 0;
    storage = (*type_0).t
        & (0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
            | 0x8000 as libc::c_int);
    (*type_0).t
        &= !(0x1000 as libc::c_int | 0x2000 as libc::c_int | 0x4000 as libc::c_int
            | 0x8000 as libc::c_int);
    ret = type_0;
    post = ret;
    while tok == '*' as i32 {
        qualifiers = 0 as libc::c_int;
        loop {
            next();
            match tok {
                274 => {
                    qualifiers |= 0x200 as libc::c_int;
                }
                275 | 276 | 277 => {
                    qualifiers |= 0x100 as libc::c_int;
                }
                278 | 279 | 280 => {
                    qualifiers |= 0x200 as libc::c_int;
                }
                289 | 290 | 291 => {}
                310 | 311 => {
                    parse_attribute(ad);
                    break;
                }
                _ => {
                    break;
                }
            }
        }
        mk_pointer(type_0);
        (*type_0).t |= qualifiers;
        if ret == type_0 {
            ret = pointed_type(type_0);
        }
    }
    let mut current_block_22: u64;
    if tok == '(' as i32 {
        if post_type(type_0, ad, 0 as libc::c_int, td) == 0 {
            parse_attribute(ad);
            post = type_decl(type_0, ad, v, td);
            skip(')' as i32);
            current_block_22 = 4775909272756257391;
        } else {
            current_block_22 = 7097738394278988061;
        }
    } else if tok >= 256 as libc::c_int && td & 2 as libc::c_int != 0 {
        *v = tok;
        next();
        current_block_22 = 4775909272756257391;
    } else {
        current_block_22 = 7097738394278988061;
    }
    match current_block_22 {
        7097738394278988061 => {
            if td & 1 as libc::c_int == 0 {
                expect(b"identifier\0" as *const u8 as *const libc::c_char);
            }
            *v = 0 as libc::c_int;
        }
        _ => {}
    }
    post_type(
        post,
        ad,
        if post != ret { 0 as libc::c_int } else { storage },
        td & !(2 as libc::c_int | 1 as libc::c_int),
    );
    parse_attribute(ad);
    (*type_0).t |= storage;
    return ret;
}
unsafe extern "C" fn indir() {
    if (*vtop).type_0.t & 0xf as libc::c_int != 5 as libc::c_int {
        if (*vtop).type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
            return;
        }
        expect(b"pointer\0" as *const u8 as *const libc::c_char);
    }
    if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0 {
        gv(0x1 as libc::c_int);
    }
    (*vtop).type_0 = *pointed_type(&mut (*vtop).type_0);
    if (*vtop).type_0.t & (0x40 as libc::c_int | 0x400 as libc::c_int) == 0
        && (*vtop).type_0.t & 0xf as libc::c_int != 6 as libc::c_int
    {
        (*vtop).r = ((*vtop).r as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
        if (*tcc_state).do_bounds_check != 0 {
            (*vtop)
                .r = ((*vtop).r as libc::c_int | 0x4000 as libc::c_int)
                as libc::c_ushort;
        }
    }
}
unsafe extern "C" fn gfunc_param_typed(mut func: *mut Sym, mut arg: *mut Sym) {
    let mut func_type: libc::c_int = 0;
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    func_type = ((*func).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
        as libc::c_int;
    if func_type == 2 as libc::c_int || func_type == 3 as libc::c_int && arg.is_null() {
        if (*vtop).type_0.t & 0xf as libc::c_int == 8 as libc::c_int {
            gen_cast_s(9 as libc::c_int);
        } else if (*vtop).type_0.t & 0x80 as libc::c_int != 0 {
            type_0.t = (*vtop).type_0.t & (0xf as libc::c_int | 0x10 as libc::c_int);
            type_0.ref_0 = (*vtop).type_0.ref_0;
            gen_cast(&mut type_0);
        } else if (*vtop).r as libc::c_int & 0xc00 as libc::c_int != 0 {
            force_charshort_cast();
        }
    } else if arg.is_null() {
        _tcc_error(
            b"too many arguments to function\0" as *const u8 as *const libc::c_char,
        );
    } else {
        type_0 = (*arg).type_0;
        type_0.t &= !(0x100 as libc::c_int);
        gen_assign_cast(&mut type_0);
    };
}
unsafe extern "C" fn expr_type(
    mut type_0: *mut CType,
    mut expr_fn: Option::<unsafe extern "C" fn() -> ()>,
) {
    nocode_wanted += 1;
    nocode_wanted;
    expr_fn.expect("non-null function pointer")();
    *type_0 = (*vtop).type_0;
    vpop();
    nocode_wanted -= 1;
    nocode_wanted;
}
unsafe extern "C" fn parse_expr_type(mut type_0: *mut CType) {
    let mut n: libc::c_int = 0;
    let mut ad: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    skip('(' as i32);
    if parse_btype(type_0, &mut ad, 0 as libc::c_int) != 0 {
        type_decl(type_0, &mut ad, &mut n, 1 as libc::c_int);
    } else {
        expr_type(type_0, Some(gexpr as unsafe extern "C" fn() -> ()));
    }
    skip(')' as i32);
}
unsafe extern "C" fn parse_type(mut type_0: *mut CType) {
    let mut ad: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    let mut n: libc::c_int = 0;
    if parse_btype(type_0, &mut ad, 0 as libc::c_int) == 0 {
        expect(b"type\0" as *const u8 as *const libc::c_char);
    }
    type_decl(type_0, &mut ad, &mut n, 1 as libc::c_int);
}
unsafe extern "C" fn parse_builtin_params(
    mut nc: libc::c_int,
    mut args: *const libc::c_char,
) {
    let mut c: libc::c_char = 0;
    let mut sep: libc::c_char = '(' as i32 as libc::c_char;
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    if nc != 0 {
        nocode_wanted += 1;
        nocode_wanted;
    }
    next();
    if *args as libc::c_int == 0 as libc::c_int {
        skip(sep as libc::c_int);
    }
    let mut current_block_20: u64;
    loop {
        let fresh158 = args;
        args = args.offset(1);
        c = *fresh158;
        if !(c != 0) {
            break;
        }
        skip(sep as libc::c_int);
        sep = ',' as i32 as libc::c_char;
        if c as libc::c_int == 't' as i32 {
            parse_type(&mut type_0);
            vpush(&mut type_0);
        } else {
            expr_eq();
            type_0.ref_0 = 0 as *mut Sym;
            type_0.t = 0 as libc::c_int;
            match c as libc::c_int {
                101 => {
                    continue;
                }
                86 => {
                    type_0.t = 0x100 as libc::c_int;
                    current_block_20 = 2603891422059848368;
                }
                118 => {
                    current_block_20 = 2603891422059848368;
                }
                83 => {
                    type_0.t = 0x100 as libc::c_int;
                    current_block_20 = 15698615826727497983;
                }
                115 => {
                    current_block_20 = 15698615826727497983;
                }
                105 => {
                    type_0.t = 3 as libc::c_int;
                    current_block_20 = 5783071609795492627;
                }
                108 => {
                    type_0
                        .t = 0x800 as libc::c_int | 4 as libc::c_int
                        | 0x10 as libc::c_int;
                    current_block_20 = 5783071609795492627;
                }
                _ => {
                    current_block_20 = 5783071609795492627;
                }
            }
            match current_block_20 {
                2603891422059848368 => {
                    type_0.t |= 0 as libc::c_int;
                    mk_pointer(&mut type_0);
                }
                15698615826727497983 => {
                    type_0.t |= char_type.t;
                    mk_pointer(&mut type_0);
                }
                _ => {}
            }
            gen_assign_cast(&mut type_0);
        }
    }
    skip(')' as i32);
    if nc != 0 {
        nocode_wanted -= 1;
        nocode_wanted;
    }
}
unsafe extern "C" fn parse_atomic(mut atok: libc::c_int) {
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut arg: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut save: libc::c_int = 0 as libc::c_int;
    let mut atom: *mut CType = 0 as *mut CType;
    let mut atom_ptr: *mut CType = 0 as *mut CType;
    let mut ct: CType = {
        let mut init = CType {
            t: 0 as libc::c_int,
            ref_0: 0 as *mut Sym,
        };
        init
    };
    let mut store_0: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    let mut buf: [libc::c_char; 40] = [0; 40];
    static mut templates: [*const libc::c_char; 16] = [
        b"alm.?\0" as *const u8 as *const libc::c_char,
        b"Asm.v\0" as *const u8 as *const libc::c_char,
        b"alsm.v\0" as *const u8 as *const libc::c_char,
        b"aplbmm.b\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
        b"avm.v\0" as *const u8 as *const libc::c_char,
    ];
    let mut template: *const libc::c_char = templates[(atok
        - TOK___atomic_store as libc::c_int) as usize];
    atom_ptr = 0 as *mut CType;
    atom = atom_ptr;
    size = 0 as libc::c_int;
    next();
    skip('(' as i32);
    arg = 0 as libc::c_int;
    loop {
        expr_eq();
        match *template.offset(arg as isize) as libc::c_int {
            97 | 65 => {
                atom_ptr = &mut (*vtop).type_0;
                if (*atom_ptr).t & 0xf as libc::c_int != 5 as libc::c_int {
                    expect(b"pointer\0" as *const u8 as *const libc::c_char);
                }
                atom = pointed_type(atom_ptr);
                size = type_size(atom, &mut align);
                if size > 8 as libc::c_int || size & size - 1 as libc::c_int != 0
                    || atok > TOK___atomic_compare_exchange as libc::c_int
                        && (0 as libc::c_int
                            == btype_size((*atom).t & 0xf as libc::c_int)
                            || (*atom).t & 0xf as libc::c_int == 5 as libc::c_int)
                {
                    expect(
                        b"integral or integer-sized pointer target type\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            }
            112 => {
                if (*vtop).type_0.t & 0xf as libc::c_int != 5 as libc::c_int
                    || type_size(pointed_type(&mut (*vtop).type_0), &mut align) != size
                {
                    _tcc_error(
                        b"pointer target type mismatch in argument %d\0" as *const u8
                            as *const libc::c_char,
                        arg + 1 as libc::c_int,
                    );
                }
                gen_assign_cast(atom_ptr);
            }
            118 => {
                gen_assign_cast(atom);
            }
            108 => {
                indir();
                gen_assign_cast(atom);
            }
            115 => {
                save = 1 as libc::c_int;
                indir();
                store_0 = *vtop;
                vpop();
            }
            109 => {
                gen_assign_cast(&mut int_type);
            }
            98 => {
                ct.t = 11 as libc::c_int;
                gen_assign_cast(&mut ct);
            }
            _ => {}
        }
        arg += 1;
        if '.' as i32 == *template.offset(arg as isize) as libc::c_int {
            break;
        }
        skip(',' as i32);
    }
    skip(')' as i32);
    ct.t = 0 as libc::c_int;
    match *template.offset((arg + 1 as libc::c_int) as isize) as libc::c_int {
        98 => {
            ct.t = 11 as libc::c_int;
        }
        118 => {
            ct = *atom;
        }
        _ => {}
    }
    sprintf(
        buf.as_mut_ptr(),
        b"%s_%d\0" as *const u8 as *const libc::c_char,
        get_tok_str(atok, 0 as *mut CValue),
        size,
    );
    vpush_helper_func(tok_alloc_const(buf.as_mut_ptr()));
    vrott(arg - save + 1 as libc::c_int);
    gfunc_call(arg - save);
    vpush(&mut ct);
    PUT_R_RET(vtop, ct.t);
    t = ct.t & 0xf as libc::c_int;
    if t == 1 as libc::c_int || t == 2 as libc::c_int || t == 11 as libc::c_int {
        (*vtop)
            .r = ((*vtop).r as libc::c_uint
            | ((0xc00 as libc::c_int & !((0xc00 as libc::c_int) << 1 as libc::c_int))
                as libc::c_uint)
                .wrapping_mul(1 as libc::c_int as libc::c_uint)) as libc::c_ushort;
    }
    gen_cast(&mut ct);
    if save != 0 {
        vpush(&mut ct);
        *vtop = store_0;
        vswap();
        vstore();
    }
}
unsafe extern "C" fn unary() {
    let mut current_block: u64;
    let mut n: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut ad: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    if debug_modes != 0 {
        tcc_debug_line(tcc_state);
        tcc_tcov_check_line(tcc_state, 1 as libc::c_int);
    }
    type_0.ref_0 = 0 as *mut Sym;
    loop {
        match tok {
            292 => {
                next();
            }
            193 | 194 | 192 => {
                t = 3 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            195 => {
                t = 3 as libc::c_int | 0x10 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            196 => {
                t = 4 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            197 => {
                t = 4 as libc::c_int | 0x10 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            202 => {
                t = 8 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            203 => {
                t = 9 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            204 => {
                t = 10 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            198 => {
                t = (if 8 as libc::c_int == 8 as libc::c_int {
                    4 as libc::c_int
                } else {
                    3 as libc::c_int
                }) | 0x800 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            199 => {
                t = (if 8 as libc::c_int == 8 as libc::c_int {
                    4 as libc::c_int
                } else {
                    3 as libc::c_int
                }) | 0x800 as libc::c_int | 0x10 as libc::c_int;
                current_block = 2832871623274853379;
                break;
            }
            337 => {
                if (*tcc_state).gnu_ext == 0 {
                    current_block = 4115625671225879719;
                    break;
                } else {
                    current_block = 7996114607250085088;
                    break;
                }
            }
            342 => {
                current_block = 7996114607250085088;
                break;
            }
            201 => {
                t = 3 as libc::c_int;
                current_block = 7929679119152003721;
                break;
            }
            200 => {
                current_block = 13036503277818778908;
                break;
            }
            167 | 40 => {
                t = tok;
                next();
                if parse_btype(&mut type_0, &mut ad, 0 as libc::c_int) != 0 {
                    type_decl(&mut type_0, &mut ad, &mut n, 1 as libc::c_int);
                    skip(')' as i32);
                    if tok == '{' as i32 {
                        if global_expr != 0 {
                            r = 0x30 as libc::c_int;
                        } else {
                            r = 0x32 as libc::c_int;
                        }
                        if type_0.t & 0x40 as libc::c_int == 0 {
                            r |= 0x100 as libc::c_int;
                        }
                        memset(
                            &mut ad as *mut AttributeDef as *mut libc::c_void,
                            0 as libc::c_int,
                            ::core::mem::size_of::<AttributeDef>() as libc::c_ulong,
                        );
                        decl_initializer_alloc(
                            &mut type_0,
                            &mut ad,
                            r,
                            1 as libc::c_int,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                    } else if t == 0xa7 as libc::c_int {
                        vpush(&mut type_0);
                        return;
                    } else {
                        unary();
                        gen_cast(&mut type_0);
                    }
                } else if tok == '{' as i32 {
                    let mut saved_nocode_wanted: libc::c_int = nocode_wanted;
                    if nocode_wanted & 0xfff0000 as libc::c_int != 0
                        && nocode_wanted & 0xffff as libc::c_int == 0
                    {
                        expect(b"constant\0" as *const u8 as *const libc::c_char);
                    }
                    if 0 as libc::c_int == local_scope {
                        _tcc_error(
                            b"statement expression outside of function\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    save_regs(0 as libc::c_int);
                    block(1 as libc::c_int);
                    if saved_nocode_wanted != 0 {
                        nocode_wanted = saved_nocode_wanted;
                    }
                    skip(')' as i32);
                } else {
                    gexpr();
                    skip(')' as i32);
                }
                current_block = 8744643727662760496;
                break;
            }
            42 => {
                next();
                unary();
                indir();
                current_block = 8744643727662760496;
                break;
            }
            38 => {
                next();
                unary();
                if (*vtop).type_0.t & 0xf as libc::c_int != 6 as libc::c_int
                    && (*vtop).type_0.t & (0x40 as libc::c_int | 0x400 as libc::c_int)
                        == 0
                {
                    test_lvalue();
                }
                if !((*vtop).c2rust_unnamed_0.sym).is_null() {
                    ((*(*vtop).c2rust_unnamed_0.sym).a)
                        .set_addrtaken(1 as libc::c_int as libc::c_ushort);
                }
                mk_pointer(&mut (*vtop).type_0);
                gaddrof();
                current_block = 8744643727662760496;
                break;
            }
            33 => {
                next();
                unary();
                gen_test_zero(0x94 as libc::c_int);
                current_block = 8744643727662760496;
                break;
            }
            126 => {
                next();
                unary();
                vpushi(-(1 as libc::c_int));
                gen_op('^' as i32);
                current_block = 8744643727662760496;
                break;
            }
            43 => {
                next();
                unary();
                if (*vtop).type_0.t & 0xf as libc::c_int == 5 as libc::c_int {
                    _tcc_error(
                        b"pointer not accepted for unary plus\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if is_float((*vtop).type_0.t) == 0 {
                    vpushi(0 as libc::c_int);
                    gen_op('+' as i32);
                }
                current_block = 8744643727662760496;
                break;
            }
            309 | 312 | 313 | 314 => {
                t = tok;
                next();
                if tok == '(' as i32 {
                    tok = 0xa7 as libc::c_int;
                }
                expr_type(&mut type_0, Some(unary as unsafe extern "C" fn() -> ()));
                if t == TOK_SIZEOF as libc::c_int {
                    vpush_type_size(&mut type_0, &mut align);
                    gen_cast_s(
                        0x800 as libc::c_int | 4 as libc::c_int | 0x10 as libc::c_int,
                    );
                } else {
                    type_size(&mut type_0, &mut align);
                    s = 0 as *mut Sym;
                    if (*vtop.offset(1 as libc::c_int as isize)).r as libc::c_int
                        & 0x200 as libc::c_int != 0
                    {
                        s = (*vtop.offset(1 as libc::c_int as isize))
                            .c2rust_unnamed_0
                            .sym;
                    }
                    if !s.is_null() && ((*s).a).aligned() as libc::c_int != 0 {
                        align = (1 as libc::c_int)
                            << ((*s).a).aligned() as libc::c_int - 1 as libc::c_int;
                    }
                    vpushs(align as Elf64_Addr);
                }
                current_block = 8744643727662760496;
                break;
            }
            401 => {
                parse_builtin_params(
                    0 as libc::c_int,
                    b"ee\0" as *const u8 as *const libc::c_char,
                );
                vpop();
                current_block = 8744643727662760496;
                break;
            }
            396 => {
                parse_builtin_params(
                    0 as libc::c_int,
                    b"tt\0" as *const u8 as *const libc::c_char,
                );
                (*vtop.offset(-(1 as libc::c_int) as isize)).type_0.t
                    &= !(0x100 as libc::c_int | 0x200 as libc::c_int);
                (*vtop.offset(0 as libc::c_int as isize)).type_0.t
                    &= !(0x100 as libc::c_int | 0x200 as libc::c_int);
                n = is_compatible_types(
                    &mut (*vtop.offset(-(1 as libc::c_int) as isize)).type_0,
                    &mut (*vtop.offset(0 as libc::c_int as isize)).type_0,
                );
                vtop = vtop.offset(-(2 as libc::c_int as isize));
                vpushi(n);
                current_block = 8744643727662760496;
                break;
            }
            397 => {
                let mut c: int64_t = 0;
                next();
                skip('(' as i32);
                c = expr_const64();
                skip(',' as i32);
                if c == 0 {
                    nocode_wanted += 1;
                    nocode_wanted;
                }
                expr_eq();
                if c == 0 {
                    vpop();
                    nocode_wanted -= 1;
                    nocode_wanted;
                }
                skip(',' as i32);
                if c != 0 {
                    nocode_wanted += 1;
                    nocode_wanted;
                }
                expr_eq();
                if c != 0 {
                    vpop();
                    nocode_wanted -= 1;
                    nocode_wanted;
                }
                skip(')' as i32);
                current_block = 8744643727662760496;
                break;
            }
            398 => {
                parse_builtin_params(
                    1 as libc::c_int,
                    b"e\0" as *const u8 as *const libc::c_char,
                );
                n = 1 as libc::c_int;
                if (*vtop).r as libc::c_int
                    & (0x3f as libc::c_int | 0x100 as libc::c_int) != 0x30 as libc::c_int
                    || (*vtop).r as libc::c_int & 0x200 as libc::c_int != 0
                        && ((*(*vtop).c2rust_unnamed_0.sym).a).addrtaken() as libc::c_int
                            != 0
                {
                    n = 0 as libc::c_int;
                }
                vtop = vtop.offset(-1);
                vtop;
                vpushi(n);
                current_block = 8744643727662760496;
                break;
            }
            402 => {
                parse_builtin_params(
                    0 as libc::c_int,
                    b"\0" as *const u8 as *const libc::c_char,
                );
                type_0.t = 0 as libc::c_int;
                vpush(&mut type_0);
                if nocode_wanted == 0 {
                    nocode_wanted |= 0x20000000 as libc::c_int;
                }
                current_block = 8744643727662760496;
                break;
            }
            399 | 400 => {
                let mut tok1: libc::c_int = tok;
                let mut level: libc::c_int = 0;
                next();
                skip('(' as i32);
                level = expr_const();
                if level < 0 as libc::c_int {
                    _tcc_error(
                        b"%s only takes positive integers\0" as *const u8
                            as *const libc::c_char,
                        get_tok_str(tok1, 0 as *mut CValue),
                    );
                }
                skip(')' as i32);
                type_0.t = 0 as libc::c_int;
                mk_pointer(&mut type_0);
                vset(&mut type_0, 0x32 as libc::c_int, 0 as libc::c_int);
                loop {
                    let fresh159 = level;
                    level = level - 1;
                    if !(fresh159 != 0) {
                        break;
                    }
                    mk_pointer(&mut (*vtop).type_0);
                    indir();
                }
                if tok1 == TOK_builtin_return_address as libc::c_int {
                    vpushi(8 as libc::c_int);
                    gen_op('+' as i32);
                    mk_pointer(&mut (*vtop).type_0);
                    indir();
                }
                current_block = 8744643727662760496;
                break;
            }
            403 => {
                parse_builtin_params(
                    0 as libc::c_int,
                    b"t\0" as *const u8 as *const libc::c_char,
                );
                vpushi(classify_x86_64_va_arg(&mut (*vtop).type_0));
                vswap();
                vpop();
                current_block = 8744643727662760496;
                break;
            }
            404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416
            | 417 | 418 | 419 => {
                parse_atomic(tok);
                current_block = 8744643727662760496;
                break;
            }
            130 | 128 => {
                t = tok;
                next();
                unary();
                inc(0 as libc::c_int, t);
                current_block = 8744643727662760496;
                break;
            }
            45 => {
                next();
                unary();
                if is_float((*vtop).type_0.t) != 0 {
                    gen_opif(0x81 as libc::c_int);
                } else {
                    vpushi(0 as libc::c_int);
                    vswap();
                    gen_op('-' as i32);
                }
                current_block = 8744643727662760496;
                break;
            }
            144 => {
                if (*tcc_state).gnu_ext == 0 {
                    current_block = 4115625671225879719;
                    break;
                } else {
                    current_block = 13918987447127423209;
                    break;
                }
            }
            294 => {
                let mut controlling_type: CType = CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                };
                let mut has_default: libc::c_int = 0 as libc::c_int;
                let mut has_match: libc::c_int = 0 as libc::c_int;
                let mut learn: libc::c_int = 0 as libc::c_int;
                let mut str: *mut TokenString = 0 as *mut TokenString;
                let mut saved_nocode_wanted_0: libc::c_int = nocode_wanted;
                nocode_wanted &= !(0xfff0000 as libc::c_int);
                next();
                skip('(' as i32);
                expr_type(
                    &mut controlling_type,
                    Some(expr_eq as unsafe extern "C" fn() -> ()),
                );
                convert_parameter_type(&mut controlling_type);
                nocode_wanted = saved_nocode_wanted_0;
                loop {
                    learn = 0 as libc::c_int;
                    skip(',' as i32);
                    if tok == TOK_DEFAULT as libc::c_int {
                        if has_default != 0 {
                            _tcc_error(
                                b"too many 'default'\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        has_default = 1 as libc::c_int;
                        if has_match == 0 {
                            learn = 1 as libc::c_int;
                        }
                        next();
                    } else {
                        let mut ad_tmp: AttributeDef = AttributeDef {
                            a: SymAttr {
                                aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                            },
                            f: FuncAttr {
                                func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
                            },
                            section: 0 as *mut Section,
                            cleanup_func: 0 as *mut Sym,
                            alias_target: 0,
                            asm_label: 0,
                            attr_mode: 0,
                        };
                        let mut itmp: libc::c_int = 0;
                        let mut cur_type: CType = CType {
                            t: 0,
                            ref_0: 0 as *mut Sym,
                        };
                        parse_btype(&mut cur_type, &mut ad_tmp, 0 as libc::c_int);
                        type_decl(
                            &mut cur_type,
                            &mut ad_tmp,
                            &mut itmp,
                            1 as libc::c_int,
                        );
                        if compare_types(
                            &mut controlling_type,
                            &mut cur_type,
                            0 as libc::c_int,
                        ) != 0
                        {
                            if has_match != 0 {
                                _tcc_error(
                                    b"type match twice\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            has_match = 1 as libc::c_int;
                            learn = 1 as libc::c_int;
                        }
                    }
                    skip(':' as i32);
                    if learn != 0 {
                        if !str.is_null() {
                            tok_str_free(str);
                        }
                        skip_or_save_block(&mut str);
                    } else {
                        skip_or_save_block(0 as *mut *mut TokenString);
                    }
                    if tok == ')' as i32 {
                        break;
                    }
                }
                if str.is_null() {
                    let mut buf: [libc::c_char; 60] = [0; 60];
                    type_to_str(
                        buf.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 60]>() as libc::c_ulong
                            as libc::c_int,
                        &mut controlling_type,
                        0 as *const libc::c_char,
                    );
                    _tcc_error(
                        b"type '%s' does not match any association\0" as *const u8
                            as *const libc::c_char,
                        buf.as_mut_ptr(),
                    );
                }
                begin_macro(str, 1 as libc::c_int);
                next();
                expr_eq();
                if tok != -(1 as libc::c_int) {
                    expect(b",\0" as *const u8 as *const libc::c_char);
                }
                end_macro();
                next();
                current_block = 8744643727662760496;
                break;
            }
            343 => {
                n = 0x7fc00000 as libc::c_int;
                current_block = 14058797729490460433;
                break;
            }
            344 => {
                n = 0x7f800001 as libc::c_int;
                current_block = 14058797729490460433;
                break;
            }
            345 => {
                n = 0x7f800000 as libc::c_int;
                current_block = 14058797729490460433;
                break;
            }
            _ => {
                current_block = 4115625671225879719;
                break;
            }
        }
    }
    match current_block {
        13918987447127423209 => {
            next();
            if tok < TOK_DEFINE as libc::c_int {
                expect(b"label identifier\0" as *const u8 as *const libc::c_char);
            }
            s = label_find(tok);
            if s.is_null() {
                s = label_push(&mut global_label_stack, tok, 1 as libc::c_int);
            } else if (*s).r as libc::c_int == 2 as libc::c_int {
                (*s).r = 1 as libc::c_int as libc::c_ushort;
            }
            if (*s).type_0.t & 0xf as libc::c_int != 5 as libc::c_int {
                (*s).type_0.t = 0 as libc::c_int;
                mk_pointer(&mut (*s).type_0);
                (*s).type_0.t |= 0x2000 as libc::c_int;
            }
            vpushsym(&mut (*s).type_0, s);
            next();
            current_block = 8744643727662760496;
        }
        14058797729490460433 => {
            vpushi(n);
            (*vtop).type_0.t = 8 as libc::c_int;
            next();
            current_block = 8744643727662760496;
        }
        7996114607250085088 => {
            tok = 0xc8 as libc::c_int;
            cstr_reset(&mut tokcstr);
            cstr_cat(&mut tokcstr, funcname, 0 as libc::c_int);
            tokc.str_0.size = tokcstr.size;
            tokc.str_0.data = tokcstr.data;
            current_block = 13036503277818778908;
        }
        4115625671225879719 => {
            if tok < TOK_DEFINE as libc::c_int {
                _tcc_error(
                    b"expression expected before '%s'\0" as *const u8
                        as *const libc::c_char,
                    get_tok_str(tok, &mut tokc),
                );
            }
            t = tok;
            next();
            s = sym_find(t);
            if s.is_null()
                || (*s).type_0.t
                    & (0xf as libc::c_int
                        | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int))
                    == 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
            {
                let mut name: *const libc::c_char = get_tok_str(t, 0 as *mut CValue);
                if tok != '(' as i32 {
                    _tcc_error(
                        b"'%s' undeclared\0" as *const u8 as *const libc::c_char,
                        name,
                    );
                }
                (*tcc_state)
                    .warn_num = (&mut (*(0 as *mut TCCState))
                    .warn_implicit_function_declaration as *mut libc::c_uchar as size_t)
                    .wrapping_sub(
                        &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                            as size_t,
                    ) as libc::c_uchar;
                (Some(
                    _tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"implicit declaration of function '%s'\0" as *const u8
                        as *const libc::c_char,
                    name,
                );
                s = external_global_sym(t, &mut func_old_type);
            }
            r = (*s).r as libc::c_int;
            if (r & 0x3f as libc::c_int) < 0x30 as libc::c_int {
                r = r & !(0x3f as libc::c_int) | 0x32 as libc::c_int;
            }
            vset(&mut (*s).type_0, r, (*s).c2rust_unnamed.c2rust_unnamed.c);
            (*vtop).c2rust_unnamed_0.sym = s;
            if r & 0x200 as libc::c_int != 0 {
                (*vtop).c2rust_unnamed.c.i = 0 as libc::c_int as uint64_t;
            } else if r == 0x30 as libc::c_int
                && (*s).type_0.t as libc::c_uint
                    & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                        .wrapping_sub(1 as libc::c_int as libc::c_uint)
                        << 20 as libc::c_int | 0x80 as libc::c_int as libc::c_uint)
                    == ((3 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
            {
                (*vtop).c2rust_unnamed.c.i = (*s).c2rust_unnamed.enum_val as uint64_t;
            }
            current_block = 8744643727662760496;
        }
        2832871623274853379 => {
            type_0.t = t;
            vsetc(&mut type_0, 0x30 as libc::c_int, &mut tokc);
            next();
            current_block = 8744643727662760496;
        }
        _ => {}
    }
    match current_block {
        13036503277818778908 => {
            t = char_type.t;
            current_block = 7929679119152003721;
        }
        _ => {}
    }
    match current_block {
        7929679119152003721 => {
            if (*tcc_state).warn_write_strings as libc::c_int & 1 as libc::c_int != 0 {
                t |= 0x100 as libc::c_int;
            }
            type_0.t = t;
            mk_pointer(&mut type_0);
            type_0.t |= 0x40 as libc::c_int;
            memset(
                &mut ad as *mut AttributeDef as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<AttributeDef>() as libc::c_ulong,
            );
            ad.section = (*tcc_state).rodata_section;
            decl_initializer_alloc(
                &mut type_0,
                &mut ad,
                0x30 as libc::c_int,
                2 as libc::c_int,
                0 as libc::c_int,
                0 as libc::c_int,
            );
        }
        _ => {}
    }
    loop {
        if tok == 0x82 as libc::c_int || tok == 0x80 as libc::c_int {
            inc(1 as libc::c_int, tok);
            next();
        } else if tok == '.' as i32 || tok == 0xa0 as libc::c_int {
            let mut qualifiers: libc::c_int = 0;
            let mut cumofs: libc::c_int = 0;
            if tok == 0xa0 as libc::c_int {
                indir();
            }
            qualifiers = (*vtop).type_0.t
                & (0x100 as libc::c_int | 0x200 as libc::c_int);
            test_lvalue();
            next();
            s = find_field(&mut (*vtop).type_0, tok, &mut cumofs);
            gaddrof();
            (*vtop).type_0 = char_pointer_type;
            vpushi(cumofs);
            gen_op('+' as i32);
            (*vtop).type_0 = (*s).type_0;
            (*vtop).type_0.t |= qualifiers;
            if (*vtop).type_0.t & 0x40 as libc::c_int == 0 {
                (*vtop)
                    .r = ((*vtop).r as libc::c_int | 0x100 as libc::c_int)
                    as libc::c_ushort;
                if (*tcc_state).do_bounds_check != 0 {
                    (*vtop)
                        .r = ((*vtop).r as libc::c_int | 0x4000 as libc::c_int)
                        as libc::c_ushort;
                }
            }
            next();
        } else if tok == '[' as i32 {
            next();
            gexpr();
            gen_op('+' as i32);
            indir();
            skip(']' as i32);
        } else {
            if !(tok == '(' as i32) {
                break;
            }
            let mut ret: SValue = SValue {
                type_0: CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                },
                r: 0,
                r2: 0,
                c2rust_unnamed: C2RustUnnamed_15 {
                    c2rust_unnamed: C2RustUnnamed_16 {
                        jtrue: 0,
                        jfalse: 0,
                    },
                },
                c2rust_unnamed_0: C2RustUnnamed_13 {
                    c2rust_unnamed: C2RustUnnamed_14 {
                        cmp_op: 0,
                        cmp_r: 0,
                    },
                },
            };
            let mut sa: *mut Sym = 0 as *mut Sym;
            let mut nb_args: libc::c_int = 0;
            let mut ret_nregs: libc::c_int = 0;
            let mut ret_align: libc::c_int = 0;
            let mut regsize: libc::c_int = 0;
            let mut variadic: libc::c_int = 0;
            let mut p: *mut TokenString = 0 as *mut TokenString;
            let mut p2: *mut TokenString = 0 as *mut TokenString;
            if (*vtop).type_0.t & 0xf as libc::c_int != 6 as libc::c_int {
                's_1385: {
                    if (*vtop).type_0.t & (0xf as libc::c_int | 0x40 as libc::c_int)
                        == 5 as libc::c_int
                    {
                        (*vtop).type_0 = *pointed_type(&mut (*vtop).type_0);
                        if !((*vtop).type_0.t & 0xf as libc::c_int != 6 as libc::c_int) {
                            break 's_1385;
                        }
                    }
                    expect(b"function pointer\0" as *const u8 as *const libc::c_char);
                }
            } else {
                (*vtop)
                    .r = ((*vtop).r as libc::c_int & !(0x100 as libc::c_int))
                    as libc::c_ushort;
            }
            s = (*vtop).type_0.ref_0;
            next();
            sa = (*s).c2rust_unnamed_0.next;
            regsize = 0 as libc::c_int;
            nb_args = regsize;
            ret.r2 = 0x30 as libc::c_int as libc::c_ushort;
            if (*s).type_0.t & 0xf as libc::c_int == 7 as libc::c_int {
                variadic = (((*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
                    .func_type() as libc::c_int == 3 as libc::c_int) as libc::c_int;
                ret_nregs = gfunc_sret(
                    &mut (*s).type_0,
                    variadic,
                    &mut ret.type_0,
                    &mut ret_align,
                    &mut regsize,
                );
                if ret_nregs <= 0 as libc::c_int {
                    size = type_size(&mut (*s).type_0, &mut align);
                    loc = loc - size & -align;
                    ret.type_0 = (*s).type_0;
                    ret
                        .r = (0x32 as libc::c_int | 0x100 as libc::c_int)
                        as libc::c_ushort;
                    vseti(0x32 as libc::c_int, loc);
                    if (*tcc_state).do_bounds_check != 0 {
                        loc -= 1;
                        loc;
                    }
                    ret.c2rust_unnamed.c = (*vtop).c2rust_unnamed.c;
                    if ret_nregs < 0 as libc::c_int {
                        vtop = vtop.offset(-1);
                        vtop;
                    } else {
                        nb_args += 1;
                        nb_args;
                    }
                }
            } else {
                ret_nregs = 1 as libc::c_int;
                ret.type_0 = (*s).type_0;
            }
            if ret_nregs > 0 as libc::c_int {
                ret.c2rust_unnamed.c.i = 0 as libc::c_int as uint64_t;
                PUT_R_RET(&mut ret, ret.type_0.t);
            }
            p = 0 as *mut TokenString;
            if tok != ')' as i32 {
                r = (*tcc_state).reverse_funcargs as libc::c_int;
                loop {
                    if r != 0 {
                        skip_or_save_block(&mut p2);
                        (*p2).prev = p;
                        p = p2;
                    } else {
                        expr_eq();
                        gfunc_param_typed(s, sa);
                    }
                    nb_args += 1;
                    nb_args;
                    if !sa.is_null() {
                        sa = (*sa).c2rust_unnamed_0.next;
                    }
                    if tok == ')' as i32 {
                        break;
                    }
                    skip(',' as i32);
                }
            }
            if !sa.is_null() {
                _tcc_error(
                    b"too few arguments to function\0" as *const u8
                        as *const libc::c_char,
                );
            }
            if !p.is_null() {
                n = 0 as libc::c_int;
                while !p.is_null() {
                    p2 = p;
                    sa = s;
                    loop {
                        sa = (*sa).c2rust_unnamed_0.next;
                        p2 = (*p2).prev;
                        if !(!p2.is_null() && !sa.is_null()) {
                            break;
                        }
                    }
                    p2 = (*p).prev;
                    begin_macro(p, 1 as libc::c_int);
                    next();
                    expr_eq();
                    gfunc_param_typed(s, sa);
                    end_macro();
                    p = p2;
                    n += 1;
                    n;
                }
                vrev(n);
            }
            next();
            vcheck_cmp();
            gfunc_call(nb_args);
            if ret_nregs < 0 as libc::c_int {
                vsetc(&mut ret.type_0, ret.r as libc::c_int, &mut ret.c2rust_unnamed.c);
            } else {
                n = ret_nregs;
                while n > 1 as libc::c_int {
                    let mut rc: libc::c_int = reg_classes[ret.r as usize]
                        & !(0x1 as libc::c_int | 0x2 as libc::c_int);
                    n -= 1;
                    rc <<= n;
                    r = 0 as libc::c_int;
                    while r < 25 as libc::c_int {
                        if reg_classes[r as usize] & rc != 0 {
                            break;
                        }
                        r += 1;
                        r;
                    }
                    vsetc(&mut ret.type_0, r, &mut ret.c2rust_unnamed.c);
                }
                vsetc(&mut ret.type_0, ret.r as libc::c_int, &mut ret.c2rust_unnamed.c);
                (*vtop).r2 = ret.r2;
                if (*s).type_0.t & 0xf as libc::c_int == 7 as libc::c_int
                    && ret_nregs != 0
                {
                    let mut addr: libc::c_int = 0;
                    let mut offset: libc::c_int = 0;
                    size = type_size(&mut (*s).type_0, &mut align);
                    size = size + regsize - 1 as libc::c_int & -regsize;
                    if ret_align > align {
                        align = ret_align;
                    }
                    loc = loc - size & -align;
                    addr = loc;
                    offset = 0 as libc::c_int;
                    loop {
                        vset(
                            &mut ret.type_0,
                            0x32 as libc::c_int | 0x100 as libc::c_int,
                            addr + offset,
                        );
                        vswap();
                        vstore();
                        vtop = vtop.offset(-1);
                        vtop;
                        ret_nregs -= 1;
                        if ret_nregs == 0 as libc::c_int {
                            break;
                        }
                        offset += regsize;
                    }
                    vset(
                        &mut (*s).type_0,
                        0x32 as libc::c_int | 0x100 as libc::c_int,
                        addr,
                    );
                }
                t = (*s).type_0.t & 0xf as libc::c_int;
                if t == 1 as libc::c_int || t == 2 as libc::c_int
                    || t == 11 as libc::c_int
                {
                    (*vtop)
                        .r = ((*vtop).r as libc::c_uint
                        | ((0xc00 as libc::c_int
                            & !((0xc00 as libc::c_int) << 1 as libc::c_int))
                            as libc::c_uint)
                            .wrapping_mul(1 as libc::c_int as libc::c_uint))
                        as libc::c_ushort;
                }
            }
            if ((*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_noreturn() != 0
            {
                if debug_modes != 0 {
                    tcc_tcov_block_end(tcc_state, -(1 as libc::c_int));
                }
                if nocode_wanted == 0 {
                    nocode_wanted |= 0x20000000 as libc::c_int;
                }
            }
        }
    };
}
unsafe extern "C" fn precedence(mut tok_0: libc::c_int) -> libc::c_int {
    match tok_0 {
        145 => return 1 as libc::c_int,
        144 => return 2 as libc::c_int,
        124 => return 3 as libc::c_int,
        94 => return 4 as libc::c_int,
        38 => return 5 as libc::c_int,
        148 | 149 => return 6 as libc::c_int,
        146 | 147 => {}
        60 | 62 => return 8 as libc::c_int,
        43 | 45 => return 9 as libc::c_int,
        42 | 47 | 37 => return 10 as libc::c_int,
        _ => {
            if !(tok_0 >= 0x96 as libc::c_int && tok_0 <= 0x9f as libc::c_int) {
                return 0 as libc::c_int;
            }
        }
    }
    return 7 as libc::c_int;
}
static mut prec: [libc::c_uchar; 256] = [0; 256];
unsafe extern "C" fn init_prec() {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 256 as libc::c_int {
        prec[i as usize] = precedence(i) as libc::c_uchar;
        i += 1;
        i;
    }
}
unsafe extern "C" fn expr_infix(mut p: libc::c_int) {
    let mut t: libc::c_int = tok;
    let mut p2: libc::c_int = 0;
    loop {
        p2 = (if (t as libc::c_uint) < 256 as libc::c_int as libc::c_uint {
            prec[t as usize] as libc::c_int
        } else {
            0 as libc::c_int
        });
        if !(p2 >= p) {
            break;
        }
        if t == 0x91 as libc::c_int || t == 0x90 as libc::c_int {
            expr_landor(t);
        } else {
            next();
            unary();
            if (if (tok as libc::c_uint) < 256 as libc::c_int as libc::c_uint {
                prec[tok as usize] as libc::c_int
            } else {
                0 as libc::c_int
            }) > p2
            {
                expr_infix(p2 + 1 as libc::c_int);
            }
            gen_op(t);
        }
        t = tok;
    };
}
unsafe extern "C" fn condition_3way() -> libc::c_int {
    let mut c: libc::c_int = -(1 as libc::c_int);
    if (*vtop).r as libc::c_int & (0x3f as libc::c_int | 0x100 as libc::c_int)
        == 0x30 as libc::c_int
        && ((*vtop).r as libc::c_int & 0x200 as libc::c_int == 0
            || ((*(*vtop).c2rust_unnamed_0.sym).a).weak() == 0)
    {
        vdup();
        gen_cast_s(11 as libc::c_int);
        c = (*vtop).c2rust_unnamed.c.i as libc::c_int;
        vpop();
    }
    return c;
}
unsafe extern "C" fn expr_landor(mut op: libc::c_int) {
    let mut t: libc::c_int = 0 as libc::c_int;
    let mut cc: libc::c_int = 1 as libc::c_int;
    let mut f: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = (op == 0x90 as libc::c_int) as libc::c_int;
    let mut c: libc::c_int = 0;
    loop {
        c = if f != 0 { i } else { condition_3way() };
        if c < 0 as libc::c_int {
            save_regs(1 as libc::c_int);
            cc = 0 as libc::c_int;
        } else if c != i {
            nocode_wanted += 1;
            nocode_wanted;
            f = 1 as libc::c_int;
        }
        if tok != op {
            break;
        }
        if c < 0 as libc::c_int {
            t = gvtst(i, t);
        } else {
            vpop();
        }
        next();
        unary();
        expr_infix(
            (if (op as libc::c_uint) < 256 as libc::c_int as libc::c_uint {
                prec[op as usize] as libc::c_int
            } else {
                0 as libc::c_int
            }) + 1 as libc::c_int,
        );
    }
    if cc != 0 || f != 0 {
        vpop();
        vpushi(i ^ f);
        gsym(t);
        nocode_wanted -= f;
    } else {
        gvtst_set(i, t);
    };
}
unsafe extern "C" fn is_cond_bool(mut sv: *mut SValue) -> libc::c_int {
    if (*sv).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int)
        == 0x30 as libc::c_int && (*sv).type_0.t & 0xf as libc::c_int == 3 as libc::c_int
    {
        return (((*sv).c2rust_unnamed.c.i as libc::c_uint)
            < 2 as libc::c_int as libc::c_uint) as libc::c_int;
    }
    if (*sv).r as libc::c_int == 0x33 as libc::c_int {
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn expr_cond() {
    let mut tt: libc::c_int = 0;
    let mut u: libc::c_int = 0;
    let mut r1: libc::c_int = 0;
    let mut r2: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut t1: libc::c_int = 0;
    let mut t2: libc::c_int = 0;
    let mut islv: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut g_0: libc::c_int = 0;
    let mut sv: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    unary();
    expr_infix(1 as libc::c_int);
    if tok == '?' as i32 {
        next();
        c = condition_3way();
        g_0 = (tok == ':' as i32 && (*tcc_state).gnu_ext as libc::c_int != 0)
            as libc::c_int;
        tt = 0 as libc::c_int;
        if g_0 == 0 {
            if c < 0 as libc::c_int {
                save_regs(1 as libc::c_int);
                tt = gvtst(1 as libc::c_int, 0 as libc::c_int);
            } else {
                vpop();
            }
        } else if c < 0 as libc::c_int {
            save_regs(1 as libc::c_int);
            gv_dup();
            tt = gvtst(0 as libc::c_int, 0 as libc::c_int);
        }
        if c == 0 as libc::c_int {
            nocode_wanted += 1;
            nocode_wanted;
        }
        if g_0 == 0 {
            gexpr();
        }
        if (*vtop).type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
            mk_pointer(&mut (*vtop).type_0);
        }
        sv = *vtop;
        vtop = vtop.offset(-1);
        vtop;
        if g_0 != 0 {
            u = tt;
        } else if c < 0 as libc::c_int {
            u = gjmp_acs(0 as libc::c_int);
            gsym(tt);
        } else {
            u = 0 as libc::c_int;
        }
        if c == 0 as libc::c_int {
            nocode_wanted -= 1;
            nocode_wanted;
        }
        if c == 1 as libc::c_int {
            nocode_wanted += 1;
            nocode_wanted;
        }
        skip(':' as i32);
        expr_cond();
        if (*vtop).type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
            mk_pointer(&mut (*vtop).type_0);
        }
        if combine_types(&mut type_0, &mut sv, vtop, '?' as i32) == 0 {
            type_incompatibility_error(
                &mut sv.type_0,
                &mut (*vtop).type_0,
                b"type mismatch in conditional expression (have '%s' and '%s')\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        if c < 0 as libc::c_int && is_cond_bool(vtop) != 0 && is_cond_bool(&mut sv) != 0
        {
            t1 = gvtst(0 as libc::c_int, 0 as libc::c_int);
            t2 = gjmp_acs(0 as libc::c_int);
            gsym(u);
            vpushv(&mut sv);
            gvtst_set(0 as libc::c_int, t1);
            gvtst_set(1 as libc::c_int, t2);
            gen_cast(&mut type_0);
            return;
        }
        islv = ((*vtop).r as libc::c_int & 0x100 as libc::c_int != 0
            && sv.r as libc::c_int & 0x100 as libc::c_int != 0
            && 7 as libc::c_int == type_0.t & 0xf as libc::c_int) as libc::c_int;
        if c != 1 as libc::c_int {
            gen_cast(&mut type_0);
            if islv != 0 {
                mk_pointer(&mut (*vtop).type_0);
                gaddrof();
            } else if 7 as libc::c_int == (*vtop).type_0.t & 0xf as libc::c_int {
                gaddrof();
            }
        }
        rc = RC_TYPE(type_0.t);
        if R2_RET(type_0.t) != 0x30 as libc::c_int {
            rc = RC_RET(type_0.t);
        }
        r2 = 0 as libc::c_int;
        tt = r2;
        if c < 0 as libc::c_int {
            r2 = gv(rc);
            tt = gjmp_acs(0 as libc::c_int);
        }
        gsym(u);
        if c == 1 as libc::c_int {
            nocode_wanted -= 1;
            nocode_wanted;
        }
        if c != 0 as libc::c_int {
            *vtop = sv;
            gen_cast(&mut type_0);
            if islv != 0 {
                mk_pointer(&mut (*vtop).type_0);
                gaddrof();
            } else if 7 as libc::c_int == (*vtop).type_0.t & 0xf as libc::c_int {
                gaddrof();
            }
        }
        if c < 0 as libc::c_int {
            r1 = gv(rc);
            move_reg(r2, r1, if islv != 0 { 5 as libc::c_int } else { type_0.t });
            (*vtop).r = r2 as libc::c_ushort;
            gsym(tt);
        }
        if islv != 0 {
            indir();
        }
    }
}
unsafe extern "C" fn expr_eq() {
    let mut t: libc::c_int = 0;
    expr_cond();
    t = tok;
    if t == '=' as i32 || t >= 0xb0 as libc::c_int && t <= 0xb9 as libc::c_int {
        test_lvalue();
        next();
        if t == '=' as i32 {
            expr_eq();
        } else {
            vdup();
            expr_eq();
            gen_op(
                (*::core::mem::transmute::<
                    &[u8; 11],
                    &[libc::c_char; 11],
                >(b"+-*/%&|^<>\0"))[(t - 0xb0 as libc::c_int) as usize] as libc::c_int,
            );
        }
        vstore();
    }
}
unsafe extern "C" fn gexpr() {
    expr_eq();
    if tok == ',' as i32 {
        loop {
            vpop();
            next();
            expr_eq();
            if !(tok == ',' as i32) {
                break;
            }
        }
        convert_parameter_type(&mut (*vtop).type_0);
        if (*vtop).r as libc::c_int & 0x3f as libc::c_int == 0x30 as libc::c_int
            && nocode_wanted != 0 && nocode_wanted & 0xfff0000 as libc::c_int == 0
        {
            gv(RC_TYPE((*vtop).type_0.t));
        }
    }
}
unsafe extern "C" fn expr_const1() {
    nocode_wanted += 0x10000 as libc::c_int;
    expr_cond();
    nocode_wanted -= 0x10000 as libc::c_int;
}
#[inline]
unsafe extern "C" fn expr_const64() -> int64_t {
    let mut c: int64_t = 0;
    expr_const1();
    if (*vtop).r as libc::c_int
        & (0x3f as libc::c_int | 0x100 as libc::c_int | 0x200 as libc::c_int
            | 0x1000 as libc::c_int) != 0x30 as libc::c_int
    {
        expect(b"constant expression\0" as *const u8 as *const libc::c_char);
    }
    c = (*vtop).c2rust_unnamed.c.i as int64_t;
    vpop();
    return c;
}
unsafe extern "C" fn expr_const() -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut wc: int64_t = expr_const64();
    c = wc as libc::c_int;
    if c as int64_t != wc && c as libc::c_uint as int64_t != wc {
        _tcc_error(b"constant exceeds 32 bit\0" as *const u8 as *const libc::c_char);
    }
    return c;
}
unsafe extern "C" fn gfunc_return(mut func_type: *mut CType) {
    if (*func_type).t & 0xf as libc::c_int == 7 as libc::c_int {
        let mut type_0: CType = CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        };
        let mut ret_type: CType = CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        };
        let mut ret_align: libc::c_int = 0;
        let mut ret_nregs: libc::c_int = 0;
        let mut regsize: libc::c_int = 0;
        ret_nregs = gfunc_sret(
            func_type,
            func_var,
            &mut ret_type,
            &mut ret_align,
            &mut regsize,
        );
        if !(ret_nregs < 0 as libc::c_int) {
            if 0 as libc::c_int == ret_nregs {
                type_0 = *func_type;
                mk_pointer(&mut type_0);
                vset(&mut type_0, 0x32 as libc::c_int | 0x100 as libc::c_int, func_vc);
                indir();
                vswap();
                vstore();
            } else {
                let mut size: libc::c_int = 0;
                let mut addr: libc::c_int = 0;
                let mut align: libc::c_int = 0;
                let mut rc: libc::c_int = 0;
                let mut n: libc::c_int = 0;
                size = type_size(func_type, &mut align);
                if align & ret_align - 1 as libc::c_int != 0
                    && (((*vtop).r as libc::c_int & 0x3f as libc::c_int)
                        < 0x30 as libc::c_int
                        || (*vtop).c2rust_unnamed.c.i
                            & (ret_align - 1 as libc::c_int) as uint64_t != 0)
                {
                    loc = loc - size & -ret_align;
                    addr = loc;
                    type_0 = *func_type;
                    vset(&mut type_0, 0x32 as libc::c_int | 0x100 as libc::c_int, addr);
                    vswap();
                    vstore();
                    vpop();
                    vset(
                        &mut ret_type,
                        0x32 as libc::c_int | 0x100 as libc::c_int,
                        addr,
                    );
                }
                (*vtop).type_0 = ret_type;
                rc = RC_RET(ret_type.t);
                n = ret_nregs;
                loop {
                    n -= 1;
                    if !(n > 0 as libc::c_int) {
                        break;
                    }
                    vdup();
                    gv(rc);
                    vswap();
                    incr_offset(regsize);
                    rc <<= 1 as libc::c_int;
                }
                gv(rc);
                vtop = vtop.offset(-((ret_nregs - 1 as libc::c_int) as isize));
            }
        }
    } else {
        gv(RC_RET((*func_type).t));
    }
    vtop = vtop.offset(-1);
    vtop;
}
unsafe extern "C" fn check_func_return() {
    if func_vt.t & 0xf as libc::c_int == 0 as libc::c_int {
        return;
    }
    if strcmp(funcname, b"main\0" as *const u8 as *const libc::c_char) == 0
        && func_vt.t & 0xf as libc::c_int == 3 as libc::c_int
    {
        vpushi(0 as libc::c_int);
        gen_assign_cast(&mut func_vt);
        gfunc_return(&mut func_vt);
    } else {
        _tcc_warning(
            b"function might return no value: '%s'\0" as *const u8
                as *const libc::c_char,
            funcname,
        );
    };
}
unsafe extern "C" fn case_cmp(mut a: uint64_t, mut b: uint64_t) -> libc::c_int {
    if (*cur_switch).sv.type_0.t & 0x10 as libc::c_int != 0 {
        return if a < b { -(1 as libc::c_int) } else { (a > b) as libc::c_int }
    } else {
        return if (a as int64_t) < b as int64_t {
            -(1 as libc::c_int)
        } else {
            (a as int64_t > b as int64_t) as libc::c_int
        }
    };
}
unsafe extern "C" fn case_cmp_qs(
    mut pa: *const libc::c_void,
    mut pb: *const libc::c_void,
) -> libc::c_int {
    return case_cmp(
        (**(pa as *mut *mut case_t)).v1 as uint64_t,
        (**(pb as *mut *mut case_t)).v1 as uint64_t,
    );
}
unsafe extern "C" fn case_sort(mut sw: *mut switch_t) {
    let mut p: *mut *mut case_t = 0 as *mut *mut case_t;
    if (*sw).n < 2 as libc::c_int {
        return;
    }
    qsort(
        (*sw).p as *mut libc::c_void,
        (*sw).n as size_t,
        ::core::mem::size_of::<*mut case_t>() as libc::c_ulong,
        Some(
            case_cmp_qs
                as unsafe extern "C" fn(
                    *const libc::c_void,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
    p = (*sw).p;
    while p < ((*sw).p).offset((*sw).n as isize).offset(-(1 as libc::c_int as isize)) {
        if case_cmp(
            (**p.offset(0 as libc::c_int as isize)).v2 as uint64_t,
            (**p.offset(1 as libc::c_int as isize)).v1 as uint64_t,
        ) >= 0 as libc::c_int
        {
            let mut l1: libc::c_int = (**p.offset(0 as libc::c_int as isize)).line;
            let mut l2: libc::c_int = (**p.offset(1 as libc::c_int as isize)).line;
            _tcc_error(
                b"%i:duplicate case value\0" as *const u8 as *const libc::c_char,
                if l1 > l2 { l1 } else { l2 },
            );
        } else if (**p.offset(0 as libc::c_int as isize)).v2
            + 1 as libc::c_int as int64_t == (**p.offset(1 as libc::c_int as isize)).v1
            && (**p.offset(0 as libc::c_int as isize)).ind
                == (**p.offset(1 as libc::c_int as isize)).ind
        {
            (**p.offset(1 as libc::c_int as isize))
                .v1 = (**p.offset(0 as libc::c_int as isize)).v1;
            tcc_free(*p.offset(0 as libc::c_int as isize) as *mut libc::c_void);
            (*sw).n -= 1;
            memmove(
                p as *mut libc::c_void,
                p.offset(1 as libc::c_int as isize) as *const libc::c_void,
                (((*sw).n as libc::c_long - p.offset_from((*sw).p) as libc::c_long)
                    as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<*mut case_t>() as libc::c_ulong),
            );
        } else {
            p = p.offset(1);
            p;
        }
    }
}
unsafe extern "C" fn gcase(
    mut base: *mut *mut case_t,
    mut len: libc::c_int,
    mut dsym: libc::c_int,
) -> libc::c_int {
    let mut p: *mut case_t = 0 as *mut case_t;
    let mut t: libc::c_int = 0;
    let mut l2: libc::c_int = 0;
    let mut e: libc::c_int = 0;
    t = (*vtop).type_0.t & 0xf as libc::c_int;
    if t != 4 as libc::c_int {
        t = 3 as libc::c_int;
    }
    while len != 0 {
        l2 = if len > 8 as libc::c_int {
            len / 2 as libc::c_int
        } else {
            0 as libc::c_int
        };
        p = *base.offset(l2 as isize);
        vdup();
        vpush64(t, (*p).v2 as libc::c_ulonglong);
        if l2 == 0 as libc::c_int && (*p).v1 == (*p).v2 {
            gen_op(0x94 as libc::c_int);
            gsym_addr(gvtst(0 as libc::c_int, 0 as libc::c_int), (*p).ind);
        } else {
            gen_op(0x9f as libc::c_int);
            if len == 1 as libc::c_int {
                dsym = gvtst(0 as libc::c_int, dsym);
                e = 0 as libc::c_int;
            } else {
                e = gvtst(0 as libc::c_int, 0 as libc::c_int);
            }
            vdup();
            vpush64(t, (*p).v1 as libc::c_ulonglong);
            gen_op(0x9d as libc::c_int);
            gsym_addr(gvtst(0 as libc::c_int, 0 as libc::c_int), (*p).ind);
            dsym = gcase(base, l2, dsym);
            gsym(e);
        }
        l2 += 1;
        l2;
        base = base.offset(l2 as isize);
        len -= l2;
    }
    return gjmp_acs(dsym);
}
unsafe extern "C" fn end_switch() {
    let mut sw: *mut switch_t = cur_switch;
    dynarray_reset(
        &mut (*sw).p as *mut *mut *mut case_t as *mut libc::c_void,
        &mut (*sw).n,
    );
    cur_switch = (*sw).prev;
    tcc_free(sw as *mut libc::c_void);
}
unsafe extern "C" fn try_call_scope_cleanup(mut stop: *mut Sym) {
    let mut cls: *mut Sym = (*cur_scope).cl.s;
    while cls != stop {
        let mut fs: *mut Sym = (*cls).c2rust_unnamed.cleanup_func;
        let mut vs: *mut Sym = (*cls).prev_tok;
        vpushsym(&mut (*fs).type_0, fs);
        vset(
            &mut (*vs).type_0,
            (*vs).r as libc::c_int,
            (*vs).c2rust_unnamed.c2rust_unnamed.c,
        );
        (*vtop).c2rust_unnamed_0.sym = vs;
        mk_pointer(&mut (*vtop).type_0);
        gaddrof();
        gfunc_call(1 as libc::c_int);
        cls = (*cls).c2rust_unnamed_0.next;
    }
}
unsafe extern "C" fn try_call_cleanup_goto(mut cleanupstate: *mut Sym) {
    let mut oc: *mut Sym = 0 as *mut Sym;
    let mut cc: *mut Sym = 0 as *mut Sym;
    let mut ocd: libc::c_int = 0;
    let mut ccd: libc::c_int = 0;
    if ((*cur_scope).cl.s).is_null() {
        return;
    }
    ocd = if !cleanupstate.is_null() {
        (*cleanupstate).v & !(0x20000000 as libc::c_int)
    } else {
        0 as libc::c_int
    };
    ccd = (*cur_scope).cl.n;
    oc = cleanupstate;
    while ocd > ccd {
        ocd -= 1;
        ocd;
        oc = (*oc).c2rust_unnamed_0.next;
    }
    cc = (*cur_scope).cl.s;
    while ccd > ocd {
        ccd -= 1;
        ccd;
        cc = (*cc).c2rust_unnamed_0.next;
    }
    while cc != oc {
        cc = (*cc).c2rust_unnamed_0.next;
        oc = (*oc).c2rust_unnamed_0.next;
        ccd -= 1;
        ccd;
    }
    try_call_scope_cleanup(cc);
}
unsafe extern "C" fn block_cleanup(mut o_0: *mut scope) {
    let mut jmp: libc::c_int = 0 as libc::c_int;
    let mut g_0: *mut Sym = 0 as *mut Sym;
    let mut pg: *mut *mut Sym = 0 as *mut *mut Sym;
    pg = &mut pending_gotos;
    loop {
        g_0 = *pg;
        if !(!g_0.is_null() && (*g_0).c2rust_unnamed.c2rust_unnamed.c > (*o_0).cl.n) {
            break;
        }
        let mut current_block_9: u64;
        if (*(*g_0).prev_tok).r as libc::c_int & 1 as libc::c_int != 0 {
            let mut pcl: *mut Sym = (*g_0).c2rust_unnamed_0.next;
            if jmp == 0 {
                jmp = gjmp_acs(0 as libc::c_int);
            }
            gsym((*pcl).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jnext);
            try_call_scope_cleanup((*o_0).cl.s);
            (*pcl)
                .c2rust_unnamed
                .c2rust_unnamed
                .c2rust_unnamed
                .jnext = gjmp_acs(0 as libc::c_int);
            if (*o_0).cl.n == 0 {
                current_block_9 = 10272739796701033666;
            } else {
                (*g_0).c2rust_unnamed.c2rust_unnamed.c = (*o_0).cl.n;
                pg = &mut (*g_0).prev;
                current_block_9 = 7651349459974463963;
            }
        } else {
            current_block_9 = 10272739796701033666;
        }
        match current_block_9 {
            10272739796701033666 => {
                *pg = (*g_0).prev;
                sym_free(g_0);
            }
            _ => {}
        }
    }
    gsym(jmp);
    try_call_scope_cleanup((*o_0).cl.s);
}
unsafe extern "C" fn vla_restore(mut loc_0: libc::c_int) {
    if loc_0 != 0 {
        gen_vla_sp_restore(loc_0);
    }
}
unsafe extern "C" fn vla_leave(mut o_0: *mut scope) {
    let mut c: *mut scope = cur_scope;
    let mut v: *mut scope = 0 as *mut scope;
    while c != o_0 && !c.is_null() {
        if (*c).vla.num != 0 {
            v = c;
        }
        c = (*c).prev;
    }
    if !v.is_null() {
        vla_restore((*v).vla.locorig);
    }
}
unsafe extern "C" fn new_scope(mut o_0: *mut scope) {
    *o_0 = *cur_scope;
    (*o_0).prev = cur_scope;
    cur_scope = o_0;
    (*cur_scope).vla.num = 0 as libc::c_int;
    (*o_0).lstk = local_stack;
    (*o_0).llstk = local_label_stack;
    local_scope += 1;
    local_scope;
}
unsafe extern "C" fn prev_scope(mut o_0: *mut scope, mut is_expr: libc::c_int) {
    vla_leave((*o_0).prev);
    if (*o_0).cl.s != (*(*o_0).prev).cl.s {
        block_cleanup((*o_0).prev);
    }
    label_pop(&mut local_label_stack, (*o_0).llstk, is_expr);
    pop_local_syms((*o_0).lstk, is_expr);
    cur_scope = (*o_0).prev;
    local_scope -= 1;
    local_scope;
}
unsafe extern "C" fn leave_scope(mut o_0: *mut scope) {
    if o_0.is_null() {
        return;
    }
    try_call_scope_cleanup((*o_0).cl.s);
    vla_leave(o_0);
}
unsafe extern "C" fn new_scope_s(mut o_0: *mut scope) {
    (*o_0).lstk = local_stack;
    local_scope += 1;
    local_scope;
}
unsafe extern "C" fn prev_scope_s(mut o_0: *mut scope) {
    sym_pop(&mut local_stack, (*o_0).lstk, 0 as libc::c_int);
    local_scope -= 1;
    local_scope;
}
unsafe extern "C" fn lblock(mut bsym: *mut libc::c_int, mut csym: *mut libc::c_int) {
    let mut lo: *mut scope = loop_scope;
    let mut co: *mut scope = cur_scope;
    let mut b: *mut libc::c_int = (*co).bsym;
    let mut c: *mut libc::c_int = (*co).csym;
    if !csym.is_null() {
        (*co).csym = csym;
        loop_scope = co;
    }
    (*co).bsym = bsym;
    block(0 as libc::c_int);
    (*co).bsym = b;
    if !csym.is_null() {
        (*co).csym = c;
        loop_scope = lo;
    }
}
unsafe extern "C" fn block(mut flags: libc::c_int) {
    let mut current_block: u64;
    let mut a: libc::c_int = 0;
    let mut b: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut d: libc::c_int = 0;
    let mut e: libc::c_int = 0;
    let mut t: libc::c_int = 0;
    let mut o_0: scope = scope {
        prev: 0 as *mut scope,
        vla: C2RustUnnamed_19 {
            loc: 0,
            locorig: 0,
            num: 0,
        },
        cl: C2RustUnnamed_20 {
            s: 0 as *mut Sym,
            n: 0,
        },
        bsym: 0 as *mut libc::c_int,
        csym: 0 as *mut libc::c_int,
        lstk: 0 as *mut Sym,
        llstk: 0 as *mut Sym,
    };
    let mut s: *mut Sym = 0 as *mut Sym;
    if flags & 1 as libc::c_int != 0 {
        vpushi(0 as libc::c_int);
        (*vtop).type_0.t = 0 as libc::c_int;
    }
    loop {
        t = tok;
        if t >= 0xc0 as libc::c_int && t <= 0xcf as libc::c_int {
            current_block = 9954010790613512735;
            break;
        }
        next();
        if debug_modes != 0 {
            tcc_tcov_check_line(tcc_state, 0 as libc::c_int);
            tcc_tcov_block_begin(tcc_state);
        }
        if t == TOK_IF as libc::c_int {
            new_scope_s(&mut o_0);
            skip('(' as i32);
            gexpr();
            skip(')' as i32);
            a = gvtst(1 as libc::c_int, 0 as libc::c_int);
            block(0 as libc::c_int);
            if tok == TOK_ELSE as libc::c_int {
                d = gjmp_acs(0 as libc::c_int);
                gsym(a);
                next();
                block(0 as libc::c_int);
                gsym(d);
            } else {
                gsym(a);
            }
            prev_scope_s(&mut o_0);
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_WHILE as libc::c_int {
            new_scope_s(&mut o_0);
            d = gind();
            skip('(' as i32);
            gexpr();
            skip(')' as i32);
            a = gvtst(1 as libc::c_int, 0 as libc::c_int);
            b = 0 as libc::c_int;
            lblock(&mut a, &mut b);
            gjmp_addr_acs(d);
            gsym_addr(b, d);
            gsym(a);
            prev_scope_s(&mut o_0);
            current_block = 2626552447423186229;
            break;
        } else if t == '{' as i32 {
            if debug_modes != 0 {
                tcc_debug_stabn(tcc_state, N_LBRAC as libc::c_int, ind - func_ind);
            }
            new_scope(&mut o_0);
            while tok == TOK_LABEL as libc::c_int {
                loop {
                    next();
                    if tok < TOK_DEFINE as libc::c_int {
                        expect(
                            b"label identifier\0" as *const u8 as *const libc::c_char,
                        );
                    }
                    label_push(&mut local_label_stack, tok, 2 as libc::c_int);
                    next();
                    if !(tok == ',' as i32) {
                        break;
                    }
                }
                skip(';' as i32);
            }
            while tok != '}' as i32 {
                decl(0x32 as libc::c_int);
                if tok != '}' as i32 {
                    if flags & 1 as libc::c_int != 0 {
                        vpop();
                    }
                    block(flags | 2 as libc::c_int);
                }
            }
            prev_scope(&mut o_0, flags & 1 as libc::c_int);
            if debug_modes != 0 {
                tcc_debug_stabn(tcc_state, N_RBRAC as libc::c_int, ind - func_ind);
            }
            if local_scope != 0 {
                next();
            } else if nocode_wanted == 0 {
                check_func_return();
            }
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_RETURN as libc::c_int {
            b = (func_vt.t & 0xf as libc::c_int != 0 as libc::c_int) as libc::c_int;
            if tok != ';' as i32 {
                gexpr();
                if b != 0 {
                    gen_assign_cast(&mut func_vt);
                } else {
                    if (*vtop).type_0.t != 0 as libc::c_int {
                        _tcc_warning(
                            b"void function returns a value\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    vtop = vtop.offset(-1);
                    vtop;
                }
            } else if b != 0 {
                _tcc_warning(
                    b"'return' with no value\0" as *const u8 as *const libc::c_char,
                );
                b = 0 as libc::c_int;
            }
            leave_scope(root_scope);
            if b != 0 {
                gfunc_return(&mut func_vt);
            }
            skip(';' as i32);
            if tok != '}' as i32 || local_scope != 1 as libc::c_int {
                rsym = gjmp_acs(rsym);
            }
            if debug_modes != 0 {
                tcc_tcov_block_end(tcc_state, -(1 as libc::c_int));
            }
            if nocode_wanted == 0 {
                nocode_wanted |= 0x20000000 as libc::c_int;
            }
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_BREAK as libc::c_int {
            if ((*cur_scope).bsym).is_null() {
                _tcc_error(b"cannot break\0" as *const u8 as *const libc::c_char);
            }
            if !cur_switch.is_null() && (*cur_scope).bsym == (*cur_switch).bsym {
                leave_scope((*cur_switch).scope);
            } else {
                leave_scope(loop_scope);
            }
            *(*cur_scope).bsym = gjmp_acs(*(*cur_scope).bsym);
            skip(';' as i32);
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_CONTINUE as libc::c_int {
            if ((*cur_scope).csym).is_null() {
                _tcc_error(b"cannot continue\0" as *const u8 as *const libc::c_char);
            }
            leave_scope(loop_scope);
            *(*cur_scope).csym = gjmp_acs(*(*cur_scope).csym);
            skip(';' as i32);
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_FOR as libc::c_int {
            new_scope(&mut o_0);
            skip('(' as i32);
            if tok != ';' as i32 {
                if decl(0x34 as libc::c_int) == 0 {
                    gexpr();
                    vpop();
                }
            }
            skip(';' as i32);
            b = 0 as libc::c_int;
            a = b;
            d = gind();
            c = d;
            if tok != ';' as i32 {
                gexpr();
                a = gvtst(1 as libc::c_int, 0 as libc::c_int);
            }
            skip(';' as i32);
            if tok != ')' as i32 {
                e = gjmp_acs(0 as libc::c_int);
                d = gind();
                gexpr();
                vpop();
                gjmp_addr_acs(c);
                gsym(e);
            }
            skip(')' as i32);
            lblock(&mut a, &mut b);
            gjmp_addr_acs(d);
            gsym_addr(b, d);
            gsym(a);
            prev_scope(&mut o_0, 0 as libc::c_int);
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_DO as libc::c_int {
            new_scope_s(&mut o_0);
            b = 0 as libc::c_int;
            a = b;
            d = gind();
            lblock(&mut a, &mut b);
            gsym(b);
            skip(TOK_WHILE as libc::c_int);
            skip('(' as i32);
            gexpr();
            skip(')' as i32);
            skip(';' as i32);
            c = gvtst(0 as libc::c_int, 0 as libc::c_int);
            gsym_addr(c, d);
            gsym(a);
            prev_scope_s(&mut o_0);
            current_block = 2626552447423186229;
            break;
        } else if t == TOK_SWITCH as libc::c_int {
            let mut sw: *mut switch_t = 0 as *mut switch_t;
            sw = tcc_mallocz(::core::mem::size_of::<switch_t>() as libc::c_ulong)
                as *mut switch_t;
            (*sw).bsym = &mut a;
            (*sw).scope = cur_scope;
            (*sw).prev = cur_switch;
            (*sw).nocode_wanted = nocode_wanted;
            cur_switch = sw;
            new_scope_s(&mut o_0);
            skip('(' as i32);
            gexpr();
            skip(')' as i32);
            if is_integer_btype((*vtop).type_0.t & 0xf as libc::c_int) == 0 {
                _tcc_error(
                    b"switch value not an integer\0" as *const u8 as *const libc::c_char,
                );
            }
            let fresh160 = vtop;
            vtop = vtop.offset(-1);
            (*sw).sv = *fresh160;
            a = 0 as libc::c_int;
            b = gjmp_acs(0 as libc::c_int);
            lblock(&mut a, 0 as *mut libc::c_int);
            a = gjmp_acs(a);
            gsym(b);
            prev_scope_s(&mut o_0);
            if !((*sw).nocode_wanted != 0) {
                case_sort(sw);
                (*sw).bsym = 0 as *mut libc::c_int;
                vpushv(&mut (*sw).sv);
                gv(0x1 as libc::c_int);
                d = gcase((*sw).p, (*sw).n, 0 as libc::c_int);
                vpop();
                if (*sw).def_sym != 0 {
                    gsym_addr(d, (*sw).def_sym);
                } else {
                    gsym(d);
                }
            }
            gsym(a);
            end_switch();
            current_block = 2626552447423186229;
            break;
        } else {
            if t == TOK_CASE as libc::c_int {
                let mut cr: *mut case_t = 0 as *mut case_t;
                if cur_switch.is_null() {
                    expect(b"switch\0" as *const u8 as *const libc::c_char);
                }
                cr = tcc_malloc(::core::mem::size_of::<case_t>() as libc::c_ulong)
                    as *mut case_t;
                dynarray_add(
                    &mut (*cur_switch).p as *mut *mut *mut case_t as *mut libc::c_void,
                    &mut (*cur_switch).n,
                    cr as *mut libc::c_void,
                );
                t = (*cur_switch).sv.type_0.t;
                (*cr).v2 = value64(expr_const64() as uint64_t, t) as int64_t;
                (*cr).v1 = (*cr).v2;
                if tok == 0xa1 as libc::c_int && (*tcc_state).gnu_ext as libc::c_int != 0
                {
                    next();
                    (*cr).v2 = value64(expr_const64() as uint64_t, t) as int64_t;
                    if case_cmp((*cr).v2 as uint64_t, (*cr).v1 as uint64_t)
                        < 0 as libc::c_int
                    {
                        _tcc_warning(
                            b"empty case range\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
                if (*cur_switch).nocode_wanted == 0 {
                    (*cr).ind = gind();
                }
                (*cr).line = (*file).line_num;
                skip(':' as i32);
            } else if t == TOK_DEFAULT as libc::c_int {
                if cur_switch.is_null() {
                    expect(b"switch\0" as *const u8 as *const libc::c_char);
                }
                if (*cur_switch).def_sym != 0 {
                    _tcc_error(
                        b"too many 'default'\0" as *const u8 as *const libc::c_char,
                    );
                }
                (*cur_switch)
                    .def_sym = if (*cur_switch).nocode_wanted != 0 {
                    -(1 as libc::c_int)
                } else {
                    gind()
                };
                skip(':' as i32);
            } else if t == TOK_GOTO as libc::c_int {
                vla_restore((*cur_scope).vla.locorig);
                if tok == '*' as i32 && (*tcc_state).gnu_ext as libc::c_int != 0 {
                    next();
                    gexpr();
                    if (*vtop).type_0.t & 0xf as libc::c_int != 5 as libc::c_int {
                        expect(b"pointer\0" as *const u8 as *const libc::c_char);
                    }
                    ggoto();
                } else if tok >= TOK_DEFINE as libc::c_int {
                    s = label_find(tok);
                    if s.is_null() {
                        s = label_push(&mut global_label_stack, tok, 1 as libc::c_int);
                    } else if (*s).r as libc::c_int == 2 as libc::c_int {
                        (*s).r = 1 as libc::c_int as libc::c_ushort;
                    }
                    if (*s).r as libc::c_int & 1 as libc::c_int != 0 {
                        if !((*cur_scope).cl.s).is_null() && nocode_wanted == 0 {
                            sym_push2(
                                &mut pending_gotos,
                                0x20000000 as libc::c_int,
                                0 as libc::c_int,
                                (*cur_scope).cl.n,
                            );
                            (*pending_gotos).prev_tok = s;
                            s = sym_push2(
                                &mut (*s).c2rust_unnamed_0.next,
                                0x20000000 as libc::c_int,
                                0 as libc::c_int,
                                0 as libc::c_int,
                            );
                            (*pending_gotos).c2rust_unnamed_0.next = s;
                        }
                        (*s)
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .c2rust_unnamed
                            .jnext = gjmp_acs(
                            (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jnext,
                        );
                    } else {
                        try_call_cleanup_goto((*s).c2rust_unnamed_0.cleanupstate);
                        gjmp_addr_acs(
                            (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jind,
                        );
                    }
                    next();
                } else {
                    expect(b"label identifier\0" as *const u8 as *const libc::c_char);
                }
                skip(';' as i32);
                current_block = 2626552447423186229;
                break;
            } else if t == TOK_ASM1 as libc::c_int || t == TOK_ASM2 as libc::c_int
                || t == TOK_ASM3 as libc::c_int
            {
                asm_instr();
                current_block = 2626552447423186229;
                break;
            } else if tok == ':' as i32 && t >= TOK_DEFINE as libc::c_int {
                next();
                s = label_find(t);
                if !s.is_null() {
                    if (*s).r as libc::c_int == 0 as libc::c_int {
                        _tcc_error(
                            b"duplicate label '%s'\0" as *const u8
                                as *const libc::c_char,
                            get_tok_str((*s).v, 0 as *mut CValue),
                        );
                    }
                    (*s).r = 0 as libc::c_int as libc::c_ushort;
                    if !((*s).c2rust_unnamed_0.next).is_null() {
                        let mut pcl: *mut Sym = 0 as *mut Sym;
                        pcl = (*s).c2rust_unnamed_0.next;
                        while !pcl.is_null() {
                            gsym(
                                (*pcl).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jnext,
                            );
                            pcl = (*pcl).prev;
                        }
                        sym_pop(
                            &mut (*s).c2rust_unnamed_0.next,
                            0 as *mut Sym,
                            0 as libc::c_int,
                        );
                    } else {
                        gsym((*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jnext);
                    }
                } else {
                    s = label_push(&mut global_label_stack, t, 0 as libc::c_int);
                }
                (*s).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.jind = gind();
                (*s).c2rust_unnamed_0.cleanupstate = (*cur_scope).cl.s;
            } else if t != ';' as i32 {
                current_block = 16167632229894708628;
                break;
            } else {
                current_block = 2626552447423186229;
                break;
            }
            let mut ad_tmp: AttributeDef = AttributeDef {
                a: SymAttr {
                    aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                },
                f: FuncAttr {
                    func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
                },
                section: 0 as *mut Section,
                cleanup_func: 0 as *mut Sym,
                alias_target: 0,
                asm_label: 0,
                attr_mode: 0,
            };
            parse_attribute(&mut ad_tmp);
            if debug_modes != 0 {
                tcc_tcov_reset_ind(tcc_state);
            }
            vla_restore((*cur_scope).vla.loc);
            if tok != '}' as i32 {
                if !(0 as libc::c_int == flags & 2 as libc::c_int) {
                    current_block = 2626552447423186229;
                    break;
                }
            } else {
                (*tcc_state)
                    .warn_num = (&mut (*(0 as *mut TCCState)).warn_all
                    as *mut libc::c_uchar as size_t)
                    .wrapping_sub(
                        &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                            as size_t,
                    ) as libc::c_uchar;
                (Some(
                    _tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"deprecated use of label at end of compound statement\0"
                        as *const u8 as *const libc::c_char,
                );
                current_block = 2626552447423186229;
                break;
            }
        }
    }
    match current_block {
        16167632229894708628 => {
            unget_tok(t);
            current_block = 9954010790613512735;
        }
        _ => {}
    }
    match current_block {
        9954010790613512735 => {
            if flags & 1 as libc::c_int != 0 {
                vpop();
                gexpr();
            } else {
                gexpr();
                vpop();
            }
            skip(';' as i32);
        }
        _ => {}
    }
    if debug_modes != 0 {
        tcc_tcov_check_line(tcc_state, 0 as libc::c_int);
        tcc_tcov_block_end(tcc_state, 0 as libc::c_int);
    }
}
unsafe extern "C" fn skip_or_save_block(mut str: *mut *mut TokenString) {
    let mut braces: libc::c_int = (tok == '{' as i32) as libc::c_int;
    let mut level: libc::c_int = 0 as libc::c_int;
    if !str.is_null() {
        *str = tok_str_alloc();
    }
    loop {
        let mut t: libc::c_int = tok;
        if level == 0 as libc::c_int
            && (t == ',' as i32 || t == ';' as i32 || t == '}' as i32 || t == ')' as i32
                || t == ']' as i32)
        {
            break;
        }
        if t == -(1 as libc::c_int) {
            if !(!str.is_null() || level > 0 as libc::c_int) {
                break;
            }
            _tcc_error(b"unexpected end of file\0" as *const u8 as *const libc::c_char);
        } else {
            if !str.is_null() {
                tok_str_add_tok(*str);
            }
            next();
            if t == '{' as i32 || t == '(' as i32 || t == '[' as i32 {
                level += 1;
                level;
            } else {
                if !(t == '}' as i32 || t == ')' as i32 || t == ']' as i32) {
                    continue;
                }
                level -= 1;
                level;
                if level == 0 as libc::c_int && braces != 0 && t == '}' as i32 {
                    break;
                }
            }
        }
    }
    if !str.is_null() {
        tok_str_add(*str, -(1 as libc::c_int));
    }
}
unsafe extern "C" fn parse_init_elem(mut expr_type_0: libc::c_int) {
    let mut saved_global_expr: libc::c_int = 0;
    match expr_type_0 {
        1 => {
            saved_global_expr = global_expr;
            global_expr = 1 as libc::c_int;
            expr_const1();
            global_expr = saved_global_expr;
            if (*vtop).r as libc::c_int & (0x3f as libc::c_int | 0x100 as libc::c_int)
                != 0x30 as libc::c_int
                && ((*vtop).r as libc::c_int
                    & (0x200 as libc::c_int | 0x100 as libc::c_int)
                    != 0x200 as libc::c_int | 0x100 as libc::c_int
                    || (*(*vtop).c2rust_unnamed_0.sym).v < 0x10000000 as libc::c_int)
            {
                _tcc_error(
                    b"initializer element is not constant\0" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        2 => {
            expr_eq();
        }
        _ => {}
    };
}
unsafe extern "C" fn init_assert(mut p: *mut init_params, mut offset: libc::c_int) {
    if if !((*p).sec).is_null() {
        (!(nocode_wanted > 0 as libc::c_int)
            && offset as libc::c_ulong > (*(*p).sec).data_offset) as libc::c_int
    } else {
        (nocode_wanted == 0 && offset > (*p).local_offset) as libc::c_int
    } != 0
    {
        _tcc_error(
            b"internal compiler error in %s:%d: %s\0" as *const u8
                as *const libc::c_char,
            (*::core::mem::transmute::<&[u8; 12], &[libc::c_char; 12]>(b"init_assert\0"))
                .as_ptr(),
            7444 as libc::c_int,
            b"initializer overflow\0" as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn init_putz(
    mut p: *mut init_params,
    mut c: libc::c_ulong,
    mut size: libc::c_int,
) {
    init_assert(p, c.wrapping_add(size as libc::c_ulong) as libc::c_int);
    if ((*p).sec).is_null() {
        vpush_helper_func(TOK_memset as libc::c_int);
        vseti(0x32 as libc::c_int, c as libc::c_int);
        vpushi(0 as libc::c_int);
        vpushs(size as Elf64_Addr);
        gfunc_call(3 as libc::c_int);
    }
}
unsafe extern "C" fn decl_design_delrels(
    mut sec: *mut Section,
    mut c: libc::c_int,
    mut size: libc::c_int,
) {
    let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut rel2: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    let mut rel_end: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
    if sec.is_null() || ((*sec).reloc).is_null() {
        return;
    }
    rel2 = (*(*sec).reloc).data as *mut Elf64_Rela;
    rel = rel2;
    rel_end = ((*(*sec).reloc).data).offset((*(*sec).reloc).data_offset as isize)
        as *mut Elf64_Rela;
    while rel < rel_end {
        if (*rel).r_offset >= c as Elf64_Addr
            && (*rel).r_offset < (c + size) as Elf64_Addr
        {
            (*(*sec).reloc)
                .data_offset = ((*(*sec).reloc).data_offset)
                .wrapping_sub(::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong);
        } else {
            if rel2 != rel {
                memcpy(
                    rel2 as *mut libc::c_void,
                    rel as *const libc::c_void,
                    ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong,
                );
            }
            rel2 = rel2.offset(1);
            rel2;
        }
        rel = rel.offset(1);
        rel;
    }
}
unsafe extern "C" fn decl_design_flex(
    mut p: *mut init_params,
    mut ref_0: *mut Sym,
    mut index: libc::c_int,
) {
    if ref_0 == (*p).flex_array_ref {
        if index >= (*ref_0).c2rust_unnamed.c2rust_unnamed.c {
            (*ref_0).c2rust_unnamed.c2rust_unnamed.c = index + 1 as libc::c_int;
        }
    } else if (*ref_0).c2rust_unnamed.c2rust_unnamed.c < 0 as libc::c_int {
        _tcc_error(
            b"flexible array has zero size in this context\0" as *const u8
                as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn decl_designator(
    mut p: *mut init_params,
    mut type_0: *mut CType,
    mut c: libc::c_ulong,
    mut cur_field: *mut *mut Sym,
    mut flags: libc::c_int,
    mut al: libc::c_int,
) -> libc::c_int {
    let mut cumofs: libc::c_int = 0;
    let mut current_block: u64;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut f: *mut Sym = 0 as *mut Sym;
    let mut index: libc::c_int = 0;
    let mut index_last: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut l: libc::c_int = 0;
    let mut nb_elems: libc::c_int = 0;
    let mut elem_size: libc::c_int = 0;
    let mut corig: libc::c_ulong = c;
    elem_size = 0 as libc::c_int;
    nb_elems = 1 as libc::c_int;
    if flags & 4 as libc::c_int != 0 {
        current_block = 9538940317606650501;
    } else {
        if (*tcc_state).gnu_ext as libc::c_int != 0 && tok >= TOK_DEFINE as libc::c_int {
            l = tok;
            next();
            if tok == ':' as i32 {
                current_block = 7751678771023401011;
            } else {
                unget_tok(l);
                current_block = 10879442775620481940;
            }
        } else {
            current_block = 10879442775620481940;
        }
        loop {
            match current_block {
                10879442775620481940 => {
                    if !(nb_elems == 1 as libc::c_int
                        && (tok == '[' as i32 || tok == '.' as i32))
                    {
                        break;
                    }
                    if tok == '[' as i32 {
                        if (*type_0).t & 0x40 as libc::c_int == 0 {
                            expect(b"array type\0" as *const u8 as *const libc::c_char);
                        }
                        next();
                        index_last = expr_const();
                        index = index_last;
                        if tok == 0xa1 as libc::c_int
                            && (*tcc_state).gnu_ext as libc::c_int != 0
                        {
                            next();
                            index_last = expr_const();
                        }
                        skip(']' as i32);
                        s = (*type_0).ref_0;
                        decl_design_flex(p, s, index_last);
                        if index < 0 as libc::c_int
                            || index_last >= (*s).c2rust_unnamed.c2rust_unnamed.c
                            || index_last < index
                        {
                            _tcc_error(
                                b"index exceeds array bounds or range is empty\0"
                                    as *const u8 as *const libc::c_char,
                            );
                        }
                        if !cur_field.is_null() {
                            (**cur_field).c2rust_unnamed.c2rust_unnamed.c = index_last;
                        }
                        type_0 = pointed_type(type_0);
                        elem_size = type_size(type_0, &mut align);
                        c = c.wrapping_add((index * elem_size) as libc::c_ulong);
                        nb_elems = index_last - index + 1 as libc::c_int;
                    } else {
                        cumofs = 0;
                        next();
                        l = tok;
                        current_block = 7751678771023401011;
                        continue;
                    }
                }
                _ => {
                    next();
                    f = find_field(type_0, l, &mut cumofs);
                    if !cur_field.is_null() {
                        *cur_field = f;
                    }
                    type_0 = &mut (*f).type_0;
                    c = c.wrapping_add(cumofs as libc::c_ulong);
                }
            }
            cur_field = 0 as *mut *mut Sym;
            current_block = 10879442775620481940;
        }
        if cur_field.is_null() {
            if tok == '=' as i32 {
                next();
            } else if (*tcc_state).gnu_ext == 0 {
                expect(b"=\0" as *const u8 as *const libc::c_char);
            }
            current_block = 14945149239039849694;
        } else {
            current_block = 9538940317606650501;
        }
    }
    match current_block {
        9538940317606650501 => {
            if (*type_0).t & 0x40 as libc::c_int != 0 {
                index = (**cur_field).c2rust_unnamed.c2rust_unnamed.c;
                s = (*type_0).ref_0;
                decl_design_flex(p, s, index);
                if index >= (*s).c2rust_unnamed.c2rust_unnamed.c {
                    _tcc_error(
                        b"too many initializers\0" as *const u8 as *const libc::c_char,
                    );
                }
                type_0 = pointed_type(type_0);
                elem_size = type_size(type_0, &mut align);
                c = c.wrapping_add((index * elem_size) as libc::c_ulong);
            } else {
                f = *cur_field;
                while !f.is_null() && (*f).v & 0x10000000 as libc::c_int != 0
                    && is_integer_btype((*f).type_0.t & 0xf as libc::c_int) != 0
                {
                    f = (*f).c2rust_unnamed_0.next;
                    *cur_field = f;
                }
                if f.is_null() {
                    _tcc_error(
                        b"too many initializers\0" as *const u8 as *const libc::c_char,
                    );
                }
                type_0 = &mut (*f).type_0;
                c = c
                    .wrapping_add((*f).c2rust_unnamed.c2rust_unnamed.c as libc::c_ulong);
            }
        }
        _ => {}
    }
    if elem_size == 0 {
        elem_size = type_size(type_0, &mut align);
    }
    if flags & 2 as libc::c_int == 0 && c.wrapping_sub(corig) < al as libc::c_ulong {
        decl_design_delrels((*p).sec, c as libc::c_int, elem_size * nb_elems);
        flags &= !(8 as libc::c_int);
    }
    decl_initializer(p, type_0, c, flags & !(1 as libc::c_int));
    if flags & 2 as libc::c_int == 0 && nb_elems > 1 as libc::c_int {
        let mut aref: Sym = {
            let mut init = Sym {
                v: 0 as libc::c_int,
                r: 0,
                a: SymAttr {
                    aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
                },
                c2rust_unnamed: C2RustUnnamed_6 {
                    c2rust_unnamed: C2RustUnnamed_7 {
                        c: 0,
                        c2rust_unnamed: C2RustUnnamed_8 { sym_scope: 0 },
                    },
                },
                type_0: CType {
                    t: 0,
                    ref_0: 0 as *mut Sym,
                },
                c2rust_unnamed_0: C2RustUnnamed_5 {
                    next: 0 as *mut Sym,
                },
                prev: 0 as *mut Sym,
                prev_tok: 0 as *mut Sym,
            };
            init
        };
        let mut t1: CType = CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        };
        let mut i: libc::c_int = 0;
        if !((*p).sec).is_null() || (*type_0).t & 0x40 as libc::c_int != 0 {
            aref.c2rust_unnamed.c2rust_unnamed.c = elem_size;
            t1.t = 7 as libc::c_int;
            t1.ref_0 = &mut aref;
            type_0 = &mut t1;
        }
        if !((*p).sec).is_null() {
            vpush_ref(type_0, (*p).sec, c, elem_size as libc::c_ulong);
        } else {
            vset(type_0, 0x32 as libc::c_int | 0x100 as libc::c_int, c as libc::c_int);
        }
        i = 1 as libc::c_int;
        while i < nb_elems {
            vdup();
            init_putv(p, type_0, c.wrapping_add((elem_size * i) as libc::c_ulong));
            i += 1;
            i;
        }
        vpop();
    }
    c = c.wrapping_add((nb_elems * elem_size) as libc::c_ulong);
    if c.wrapping_sub(corig) > al as libc::c_ulong {
        al = c.wrapping_sub(corig) as libc::c_int;
    }
    return al;
}
unsafe extern "C" fn init_putv(
    mut p: *mut init_params,
    mut type_0: *mut CType,
    mut c: libc::c_ulong,
) {
    let mut bt: libc::c_int = 0;
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut dtype: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut sec: *mut Section = (*p).sec;
    let mut val: uint64_t = 0;
    dtype = *type_0;
    dtype.t &= !(0x100 as libc::c_int);
    size = type_size(type_0, &mut align);
    if (*type_0).t & 0x80 as libc::c_int != 0 {
        size = (((*type_0).t >> 20 as libc::c_int & 0x3f as libc::c_int)
            + ((*type_0).t >> 20 as libc::c_int + 6 as libc::c_int & 0x3f as libc::c_int)
            + 7 as libc::c_int) / 8 as libc::c_int;
    }
    init_assert(p, c.wrapping_add(size as libc::c_ulong) as libc::c_int);
    if !sec.is_null() {
        gen_assign_cast(&mut dtype);
        bt = (*type_0).t & 0xf as libc::c_int;
        if (*vtop).r as libc::c_int & 0x200 as libc::c_int != 0 && bt != 5 as libc::c_int
            && (bt
                != (if 8 as libc::c_int == 8 as libc::c_int {
                    4 as libc::c_int
                } else {
                    3 as libc::c_int
                }) || (*type_0).t & 0x80 as libc::c_int != 0)
            && !((*vtop).r as libc::c_int & 0x30 as libc::c_int != 0
                && (*(*vtop).c2rust_unnamed_0.sym).v >= 0x10000000 as libc::c_int)
        {
            _tcc_error(
                b"initializer element is not computable at load time\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if nocode_wanted > 0 as libc::c_int {
            vtop = vtop.offset(-1);
            vtop;
            return;
        }
        ptr = ((*sec).data).offset(c as isize) as *mut libc::c_void;
        val = (*vtop).c2rust_unnamed.c.i;
        if (*vtop).r as libc::c_int & (0x200 as libc::c_int | 0x30 as libc::c_int)
            == 0x200 as libc::c_int | 0x30 as libc::c_int
            && (*(*vtop).c2rust_unnamed_0.sym).v >= 0x10000000 as libc::c_int
            && (*vtop).type_0.t & 0xf as libc::c_int != 5 as libc::c_int
        {
            let mut ssec: *mut Section = 0 as *mut Section;
            let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
            let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
            esym = elfsym((*vtop).c2rust_unnamed_0.sym);
            ssec = *((*tcc_state).sections).offset((*esym).st_shndx as isize);
            memmove(
                ptr,
                ((*ssec).data)
                    .offset((*esym).st_value as isize)
                    .offset((*vtop).c2rust_unnamed.c.i as libc::c_int as isize)
                    as *const libc::c_void,
                size as libc::c_ulong,
            );
            if !((*ssec).reloc).is_null() {
                let mut relofs: libc::c_ulong = (*(*ssec).reloc).data_offset;
                while relofs >= ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong {
                    relofs = relofs
                        .wrapping_sub(
                            ::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong,
                        );
                    rel = ((*(*ssec).reloc).data).offset(relofs as isize)
                        as *mut Elf64_Rela;
                    if (*rel).r_offset
                        >= ((*esym).st_value).wrapping_add(size as Elf64_Addr)
                    {
                        continue;
                    }
                    if (*rel).r_offset < (*esym).st_value {
                        break;
                    }
                    put_elf_reloca(
                        (*tcc_state).c2rust_unnamed.symtab_section,
                        sec,
                        c.wrapping_add((*rel).r_offset).wrapping_sub((*esym).st_value),
                        ((*rel).r_info & 0xffffffff as libc::c_uint as Elf64_Xword)
                            as libc::c_int,
                        ((*rel).r_info >> 32 as libc::c_int) as libc::c_int,
                        (*rel).r_addend as Elf64_Addr,
                    );
                }
            }
        } else if (*type_0).t & 0x80 as libc::c_int != 0 {
            let mut bit_pos: libc::c_int = 0;
            let mut bit_size: libc::c_int = 0;
            let mut bits: libc::c_int = 0;
            let mut n: libc::c_int = 0;
            let mut p_0: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            let mut v: libc::c_uchar = 0;
            let mut m: libc::c_uchar = 0;
            bit_pos = (*vtop).type_0.t >> 20 as libc::c_int & 0x3f as libc::c_int;
            bit_size = (*vtop).type_0.t >> 20 as libc::c_int + 6 as libc::c_int
                & 0x3f as libc::c_int;
            p_0 = (ptr as *mut libc::c_uchar)
                .offset((bit_pos >> 3 as libc::c_int) as isize);
            bit_pos &= 7 as libc::c_int;
            bits = 0 as libc::c_int;
            while bit_size != 0 {
                n = 8 as libc::c_int - bit_pos;
                if n > bit_size {
                    n = bit_size;
                }
                v = (val >> bits << bit_pos) as libc::c_uchar;
                m = ((((1 as libc::c_int) << n) - 1 as libc::c_int) << bit_pos)
                    as libc::c_uchar;
                *p_0 = (*p_0 as libc::c_int & !(m as libc::c_int)
                    | v as libc::c_int & m as libc::c_int) as libc::c_uchar;
                bits += n;
                bit_size -= n;
                bit_pos = 0 as libc::c_int;
                p_0 = p_0.offset(1);
                p_0;
            }
        } else {
            match bt {
                11 => {
                    *(ptr
                        as *mut libc::c_char) = (val != 0 as libc::c_int as uint64_t)
                        as libc::c_int as libc::c_char;
                }
                1 => {
                    *(ptr as *mut libc::c_char) = val as libc::c_char;
                }
                2 => {
                    write16le(ptr as *mut libc::c_uchar, val as uint16_t);
                }
                8 => {
                    write32le(ptr as *mut libc::c_uchar, val as uint32_t);
                }
                9 => {
                    write64le(ptr as *mut libc::c_uchar, val);
                }
                10 => {
                    if ::core::mem::size_of::<f128::f128>() as libc::c_ulong
                        >= 10 as libc::c_int as libc::c_ulong
                    {
                        memcpy(
                            ptr,
                            &mut (*vtop).c2rust_unnamed.c.ld as *mut f128::f128
                                as *const libc::c_void,
                            10 as libc::c_int as libc::c_ulong,
                        );
                    } else if ::core::mem::size_of::<f128::f128>() as libc::c_ulong
                        == 16 as libc::c_int as libc::c_ulong
                    {
                        memcpy(
                            ptr,
                            &mut (*vtop).c2rust_unnamed.c.ld as *mut f128::f128
                                as *const libc::c_void,
                            16 as libc::c_int as libc::c_ulong,
                        );
                    } else if ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
                        == 16 as libc::c_int as libc::c_ulong
                    {
                        *(ptr
                            as *mut libc::c_double) = ((*vtop).c2rust_unnamed.c.ld)
                            .to_f64()
                            .unwrap();
                    } else if 0 as libc::c_int
                        == memcmp(
                            ptr,
                            &mut (*vtop).c2rust_unnamed.c.ld as *mut f128::f128
                                as *const libc::c_void,
                            16 as libc::c_int as libc::c_ulong,
                        )
                    {} else {
                        _tcc_error(
                            b"can't cross compile long double constants\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
                4 | 5 => {
                    if (*vtop).r as libc::c_int & 0x200 as libc::c_int != 0 {
                        greloca(
                            sec,
                            (*vtop).c2rust_unnamed_0.sym,
                            c,
                            1 as libc::c_int,
                            val,
                        );
                    } else {
                        write64le(ptr as *mut libc::c_uchar, val);
                    }
                }
                3 => {
                    write32le(ptr as *mut libc::c_uchar, val as uint32_t);
                }
                _ => {}
            }
        }
        vtop = vtop.offset(-1);
        vtop;
    } else {
        vset(&mut dtype, 0x32 as libc::c_int | 0x100 as libc::c_int, c as libc::c_int);
        vswap();
        vstore();
        vpop();
    };
}
unsafe extern "C" fn decl_initializer(
    mut p: *mut init_params,
    mut type_0: *mut CType,
    mut c: libc::c_ulong,
    mut flags: libc::c_int,
) {
    let mut len: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut no_oblock: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut size1: libc::c_int = 0;
    let mut align1: libc::c_int = 0;
    let mut s: *mut Sym = 0 as *mut Sym;
    let mut f: *mut Sym = 0 as *mut Sym;
    let mut indexsym: Sym = Sym {
        v: 0,
        r: 0,
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        c2rust_unnamed: C2RustUnnamed_6 {
            c2rust_unnamed: C2RustUnnamed_7 {
                c: 0,
                c2rust_unnamed: C2RustUnnamed_8 { sym_scope: 0 },
            },
        },
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        c2rust_unnamed_0: C2RustUnnamed_5 {
            next: 0 as *mut Sym,
        },
        prev: 0 as *mut Sym,
        prev_tok: 0 as *mut Sym,
    };
    let mut t1: *mut CType = 0 as *mut CType;
    if debug_modes as libc::c_int != 0 && flags & 2 as libc::c_int == 0
        && ((*p).sec).is_null()
    {
        tcc_debug_line(tcc_state);
        tcc_tcov_check_line(tcc_state, 1 as libc::c_int);
    }
    if flags & 4 as libc::c_int == 0 && tok != '{' as i32 && tok != 0xc9 as libc::c_int
        && tok != 0xc8 as libc::c_int
        && (flags & 2 as libc::c_int == 0
            || (*type_0).t & 0xf as libc::c_int == 7 as libc::c_int)
    {
        let mut ncw_prev: libc::c_int = nocode_wanted;
        if flags & 2 as libc::c_int != 0 && ((*p).sec).is_null() {
            nocode_wanted += 1;
            nocode_wanted;
        }
        parse_init_elem(
            if ((*p).sec).is_null() { 2 as libc::c_int } else { 1 as libc::c_int },
        );
        nocode_wanted = ncw_prev;
        flags |= 4 as libc::c_int;
    }
    let mut current_block_103: u64;
    if (*type_0).t & 0x40 as libc::c_int != 0 {
        no_oblock = 1 as libc::c_int;
        if flags & 1 as libc::c_int != 0 && tok != 0xc9 as libc::c_int
            && tok != 0xc8 as libc::c_int || tok == '{' as i32
        {
            skip('{' as i32);
            no_oblock = 0 as libc::c_int;
        }
        s = (*type_0).ref_0;
        n = (*s).c2rust_unnamed.c2rust_unnamed.c;
        t1 = pointed_type(type_0);
        size1 = type_size(t1, &mut align1);
        if tok == 0xc9 as libc::c_int && (*t1).t & 0xf as libc::c_int == 3 as libc::c_int
            || tok == 0xc8 as libc::c_int
                && (*t1).t & 0xf as libc::c_int == 1 as libc::c_int
        {
            len = 0 as libc::c_int;
            cstr_reset(&mut initstr);
            if size1 as libc::c_ulong
                != (if tok == 0xc8 as libc::c_int {
                    1 as libc::c_int as libc::c_ulong
                } else {
                    ::core::mem::size_of::<nwchar_t>() as libc::c_ulong
                })
            {
                _tcc_error(
                    b"unhandled string literal merging\0" as *const u8
                        as *const libc::c_char,
                );
            }
            while tok == 0xc8 as libc::c_int || tok == 0xc9 as libc::c_int {
                if initstr.size != 0 {
                    initstr.size -= size1;
                }
                if tok == 0xc8 as libc::c_int {
                    len += tokc.str_0.size;
                } else {
                    len = (len as libc::c_ulong)
                        .wrapping_add(
                            (tokc.str_0.size as libc::c_ulong)
                                .wrapping_div(
                                    ::core::mem::size_of::<nwchar_t>() as libc::c_ulong,
                                ),
                        ) as libc::c_int as libc::c_int;
                }
                len -= 1;
                len;
                cstr_cat(&mut initstr, tokc.str_0.data, tokc.str_0.size);
                next();
            }
            if tok != ')' as i32 && tok != '}' as i32 && tok != ',' as i32
                && tok != ';' as i32 && tok != -(1 as libc::c_int)
            {
                unget_tok(
                    if size1 == 1 as libc::c_int {
                        0xc8 as libc::c_int
                    } else {
                        0xc9 as libc::c_int
                    },
                );
                tokc.str_0.size = initstr.size;
                tokc.str_0.data = initstr.data;
                current_block_103 = 8490579822618541675;
            } else {
                decl_design_flex(p, s, len);
                if flags & 2 as libc::c_int == 0 {
                    let mut nb: libc::c_int = n;
                    let mut ch: libc::c_int = 0;
                    if len < nb {
                        nb = len;
                    }
                    if len > nb {
                        _tcc_warning(
                            b"initializer-string for array is too long\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    if !((*p).sec).is_null() && size1 == 1 as libc::c_int {
                        init_assert(
                            p,
                            c.wrapping_add(nb as libc::c_ulong) as libc::c_int,
                        );
                        if !(nocode_wanted > 0 as libc::c_int) {
                            memcpy(
                                ((*(*p).sec).data).offset(c as isize) as *mut libc::c_void,
                                initstr.data as *const libc::c_void,
                                nb as libc::c_ulong,
                            );
                        }
                    } else {
                        i = 0 as libc::c_int;
                        while i < n {
                            if i >= nb {
                                if flags & 8 as libc::c_int != 0 {
                                    break;
                                }
                                if n - i >= 4 as libc::c_int {
                                    init_putz(
                                        p,
                                        c.wrapping_add((i * size1) as libc::c_ulong),
                                        (n - i) * size1,
                                    );
                                    break;
                                } else {
                                    ch = 0 as libc::c_int;
                                }
                            } else if size1 == 1 as libc::c_int {
                                ch = *(initstr.data as *mut libc::c_uchar)
                                    .offset(i as isize) as libc::c_int;
                            } else {
                                ch = *(initstr.data as *mut nwchar_t).offset(i as isize);
                            }
                            vpushi(ch);
                            init_putv(
                                p,
                                t1,
                                c.wrapping_add((i * size1) as libc::c_ulong),
                            );
                            i += 1;
                            i;
                        }
                    }
                }
                current_block_103 = 777662472977924419;
            }
        } else {
            current_block_103 = 8490579822618541675;
        }
        match current_block_103 {
            777662472977924419 => {}
            _ => {
                indexsym.c2rust_unnamed.c2rust_unnamed.c = 0 as libc::c_int;
                f = &mut indexsym;
                current_block_103 = 6439216900957145757;
            }
        }
    } else {
        if flags & 4 as libc::c_int != 0
            && is_compatible_unqualified_types(type_0, &mut (*vtop).type_0) != 0
        {
            current_block_103 = 11241624997877111895;
        } else if (*type_0).t & 0xf as libc::c_int == 7 as libc::c_int {
            no_oblock = 1 as libc::c_int;
            if flags & 1 as libc::c_int != 0 || tok == '{' as i32 {
                skip('{' as i32);
                no_oblock = 0 as libc::c_int;
            }
            s = (*type_0).ref_0;
            f = (*s).c2rust_unnamed_0.next;
            n = (*s).c2rust_unnamed.c2rust_unnamed.c;
            size1 = 1 as libc::c_int;
            current_block_103 = 6439216900957145757;
        } else if tok == '{' as i32 {
            if flags & 4 as libc::c_int != 0 {
                skip(';' as i32);
            }
            next();
            decl_initializer(p, type_0, c, flags & !(4 as libc::c_int));
            skip('}' as i32);
            current_block_103 = 796174441944384681;
        } else {
            current_block_103 = 11241624997877111895;
        }
        match current_block_103 {
            6439216900957145757 => {}
            796174441944384681 => {}
            _ => {
                if flags & 2 as libc::c_int != 0 {
                    if flags & 4 as libc::c_int != 0 {
                        vpop();
                    } else {
                        skip_or_save_block(0 as *mut *mut TokenString);
                    }
                } else {
                    if flags & 4 as libc::c_int == 0 {
                        if tok != 0xc8 as libc::c_int && tok != 0xc9 as libc::c_int {
                            expect(
                                b"string constant\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        parse_init_elem(
                            if ((*p).sec).is_null() {
                                2 as libc::c_int
                            } else {
                                1 as libc::c_int
                            },
                        );
                    }
                    if ((*p).sec).is_null() && flags & 8 as libc::c_int != 0
                        && (*vtop).r as libc::c_int
                            & (0x3f as libc::c_int | 0x100 as libc::c_int
                                | 0x200 as libc::c_int) == 0x30 as libc::c_int
                        && (*vtop).c2rust_unnamed.c.i == 0 as libc::c_int as uint64_t
                        && btype_size((*type_0).t & 0xf as libc::c_int) != 0
                    {
                        vpop();
                    } else {
                        init_putv(p, type_0, c);
                    }
                }
                current_block_103 = 796174441944384681;
            }
        }
    }
    match current_block_103 {
        6439216900957145757 => {
            if flags & (8 as libc::c_int | 2 as libc::c_int) == 0 {
                init_putz(p, c, n * size1);
                flags |= 8 as libc::c_int;
            }
            len = 0 as libc::c_int;
            decl_design_flex(p, s, len);
            while tok != '}' as i32 || flags & 4 as libc::c_int != 0 {
                len = decl_designator(p, type_0, c, &mut f, flags, len);
                flags &= !(4 as libc::c_int);
                if (*type_0).t & 0x40 as libc::c_int != 0 {
                    indexsym.c2rust_unnamed.c2rust_unnamed.c += 1;
                    indexsym.c2rust_unnamed.c2rust_unnamed.c;
                    if no_oblock != 0 && len >= n * size1 {
                        break;
                    }
                } else {
                    if (*s).type_0.t
                        == (1 as libc::c_int) << 20 as libc::c_int | 7 as libc::c_int
                    {
                        f = 0 as *mut Sym;
                    } else {
                        f = (*f).c2rust_unnamed_0.next;
                    }
                    if no_oblock != 0 && f.is_null() {
                        break;
                    }
                }
                if tok == '}' as i32 {
                    break;
                }
                skip(',' as i32);
            }
            current_block_103 = 777662472977924419;
        }
        _ => {}
    }
    match current_block_103 {
        777662472977924419 => {
            if no_oblock == 0 {
                skip('}' as i32);
            }
        }
        _ => {}
    };
}
unsafe extern "C" fn decl_initializer_alloc(
    mut type_0: *mut CType,
    mut ad: *mut AttributeDef,
    mut r: libc::c_int,
    mut has_init: libc::c_int,
    mut v: libc::c_int,
    mut global: libc::c_int,
) {
    let mut current_block: u64;
    let mut size: libc::c_int = 0;
    let mut align: libc::c_int = 0;
    let mut addr: libc::c_int = 0;
    let mut init_str: *mut TokenString = 0 as *mut TokenString;
    let mut sec: *mut Section = 0 as *mut Section;
    let mut flexible_array: *mut Sym = 0 as *mut Sym;
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut saved_nocode_wanted: libc::c_int = nocode_wanted;
    let mut bcheck: libc::c_int = ((*tcc_state).do_bounds_check as libc::c_int != 0
        && !(nocode_wanted > 0 as libc::c_int)) as libc::c_int;
    let mut p: init_params = {
        let mut init = init_params {
            sec: 0 as *mut Section,
            local_offset: 0,
            flex_array_ref: 0 as *mut Sym,
        };
        init
    };
    if v != 0 && r & 0x3f as libc::c_int == 0x30 as libc::c_int {
        nocode_wanted = (nocode_wanted as libc::c_uint | 0x80000000 as libc::c_uint)
            as libc::c_int;
    }
    flexible_array = 0 as *mut Sym;
    size = type_size(type_0, &mut align);
    if size < 0 as libc::c_int {
        if (*type_0).t & 0x40 as libc::c_int == 0 {
            _tcc_error(
                b"initialization of incomplete type\0" as *const u8
                    as *const libc::c_char,
            );
        }
        (*type_0)
            .ref_0 = sym_push(
            0x20000000 as libc::c_int,
            &mut (*(*type_0).ref_0).type_0,
            0 as libc::c_int,
            (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c,
        );
        p.flex_array_ref = (*type_0).ref_0;
    } else if has_init != 0 && (*type_0).t & 0xf as libc::c_int == 7 as libc::c_int {
        let mut field: *mut Sym = (*(*type_0).ref_0).c2rust_unnamed_0.next;
        if !field.is_null() {
            while !((*field).c2rust_unnamed_0.next).is_null() {
                field = (*field).c2rust_unnamed_0.next;
            }
            if (*field).type_0.t & 0x40 as libc::c_int != 0
                && (*(*field).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c
                    < 0 as libc::c_int
            {
                flexible_array = field;
                p.flex_array_ref = (*field).type_0.ref_0;
                size = -(1 as libc::c_int);
            }
        }
    }
    if size < 0 as libc::c_int {
        if has_init == 0 {
            _tcc_error(b"unknown type size\0" as *const u8 as *const libc::c_char);
        }
        if has_init == 2 as libc::c_int {
            init_str = tok_str_alloc();
            while tok == 0xc8 as libc::c_int || tok == 0xc9 as libc::c_int {
                tok_str_add_tok(init_str);
                next();
            }
            tok_str_add(init_str, -(1 as libc::c_int));
        } else {
            skip_or_save_block(&mut init_str);
        }
        unget_tok(0 as libc::c_int);
        begin_macro(init_str, 1 as libc::c_int);
        next();
        decl_initializer(
            &mut p,
            type_0,
            0 as libc::c_int as libc::c_ulong,
            1 as libc::c_int | 2 as libc::c_int,
        );
        macro_ptr = (*init_str).str_0;
        next();
        size = type_size(type_0, &mut align);
        if size < 0 as libc::c_int {
            _tcc_error(b"unknown type size\0" as *const u8 as *const libc::c_char);
        }
        if !flexible_array.is_null()
            && (*(*flexible_array).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c
                > 0 as libc::c_int
        {
            size
                += (*(*flexible_array).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c
                    * pointed_size(&mut (*flexible_array).type_0);
        }
    }
    if ((*ad).a).aligned() != 0 {
        let mut speca: libc::c_int = (1 as libc::c_int)
            << ((*ad).a).aligned() as libc::c_int - 1 as libc::c_int;
        if speca > align {
            align = speca;
        }
    } else if ((*ad).a).packed() != 0 {
        align = 1 as libc::c_int;
    }
    if v == 0 && nocode_wanted > 0 as libc::c_int {
        size = 0 as libc::c_int;
        align = 1 as libc::c_int;
    }
    if r & 0x3f as libc::c_int == 0x32 as libc::c_int {
        sec = 0 as *mut Section;
        if bcheck != 0 && v != 0 {
            loc -= align;
        }
        loc = loc - size & -align;
        addr = loc;
        p.local_offset = addr + size;
        if bcheck != 0 && v != 0 {
            loc -= align;
        }
        if v != 0 {
            if (*ad).asm_label != 0 {
                let mut reg: libc::c_int = asm_parse_regvar((*ad).asm_label);
                if reg >= 0 as libc::c_int {
                    r = r & !(0x3f as libc::c_int) | reg;
                }
            }
            sym = sym_push(v, type_0, r, addr);
            if !((*ad).cleanup_func).is_null() {
                (*cur_scope).cl.n += 1;
                let mut cls: *mut Sym = sym_push2(
                    &mut all_cleanups,
                    0x20000000 as libc::c_int | (*cur_scope).cl.n,
                    0 as libc::c_int,
                    0 as libc::c_int,
                );
                (*cls).prev_tok = sym;
                (*cls).c2rust_unnamed.cleanup_func = (*ad).cleanup_func;
                (*cls).c2rust_unnamed_0.next = (*cur_scope).cl.s;
                (*cur_scope).cl.s = cls;
            }
            (*sym).a = (*ad).a;
        } else {
            vset(type_0, r, addr);
        }
        current_block = 3024367268842933116;
    } else {
        sym = 0 as *mut Sym;
        if v != 0 && global != 0 {
            sym = sym_find(v);
            if !sym.is_null() {
                if !(p.flex_array_ref).is_null()
                    && (*sym).type_0.t & (*type_0).t & 0x40 as libc::c_int != 0
                    && (*(*sym).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c
                        > (*(*type_0).ref_0).c2rust_unnamed.c2rust_unnamed.c
                {
                    (*(*type_0).ref_0)
                        .c2rust_unnamed
                        .c2rust_unnamed
                        .c = (*(*sym).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c;
                    size = type_size(type_0, &mut align);
                }
                patch_storage(sym, ad, type_0);
                if has_init == 0 && (*sym).c2rust_unnamed.c2rust_unnamed.c != 0
                    && (*elfsym(sym)).st_shndx as libc::c_int != 0 as libc::c_int
                {
                    current_block = 6159012361819358981;
                } else {
                    current_block = 17020603795727957434;
                }
            } else {
                current_block = 17020603795727957434;
            }
        } else {
            current_block = 17020603795727957434;
        }
        match current_block {
            6159012361819358981 => {}
            _ => {
                sec = (*ad).section;
                if sec.is_null() {
                    let mut tp: *mut CType = type_0;
                    while (*tp).t & (0xf as libc::c_int | 0x40 as libc::c_int)
                        == 5 as libc::c_int | 0x40 as libc::c_int
                    {
                        tp = &mut (*(*tp).ref_0).type_0;
                    }
                    if (*tp).t & 0x100 as libc::c_int != 0 {
                        sec = (*tcc_state).rodata_section;
                    } else if has_init != 0 {
                        sec = (*tcc_state).data_section;
                    } else if (*tcc_state).nocommon != 0 {
                        sec = (*tcc_state).bss_section;
                    }
                }
                if !sec.is_null() {
                    addr = section_add(sec, size as Elf64_Addr, align) as libc::c_int;
                    if bcheck != 0 {
                        section_add(
                            sec,
                            1 as libc::c_int as Elf64_Addr,
                            1 as libc::c_int,
                        );
                    }
                } else {
                    addr = align;
                    sec = (*tcc_state).common_section;
                }
                if v != 0 {
                    if sym.is_null() {
                        sym = sym_push(
                            v,
                            type_0,
                            r | 0x200 as libc::c_int,
                            0 as libc::c_int,
                        );
                        patch_storage(sym, ad, 0 as *mut CType);
                    }
                    put_extern_sym(sym, sec, addr as Elf64_Addr, size as libc::c_ulong);
                } else {
                    vpush_ref(type_0, sec, addr as libc::c_ulong, size as libc::c_ulong);
                    sym = (*vtop).c2rust_unnamed_0.sym;
                    (*vtop).r = ((*vtop).r as libc::c_int | r) as libc::c_ushort;
                }
                if bcheck != 0 {
                    let mut bounds_ptr: *mut Elf64_Addr = 0 as *mut Elf64_Addr;
                    greloca(
                        (*tcc_state).bounds_section,
                        sym,
                        (*(*tcc_state).bounds_section).data_offset,
                        1 as libc::c_int,
                        0 as libc::c_int as Elf64_Addr,
                    );
                    bounds_ptr = section_ptr_add(
                        (*tcc_state).bounds_section,
                        (2 as libc::c_int as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<Elf64_Addr>() as libc::c_ulong,
                            ),
                    ) as *mut Elf64_Addr;
                    *bounds_ptr
                        .offset(
                            0 as libc::c_int as isize,
                        ) = 0 as libc::c_int as Elf64_Addr;
                    *bounds_ptr.offset(1 as libc::c_int as isize) = size as Elf64_Addr;
                }
                current_block = 3024367268842933116;
            }
        }
    }
    match current_block {
        3024367268842933116 => {
            if (*type_0).t & 0x400 as libc::c_int != 0 {
                let mut a: libc::c_int = 0;
                if !(nocode_wanted > 0 as libc::c_int) {
                    if (*cur_scope).vla.num == 0 as libc::c_int {
                        if !((*cur_scope).prev).is_null()
                            && (*(*cur_scope).prev).vla.num != 0
                        {
                            (*cur_scope).vla.locorig = (*(*cur_scope).prev).vla.loc;
                        } else {
                            loc -= 8 as libc::c_int;
                            gen_vla_sp_save(loc);
                            (*cur_scope).vla.locorig = loc;
                        }
                    }
                    vpush_type_size(type_0, &mut a);
                    gen_vla_alloc(type_0, a);
                    gen_vla_sp_save(addr);
                    (*cur_scope).vla.loc = addr;
                    (*cur_scope).vla.num += 1;
                    (*cur_scope).vla.num;
                }
            } else if has_init != 0 {
                p.sec = sec;
                decl_initializer(
                    &mut p,
                    type_0,
                    addr as libc::c_ulong,
                    1 as libc::c_int,
                );
                if !flexible_array.is_null() {
                    (*(*flexible_array).type_0.ref_0)
                        .c2rust_unnamed
                        .c2rust_unnamed
                        .c = -(1 as libc::c_int);
                }
            }
        }
        _ => {}
    }
    if !init_str.is_null() {
        end_macro();
        next();
    }
    nocode_wanted = saved_nocode_wanted;
}
unsafe extern "C" fn func_vla_arg_code(mut arg: *mut Sym) {
    let mut align: libc::c_int = 0;
    let mut vla_array_tok: *mut TokenString = 0 as *mut TokenString;
    if !((*arg).type_0.ref_0).is_null() {
        func_vla_arg_code((*arg).type_0.ref_0);
    }
    if (*arg).type_0.t & 0x400 as libc::c_int != 0
        && !((*(*arg).type_0.ref_0).c2rust_unnamed_0.vla_array_str).is_null()
    {
        loc -= type_size(&mut int_type, &mut align);
        loc &= -align;
        (*(*arg).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c = loc;
        unget_tok(0 as libc::c_int);
        vla_array_tok = tok_str_alloc();
        (*vla_array_tok).str_0 = (*(*arg).type_0.ref_0).c2rust_unnamed_0.vla_array_str;
        begin_macro(vla_array_tok, 1 as libc::c_int);
        next();
        gexpr();
        end_macro();
        next();
        vpush_type_size(&mut (*(*arg).type_0.ref_0).type_0, &mut align);
        gen_op('*' as i32);
        vset(
            &mut int_type,
            0x32 as libc::c_int | 0x100 as libc::c_int,
            (*(*arg).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c,
        );
        vswap();
        vstore();
        vpop();
    }
}
unsafe extern "C" fn func_vla_arg(mut sym: *mut Sym) {
    let mut arg: *mut Sym = 0 as *mut Sym;
    arg = (*(*sym).type_0.ref_0).c2rust_unnamed_0.next;
    while !arg.is_null() {
        if (*arg).type_0.t & 0xf as libc::c_int == 5 as libc::c_int
            && (*(*arg).type_0.ref_0).type_0.t & 0x400 as libc::c_int != 0
        {
            func_vla_arg_code((*arg).type_0.ref_0);
        }
        arg = (*arg).c2rust_unnamed_0.next;
    }
}
unsafe extern "C" fn gen_function(mut sym: *mut Sym) {
    let mut f: scope = {
        let mut init = scope {
            prev: 0 as *mut scope,
            vla: C2RustUnnamed_19 {
                loc: 0,
                locorig: 0,
                num: 0,
            },
            cl: C2RustUnnamed_20 {
                s: 0 as *mut Sym,
                n: 0,
            },
            bsym: 0 as *mut libc::c_int,
            csym: 0 as *mut libc::c_int,
            lstk: 0 as *mut Sym,
            llstk: 0 as *mut Sym,
        };
        init
    };
    root_scope = &mut f;
    cur_scope = root_scope;
    nocode_wanted = 0 as libc::c_int;
    ind = (*(*tcc_state).cur_text_section).data_offset as libc::c_int;
    if ((*sym).a).aligned() != 0 {
        let mut newoff: size_t = section_add(
            (*tcc_state).cur_text_section,
            0 as libc::c_int as Elf64_Addr,
            (1 as libc::c_int) << ((*sym).a).aligned() as libc::c_int - 1 as libc::c_int,
        );
        gen_fill_nops(newoff.wrapping_sub(ind as size_t) as libc::c_int);
    }
    funcname = get_tok_str((*sym).v, 0 as *mut CValue);
    func_ind = ind;
    func_vt = (*(*sym).type_0.ref_0).type_0;
    func_var = (((*(*sym).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
        .func_type() as libc::c_int == 3 as libc::c_int) as libc::c_int;
    put_extern_sym(
        sym,
        (*tcc_state).cur_text_section,
        ind as Elf64_Addr,
        0 as libc::c_int as libc::c_ulong,
    );
    if ((*(*sym).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
        .func_ctor() != 0
    {
        add_array(
            tcc_state,
            b".init_array\0" as *const u8 as *const libc::c_char,
            (*sym).c2rust_unnamed.c2rust_unnamed.c,
        );
    }
    if ((*(*sym).type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
        .func_dtor() != 0
    {
        add_array(
            tcc_state,
            b".fini_array\0" as *const u8 as *const libc::c_char,
            (*sym).c2rust_unnamed.c2rust_unnamed.c,
        );
    }
    tcc_debug_funcstart(tcc_state, sym);
    sym_push2(
        &mut local_stack,
        0x20000000 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    local_scope = 1 as libc::c_int;
    nb_temp_local_vars = 0 as libc::c_int;
    gfunc_prolog(sym);
    tcc_debug_prolog_epilog(tcc_state, 0 as libc::c_int);
    local_scope = 0 as libc::c_int;
    rsym = 0 as libc::c_int;
    func_vla_arg(sym);
    block(0 as libc::c_int);
    gsym(rsym);
    nocode_wanted = 0 as libc::c_int;
    pop_local_syms(0 as *mut Sym, 0 as libc::c_int);
    tcc_debug_prolog_epilog(tcc_state, 1 as libc::c_int);
    gfunc_epilog();
    tcc_debug_funcend(tcc_state, ind - func_ind);
    (*elfsym(sym)).st_size = (ind - func_ind) as Elf64_Xword;
    (*(*tcc_state).cur_text_section).data_offset = ind as libc::c_ulong;
    local_scope = 0 as libc::c_int;
    label_pop(&mut global_label_stack, 0 as *mut Sym, 0 as libc::c_int);
    sym_pop(&mut all_cleanups, 0 as *mut Sym, 0 as libc::c_int);
    (*tcc_state).cur_text_section = 0 as *mut Section;
    funcname = b"\0" as *const u8 as *const libc::c_char;
    func_vt.t = 0 as libc::c_int;
    func_var = 0 as libc::c_int;
    ind = 0 as libc::c_int;
    func_ind = -(1 as libc::c_int);
    nocode_wanted = 0x80000000 as libc::c_uint as libc::c_int;
    check_vstack();
    next();
}
unsafe extern "C" fn gen_inline_functions(mut s: *mut TCCState) {
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut inline_generated: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut fn_0: *mut InlineFunc = 0 as *mut InlineFunc;
    tcc_open_bf(s, b":inline:\0" as *const u8 as *const libc::c_char, 0 as libc::c_int);
    loop {
        inline_generated = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while i < (*s).nb_inline_fns {
            fn_0 = *((*s).inline_fns).offset(i as isize);
            sym = (*fn_0).sym;
            if !sym.is_null()
                && ((*sym).c2rust_unnamed.c2rust_unnamed.c != 0
                    || (*sym).type_0.t & 0x8000 as libc::c_int == 0)
            {
                (*fn_0).sym = 0 as *mut Sym;
                tccpp_putfile(((*fn_0).filename).as_mut_ptr());
                begin_macro((*fn_0).func_str, 1 as libc::c_int);
                next();
                (*tcc_state).cur_text_section = (*tcc_state).text_section;
                gen_function(sym);
                end_macro();
                inline_generated = 1 as libc::c_int;
            }
            i += 1;
            i;
        }
        if !(inline_generated != 0) {
            break;
        }
    }
    tcc_close();
}
unsafe extern "C" fn free_inline_functions(mut s: *mut TCCState) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s).nb_inline_fns {
        let mut fn_0: *mut InlineFunc = *((*s).inline_fns).offset(i as isize);
        if !((*fn_0).sym).is_null() {
            tok_str_free((*fn_0).func_str);
        }
        i += 1;
        i;
    }
    dynarray_reset(
        &mut (*s).inline_fns as *mut *mut *mut InlineFunc as *mut libc::c_void,
        &mut (*s).nb_inline_fns,
    );
}
unsafe extern "C" fn do_Static_assert() {
    let mut c: libc::c_int = 0;
    let mut msg: *const libc::c_char = 0 as *const libc::c_char;
    next();
    skip('(' as i32);
    c = expr_const();
    msg = b"_Static_assert fail\0" as *const u8 as *const libc::c_char;
    if tok == ',' as i32 {
        next();
        msg = (*parse_mult_str(b"string constant\0" as *const u8 as *const libc::c_char))
            .data;
    }
    skip(')' as i32);
    if c == 0 as libc::c_int {
        _tcc_error(b"%s\0" as *const u8 as *const libc::c_char, msg);
    }
    skip(';' as i32);
}
unsafe extern "C" fn decl(mut l: libc::c_int) -> libc::c_int {
    let mut v: libc::c_int = 0;
    let mut has_init: libc::c_int = 0;
    let mut r: libc::c_int = 0;
    let mut oldint: libc::c_int = 0;
    let mut type_0: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut btype: CType = CType {
        t: 0,
        ref_0: 0 as *mut Sym,
    };
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut ad: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    let mut adbase: AttributeDef = AttributeDef {
        a: SymAttr {
            aligned_packed_weak_visibility_dllexport_nodecorate_dllimport_addrtaken_nodebug_xxxx: [0; 2],
        },
        f: FuncAttr {
            func_call_func_type_func_noreturn_func_ctor_func_dtor_func_args_func_alwinl_xxxx: [0; 4],
        },
        section: 0 as *mut Section,
        cleanup_func: 0 as *mut Sym,
        alias_target: 0,
        asm_label: 0,
        attr_mode: 0,
    };
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    loop {
        oldint = 0 as libc::c_int;
        if parse_btype(
            &mut btype,
            &mut adbase,
            (l == 0x32 as libc::c_int) as libc::c_int,
        ) == 0
        {
            if l == 0x34 as libc::c_int {
                return 0 as libc::c_int;
            }
            if tok == ';' as i32 && l != 0x33 as libc::c_int {
                next();
                continue;
            } else if tok == TOK_STATIC_ASSERT as libc::c_int {
                do_Static_assert();
                continue;
            } else {
                if l != 0x30 as libc::c_int {
                    break;
                }
                if tok == TOK_ASM1 as libc::c_int || tok == TOK_ASM2 as libc::c_int
                    || tok == TOK_ASM3 as libc::c_int
                {
                    asm_global_instr();
                    continue;
                } else if tok >= TOK_DEFINE as libc::c_int {
                    btype.t = 3 as libc::c_int;
                    oldint = 1 as libc::c_int;
                } else {
                    if tok != -(1 as libc::c_int) {
                        expect(b"declaration\0" as *const u8 as *const libc::c_char);
                    }
                    break;
                }
            }
        }
        if tok == ';' as i32 {
            if btype.t & 0xf as libc::c_int == 7 as libc::c_int {
                v = (*btype.ref_0).v;
                if v & 0x20000000 as libc::c_int == 0
                    && v & !(0x40000000 as libc::c_int) >= 0x10000000 as libc::c_int
                {
                    _tcc_warning(
                        b"unnamed struct/union that defines no instances\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                next();
                continue;
            } else if btype.t as libc::c_uint
                & (((1 as libc::c_uint) << 6 as libc::c_int + 6 as libc::c_int)
                    .wrapping_sub(1 as libc::c_int as libc::c_uint) << 20 as libc::c_int
                    | 0x80 as libc::c_int as libc::c_uint)
                == ((2 as libc::c_int) << 20 as libc::c_int) as libc::c_uint
            {
                next();
                continue;
            }
        }
        loop {
            type_0 = btype;
            ad = adbase;
            type_decl(&mut type_0, &mut ad, &mut v, 2 as libc::c_int);
            if type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
                if type_0.t & 0x2000 as libc::c_int != 0 && l != 0x30 as libc::c_int {
                    _tcc_error(
                        b"function without file scope cannot be static\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                sym = type_0.ref_0;
                if ((*sym).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f).func_type()
                    as libc::c_int == 2 as libc::c_int && l == 0x30 as libc::c_int
                {
                    func_vt = type_0;
                    decl(0x33 as libc::c_int);
                }
                if type_0.t & (0x1000 as libc::c_int | 0x8000 as libc::c_int)
                    == 0x1000 as libc::c_int | 0x8000 as libc::c_int
                {
                    if (*tcc_state).gnu89_inline as libc::c_int != 0
                        || ((*sym).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f)
                            .func_alwinl() as libc::c_int != 0
                    {
                        type_0
                            .t = type_0.t & !(0x1000 as libc::c_int)
                            | 0x2000 as libc::c_int;
                    } else {
                        type_0.t &= !(0x8000 as libc::c_int);
                    }
                }
            } else if oldint != 0 {
                _tcc_warning(
                    b"type defaults to int\0" as *const u8 as *const libc::c_char,
                );
            }
            if (*tcc_state).gnu_ext as libc::c_int != 0
                && (tok == TOK_ASM1 as libc::c_int || tok == TOK_ASM2 as libc::c_int
                    || tok == TOK_ASM3 as libc::c_int)
            {
                ad.asm_label = asm_label_instr();
                parse_attribute(&mut ad);
            }
            if tok == '{' as i32 {
                if l != 0x30 as libc::c_int {
                    _tcc_error(
                        b"cannot use local functions\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                if type_0.t & 0xf as libc::c_int != 6 as libc::c_int {
                    expect(b"function definition\0" as *const u8 as *const libc::c_char);
                }
                sym = type_0.ref_0;
                loop {
                    sym = (*sym).c2rust_unnamed_0.next;
                    if sym.is_null() {
                        break;
                    }
                    if (*sym).v & !(0x20000000 as libc::c_int) == 0 {
                        expect(b"identifier\0" as *const u8 as *const libc::c_char);
                    }
                    if (*sym).type_0.t == 0 as libc::c_int {
                        (*sym).type_0 = int_type;
                    }
                }
                merge_funcattr(
                    &mut (*type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.f,
                    &mut ad.f,
                );
                type_0.t &= !(0x1000 as libc::c_int);
                sym = external_sym(v, &mut type_0, 0 as libc::c_int, &mut ad);
                if (*sym).type_0.t & 0x8000 as libc::c_int != 0 {
                    let mut fn_0: *mut InlineFunc = 0 as *mut InlineFunc;
                    fn_0 = tcc_malloc(
                        (::core::mem::size_of::<InlineFunc>() as libc::c_ulong)
                            .wrapping_add(strlen(((*file).filename).as_mut_ptr())),
                    ) as *mut InlineFunc;
                    strcpy(
                        ((*fn_0).filename).as_mut_ptr(),
                        ((*file).filename).as_mut_ptr(),
                    );
                    (*fn_0).sym = sym;
                    dynarray_add(
                        &mut (*tcc_state).inline_fns as *mut *mut *mut InlineFunc
                            as *mut libc::c_void,
                        &mut (*tcc_state).nb_inline_fns,
                        fn_0 as *mut libc::c_void,
                    );
                    skip_or_save_block(&mut (*fn_0).func_str);
                } else {
                    (*tcc_state).cur_text_section = ad.section;
                    if ((*tcc_state).cur_text_section).is_null() {
                        (*tcc_state).cur_text_section = (*tcc_state).text_section;
                    } else if (*(*tcc_state).cur_text_section).sh_num
                        > (*(*tcc_state).bss_section).sh_num
                    {
                        (*(*tcc_state).cur_text_section)
                            .sh_flags = (*(*tcc_state).text_section).sh_flags;
                    }
                    gen_function(sym);
                }
                break;
            } else {
                if l == 0x33 as libc::c_int {
                    let mut current_block_75: u64;
                    sym = (*func_vt.ref_0).c2rust_unnamed_0.next;
                    loop {
                        if sym.is_null() {
                            current_block_75 = 13853033528615664019;
                            break;
                        }
                        if (*sym).v & !(0x20000000 as libc::c_int) == v {
                            current_block_75 = 12574943066570679846;
                            break;
                        }
                        sym = (*sym).c2rust_unnamed_0.next;
                    }
                    match current_block_75 {
                        13853033528615664019 => {
                            _tcc_error(
                                b"declaration for parameter '%s' but no such parameter\0"
                                    as *const u8 as *const libc::c_char,
                                get_tok_str(v, 0 as *mut CValue),
                            );
                        }
                        _ => {
                            if type_0.t
                                & (0x1000 as libc::c_int | 0x2000 as libc::c_int
                                    | 0x4000 as libc::c_int | 0x8000 as libc::c_int) != 0
                            {
                                _tcc_error(
                                    b"storage class specified for '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            }
                            if (*sym).type_0.t != 0 as libc::c_int {
                                _tcc_error(
                                    b"redefinition of parameter '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    get_tok_str(v, 0 as *mut CValue),
                                );
                            }
                            convert_parameter_type(&mut type_0);
                            (*sym).type_0 = type_0;
                        }
                    }
                } else if type_0.t & 0x4000 as libc::c_int != 0 {
                    sym = sym_find(v);
                    if !sym.is_null()
                        && (*sym).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope
                            == local_scope
                    {
                        if is_compatible_types(&mut (*sym).type_0, &mut type_0) == 0
                            || (*sym).type_0.t & 0x4000 as libc::c_int == 0
                        {
                            _tcc_error(
                                b"incompatible redefinition of '%s'\0" as *const u8
                                    as *const libc::c_char,
                                get_tok_str(v, 0 as *mut CValue),
                            );
                        }
                        (*sym).type_0 = type_0;
                    } else {
                        sym = sym_push(
                            v,
                            &mut type_0,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                    }
                    (*sym).a = ad.a;
                    if type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
                        merge_funcattr(
                            &mut (*(*sym).type_0.ref_0)
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .f,
                            &mut ad.f,
                        );
                    }
                    if debug_modes != 0 {
                        tcc_debug_typedef(tcc_state, sym);
                    }
                } else if type_0.t & 0xf as libc::c_int == 0 as libc::c_int
                    && type_0.t & 0x1000 as libc::c_int == 0
                {
                    _tcc_error(
                        b"declaration of void object\0" as *const u8
                            as *const libc::c_char,
                    );
                } else {
                    r = 0 as libc::c_int;
                    if type_0.t & 0xf as libc::c_int == 6 as libc::c_int {
                        merge_funcattr(
                            &mut (*type_0.ref_0)
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .c2rust_unnamed
                                .f,
                            &mut ad.f,
                        );
                    } else if type_0.t & 0x40 as libc::c_int == 0 {
                        r |= 0x100 as libc::c_int;
                    }
                    has_init = (tok == '=' as i32) as libc::c_int;
                    if has_init != 0 && type_0.t & 0x400 as libc::c_int != 0 {
                        _tcc_error(
                            b"variable length array cannot be initialized\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                    if type_0.t & 0x1000 as libc::c_int != 0
                        && (has_init == 0 || l != 0x30 as libc::c_int)
                        || type_0.t & 0xf as libc::c_int == 6 as libc::c_int
                        || type_0.t & 0x40 as libc::c_int != 0 && has_init == 0
                            && l == 0x30 as libc::c_int
                            && (*type_0.ref_0).c2rust_unnamed.c2rust_unnamed.c
                                < 0 as libc::c_int
                    {
                        type_0.t |= 0x1000 as libc::c_int;
                        external_sym(v, &mut type_0, r, &mut ad);
                    } else {
                        if l == 0x30 as libc::c_int
                            || type_0.t & 0x2000 as libc::c_int != 0
                        {
                            r |= 0x30 as libc::c_int;
                        } else {
                            r |= 0x32 as libc::c_int;
                        }
                        if has_init != 0 {
                            next();
                        } else if l == 0x30 as libc::c_int {
                            type_0.t |= 0x1000 as libc::c_int;
                        }
                        decl_initializer_alloc(
                            &mut type_0,
                            &mut ad,
                            r,
                            has_init,
                            v,
                            (l == 0x30 as libc::c_int) as libc::c_int,
                        );
                    }
                    if ad.alias_target != 0 && l == 0x30 as libc::c_int {
                        esym = elfsym(sym_find(ad.alias_target));
                        if esym.is_null() {
                            _tcc_error(
                                b"unsupported forward __alias__ attribute\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        put_extern_sym2(
                            sym_find(v),
                            (*esym).st_shndx as libc::c_int,
                            (*esym).st_value,
                            (*esym).st_size,
                            1 as libc::c_int,
                        );
                    }
                }
                if tok != ',' as i32 {
                    if l == 0x34 as libc::c_int {
                        return 1 as libc::c_int;
                    }
                    skip(';' as i32);
                    break;
                } else {
                    next();
                }
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn code_reloc(mut reloc_type: libc::c_int) -> libc::c_int {
    match reloc_type {
        10 | 11 | 1 | 26 | 29 | 9 | 41 | 42 | 22 | 3 | 27 | 6 | 5 | 8 | 25 | 19 | 20 | 21
        | 23 | 17 | 18 => return 0 as libc::c_int,
        2 | 24 | 4 | 31 | 7 => return 1 as libc::c_int,
        _ => {}
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn gotplt_entry_type(mut reloc_type: libc::c_int) -> libc::c_int {
    match reloc_type {
        6 | 7 | 5 | 8 => return NO_GOTPLT_ENTRY as libc::c_int,
        10 | 11 | 1 | 2 | 24 => return AUTO_GOTPLT_ENTRY as libc::c_int,
        22 => return BUILD_GOT_ONLY as libc::c_int,
        3 | 27 | 26 | 29 | 25 | 9 | 41 | 19 | 20 | 21 | 23 | 17 | 18 | 42 | 4 | 31 => {
            return ALWAYS_GOTPLT_ENTRY as libc::c_int;
        }
        _ => {}
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn create_plt_entry(
    mut s1: *mut TCCState,
    mut got_offset: libc::c_uint,
    mut attr: *mut sym_attr,
) -> libc::c_uint {
    let mut plt: *mut Section = (*s1).plt;
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut modrm: libc::c_int = 0;
    let mut plt_offset: libc::c_uint = 0;
    let mut relofs: libc::c_uint = 0;
    modrm = 0x25 as libc::c_int;
    if (*plt).data_offset == 0 as libc::c_int as libc::c_ulong {
        p = section_ptr_add(plt, 16 as libc::c_int as Elf64_Addr) as *mut uint8_t;
        *p.offset(0 as libc::c_int as isize) = 0xff as libc::c_int as uint8_t;
        *p.offset(1 as libc::c_int as isize) = (modrm + 0x10 as libc::c_int) as uint8_t;
        write32le(p.offset(2 as libc::c_int as isize), 8 as libc::c_int as uint32_t);
        *p.offset(6 as libc::c_int as isize) = 0xff as libc::c_int as uint8_t;
        *p.offset(7 as libc::c_int as isize) = modrm as uint8_t;
        write32le(
            p.offset(8 as libc::c_int as isize),
            (8 as libc::c_int * 2 as libc::c_int) as uint32_t,
        );
    }
    plt_offset = (*plt).data_offset as libc::c_uint;
    relofs = (if !((*(*s1).plt).reloc).is_null() {
        (*(*(*s1).plt).reloc).data_offset
    } else {
        0 as libc::c_int as libc::c_ulong
    }) as libc::c_uint;
    p = section_ptr_add(plt, 16 as libc::c_int as Elf64_Addr) as *mut uint8_t;
    *p.offset(0 as libc::c_int as isize) = 0xff as libc::c_int as uint8_t;
    *p.offset(1 as libc::c_int as isize) = modrm as uint8_t;
    write32le(p.offset(2 as libc::c_int as isize), got_offset);
    *p.offset(6 as libc::c_int as isize) = 0x68 as libc::c_int as uint8_t;
    write32le(
        p.offset(7 as libc::c_int as isize),
        (relofs as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<Elf64_Rela>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as uint32_t,
    );
    *p.offset(11 as libc::c_int as isize) = 0xe9 as libc::c_int as uint8_t;
    write32le(
        p.offset(12 as libc::c_int as isize),
        ((*plt).data_offset).wrapping_neg() as uint32_t,
    );
    return plt_offset;
}
unsafe extern "C" fn relocate_plt(mut s1: *mut TCCState) {
    let mut p: *mut uint8_t = 0 as *mut uint8_t;
    let mut p_end: *mut uint8_t = 0 as *mut uint8_t;
    if ((*s1).plt).is_null() {
        return;
    }
    p = (*(*s1).plt).data;
    p_end = p.offset((*(*s1).plt).data_offset as isize);
    if p < p_end {
        let mut x: libc::c_int = ((*(*s1).got).sh_addr)
            .wrapping_sub((*(*s1).plt).sh_addr)
            .wrapping_sub(6 as libc::c_int as Elf64_Addr) as libc::c_int;
        add32le(p.offset(2 as libc::c_int as isize), x);
        add32le(p.offset(8 as libc::c_int as isize), x - 6 as libc::c_int);
        p = p.offset(16 as libc::c_int as isize);
        while p < p_end {
            add32le(
                p.offset(2 as libc::c_int as isize),
                (x as libc::c_long + ((*(*s1).plt).data).offset_from(p) as libc::c_long)
                    as int32_t,
            );
            p = p.offset(16 as libc::c_int as isize);
        }
    }
    if !((*(*s1).plt).reloc).is_null() {
        let mut rel: *mut Elf64_Rela = 0 as *mut Elf64_Rela;
        let mut x_0: libc::c_int = ((*(*s1).plt).sh_addr)
            .wrapping_add(16 as libc::c_int as Elf64_Addr)
            .wrapping_add(6 as libc::c_int as Elf64_Addr) as libc::c_int;
        p = (*(*s1).got).data;
        rel = ((*(*(*s1).plt).reloc).data as *mut Elf64_Rela)
            .offset(0 as libc::c_int as isize);
        while rel
            < ((*(*(*s1).plt).reloc).data)
                .offset((*(*(*s1).plt).reloc).data_offset as isize) as *mut Elf64_Rela
        {
            write64le(p.offset((*rel).r_offset as isize), x_0 as uint64_t);
            x_0 += 16 as libc::c_int;
            rel = rel.offset(1);
            rel;
        }
    }
}
unsafe extern "C" fn relocate(
    mut s1: *mut TCCState,
    mut rel: *mut Elf64_Rela,
    mut type_0: libc::c_int,
    mut ptr: *mut libc::c_uchar,
    mut addr: Elf64_Addr,
    mut val: Elf64_Addr,
) {
    let mut sym_index: libc::c_int = 0;
    let mut esym_index: libc::c_int = 0;
    sym_index = ((*rel).r_info >> 32 as libc::c_int) as libc::c_int;
    let mut current_block_70: u64;
    match type_0 {
        1 => {
            if (*s1).output_type & 4 as libc::c_int != 0 {
                esym_index = (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).dyn_index;
                (*(*s1).qrel).r_offset = (*rel).r_offset;
                if esym_index != 0 {
                    (*(*s1).qrel)
                        .r_info = ((esym_index as Elf64_Xword) << 32 as libc::c_int)
                        .wrapping_add(1 as libc::c_int as Elf64_Xword);
                    (*(*s1).qrel).r_addend = (*rel).r_addend;
                    (*s1).qrel = ((*s1).qrel).offset(1);
                    (*s1).qrel;
                    current_block_70 = 576355610076403033;
                } else {
                    (*(*s1).qrel)
                        .r_info = ((0 as libc::c_int as Elf64_Xword)
                        << 32 as libc::c_int)
                        .wrapping_add(8 as libc::c_int as Elf64_Xword);
                    (*(*s1).qrel)
                        .r_addend = (read64le(ptr)).wrapping_add(val) as Elf64_Sxword;
                    (*s1).qrel = ((*s1).qrel).offset(1);
                    (*s1).qrel;
                    current_block_70 = 13109137661213826276;
                }
            } else {
                current_block_70 = 13109137661213826276;
            }
            match current_block_70 {
                576355610076403033 => {}
                _ => {
                    add64le(ptr, val as int64_t);
                    current_block_70 = 576355610076403033;
                }
            }
        }
        10 | 11 => {
            if (*s1).output_type & 4 as libc::c_int != 0 {
                (*(*s1).qrel).r_offset = (*rel).r_offset;
                (*(*s1).qrel)
                    .r_info = ((0 as libc::c_int as Elf64_Xword) << 32 as libc::c_int)
                    .wrapping_add(8 as libc::c_int as Elf64_Xword);
                (*(*s1).qrel)
                    .r_addend = (read32le(ptr) as libc::c_int as Elf64_Addr)
                    .wrapping_add(val) as Elf64_Sxword;
                (*s1).qrel = ((*s1).qrel).offset(1);
                (*s1).qrel;
            }
            add32le(ptr, val as int32_t);
            current_block_70 = 576355610076403033;
        }
        2 => {
            if (*s1).output_type == 4 as libc::c_int {
                esym_index = (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).dyn_index;
                if esym_index != 0 {
                    (*(*s1).qrel).r_offset = (*rel).r_offset;
                    (*(*s1).qrel)
                        .r_info = ((esym_index as Elf64_Xword) << 32 as libc::c_int)
                        .wrapping_add(2 as libc::c_int as Elf64_Xword);
                    (*(*s1).qrel)
                        .r_addend = read32le(ptr) as libc::c_int as Elf64_Sxword
                        + (*rel).r_addend;
                    (*s1).qrel = ((*s1).qrel).offset(1);
                    (*s1).qrel;
                    current_block_70 = 576355610076403033;
                } else {
                    current_block_70 = 9500136823799725703;
                }
            } else {
                current_block_70 = 9500136823799725703;
            }
        }
        4 => {
            current_block_70 = 9500136823799725703;
        }
        31 => {
            add64le(
                ptr,
                val
                    .wrapping_sub((*(*s1).got).sh_addr)
                    .wrapping_add((*rel).r_addend as Elf64_Addr) as int64_t,
            );
            current_block_70 = 576355610076403033;
        }
        24 => {
            if (*s1).output_type == 4 as libc::c_int {
                esym_index = (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).dyn_index;
                if esym_index != 0 {
                    (*(*s1).qrel).r_offset = (*rel).r_offset;
                    (*(*s1).qrel)
                        .r_info = ((esym_index as Elf64_Xword) << 32 as libc::c_int)
                        .wrapping_add(24 as libc::c_int as Elf64_Xword);
                    (*(*s1).qrel)
                        .r_addend = (read64le(ptr))
                        .wrapping_add((*rel).r_addend as uint64_t) as Elf64_Sxword;
                    (*s1).qrel = ((*s1).qrel).offset(1);
                    (*s1).qrel;
                    current_block_70 = 576355610076403033;
                } else {
                    current_block_70 = 5529461102203738653;
                }
            } else {
                current_block_70 = 5529461102203738653;
            }
            match current_block_70 {
                576355610076403033 => {}
                _ => {
                    add64le(ptr, val.wrapping_sub(addr) as int64_t);
                    current_block_70 = 576355610076403033;
                }
            }
        }
        6 | 7 => {
            write64le(ptr, val.wrapping_sub((*rel).r_addend as Elf64_Addr));
            current_block_70 = 576355610076403033;
        }
        9 | 41 | 42 => {
            add32le(
                ptr,
                ((*(*s1).got).sh_addr)
                    .wrapping_sub(addr)
                    .wrapping_add(
                        (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).got_offset
                            as Elf64_Addr,
                    )
                    .wrapping_sub(4 as libc::c_int as Elf64_Addr) as int32_t,
            );
            current_block_70 = 576355610076403033;
        }
        26 => {
            add32le(
                ptr,
                ((*(*s1).got).sh_addr)
                    .wrapping_sub(addr)
                    .wrapping_add((*rel).r_addend as Elf64_Addr) as int32_t,
            );
            current_block_70 = 576355610076403033;
        }
        29 => {
            add64le(
                ptr,
                ((*(*s1).got).sh_addr)
                    .wrapping_sub(addr)
                    .wrapping_add((*rel).r_addend as Elf64_Addr) as int64_t,
            );
            current_block_70 = 576355610076403033;
        }
        22 => {
            add32le(ptr, val.wrapping_sub((*(*s1).got).sh_addr) as int32_t);
            current_block_70 = 576355610076403033;
        }
        3 => {
            add32le(
                ptr,
                (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).got_offset as int32_t,
            );
            current_block_70 = 576355610076403033;
        }
        27 => {
            add64le(
                ptr,
                (*get_sym_attr(s1, sym_index, 0 as libc::c_int)).got_offset as int64_t,
            );
            current_block_70 = 576355610076403033;
        }
        25 => {
            add64le(ptr, val.wrapping_sub((*(*s1).got).sh_addr) as int64_t);
            current_block_70 = 576355610076403033;
        }
        19 => {
            static mut expect_0: [libc::c_uchar; 16] = [
                0x66 as libc::c_int as libc::c_uchar,
                0x48 as libc::c_int as libc::c_uchar,
                0x8d as libc::c_int as libc::c_uchar,
                0x3d as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0x48 as libc::c_int as libc::c_uchar,
                0xe8 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
            ];
            static mut replace: [libc::c_uchar; 16] = [
                0x64 as libc::c_int as libc::c_uchar,
                0x48 as libc::c_int as libc::c_uchar,
                0x8b as libc::c_int as libc::c_uchar,
                0x4 as libc::c_int as libc::c_uchar,
                0x25 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0x48 as libc::c_int as libc::c_uchar,
                0x8d as libc::c_int as libc::c_uchar,
                0x80 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
            ];
            if memcmp(
                ptr.offset(-(4 as libc::c_int as isize)) as *const libc::c_void,
                expect_0.as_ptr() as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_uchar; 16]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                let mut sym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
                let mut sec: *mut Section = 0 as *mut Section;
                let mut x: int32_t = 0;
                memcpy(
                    ptr.offset(-(4 as libc::c_int as isize)) as *mut libc::c_void,
                    replace.as_ptr() as *const libc::c_void,
                    ::core::mem::size_of::<[libc::c_uchar; 16]>() as libc::c_ulong,
                );
                (*rel.offset(1 as libc::c_int as isize))
                    .r_info = ((0 as libc::c_int as Elf64_Xword) << 32 as libc::c_int)
                    .wrapping_add(0 as libc::c_int as Elf64_Xword);
                sym = &mut *((*(*s1).c2rust_unnamed.symtab_section).data
                    as *mut Elf64_Sym)
                    .offset(sym_index as isize) as *mut Elf64_Sym;
                sec = *((*s1).sections).offset((*sym).st_shndx as isize);
                x = ((*sym).st_value)
                    .wrapping_sub((*sec).sh_addr)
                    .wrapping_sub((*sec).data_offset) as int32_t;
                add32le(ptr.offset(8 as libc::c_int as isize), x);
            } else {
                tcc_enter_state(s1);
                (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"unexpected R_X86_64_TLSGD pattern\0" as *const u8
                        as *const libc::c_char,
                );
            }
            current_block_70 = 576355610076403033;
        }
        20 => {
            static mut expect_1: [libc::c_uchar; 12] = [
                0x48 as libc::c_int as libc::c_uchar,
                0x8d as libc::c_int as libc::c_uchar,
                0x3d as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0xe8 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
            ];
            static mut replace_0: [libc::c_uchar; 12] = [
                0x66 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0x66 as libc::c_int as libc::c_uchar,
                0x64 as libc::c_int as libc::c_uchar,
                0x48 as libc::c_int as libc::c_uchar,
                0x8b as libc::c_int as libc::c_uchar,
                0x4 as libc::c_int as libc::c_uchar,
                0x25 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
                0 as libc::c_int as libc::c_uchar,
            ];
            if memcmp(
                ptr.offset(-(3 as libc::c_int as isize)) as *const libc::c_void,
                expect_1.as_ptr() as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                memcpy(
                    ptr.offset(-(3 as libc::c_int as isize)) as *mut libc::c_void,
                    replace_0.as_ptr() as *const libc::c_void,
                    ::core::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong,
                );
                (*rel.offset(1 as libc::c_int as isize))
                    .r_info = ((0 as libc::c_int as Elf64_Xword) << 32 as libc::c_int)
                    .wrapping_add(0 as libc::c_int as Elf64_Xword);
            } else {
                tcc_enter_state(s1);
                (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"unexpected R_X86_64_TLSLD pattern\0" as *const u8
                        as *const libc::c_char,
                );
            }
            current_block_70 = 576355610076403033;
        }
        21 | 23 => {
            let mut sym_0: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
            let mut sec_0: *mut Section = 0 as *mut Section;
            let mut x_0: int32_t = 0;
            sym_0 = &mut *((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
                .offset(sym_index as isize) as *mut Elf64_Sym;
            sec_0 = *((*s1).sections).offset((*sym_0).st_shndx as isize);
            x_0 = val.wrapping_sub((*sec_0).sh_addr).wrapping_sub((*sec_0).data_offset)
                as int32_t;
            add32le(ptr, x_0);
            current_block_70 = 576355610076403033;
        }
        17 | 18 => {
            let mut sym_1: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
            let mut sec_1: *mut Section = 0 as *mut Section;
            let mut x_1: int32_t = 0;
            sym_1 = &mut *((*(*s1).c2rust_unnamed.symtab_section).data as *mut Elf64_Sym)
                .offset(sym_index as isize) as *mut Elf64_Sym;
            sec_1 = *((*s1).sections).offset((*sym_1).st_shndx as isize);
            x_1 = val.wrapping_sub((*sec_1).sh_addr).wrapping_sub((*sec_1).data_offset)
                as int32_t;
            add64le(ptr, x_1 as int64_t);
            current_block_70 = 576355610076403033;
        }
        5 | 0 | 8 => {
            current_block_70 = 576355610076403033;
        }
        _ => {
            fprintf(
                stderr,
                b"FIXME: handle reloc type %d at %x [%p] to %x\n\0" as *const u8
                    as *const libc::c_char,
                type_0,
                addr as libc::c_uint,
                ptr,
                val as libc::c_uint,
            );
            current_block_70 = 576355610076403033;
        }
    }
    match current_block_70 {
        9500136823799725703 => {
            let mut diff: libc::c_longlong = 0;
            diff = (val as libc::c_longlong as libc::c_ulonglong)
                .wrapping_sub(addr as libc::c_ulonglong) as libc::c_longlong;
            if diff < -(2147483648 as libc::c_longlong)
                || diff > 2147483647 as libc::c_longlong
            {
                tcc_enter_state(s1);
                (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"internal error: relocation failed\0" as *const u8
                        as *const libc::c_char,
                );
            }
            add32le(ptr, diff as int32_t);
        }
        _ => {}
    };
}
static mut last_text_section: *mut Section = 0 as *const Section as *mut Section;
static mut asmgoto_n: libc::c_int = 0;
unsafe extern "C" fn asm_get_prefix_name(
    mut s1: *mut TCCState,
    mut prefix: *const libc::c_char,
    mut n: libc::c_uint,
) -> libc::c_int {
    let mut buf: [libc::c_char; 64] = [0; 64];
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 64]>() as libc::c_ulong,
        b"%s%u\0" as *const u8 as *const libc::c_char,
        prefix,
        n,
    );
    return tok_alloc_const(buf.as_mut_ptr());
}
unsafe extern "C" fn asm_get_local_label_name(
    mut s1: *mut TCCState,
    mut n: libc::c_uint,
) -> libc::c_int {
    return asm_get_prefix_name(s1, b"L..\0" as *const u8 as *const libc::c_char, n);
}
unsafe extern "C" fn asm2cname(
    mut v: libc::c_int,
    mut addeddot: *mut libc::c_int,
) -> libc::c_int {
    let mut name: *const libc::c_char = 0 as *const libc::c_char;
    *addeddot = 0 as libc::c_int;
    if (*tcc_state).leading_underscore == 0 {
        return v;
    }
    name = get_tok_str(v, 0 as *mut CValue);
    if name.is_null() {
        return v;
    }
    if *name.offset(0 as libc::c_int as isize) as libc::c_int == '_' as i32 {
        v = tok_alloc_const(name.offset(1 as libc::c_int as isize));
    } else if (strchr(name, '.' as i32)).is_null() {
        let mut newname: [libc::c_char; 256] = [0; 256];
        snprintf(
            newname.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
            b".%s\0" as *const u8 as *const libc::c_char,
            name,
        );
        v = tok_alloc_const(newname.as_mut_ptr());
        *addeddot = 1 as libc::c_int;
    }
    return v;
}
unsafe extern "C" fn asm_label_find(mut v: libc::c_int) -> *mut Sym {
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut addeddot: libc::c_int = 0;
    v = asm2cname(v, &mut addeddot);
    sym = sym_find(v);
    while !sym.is_null()
        && (*sym).c2rust_unnamed.c2rust_unnamed.c2rust_unnamed.sym_scope != 0
        && (*sym).type_0.t & 0x2000 as libc::c_int == 0
    {
        sym = (*sym).prev_tok;
    }
    return sym;
}
unsafe extern "C" fn asm_label_push(mut v: libc::c_int) -> *mut Sym {
    let mut addeddot: libc::c_int = 0;
    let mut v2: libc::c_int = asm2cname(v, &mut addeddot);
    let mut sym: *mut Sym = global_identifier_push(
        v2,
        0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
            | 0x1000 as libc::c_int | 0x2000 as libc::c_int,
        0 as libc::c_int,
    );
    if addeddot != 0 {
        (*sym).c2rust_unnamed_0.asm_label = v;
    }
    return sym;
}
unsafe extern "C" fn get_asm_sym(mut name: libc::c_int, mut csym: *mut Sym) -> *mut Sym {
    let mut sym: *mut Sym = asm_label_find(name);
    if sym.is_null() {
        sym = asm_label_push(name);
        if !csym.is_null() {
            (*sym)
                .c2rust_unnamed
                .c2rust_unnamed
                .c = (*csym).c2rust_unnamed.c2rust_unnamed.c;
        }
    }
    return sym;
}
unsafe extern "C" fn asm_section_sym(
    mut s1: *mut TCCState,
    mut sec: *mut Section,
) -> *mut Sym {
    let mut buf: [libc::c_char; 100] = [0; 100];
    let mut label: libc::c_int = 0;
    let mut sym: *mut Sym = 0 as *mut Sym;
    snprintf(
        buf.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong,
        b"L.%s\0" as *const u8 as *const libc::c_char,
        ((*sec).name).as_mut_ptr(),
    );
    label = tok_alloc_const(buf.as_mut_ptr());
    sym = asm_label_find(label);
    return if !sym.is_null() {
        sym
    } else {
        asm_new_label1(s1, label, 1 as libc::c_int, (*sec).sh_num, 0 as libc::c_int)
    };
}
unsafe extern "C" fn asm_expr_unary(mut s1: *mut TCCState, mut pe: *mut ExprValue) {
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut op: libc::c_int = 0;
    let mut label: libc::c_int = 0;
    let mut n: uint64_t = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    match tok {
        205 => {
            p = tokc.str_0.data;
            n = strtoull(
                p,
                &mut p as *mut *const libc::c_char as *mut *mut libc::c_char,
                0 as libc::c_int,
            ) as uint64_t;
            if *p as libc::c_int == 'b' as i32 || *p as libc::c_int == 'f' as i32 {
                label = asm_get_local_label_name(s1, n as libc::c_uint);
                sym = asm_label_find(label);
                if *p as libc::c_int == 'b' as i32 {
                    if !sym.is_null()
                        && ((*sym).c2rust_unnamed.c2rust_unnamed.c == 0
                            || (*elfsym(sym)).st_shndx as libc::c_int
                                == 0 as libc::c_int)
                    {
                        sym = (*sym).prev_tok;
                    }
                    if sym.is_null() {
                        _tcc_error(
                            b"local label '%d' not found backward\0" as *const u8
                                as *const libc::c_char,
                            n as libc::c_int,
                        );
                    }
                } else if sym.is_null()
                    || (*sym).c2rust_unnamed.c2rust_unnamed.c != 0
                        && (*elfsym(sym)).st_shndx as libc::c_int != 0 as libc::c_int
                {
                    sym = asm_label_push(label);
                }
                (*pe).v = 0 as libc::c_int as uint64_t;
                (*pe).sym = sym;
                (*pe).pcrel = 0 as libc::c_int;
            } else if *p as libc::c_int == '\0' as i32 {
                (*pe).v = n;
                (*pe).sym = 0 as *mut Sym;
                (*pe).pcrel = 0 as libc::c_int;
            } else {
                _tcc_error(
                    b"invalid number syntax\0" as *const u8 as *const libc::c_char,
                );
            }
            next();
        }
        43 => {
            next();
            asm_expr_unary(s1, pe);
        }
        45 | 126 => {
            op = tok;
            next();
            asm_expr_unary(s1, pe);
            if !((*pe).sym).is_null() {
                _tcc_error(
                    b"invalid operation with label\0" as *const u8 as *const libc::c_char,
                );
            }
            if op == '-' as i32 {
                (*pe).v = ((*pe).v).wrapping_neg();
            } else {
                (*pe).v = !(*pe).v;
            }
        }
        192 | 193 => {
            (*pe).v = tokc.i;
            (*pe).sym = 0 as *mut Sym;
            (*pe).pcrel = 0 as libc::c_int;
            next();
        }
        40 => {
            next();
            asm_expr(s1, pe);
            skip(')' as i32);
        }
        46 => {
            (*pe).v = ind as uint64_t;
            (*pe).sym = asm_section_sym(s1, (*tcc_state).cur_text_section);
            (*pe).pcrel = 0 as libc::c_int;
            next();
        }
        _ => {
            if tok >= 256 as libc::c_int {
                let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
                sym = get_asm_sym(tok, 0 as *mut Sym);
                esym = elfsym(sym);
                if !esym.is_null()
                    && (*esym).st_shndx as libc::c_int == 0xfff1 as libc::c_int
                {
                    (*pe).v = (*esym).st_value;
                    (*pe).sym = 0 as *mut Sym;
                    (*pe).pcrel = 0 as libc::c_int;
                } else {
                    (*pe).v = 0 as libc::c_int as uint64_t;
                    (*pe).sym = sym;
                    (*pe).pcrel = 0 as libc::c_int;
                }
                next();
            } else {
                _tcc_error(
                    b"bad expression syntax [%s]\0" as *const u8 as *const libc::c_char,
                    get_tok_str(tok, &mut tokc),
                );
            }
        }
    };
}
unsafe extern "C" fn asm_expr_prod(mut s1: *mut TCCState, mut pe: *mut ExprValue) {
    let mut op: libc::c_int = 0;
    let mut e2: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    asm_expr_unary(s1, pe);
    loop {
        op = tok;
        if op != '*' as i32 && op != '/' as i32 && op != '%' as i32 && op != '<' as i32
            && op != '>' as i32
        {
            break;
        }
        next();
        asm_expr_unary(s1, &mut e2);
        if !((*pe).sym).is_null() || !(e2.sym).is_null() {
            _tcc_error(
                b"invalid operation with label\0" as *const u8 as *const libc::c_char,
            );
        }
        let mut current_block_11: u64;
        match op {
            42 => {
                (*pe).v = (*pe).v * e2.v;
                current_block_11 = 17833034027772472439;
            }
            47 => {
                if e2.v == 0 as libc::c_int as uint64_t {
                    current_block_11 = 5787426337708173490;
                } else {
                    (*pe).v = (*pe).v / e2.v;
                    current_block_11 = 17833034027772472439;
                }
            }
            37 => {
                if e2.v == 0 as libc::c_int as uint64_t {
                    current_block_11 = 5787426337708173490;
                } else {
                    (*pe).v = (*pe).v % e2.v;
                    current_block_11 = 17833034027772472439;
                }
            }
            60 => {
                (*pe).v <<= e2.v;
                current_block_11 = 17833034027772472439;
            }
            62 | _ => {
                (*pe).v >>= e2.v;
                current_block_11 = 17833034027772472439;
            }
        }
        match current_block_11 {
            17833034027772472439 => {}
            _ => {
                _tcc_error(b"division by zero\0" as *const u8 as *const libc::c_char);
            }
        }
    };
}
unsafe extern "C" fn asm_expr_logic(mut s1: *mut TCCState, mut pe: *mut ExprValue) {
    let mut op: libc::c_int = 0;
    let mut e2: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    asm_expr_prod(s1, pe);
    loop {
        op = tok;
        if op != '&' as i32 && op != '|' as i32 && op != '^' as i32 {
            break;
        }
        next();
        asm_expr_prod(s1, &mut e2);
        if !((*pe).sym).is_null() || !(e2.sym).is_null() {
            _tcc_error(
                b"invalid operation with label\0" as *const u8 as *const libc::c_char,
            );
        }
        match op {
            38 => {
                (*pe).v &= e2.v;
            }
            124 => {
                (*pe).v |= e2.v;
            }
            94 | _ => {
                (*pe).v ^= e2.v;
            }
        }
    };
}
#[inline]
unsafe extern "C" fn asm_expr_sum(mut s1: *mut TCCState, mut pe: *mut ExprValue) {
    let mut esym1: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut esym2: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    let mut op: libc::c_int = 0;
    let mut e2: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    asm_expr_logic(s1, pe);
    loop {
        op = tok;
        if op != '+' as i32 && op != '-' as i32 {
            break;
        }
        next();
        asm_expr_logic(s1, &mut e2);
        if op == '+' as i32 {
            if !(!((*pe).sym).is_null() && !(e2.sym).is_null()) {
                (*pe).v = ((*pe).v).wrapping_add(e2.v);
                if ((*pe).sym).is_null() && !(e2.sym).is_null() {
                    (*pe).sym = e2.sym;
                }
                continue;
            }
        } else {
            (*pe).v = ((*pe).v).wrapping_sub(e2.v);
            if (e2.sym).is_null() {
                continue;
            }
            if (*pe).sym == e2.sym {
                (*pe).sym = 0 as *mut Sym;
                continue;
            } else {
                esym1 = 0 as *mut Elf64_Sym;
                esym2 = 0 as *mut Elf64_Sym;
                esym1 = elfsym((*pe).sym);
                esym2 = elfsym(e2.sym);
                if !esym2.is_null() {
                    if !esym1.is_null()
                        && (*esym1).st_shndx as libc::c_int
                            == (*esym2).st_shndx as libc::c_int
                        && (*esym1).st_shndx as libc::c_int != 0 as libc::c_int
                    {
                        (*pe)
                            .v = ((*pe).v)
                            .wrapping_add(
                                ((*esym1).st_value).wrapping_sub((*esym2).st_value),
                            );
                        (*pe).sym = 0 as *mut Sym;
                        continue;
                    } else if (*esym2).st_shndx as libc::c_int
                        == (*(*tcc_state).cur_text_section).sh_num
                    {
                        (*pe)
                            .v = ((*pe).v)
                            .wrapping_add(
                                (0 as libc::c_int as Elf64_Addr)
                                    .wrapping_sub((*esym2).st_value),
                            );
                        (*pe).pcrel = 1 as libc::c_int;
                        e2.sym = 0 as *mut Sym;
                        continue;
                    }
                }
            }
        }
        _tcc_error(
            b"invalid operation with label\0" as *const u8 as *const libc::c_char,
        );
    };
}
#[inline]
unsafe extern "C" fn asm_expr_cmp(mut s1: *mut TCCState, mut pe: *mut ExprValue) {
    let mut op: libc::c_int = 0;
    let mut e2: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    asm_expr_sum(s1, pe);
    loop {
        op = tok;
        if op != 0x94 as libc::c_int && op != 0x95 as libc::c_int
            && (op > 0x9f as libc::c_int || op < 0x96 as libc::c_int)
        {
            break;
        }
        next();
        asm_expr_sum(s1, &mut e2);
        if !((*pe).sym).is_null() || !(e2.sym).is_null() {
            _tcc_error(
                b"invalid operation with label\0" as *const u8 as *const libc::c_char,
            );
        }
        match op {
            148 => {
                (*pe).v = ((*pe).v == e2.v) as libc::c_int as uint64_t;
            }
            149 => {
                (*pe).v = ((*pe).v != e2.v) as libc::c_int as uint64_t;
            }
            156 => {
                (*pe)
                    .v = (((*pe).v as int64_t) < e2.v as int64_t) as libc::c_int
                    as uint64_t;
            }
            157 => {
                (*pe)
                    .v = ((*pe).v as int64_t >= e2.v as int64_t) as libc::c_int
                    as uint64_t;
            }
            158 => {
                (*pe)
                    .v = ((*pe).v as int64_t <= e2.v as int64_t) as libc::c_int
                    as uint64_t;
            }
            159 => {
                (*pe)
                    .v = ((*pe).v as int64_t > e2.v as int64_t) as libc::c_int
                    as uint64_t;
            }
            _ => {}
        }
        (*pe).v = -((*pe).v as int64_t) as uint64_t;
    };
}
unsafe extern "C" fn asm_expr(mut s1: *mut TCCState, mut pe: *mut ExprValue) {
    asm_expr_cmp(s1, pe);
}
unsafe extern "C" fn asm_int_expr(mut s1: *mut TCCState) -> libc::c_int {
    let mut e: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    asm_expr(s1, &mut e);
    if !(e.sym).is_null() {
        expect(b"constant\0" as *const u8 as *const libc::c_char);
    }
    return e.v as libc::c_int;
}
unsafe extern "C" fn asm_new_label1(
    mut s1: *mut TCCState,
    mut label: libc::c_int,
    mut is_local: libc::c_int,
    mut sh_num: libc::c_int,
    mut value: libc::c_int,
) -> *mut Sym {
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    sym = asm_label_find(label);
    let mut current_block_4: u64;
    if !sym.is_null() {
        esym = elfsym(sym);
        if !esym.is_null() && (*esym).st_shndx as libc::c_int != 0 as libc::c_int {
            if (*sym).type_0.t
                & (0xf as libc::c_int
                    | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int))
                == 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
                && (is_local == 1 as libc::c_int
                    || (*sym).type_0.t & 0x1000 as libc::c_int != 0)
            {
                current_block_4 = 11857991675742611322;
            } else {
                if (*sym).type_0.t & 0x1000 as libc::c_int == 0 {
                    _tcc_error(
                        b"assembler label '%s' already defined\0" as *const u8
                            as *const libc::c_char,
                        get_tok_str(label, 0 as *mut CValue),
                    );
                }
                current_block_4 = 8515828400728868193;
            }
        } else {
            current_block_4 = 8515828400728868193;
        }
    } else {
        current_block_4 = 11857991675742611322;
    }
    match current_block_4 {
        11857991675742611322 => {
            sym = asm_label_push(label);
        }
        _ => {}
    }
    if (*sym).c2rust_unnamed.c2rust_unnamed.c == 0 {
        put_extern_sym2(
            sym,
            0 as libc::c_int,
            0 as libc::c_int as Elf64_Addr,
            0 as libc::c_int as libc::c_ulong,
            1 as libc::c_int,
        );
    }
    esym = elfsym(sym);
    (*esym).st_shndx = sh_num as Elf64_Section;
    (*esym).st_value = value as Elf64_Addr;
    if is_local != 2 as libc::c_int {
        (*sym).type_0.t &= !(0x1000 as libc::c_int);
    }
    return sym;
}
unsafe extern "C" fn asm_new_label(
    mut s1: *mut TCCState,
    mut label: libc::c_int,
    mut is_local: libc::c_int,
) -> *mut Sym {
    return asm_new_label1(
        s1,
        label,
        is_local,
        (*(*tcc_state).cur_text_section).sh_num,
        ind,
    );
}
unsafe extern "C" fn set_symbol(
    mut s1: *mut TCCState,
    mut label: libc::c_int,
) -> *mut Sym {
    let mut n: libc::c_long = 0;
    let mut e: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    let mut sym: *mut Sym = 0 as *mut Sym;
    let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
    next();
    asm_expr(s1, &mut e);
    n = e.v as libc::c_long;
    esym = elfsym(e.sym);
    if !esym.is_null() {
        n = (n as Elf64_Addr).wrapping_add((*esym).st_value) as libc::c_long
            as libc::c_long;
    }
    sym = asm_new_label1(
        s1,
        label,
        2 as libc::c_int,
        if !esym.is_null() {
            (*esym).st_shndx as libc::c_int
        } else {
            0xfff1 as libc::c_int
        },
        n as libc::c_int,
    );
    let ref mut fresh161 = (*elfsym(sym)).st_other;
    *fresh161 = (*fresh161 as libc::c_int | 0x4 as libc::c_int) as libc::c_uchar;
    return sym;
}
unsafe extern "C" fn use_section1(mut s1: *mut TCCState, mut sec: *mut Section) {
    (*(*tcc_state).cur_text_section).data_offset = ind as libc::c_ulong;
    (*tcc_state).cur_text_section = sec;
    ind = (*(*tcc_state).cur_text_section).data_offset as libc::c_int;
}
unsafe extern "C" fn use_section(mut s1: *mut TCCState, mut name: *const libc::c_char) {
    let mut sec: *mut Section = 0 as *mut Section;
    sec = find_section(s1, name);
    use_section1(s1, sec);
}
unsafe extern "C" fn push_section(mut s1: *mut TCCState, mut name: *const libc::c_char) {
    let mut sec: *mut Section = find_section(s1, name);
    (*sec).prev = (*tcc_state).cur_text_section;
    use_section1(s1, sec);
}
unsafe extern "C" fn pop_section(mut s1: *mut TCCState) {
    let mut prev: *mut Section = (*(*tcc_state).cur_text_section).prev;
    if prev.is_null() {
        _tcc_error(
            b".popsection without .pushsection\0" as *const u8 as *const libc::c_char,
        );
    }
    (*(*tcc_state).cur_text_section).prev = 0 as *mut Section;
    use_section1(s1, prev);
}
unsafe extern "C" fn asm_parse_directive(
    mut s1: *mut TCCState,
    mut global: libc::c_int,
) {
    let mut current_block: u64;
    let mut n: libc::c_int = 0;
    let mut offset: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut tok1: libc::c_int = 0;
    let mut sec: *mut Section = 0 as *mut Section;
    let mut ptr: *mut uint8_t = 0 as *mut uint8_t;
    sec = (*tcc_state).cur_text_section;
    match tok {
        465 | 466 | 467 | 469 | 470 => {
            tok1 = tok;
            next();
            n = asm_int_expr(s1);
            if tok1 == TOK_ASMDIR_p2align as libc::c_int {
                if n < 0 as libc::c_int || n > 30 as libc::c_int {
                    _tcc_error(
                        b"invalid p2align, must be between 0 and 30\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                n = (1 as libc::c_int) << n;
                tok1 = TOK_ASMDIR_align as libc::c_int;
            }
            if tok1 == TOK_ASMDIR_align as libc::c_int
                || tok1 == TOK_ASMDIR_balign as libc::c_int
            {
                if n < 0 as libc::c_int || n & n - 1 as libc::c_int != 0 as libc::c_int {
                    _tcc_error(
                        b"alignment must be a positive power of two\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                offset = ind + n - 1 as libc::c_int & -n;
                size = offset - ind;
                if (*sec).sh_addralign < n {
                    (*sec).sh_addralign = n;
                }
            } else {
                if n < 0 as libc::c_int {
                    n = 0 as libc::c_int;
                }
                size = n;
            }
            v = 0 as libc::c_int;
            if tok == ',' as i32 {
                next();
                v = asm_int_expr(s1);
            }
            current_block = 1991815874241808566;
        }
        492 => {
            size = 8 as libc::c_int;
            current_block = 5957234037001372331;
        }
        463 => {
            size = 1 as libc::c_int;
            current_block = 5957234037001372331;
        }
        464 | 494 => {
            size = 2 as libc::c_int;
            current_block = 5957234037001372331;
        }
        495 | 496 => {
            size = 4 as libc::c_int;
            current_block = 5957234037001372331;
        }
        488 => {
            let mut repeat: libc::c_int = 0;
            let mut size_0: libc::c_int = 0;
            let mut val: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            let mut j: libc::c_int = 0;
            let mut repeat_buf: [uint8_t; 8] = [0; 8];
            next();
            repeat = asm_int_expr(s1);
            if repeat < 0 as libc::c_int {
                _tcc_error(
                    b"repeat < 0; .fill ignored\0" as *const u8 as *const libc::c_char,
                );
            } else {
                size_0 = 1 as libc::c_int;
                val = 0 as libc::c_int;
                if tok == ',' as i32 {
                    next();
                    size_0 = asm_int_expr(s1);
                    if size_0 < 0 as libc::c_int {
                        _tcc_error(
                            b"size < 0; .fill ignored\0" as *const u8
                                as *const libc::c_char,
                        );
                    } else {
                        if size_0 > 8 as libc::c_int {
                            size_0 = 8 as libc::c_int;
                        }
                        if tok == ',' as i32 {
                            next();
                            val = asm_int_expr(s1);
                        }
                    }
                }
                repeat_buf[0 as libc::c_int as usize] = val as uint8_t;
                repeat_buf[1 as libc::c_int
                    as usize] = (val >> 8 as libc::c_int) as uint8_t;
                repeat_buf[2 as libc::c_int
                    as usize] = (val >> 16 as libc::c_int) as uint8_t;
                repeat_buf[3 as libc::c_int
                    as usize] = (val >> 24 as libc::c_int) as uint8_t;
                repeat_buf[4 as libc::c_int as usize] = 0 as libc::c_int as uint8_t;
                repeat_buf[5 as libc::c_int as usize] = 0 as libc::c_int as uint8_t;
                repeat_buf[6 as libc::c_int as usize] = 0 as libc::c_int as uint8_t;
                repeat_buf[7 as libc::c_int as usize] = 0 as libc::c_int as uint8_t;
                i = 0 as libc::c_int;
                while i < repeat {
                    j = 0 as libc::c_int;
                    while j < size_0 {
                        g(repeat_buf[j as usize] as libc::c_int);
                        j += 1;
                        j;
                    }
                    i += 1;
                    i;
                }
            }
            current_block = 8744643727662760496;
        }
        489 => {
            let mut repeat_0: libc::c_int = 0;
            let mut init_str: *mut TokenString = 0 as *mut TokenString;
            next();
            repeat_0 = asm_int_expr(s1);
            init_str = tok_str_alloc();
            loop {
                next();
                if !(tok != TOK_ASMDIR_endr as libc::c_int) {
                    break;
                }
                if tok == -(1 as libc::c_int) {
                    _tcc_error(
                        b"we at end of file, .endr not found\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                tok_str_add_tok(init_str);
            }
            tok_str_add(init_str, -(1 as libc::c_int));
            begin_macro(init_str, 1 as libc::c_int);
            loop {
                let fresh162 = repeat_0;
                repeat_0 = repeat_0 - 1;
                if !(fresh162 > 0 as libc::c_int) {
                    break;
                }
                tcc_assemble_internal(s1, parse_flags & 0x1 as libc::c_int, global);
                macro_ptr = (*init_str).str_0;
            }
            end_macro();
            next();
            current_block = 8744643727662760496;
        }
        491 => {
            let mut n_0: libc::c_ulong = 0;
            let mut e_0: ExprValue = ExprValue {
                v: 0,
                sym: 0 as *mut Sym,
                pcrel: 0,
            };
            let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
            next();
            asm_expr(s1, &mut e_0);
            n_0 = e_0.v;
            esym = elfsym(e_0.sym);
            if !esym.is_null() {
                if (*esym).st_shndx as libc::c_int
                    != (*(*tcc_state).cur_text_section).sh_num
                {
                    expect(
                        b"constant or same-section symbol\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                n_0 = n_0.wrapping_add((*esym).st_value);
            }
            if n_0 < ind as libc::c_ulong {
                _tcc_error(
                    b"attempt to .org backwards\0" as *const u8 as *const libc::c_char,
                );
            }
            v = 0 as libc::c_int;
            size = n_0.wrapping_sub(ind as libc::c_ulong) as libc::c_int;
            current_block = 1991815874241808566;
        }
        468 => {
            next();
            tok1 = tok;
            next();
            if tok == ',' as i32 {
                set_symbol(s1, tok1);
            }
            current_block = 8744643727662760496;
        }
        475 | 476 | 477 | 478 => {
            tok1 = tok;
            loop {
                let mut sym: *mut Sym = 0 as *mut Sym;
                next();
                sym = get_asm_sym(tok, 0 as *mut Sym);
                if tok1 != TOK_ASMDIR_hidden as libc::c_int {
                    (*sym).type_0.t &= !(0x2000 as libc::c_int);
                }
                if tok1 == TOK_ASMDIR_weak as libc::c_int {
                    ((*sym).a).set_weak(1 as libc::c_int as libc::c_ushort);
                } else if tok1 == TOK_ASMDIR_hidden as libc::c_int {
                    ((*sym).a).set_visibility(2 as libc::c_int as libc::c_ushort);
                }
                update_storage(sym);
                next();
                if !(tok == ',' as i32) {
                    break;
                }
            }
            current_block = 8744643727662760496;
        }
        471 | 473 | 472 => {
            let mut p: *const libc::c_char = 0 as *const libc::c_char;
            let mut i_0: libc::c_int = 0;
            let mut size_1: libc::c_int = 0;
            let mut t: libc::c_int = 0;
            t = tok;
            next();
            loop {
                if tok != 0xc8 as libc::c_int {
                    expect(b"string constant\0" as *const u8 as *const libc::c_char);
                }
                p = tokc.str_0.data;
                size_1 = tokc.str_0.size;
                if t == TOK_ASMDIR_ascii as libc::c_int && size_1 > 0 as libc::c_int {
                    size_1 -= 1;
                    size_1;
                }
                i_0 = 0 as libc::c_int;
                while i_0 < size_1 {
                    g(*p.offset(i_0 as isize) as libc::c_int);
                    i_0 += 1;
                    i_0;
                }
                next();
                if tok == ',' as i32 {
                    next();
                } else if tok != 0xc8 as libc::c_int {
                    break;
                }
            }
            current_block = 8744643727662760496;
        }
        482 | 483 | 484 => {
            let mut sname: [libc::c_char; 64] = [0; 64];
            tok1 = tok;
            n = 0 as libc::c_int;
            next();
            if tok != ';' as i32 && tok != 10 as libc::c_int {
                n = asm_int_expr(s1);
                next();
            }
            if n != 0 {
                sprintf(
                    sname.as_mut_ptr(),
                    b"%s%d\0" as *const u8 as *const libc::c_char,
                    get_tok_str(tok1, 0 as *mut CValue),
                    n,
                );
            } else {
                sprintf(
                    sname.as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    get_tok_str(tok1, 0 as *mut CValue),
                );
            }
            use_section(s1, sname.as_mut_ptr());
            current_block = 8744643727662760496;
        }
        474 => {
            let mut p_0: *const libc::c_char = 0 as *const libc::c_char;
            parse_flags &= !(0x40 as libc::c_int);
            next();
            if tok == 0xcd as libc::c_int {
                next();
            }
            if tok == 0xce as libc::c_int
                && *(tokc.str_0.data).offset(0 as libc::c_int as isize) as libc::c_int
                    == '"' as i32
            {
                *(tokc.str_0.data)
                    .offset(
                        (tokc.str_0.size - 2 as libc::c_int) as isize,
                    ) = 0 as libc::c_int as libc::c_char;
                p_0 = (tokc.str_0.data).offset(1 as libc::c_int as isize);
                current_block = 8968043056769084000;
            } else if tok >= 256 as libc::c_int {
                p_0 = get_tok_str(tok, &mut tokc);
                current_block = 8968043056769084000;
            } else {
                skip_to_eol(0 as libc::c_int);
                current_block = 8744643727662760496;
            }
            match current_block {
                8744643727662760496 => {}
                _ => {
                    tccpp_putfile(p_0);
                    next();
                    current_block = 8744643727662760496;
                }
            }
        }
        479 => {
            let mut ident: [libc::c_char; 256] = [0; 256];
            ident[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
            next();
            if tok == 0xc8 as libc::c_int {
                pstrcat(
                    ident.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    tokc.str_0.data,
                );
            } else {
                pstrcat(
                    ident.as_mut_ptr(),
                    ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                    get_tok_str(tok, 0 as *mut CValue),
                );
            }
            (*tcc_state)
                .warn_num = (&mut (*(0 as *mut TCCState)).warn_unsupported
                as *mut libc::c_uchar as size_t)
                .wrapping_sub(
                    &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                        as size_t,
                ) as libc::c_uchar;
            (Some(_tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> ()))
                .expect(
                    "non-null function pointer",
                )(
                b"ignoring .ident %s\0" as *const u8 as *const libc::c_char,
                ident.as_mut_ptr(),
            );
            next();
            current_block = 8744643727662760496;
        }
        480 => {
            let mut sym_0: *mut Sym = 0 as *mut Sym;
            next();
            sym_0 = asm_label_find(tok);
            if sym_0.is_null() {
                _tcc_error(
                    b"label not found: %s\0" as *const u8 as *const libc::c_char,
                    get_tok_str(tok, 0 as *mut CValue),
                );
            }
            (*tcc_state)
                .warn_num = (&mut (*(0 as *mut TCCState)).warn_unsupported
                as *mut libc::c_uchar as size_t)
                .wrapping_sub(
                    &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                        as size_t,
                ) as libc::c_uchar;
            (Some(_tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> ()))
                .expect(
                    "non-null function pointer",
                )(
                b"ignoring .size %s,*\0" as *const u8 as *const libc::c_char,
                get_tok_str(tok, 0 as *mut CValue),
            );
            next();
            skip(',' as i32);
            while tok != 10 as libc::c_int && tok != ';' as i32
                && tok != -(1 as libc::c_int)
            {
                next();
            }
            current_block = 8744643727662760496;
        }
        481 => {
            let mut sym_1: *mut Sym = 0 as *mut Sym;
            let mut newtype: *const libc::c_char = 0 as *const libc::c_char;
            let mut st_type: libc::c_int = 0;
            next();
            sym_1 = get_asm_sym(tok, 0 as *mut Sym);
            next();
            skip(',' as i32);
            if tok == 0xc8 as libc::c_int {
                newtype = tokc.str_0.data;
            } else {
                if tok == '@' as i32 || tok == '%' as i32 {
                    next();
                }
                newtype = get_tok_str(tok, 0 as *mut CValue);
            }
            let mut current_block_211: u64;
            if strcmp(newtype, b"function\0" as *const u8 as *const libc::c_char) == 0
                || strcmp(newtype, b"STT_FUNC\0" as *const u8 as *const libc::c_char)
                    == 0
            {
                if (*sym_1).type_0.t
                    & (0xf as libc::c_int
                        | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int))
                    == 0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
                {
                    (*sym_1)
                        .type_0
                        .t = (*sym_1).type_0.t
                        & !(0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int)
                        | (0 as libc::c_int | (1 as libc::c_int) << 20 as libc::c_int
                            | (2 as libc::c_int) << 20 as libc::c_int);
                }
                st_type = 2 as libc::c_int;
                current_block_211 = 9420223868266379005;
            } else if strcmp(newtype, b"object\0" as *const u8 as *const libc::c_char)
                == 0
                || strcmp(newtype, b"STT_OBJECT\0" as *const u8 as *const libc::c_char)
                    == 0
            {
                st_type = 1 as libc::c_int;
                current_block_211 = 9420223868266379005;
            } else {
                (*tcc_state)
                    .warn_num = (&mut (*(0 as *mut TCCState)).warn_unsupported
                    as *mut libc::c_uchar as size_t)
                    .wrapping_sub(
                        &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                            as size_t,
                    ) as libc::c_uchar;
                (Some(
                    _tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"change type of '%s' from 0x%x to '%s' ignored\0" as *const u8
                        as *const libc::c_char,
                    get_tok_str((*sym_1).v, 0 as *mut CValue),
                    (*sym_1).type_0.t,
                    newtype,
                );
                current_block_211 = 12153365054289215322;
            }
            match current_block_211 {
                9420223868266379005 => {
                    if (*sym_1).c2rust_unnamed.c2rust_unnamed.c != 0 {
                        let mut esym_0: *mut Elf64_Sym = elfsym(sym_1);
                        (*esym_0)
                            .st_info = ((((*esym_0).st_info as libc::c_int
                            >> 4 as libc::c_int) << 4 as libc::c_int)
                            + (st_type & 0xf as libc::c_int)) as libc::c_uchar;
                    }
                }
                _ => {}
            }
            next();
            current_block = 8744643727662760496;
        }
        486 | 498 => {
            let mut sname_0: [libc::c_char; 256] = [0; 256];
            let mut old_nb_section: libc::c_int = (*s1).nb_sections;
            let mut flags: libc::c_int = (1 as libc::c_int) << 1 as libc::c_int;
            tok1 = tok;
            next();
            sname_0[0 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
            while tok != ';' as i32 && tok != 10 as libc::c_int && tok != ',' as i32 {
                if tok == 0xc8 as libc::c_int {
                    pstrcat(
                        sname_0.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        tokc.str_0.data,
                    );
                } else {
                    pstrcat(
                        sname_0.as_mut_ptr(),
                        ::core::mem::size_of::<[libc::c_char; 256]>() as libc::c_ulong,
                        get_tok_str(tok, 0 as *mut CValue),
                    );
                }
                next();
            }
            if tok == ',' as i32 {
                let mut p_1: *const libc::c_char = 0 as *const libc::c_char;
                next();
                if tok != 0xc8 as libc::c_int {
                    expect(b"string constant\0" as *const u8 as *const libc::c_char);
                }
                p_1 = tokc.str_0.data;
                while *p_1 != 0 {
                    if *p_1 as libc::c_int == 'w' as i32 {
                        flags |= (1 as libc::c_int) << 0 as libc::c_int;
                    }
                    if *p_1 as libc::c_int == 'x' as i32 {
                        flags |= (1 as libc::c_int) << 2 as libc::c_int;
                    }
                    p_1 = p_1.offset(1);
                    p_1;
                }
                next();
                if tok == ',' as i32 {
                    next();
                    if tok == '@' as i32 || tok == '%' as i32 {
                        next();
                    }
                    next();
                }
            }
            last_text_section = (*tcc_state).cur_text_section;
            if tok1 == TOK_ASMDIR_section as libc::c_int {
                use_section(s1, sname_0.as_mut_ptr());
            } else {
                push_section(s1, sname_0.as_mut_ptr());
            }
            if old_nb_section != (*s1).nb_sections {
                (*(*tcc_state).cur_text_section).sh_addralign = 1 as libc::c_int;
                (*(*tcc_state).cur_text_section).sh_flags = flags;
            }
            current_block = 8744643727662760496;
        }
        485 => {
            let mut sec_0: *mut Section = 0 as *mut Section;
            next();
            if last_text_section.is_null() {
                _tcc_error(
                    b"no previous section referenced\0" as *const u8
                        as *const libc::c_char,
                );
            }
            sec_0 = (*tcc_state).cur_text_section;
            use_section1(s1, last_text_section);
            last_text_section = sec_0;
            current_block = 8744643727662760496;
        }
        487 => {
            next();
            pop_section(s1);
            current_block = 8744643727662760496;
        }
        493 => {
            next();
            current_block = 8744643727662760496;
        }
        497 => {
            next();
            next();
            skip(',' as i32);
            next();
            skip('@' as i32);
            next();
            current_block = 8744643727662760496;
        }
        _ => {
            _tcc_error(
                b"unknown assembler directive '.%s'\0" as *const u8
                    as *const libc::c_char,
                get_tok_str(tok, 0 as *mut CValue),
            );
        }
    }
    match current_block {
        5957234037001372331 => {
            next();
            loop {
                let mut e: ExprValue = ExprValue {
                    v: 0,
                    sym: 0 as *mut Sym,
                    pcrel: 0,
                };
                asm_expr(s1, &mut e);
                if (*sec).sh_type != 8 as libc::c_int {
                    if size == 4 as libc::c_int {
                        gen_expr32(&mut e);
                    } else if size == 8 as libc::c_int {
                        gen_expr64(&mut e);
                    } else {
                        if !(e.sym).is_null() {
                            expect(b"constant\0" as *const u8 as *const libc::c_char);
                        }
                        if size == 1 as libc::c_int {
                            g(e.v as libc::c_int);
                        } else {
                            gen_le16(e.v as libc::c_int);
                        }
                    }
                } else {
                    ind += size;
                }
                if tok != ',' as i32 {
                    break;
                }
                next();
            }
        }
        1991815874241808566 => {
            if (*sec).sh_type != 8 as libc::c_int {
                (*sec).data_offset = ind as libc::c_ulong;
                ptr = section_ptr_add(sec, size as Elf64_Addr) as *mut uint8_t;
                memset(ptr as *mut libc::c_void, v, size as libc::c_ulong);
            }
            ind += size;
        }
        _ => {}
    };
}
unsafe extern "C" fn tcc_assemble_internal(
    mut s1: *mut TCCState,
    mut do_preprocess: libc::c_int,
    mut global: libc::c_int,
) -> libc::c_int {
    let mut opcode: libc::c_int = 0;
    let mut saved_parse_flags: libc::c_int = parse_flags;
    parse_flags = 0x8 as libc::c_int | 0x40 as libc::c_int;
    if do_preprocess != 0 {
        parse_flags |= 0x1 as libc::c_int;
    }
    loop {
        next();
        if tok == -(1 as libc::c_int) {
            break;
        }
        tcc_debug_line(s1);
        parse_flags |= 0x4 as libc::c_int;
        loop {
            if tok == '#' as i32 {
                while tok != 10 as libc::c_int {
                    next();
                }
                break;
            } else if tok >= TOK_ASMDIR_byte as libc::c_int
                && tok <= TOK_ASMDIR_section as libc::c_int
            {
                asm_parse_directive(s1, global);
                break;
            } else if tok == 0xcd as libc::c_int {
                let mut p: *const libc::c_char = 0 as *const libc::c_char;
                let mut n: libc::c_int = 0;
                p = tokc.str_0.data;
                n = strtoul(
                    p,
                    &mut p as *mut *const libc::c_char as *mut *mut libc::c_char,
                    10 as libc::c_int,
                ) as libc::c_int;
                if *p as libc::c_int != '\0' as i32 {
                    expect(b"':'\0" as *const u8 as *const libc::c_char);
                }
                asm_new_label(
                    s1,
                    asm_get_local_label_name(s1, n as libc::c_uint),
                    1 as libc::c_int,
                );
                next();
                skip(':' as i32);
            } else {
                if !(tok >= 256 as libc::c_int) {
                    break;
                }
                opcode = tok;
                next();
                if tok == ':' as i32 {
                    asm_new_label(s1, opcode, 0 as libc::c_int);
                    next();
                } else if tok == '=' as i32 {
                    set_symbol(s1, opcode);
                } else {
                    asm_opcode(s1, opcode);
                    break;
                }
            }
        }
        if tok != ';' as i32 && tok != 10 as libc::c_int {
            expect(b"end of line\0" as *const u8 as *const libc::c_char);
        }
        parse_flags &= !(0x4 as libc::c_int);
    }
    parse_flags = saved_parse_flags;
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcc_assemble(
    mut s1: *mut TCCState,
    mut do_preprocess: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_int = 0;
    tcc_debug_start(s1);
    (*tcc_state).cur_text_section = (*tcc_state).text_section;
    ind = (*(*tcc_state).cur_text_section).data_offset as libc::c_int;
    nocode_wanted = 0 as libc::c_int;
    ret = tcc_assemble_internal(s1, do_preprocess, 1 as libc::c_int);
    (*(*tcc_state).cur_text_section).data_offset = ind as libc::c_ulong;
    tcc_debug_end(s1);
    return ret;
}
unsafe extern "C" fn tcc_assemble_inline(
    mut s1: *mut TCCState,
    mut str: *const libc::c_char,
    mut len: libc::c_int,
    mut global: libc::c_int,
) {
    let mut saved_macro_ptr: *const libc::c_int = macro_ptr;
    let mut dotid: libc::c_int = set_idnum('.' as i32, 2 as libc::c_int);
    let mut dolid: libc::c_int = set_idnum('$' as i32, 0 as libc::c_int);
    tcc_open_bf(s1, b":asm:\0" as *const u8 as *const libc::c_char, len);
    memcpy(
        ((*file).buffer).as_mut_ptr() as *mut libc::c_void,
        str as *const libc::c_void,
        len as libc::c_ulong,
    );
    macro_ptr = 0 as *const libc::c_int;
    tcc_assemble_internal(s1, 0 as libc::c_int, global);
    tcc_close();
    set_idnum('$' as i32, dolid);
    set_idnum('.' as i32, dotid);
    macro_ptr = saved_macro_ptr;
}
unsafe extern "C" fn find_constraint(
    mut operands: *mut ASMOperand,
    mut nb_operands: libc::c_int,
    mut name: *const libc::c_char,
    mut pp: *mut *const libc::c_char,
) -> libc::c_int {
    let mut index: libc::c_int = 0;
    let mut ts: *mut TokenSym = 0 as *mut TokenSym;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    if isnum(*name as libc::c_int) != 0 {
        index = 0 as libc::c_int;
        while isnum(*name as libc::c_int) != 0 {
            index = index * 10 as libc::c_int + *name as libc::c_int - '0' as i32;
            name = name.offset(1);
            name;
        }
        if index as libc::c_uint >= nb_operands as libc::c_uint {
            index = -(1 as libc::c_int);
        }
    } else if *name as libc::c_int == '[' as i32 {
        name = name.offset(1);
        name;
        p = strchr(name, ']' as i32);
        if !p.is_null() {
            let mut current_block_13: u64;
            ts = tok_alloc(name, p.offset_from(name) as libc::c_long as libc::c_int);
            index = 0 as libc::c_int;
            loop {
                if !(index < nb_operands) {
                    current_block_13 = 8236137900636309791;
                    break;
                }
                if (*operands.offset(index as isize)).id == (*ts).tok {
                    current_block_13 = 8240901718659468782;
                    break;
                }
                index += 1;
                index;
            }
            match current_block_13 {
                8236137900636309791 => {
                    index = -(1 as libc::c_int);
                }
                _ => {}
            }
            name = p.offset(1 as libc::c_int as isize);
        } else {
            index = -(1 as libc::c_int);
        }
    } else {
        index = -(1 as libc::c_int);
    }
    if !pp.is_null() {
        *pp = name;
    }
    return index;
}
unsafe extern "C" fn subst_asm_operands(
    mut operands: *mut ASMOperand,
    mut nb_operands: libc::c_int,
    mut out_str: *mut CString,
    mut str: *const libc::c_char,
) {
    let mut c: libc::c_int = 0;
    let mut index: libc::c_int = 0;
    let mut modifier: libc::c_int = 0;
    let mut op: *mut ASMOperand = 0 as *mut ASMOperand;
    let mut sv: SValue = SValue {
        type_0: CType {
            t: 0,
            ref_0: 0 as *mut Sym,
        },
        r: 0,
        r2: 0,
        c2rust_unnamed: C2RustUnnamed_15 {
            c2rust_unnamed: C2RustUnnamed_16 {
                jtrue: 0,
                jfalse: 0,
            },
        },
        c2rust_unnamed_0: C2RustUnnamed_13 {
            c2rust_unnamed: C2RustUnnamed_14 {
                cmp_op: 0,
                cmp_r: 0,
            },
        },
    };
    loop {
        let fresh163 = str;
        str = str.offset(1);
        c = *fresh163 as libc::c_int;
        if c == '%' as i32 {
            if *str as libc::c_int == '%' as i32 {
                str = str.offset(1);
                str;
            } else {
                modifier = 0 as libc::c_int;
                if *str as libc::c_int == 'c' as i32 || *str as libc::c_int == 'n' as i32
                    || *str as libc::c_int == 'b' as i32
                    || *str as libc::c_int == 'w' as i32
                    || *str as libc::c_int == 'h' as i32
                    || *str as libc::c_int == 'k' as i32
                    || *str as libc::c_int == 'q' as i32
                    || *str as libc::c_int == 'l' as i32
                    || *str as libc::c_int == 'P' as i32
                {
                    let fresh164 = str;
                    str = str.offset(1);
                    modifier = *fresh164 as libc::c_int;
                }
                index = find_constraint(operands, nb_operands, str, &mut str);
                if index < 0 as libc::c_int {
                    _tcc_error(
                        b"invalid operand reference after %%\0" as *const u8
                            as *const libc::c_char,
                    );
                }
                op = &mut *operands.offset(index as isize) as *mut ASMOperand;
                if modifier == 'l' as i32 {
                    cstr_cat(
                        out_str,
                        get_tok_str((*op).is_label, 0 as *mut CValue),
                        -(1 as libc::c_int),
                    );
                } else {
                    sv = *(*op).vt;
                    if (*op).reg >= 0 as libc::c_int {
                        sv.r = (*op).reg as libc::c_ushort;
                        if (*(*op).vt).r as libc::c_int & 0x3f as libc::c_int
                            == 0x31 as libc::c_int && (*op).is_memory != 0
                        {
                            sv
                                .r = (sv.r as libc::c_int | 0x100 as libc::c_int)
                                as libc::c_ushort;
                        }
                    }
                    subst_asm_operand(out_str, &mut sv, modifier);
                }
                continue;
            }
        }
        cstr_ccat(out_str, c);
        if c == '\0' as i32 {
            break;
        }
    };
}
unsafe extern "C" fn parse_asm_operands(
    mut operands: *mut ASMOperand,
    mut nb_operands_ptr: *mut libc::c_int,
    mut is_output: libc::c_int,
) {
    let mut op: *mut ASMOperand = 0 as *mut ASMOperand;
    let mut nb_operands: libc::c_int = 0;
    let mut astr: *mut libc::c_char = 0 as *mut libc::c_char;
    if tok != ':' as i32 {
        nb_operands = *nb_operands_ptr;
        loop {
            if nb_operands >= 30 as libc::c_int {
                _tcc_error(
                    b"too many asm operands\0" as *const u8 as *const libc::c_char,
                );
            }
            let fresh165 = nb_operands;
            nb_operands = nb_operands + 1;
            op = &mut *operands.offset(fresh165 as isize) as *mut ASMOperand;
            (*op).id = 0 as libc::c_int;
            if tok == '[' as i32 {
                next();
                if tok < 256 as libc::c_int {
                    expect(b"identifier\0" as *const u8 as *const libc::c_char);
                }
                (*op).id = tok;
                next();
                skip(']' as i32);
            }
            astr = (*parse_mult_str(
                b"string constant\0" as *const u8 as *const libc::c_char,
            ))
                .data;
            pstrcpy(
                ((*op).constraint).as_mut_ptr(),
                ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
                astr,
            );
            skip('(' as i32);
            gexpr();
            if is_output != 0 {
                if (*vtop).type_0.t & 0x40 as libc::c_int == 0 {
                    test_lvalue();
                }
            } else if (*vtop).r as libc::c_int & 0x100 as libc::c_int != 0
                && ((*vtop).r as libc::c_int & 0x3f as libc::c_int == 0x31 as libc::c_int
                    || ((*vtop).r as libc::c_int & 0x3f as libc::c_int)
                        < 0x30 as libc::c_int)
                && (strchr(((*op).constraint).as_mut_ptr(), 'm' as i32)).is_null()
            {
                gv(0x1 as libc::c_int);
            }
            (*op).vt = vtop;
            skip(')' as i32);
            if !(tok == ',' as i32) {
                break;
            }
            next();
        }
        *nb_operands_ptr = nb_operands;
    }
}
unsafe extern "C" fn asm_instr() {
    let mut astr: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    let mut astr1: *mut CString = 0 as *mut CString;
    let mut operands: [ASMOperand; 30] = [ASMOperand {
        id: 0,
        constraint: [0; 16],
        asm_str: [0; 16],
        vt: 0 as *mut SValue,
        ref_index: 0,
        input_index: 0,
        priority: 0,
        reg: 0,
        is_llong: 0,
        is_memory: 0,
        is_rw: 0,
        is_label: 0,
    }; 30];
    let mut nb_outputs: libc::c_int = 0;
    let mut nb_operands: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut must_subst: libc::c_int = 0;
    let mut out_reg: libc::c_int = 0;
    let mut nb_labels: libc::c_int = 0;
    let mut clobber_regs: [uint8_t; 16] = [0; 16];
    let mut sec: *mut Section = 0 as *mut Section;
    while tok == TOK_VOLATILE1 as libc::c_int || tok == TOK_VOLATILE2 as libc::c_int
        || tok == TOK_VOLATILE3 as libc::c_int || tok == TOK_GOTO as libc::c_int
    {
        next();
    }
    astr1 = parse_asm_str();
    cstr_new(&mut astr);
    dynarray_add(
        &mut stk_data as *mut *mut *mut libc::c_void as *mut libc::c_void,
        &mut nb_stk_data,
        &mut astr.data as *mut *mut libc::c_char as *mut libc::c_void,
    );
    cstr_cat(&mut astr, (*astr1).data, (*astr1).size);
    nb_operands = 0 as libc::c_int;
    nb_outputs = 0 as libc::c_int;
    nb_labels = 0 as libc::c_int;
    must_subst = 0 as libc::c_int;
    memset(
        clobber_regs.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong,
    );
    if tok == ':' as i32 {
        next();
        must_subst = 1 as libc::c_int;
        parse_asm_operands(operands.as_mut_ptr(), &mut nb_operands, 1 as libc::c_int);
        nb_outputs = nb_operands;
        if tok == ':' as i32 {
            next();
            if tok != ')' as i32 {
                parse_asm_operands(
                    operands.as_mut_ptr(),
                    &mut nb_operands,
                    0 as libc::c_int,
                );
                if tok == ':' as i32 {
                    next();
                    while !(tok == ':' as i32) {
                        if tok != 0xc8 as libc::c_int {
                            expect(
                                b"string constant\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        asm_clobber(clobber_regs.as_mut_ptr(), tokc.str_0.data);
                        next();
                        if !(tok == ',' as i32) {
                            break;
                        }
                        next();
                    }
                }
                if tok == ':' as i32 {
                    next();
                    loop {
                        let mut csym: *mut Sym = 0 as *mut Sym;
                        let mut asmname: libc::c_int = 0;
                        if nb_operands + nb_labels >= 30 as libc::c_int {
                            _tcc_error(
                                b"too many asm operands\0" as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        if tok < TOK_DEFINE as libc::c_int {
                            expect(
                                b"label identifier\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        let fresh166 = nb_labels;
                        nb_labels = nb_labels + 1;
                        operands[(nb_operands + fresh166) as usize].id = tok;
                        csym = label_find(tok);
                        if csym.is_null() {
                            csym = label_push(
                                &mut global_label_stack,
                                tok,
                                1 as libc::c_int,
                            );
                        } else if (*csym).r as libc::c_int == 2 as libc::c_int {
                            (*csym).r = 1 as libc::c_int as libc::c_ushort;
                        }
                        next();
                        asmgoto_n += 1;
                        asmname = asm_get_prefix_name(
                            tcc_state,
                            b"LG.\0" as *const u8 as *const libc::c_char,
                            asmgoto_n as libc::c_uint,
                        );
                        if (*csym).c2rust_unnamed.c2rust_unnamed.c == 0 {
                            put_extern_sym2(
                                csym,
                                0 as libc::c_int,
                                0 as libc::c_int as Elf64_Addr,
                                0 as libc::c_int as libc::c_ulong,
                                1 as libc::c_int,
                            );
                        }
                        get_asm_sym(asmname, csym);
                        operands[(nb_operands + nb_labels - 1 as libc::c_int) as usize]
                            .is_label = asmname;
                        if tok != ',' as i32 {
                            break;
                        }
                        next();
                    }
                }
            }
        }
    }
    skip(')' as i32);
    if tok != ';' as i32 {
        expect(b"';'\0" as *const u8 as *const libc::c_char);
    }
    save_regs(0 as libc::c_int);
    asm_compute_constraints(
        operands.as_mut_ptr(),
        nb_operands,
        nb_outputs,
        clobber_regs.as_mut_ptr(),
        &mut out_reg,
    );
    if must_subst != 0 {
        cstr_reset(astr1);
        cstr_cat(astr1, astr.data, astr.size);
        cstr_reset(&mut astr);
        subst_asm_operands(
            operands.as_mut_ptr(),
            nb_operands + nb_labels,
            &mut astr,
            (*astr1).data,
        );
    }
    asm_gen_code(
        operands.as_mut_ptr(),
        nb_operands,
        nb_outputs,
        0 as libc::c_int,
        clobber_regs.as_mut_ptr(),
        out_reg,
    );
    sec = (*tcc_state).cur_text_section;
    tcc_assemble_inline(
        tcc_state,
        astr.data,
        astr.size - 1 as libc::c_int,
        0 as libc::c_int,
    );
    cstr_free(&mut astr);
    nb_stk_data -= 1;
    nb_stk_data;
    if sec != (*tcc_state).cur_text_section {
        _tcc_warning(
            b"inline asm tries to change current section\0" as *const u8
                as *const libc::c_char,
        );
        use_section1(tcc_state, sec);
    }
    next();
    asm_gen_code(
        operands.as_mut_ptr(),
        nb_operands,
        nb_outputs,
        1 as libc::c_int,
        clobber_regs.as_mut_ptr(),
        out_reg,
    );
    i = 0 as libc::c_int;
    while i < nb_operands {
        vpop();
        i += 1;
        i;
    }
}
unsafe extern "C" fn asm_global_instr() {
    let mut astr: *mut CString = 0 as *mut CString;
    let mut saved_nocode_wanted: libc::c_int = nocode_wanted;
    nocode_wanted = 0 as libc::c_int;
    next();
    astr = parse_asm_str();
    skip(')' as i32);
    if tok != ';' as i32 {
        expect(b"';'\0" as *const u8 as *const libc::c_char);
    }
    (*tcc_state).cur_text_section = (*tcc_state).text_section;
    ind = (*(*tcc_state).cur_text_section).data_offset as libc::c_int;
    tcc_assemble_inline(
        tcc_state,
        (*astr).data,
        (*astr).size - 1 as libc::c_int,
        1 as libc::c_int,
    );
    (*(*tcc_state).cur_text_section).data_offset = ind as libc::c_ulong;
    next();
    nocode_wanted = saved_nocode_wanted;
}
static mut reg_to_size: [uint8_t; 9] = [
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    1 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    2 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    0 as libc::c_int as uint8_t,
    3 as libc::c_int as uint8_t,
];
static mut test_bits: [uint8_t; 30] = [
    0 as libc::c_int as uint8_t,
    0x1 as libc::c_int as uint8_t,
    0x2 as libc::c_int as uint8_t,
    0x2 as libc::c_int as uint8_t,
    0x2 as libc::c_int as uint8_t,
    0x3 as libc::c_int as uint8_t,
    0x3 as libc::c_int as uint8_t,
    0x3 as libc::c_int as uint8_t,
    0x4 as libc::c_int as uint8_t,
    0x4 as libc::c_int as uint8_t,
    0x5 as libc::c_int as uint8_t,
    0x5 as libc::c_int as uint8_t,
    0x6 as libc::c_int as uint8_t,
    0x6 as libc::c_int as uint8_t,
    0x7 as libc::c_int as uint8_t,
    0x7 as libc::c_int as uint8_t,
    0x8 as libc::c_int as uint8_t,
    0x9 as libc::c_int as uint8_t,
    0xa as libc::c_int as uint8_t,
    0xa as libc::c_int as uint8_t,
    0xb as libc::c_int as uint8_t,
    0xb as libc::c_int as uint8_t,
    0xc as libc::c_int as uint8_t,
    0xc as libc::c_int as uint8_t,
    0xd as libc::c_int as uint8_t,
    0xd as libc::c_int as uint8_t,
    0xe as libc::c_int as uint8_t,
    0xe as libc::c_int as uint8_t,
    0xf as libc::c_int as uint8_t,
    0xf as libc::c_int as uint8_t,
];
static mut segment_prefixes: [uint8_t; 6] = [
    0x26 as libc::c_int as uint8_t,
    0x2e as libc::c_int as uint8_t,
    0x36 as libc::c_int as uint8_t,
    0x3e as libc::c_int as uint8_t,
    0x64 as libc::c_int as uint8_t,
    0x65 as libc::c_int as uint8_t,
];
static mut asm_instrs: [ASMInstr; 347] = [ASMInstr {
    sym: 0,
    opcode: 0,
    instr_type: 0,
    nb_ops: 0,
    op_type: [0; 3],
}; 347];
static mut op0_codes: [uint16_t; 96] = [
    0xf8 as libc::c_int as uint16_t,
    0xfc as libc::c_int as uint16_t,
    0xfa as libc::c_int as uint16_t,
    0xf06 as libc::c_int as uint16_t,
    0xf5 as libc::c_int as uint16_t,
    0x9f as libc::c_int as uint16_t,
    0x9e as libc::c_int as uint16_t,
    0x9c as libc::c_int as uint16_t,
    0x9d as libc::c_int as uint16_t,
    0x9c as libc::c_int as uint16_t,
    0x9d as libc::c_int as uint16_t,
    0xf9 as libc::c_int as uint16_t,
    0xfd as libc::c_int as uint16_t,
    0xfb as libc::c_int as uint16_t,
    0x37 as libc::c_int as uint16_t,
    0x3f as libc::c_int as uint16_t,
    0x27 as libc::c_int as uint16_t,
    0x2f as libc::c_int as uint16_t,
    0xd50a as libc::c_int as uint16_t,
    0xd40a as libc::c_int as uint16_t,
    0x6698 as libc::c_int as uint16_t,
    0x6699 as libc::c_int as uint16_t,
    0x98 as libc::c_int as uint16_t,
    0x99 as libc::c_int as uint16_t,
    0x6698 as libc::c_int as uint16_t,
    0x98 as libc::c_int as uint16_t,
    0x6699 as libc::c_int as uint16_t,
    0x99 as libc::c_int as uint16_t,
    0x4899 as libc::c_int as uint16_t,
    0xcc as libc::c_int as uint16_t,
    0xce as libc::c_int as uint16_t,
    0xcf as libc::c_int as uint16_t,
    0x66cf as libc::c_int as uint16_t,
    0xcf as libc::c_int as uint16_t,
    0x48cf as libc::c_int as uint16_t,
    0xfaa as libc::c_int as uint16_t,
    0xf4 as libc::c_int as uint16_t,
    0x9b as libc::c_int as uint16_t,
    0x90 as libc::c_int as uint16_t,
    0xf390 as libc::c_int as uint16_t,
    0xd7 as libc::c_int as uint16_t,
    0xf0 as libc::c_int as uint16_t,
    0xf3 as libc::c_int as uint16_t,
    0xf3 as libc::c_int as uint16_t,
    0xf3 as libc::c_int as uint16_t,
    0xf2 as libc::c_int as uint16_t,
    0xf2 as libc::c_int as uint16_t,
    0xf08 as libc::c_int as uint16_t,
    0xf09 as libc::c_int as uint16_t,
    0xfa2 as libc::c_int as uint16_t,
    0xf30 as libc::c_int as uint16_t,
    0xf31 as libc::c_int as uint16_t,
    0xf32 as libc::c_int as uint16_t,
    0xf33 as libc::c_int as uint16_t,
    0xf05 as libc::c_int as uint16_t,
    0xf07 as libc::c_int as uint16_t,
    0xf0b as libc::c_int as uint16_t,
    0xc9 as libc::c_int as uint16_t,
    0xc3 as libc::c_int as uint16_t,
    0xc3 as libc::c_int as uint16_t,
    0xcb as libc::c_int as uint16_t,
    0xdae9 as libc::c_int as uint16_t,
    0xd9e4 as libc::c_int as uint16_t,
    0xd9e5 as libc::c_int as uint16_t,
    0xd9e8 as libc::c_int as uint16_t,
    0xd9e9 as libc::c_int as uint16_t,
    0xd9ea as libc::c_int as uint16_t,
    0xd9eb as libc::c_int as uint16_t,
    0xd9ec as libc::c_int as uint16_t,
    0xd9ed as libc::c_int as uint16_t,
    0xd9ee as libc::c_int as uint16_t,
    0xd9f0 as libc::c_int as uint16_t,
    0xd9f1 as libc::c_int as uint16_t,
    0xd9f2 as libc::c_int as uint16_t,
    0xd9f3 as libc::c_int as uint16_t,
    0xd9f4 as libc::c_int as uint16_t,
    0xd9f5 as libc::c_int as uint16_t,
    0xd9f6 as libc::c_int as uint16_t,
    0xd9f7 as libc::c_int as uint16_t,
    0xd9f8 as libc::c_int as uint16_t,
    0xd9f9 as libc::c_int as uint16_t,
    0xd9fa as libc::c_int as uint16_t,
    0xd9fb as libc::c_int as uint16_t,
    0xd9fc as libc::c_int as uint16_t,
    0xd9fd as libc::c_int as uint16_t,
    0xd9fe as libc::c_int as uint16_t,
    0xd9ff as libc::c_int as uint16_t,
    0xd9e0 as libc::c_int as uint16_t,
    0xd9e1 as libc::c_int as uint16_t,
    0xdbe3 as libc::c_int as uint16_t,
    0xdbe2 as libc::c_int as uint16_t,
    0xd9d0 as libc::c_int as uint16_t,
    0x9b as libc::c_int as uint16_t,
    0xd9c9 as libc::c_int as uint16_t,
    0xdfe0 as libc::c_int as uint16_t,
    0xf77 as libc::c_int as uint16_t,
];
#[inline]
unsafe extern "C" fn get_reg_shift(mut s1: *mut TCCState) -> libc::c_int {
    let mut shift: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    v = asm_int_expr(s1);
    match v {
        1 => {
            shift = 0 as libc::c_int;
        }
        2 => {
            shift = 1 as libc::c_int;
        }
        4 => {
            shift = 2 as libc::c_int;
        }
        8 => {
            shift = 3 as libc::c_int;
        }
        _ => {
            expect(b"1, 2, 4 or 8 constant\0" as *const u8 as *const libc::c_char);
        }
    }
    return shift;
}
unsafe extern "C" fn asm_parse_numeric_reg(
    mut t: libc::c_int,
    mut type_0: *mut libc::c_uint,
) -> libc::c_int {
    let mut reg: libc::c_int = -(1 as libc::c_int);
    if t >= 256 as libc::c_int && t < tok_ident {
        let mut s: *const libc::c_char = ((**table_ident
            .offset((t - 256 as libc::c_int) as isize))
            .str_0)
            .as_mut_ptr();
        let mut c: libc::c_char = 0;
        *type_0 = ((1 as libc::c_int) << OPT_REG64 as libc::c_int) as libc::c_uint;
        if *s as libc::c_int == 'c' as i32 {
            s = s.offset(1);
            s;
            *type_0 = ((1 as libc::c_int) << OPT_CR as libc::c_int) as libc::c_uint;
        }
        let fresh167 = s;
        s = s.offset(1);
        if *fresh167 as libc::c_int != 'r' as i32 {
            return -(1 as libc::c_int);
        }
        let fresh168 = s;
        s = s.offset(1);
        c = *fresh168;
        if c as libc::c_int >= '1' as i32 && c as libc::c_int <= '9' as i32 {
            reg = c as libc::c_int - '0' as i32;
        } else {
            return -(1 as libc::c_int)
        }
        c = *s;
        if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '5' as i32 {
            s = s.offset(1);
            s;
            reg = reg * 10 as libc::c_int + c as libc::c_int - '0' as i32;
        }
        if reg > 15 as libc::c_int {
            return -(1 as libc::c_int);
        }
        c = *s;
        if !(c as libc::c_int == 0 as libc::c_int) {
            if *type_0
                != ((1 as libc::c_int) << OPT_REG64 as libc::c_int) as libc::c_uint
            {
                return -(1 as libc::c_int)
            } else if c as libc::c_int == 'b' as i32
                && *s.offset(1 as libc::c_int as isize) == 0
            {
                *type_0 = ((1 as libc::c_int) << OPT_REG8 as libc::c_int)
                    as libc::c_uint;
            } else if c as libc::c_int == 'w' as i32
                && *s.offset(1 as libc::c_int as isize) == 0
            {
                *type_0 = ((1 as libc::c_int) << OPT_REG16 as libc::c_int)
                    as libc::c_uint;
            } else if c as libc::c_int == 'd' as i32
                && *s.offset(1 as libc::c_int as isize) == 0
            {
                *type_0 = ((1 as libc::c_int) << OPT_REG32 as libc::c_int)
                    as libc::c_uint;
            } else {
                return -(1 as libc::c_int)
            }
        }
    }
    return reg;
}
unsafe extern "C" fn asm_parse_reg(mut type_0: *mut libc::c_uint) -> libc::c_int {
    let mut current_block: u64;
    let mut reg: libc::c_int = 0 as libc::c_int;
    *type_0 = 0 as libc::c_int as libc::c_uint;
    if !(tok != '%' as i32) {
        next();
        if tok >= TOK_ASM_eax as libc::c_int && tok <= TOK_ASM_edi as libc::c_int {
            reg = tok - TOK_ASM_eax as libc::c_int;
            *type_0 = ((1 as libc::c_int) << OPT_REG32 as libc::c_int) as libc::c_uint;
            current_block = 8236137900636309791;
        } else if tok >= TOK_ASM_rax as libc::c_int && tok <= TOK_ASM_rdi as libc::c_int
        {
            reg = tok - TOK_ASM_rax as libc::c_int;
            *type_0 = ((1 as libc::c_int) << OPT_REG64 as libc::c_int) as libc::c_uint;
            current_block = 8236137900636309791;
        } else if tok == TOK_ASM_rip as libc::c_int {
            reg = -(2 as libc::c_int);
            *type_0 = ((1 as libc::c_int) << OPT_REG64 as libc::c_int) as libc::c_uint;
            current_block = 8236137900636309791;
        } else {
            reg = asm_parse_numeric_reg(tok, type_0);
            if reg >= 0 as libc::c_int
                && (*type_0
                    == ((1 as libc::c_int) << OPT_REG32 as libc::c_int) as libc::c_uint
                    || *type_0
                        == ((1 as libc::c_int) << OPT_REG64 as libc::c_int)
                            as libc::c_uint)
            {
                current_block = 8236137900636309791;
            } else {
                current_block = 3521601658099059635;
            }
        }
        match current_block {
            3521601658099059635 => {}
            _ => {
                next();
                return reg;
            }
        }
    }
    expect(b"register\0" as *const u8 as *const libc::c_char);
}
unsafe extern "C" fn parse_operand(mut s1: *mut TCCState, mut op: *mut Operand) {
    let mut current_block: u64;
    let mut e: ExprValue = ExprValue {
        v: 0,
        sym: 0 as *mut Sym,
        pcrel: 0,
    };
    let mut reg: libc::c_int = 0;
    let mut indir_0: libc::c_int = 0;
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    indir_0 = 0 as libc::c_int;
    if tok == '*' as i32 {
        next();
        indir_0 = (1 as libc::c_int) << OPT_INDIR as libc::c_int;
    }
    if tok == '%' as i32 {
        next();
        if tok >= TOK_ASM_al as libc::c_int && tok <= TOK_ASM_db7 as libc::c_int {
            reg = tok - TOK_ASM_al as libc::c_int;
            (*op).type_0 = ((1 as libc::c_int) << (reg >> 3 as libc::c_int)) as uint32_t;
            (*op).reg = (reg & 7 as libc::c_int) as int8_t;
            if (*op).type_0
                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG64 as libc::c_int) as uint32_t != 0
                && (*op).reg as libc::c_int == TREG_RAX as libc::c_int
            {
                (*op).type_0
                    |= ((1 as libc::c_int) << OPT_EAX as libc::c_int) as uint32_t;
            } else if (*op).type_0
                == ((1 as libc::c_int) << OPT_REG8 as libc::c_int) as uint32_t
                && (*op).reg as libc::c_int == TREG_RCX as libc::c_int
            {
                (*op).type_0
                    |= ((1 as libc::c_int) << OPT_CL as libc::c_int) as uint32_t;
            } else if (*op).type_0
                == ((1 as libc::c_int) << OPT_REG16 as libc::c_int) as uint32_t
                && (*op).reg as libc::c_int == TREG_RDX as libc::c_int
            {
                (*op).type_0
                    |= ((1 as libc::c_int) << OPT_DX as libc::c_int) as uint32_t;
            }
            current_block = 13131896068329595644;
        } else if tok >= TOK_ASM_dr0 as libc::c_int && tok <= TOK_ASM_dr7 as libc::c_int
        {
            (*op).type_0 = ((1 as libc::c_int) << OPT_DB as libc::c_int) as uint32_t;
            (*op).reg = (tok - TOK_ASM_dr0 as libc::c_int) as int8_t;
            current_block = 13131896068329595644;
        } else if tok >= TOK_ASM_es as libc::c_int && tok <= TOK_ASM_gs as libc::c_int {
            (*op).type_0 = ((1 as libc::c_int) << OPT_SEG as libc::c_int) as uint32_t;
            (*op).reg = (tok - TOK_ASM_es as libc::c_int) as int8_t;
            current_block = 13131896068329595644;
        } else {
            if tok == TOK_ASM_st as libc::c_int {
                (*op).type_0 = ((1 as libc::c_int) << OPT_ST as libc::c_int) as uint32_t;
                (*op).reg = 0 as libc::c_int as int8_t;
                next();
                if tok == '(' as i32 {
                    next();
                    if tok != 0xcd as libc::c_int {
                        current_block = 6599959443913819895;
                    } else {
                        p = tokc.str_0.data;
                        reg = *p.offset(0 as libc::c_int as isize) as libc::c_int
                            - '0' as i32;
                        if reg as libc::c_uint >= 8 as libc::c_int as libc::c_uint
                            || *p.offset(1 as libc::c_int as isize) as libc::c_int
                                != '\0' as i32
                        {
                            current_block = 6599959443913819895;
                        } else {
                            (*op).reg = reg as int8_t;
                            next();
                            skip(')' as i32);
                            current_block = 4775909272756257391;
                        }
                    }
                } else {
                    current_block = 4775909272756257391;
                }
                match current_block {
                    6599959443913819895 => {}
                    _ => {
                        if (*op).reg as libc::c_int == 0 as libc::c_int {
                            (*op).type_0
                                |= ((1 as libc::c_int) << OPT_ST0 as libc::c_int)
                                    as uint32_t;
                        }
                        current_block = 8102658916883067714;
                    }
                }
            } else if tok >= TOK_ASM_spl as libc::c_int
                && tok <= TOK_ASM_dil as libc::c_int
            {
                (*op)
                    .type_0 = ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG8_LOW as libc::c_int) as uint32_t;
                (*op)
                    .reg = (4 as libc::c_int + tok - TOK_ASM_spl as libc::c_int)
                    as int8_t;
                current_block = 13131896068329595644;
            } else {
                (*op).reg = asm_parse_numeric_reg(tok, &mut (*op).type_0) as int8_t;
                if (*op).reg as libc::c_int >= 0 as libc::c_int {
                    current_block = 13131896068329595644;
                } else {
                    current_block = 6599959443913819895;
                }
            }
            match current_block {
                8102658916883067714 => {}
                13131896068329595644 => {}
                _ => {
                    _tcc_error(
                        b"unknown register %%%s\0" as *const u8 as *const libc::c_char,
                        get_tok_str(tok, &mut tokc),
                    );
                }
            }
        }
        match current_block {
            8102658916883067714 => {}
            _ => {
                next();
            }
        }
    } else if tok == '$' as i32 {
        next();
        asm_expr(s1, &mut e);
        (*op).type_0 = ((1 as libc::c_int) << OPT_IM32 as libc::c_int) as uint32_t;
        (*op).e = e;
        if ((*op).e.sym).is_null() {
            if (*op).e.v == (*op).e.v as uint8_t as uint64_t {
                (*op).type_0
                    |= ((1 as libc::c_int) << OPT_IM8 as libc::c_int) as uint32_t;
            }
            if (*op).e.v == (*op).e.v as int8_t as uint64_t {
                (*op).type_0
                    |= ((1 as libc::c_int) << OPT_IM8S as libc::c_int) as uint32_t;
            }
            if (*op).e.v == (*op).e.v as uint16_t as uint64_t {
                (*op).type_0
                    |= ((1 as libc::c_int) << OPT_IM16 as libc::c_int) as uint32_t;
            }
            if (*op).e.v != (*op).e.v as int32_t as uint64_t
                && (*op).e.v != (*op).e.v as uint32_t as uint64_t
            {
                (*op)
                    .type_0 = ((1 as libc::c_int) << OPT_IM64 as libc::c_int)
                    as uint32_t;
            }
        }
    } else {
        (*op).type_0 = 0x40000000 as libc::c_int as uint32_t;
        (*op).reg = -(1 as libc::c_int) as int8_t;
        (*op).reg2 = -(1 as libc::c_int) as int8_t;
        (*op).shift = 0 as libc::c_int as uint8_t;
        if tok != '(' as i32 {
            asm_expr(s1, &mut e);
            (*op).e = e;
        } else {
            next();
            if tok == '%' as i32 {
                unget_tok('(' as i32);
                (*op).e.v = 0 as libc::c_int as uint64_t;
                (*op).e.sym = 0 as *mut Sym;
            } else {
                asm_expr(s1, &mut e);
                if tok != ')' as i32 {
                    expect(b")\0" as *const u8 as *const libc::c_char);
                }
                next();
                (*op).e.v = e.v;
                (*op).e.sym = e.sym;
            }
            (*op).e.pcrel = 0 as libc::c_int;
        }
        if tok == '(' as i32 {
            let mut type_0: libc::c_uint = 0 as libc::c_int as libc::c_uint;
            next();
            if tok != ',' as i32 {
                (*op).reg = asm_parse_reg(&mut type_0) as int8_t;
            }
            if tok == ',' as i32 {
                next();
                if tok != ',' as i32 {
                    (*op).reg2 = asm_parse_reg(&mut type_0) as int8_t;
                }
                if tok == ',' as i32 {
                    next();
                    (*op).shift = get_reg_shift(s1) as uint8_t;
                }
            }
            if type_0 & ((1 as libc::c_int) << OPT_REG32 as libc::c_int) as libc::c_uint
                != 0
            {
                (*op).type_0
                    |= ((0x40000000 as libc::c_int) << 1 as libc::c_int) as uint32_t;
            }
            skip(')' as i32);
        }
        if (*op).reg as libc::c_int == -(1 as libc::c_int)
            && (*op).reg2 as libc::c_int == -(1 as libc::c_int)
        {
            (*op).type_0 |= ((1 as libc::c_int) << OPT_ADDR as libc::c_int) as uint32_t;
        }
    }
    (*op).type_0 |= indir_0 as uint32_t;
}
unsafe extern "C" fn gen_expr32(mut pe: *mut ExprValue) {
    if (*pe).pcrel != 0 {
        gen_addrpc32(
            0x200 as libc::c_int,
            (*pe).sym,
            ((*pe).v).wrapping_add((ind + 4 as libc::c_int) as uint64_t) as libc::c_int,
        );
    } else {
        gen_addr32(
            if !((*pe).sym).is_null() { 0x200 as libc::c_int } else { 0 as libc::c_int },
            (*pe).sym,
            (*pe).v as libc::c_int,
        );
    };
}
unsafe extern "C" fn gen_expr64(mut pe: *mut ExprValue) {
    gen_addr64(
        if !((*pe).sym).is_null() { 0x200 as libc::c_int } else { 0 as libc::c_int },
        (*pe).sym,
        (*pe).v as int64_t,
    );
}
unsafe extern "C" fn gen_disp32(mut pe: *mut ExprValue) {
    let mut sym: *mut Sym = (*pe).sym;
    let mut esym: *mut Elf64_Sym = elfsym(sym);
    if !esym.is_null()
        && (*esym).st_shndx as libc::c_int == (*(*tcc_state).cur_text_section).sh_num
    {
        gen_le32(
            ((*pe).v)
                .wrapping_add((*esym).st_value)
                .wrapping_sub(ind as uint64_t)
                .wrapping_sub(4 as libc::c_int as uint64_t) as libc::c_int,
        );
    } else {
        if !sym.is_null() && (*sym).type_0.t == 0 as libc::c_int {
            (*sym).type_0.t = 6 as libc::c_int;
            (*sym).type_0.ref_0 = 0 as *mut Sym;
        }
        greloca(
            (*tcc_state).cur_text_section,
            sym,
            ind as libc::c_ulong,
            4 as libc::c_int,
            ((*pe).v).wrapping_sub(4 as libc::c_int as uint64_t),
        );
        gen_le32(0 as libc::c_int);
    };
}
#[inline]
unsafe extern "C" fn asm_modrm(
    mut reg: libc::c_int,
    mut op: *mut Operand,
) -> libc::c_int {
    let mut mod_0: libc::c_int = 0;
    let mut reg1: libc::c_int = 0;
    let mut reg2: libc::c_int = 0;
    let mut sib_reg1: libc::c_int = 0;
    if (*op).type_0
        & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
            | (1 as libc::c_int) << OPT_REG16 as libc::c_int
            | (1 as libc::c_int) << OPT_REG32 as libc::c_int
            | (1 as libc::c_int) << OPT_REG64 as libc::c_int
            | (1 as libc::c_int) << OPT_MMX as libc::c_int
            | (1 as libc::c_int) << OPT_SSE as libc::c_int) as uint32_t != 0
    {
        g(0xc0 as libc::c_int + (reg << 3 as libc::c_int) + (*op).reg as libc::c_int);
    } else if (*op).reg as libc::c_int == -(1 as libc::c_int)
        && (*op).reg2 as libc::c_int == -(1 as libc::c_int)
    {
        g(0x4 as libc::c_int + (reg << 3 as libc::c_int));
        g(0x25 as libc::c_int);
        gen_expr32(&mut (*op).e);
    } else if (*op).reg as libc::c_int == -(2 as libc::c_int) {
        let mut pe: *mut ExprValue = &mut (*op).e;
        g(0x5 as libc::c_int + (reg << 3 as libc::c_int));
        gen_addrpc32(
            if !((*pe).sym).is_null() { 0x200 as libc::c_int } else { 0 as libc::c_int },
            (*pe).sym,
            (*pe).v as libc::c_int,
        );
        return ind;
    } else {
        sib_reg1 = (*op).reg as libc::c_int;
        if sib_reg1 == -(1 as libc::c_int) {
            sib_reg1 = 5 as libc::c_int;
            mod_0 = 0 as libc::c_int;
        } else if (*op).e.v == 0 as libc::c_int as uint64_t && ((*op).e.sym).is_null()
            && (*op).reg as libc::c_int != 5 as libc::c_int
        {
            mod_0 = 0 as libc::c_int;
        } else if (*op).e.v == (*op).e.v as int8_t as uint64_t && ((*op).e.sym).is_null()
        {
            mod_0 = 0x40 as libc::c_int;
        } else {
            mod_0 = 0x80 as libc::c_int;
        }
        reg1 = (*op).reg as libc::c_int;
        if (*op).reg2 as libc::c_int != -(1 as libc::c_int) {
            reg1 = 4 as libc::c_int;
        }
        g(mod_0 + (reg << 3 as libc::c_int) + reg1);
        if reg1 == 4 as libc::c_int {
            reg2 = (*op).reg2 as libc::c_int;
            if reg2 == -(1 as libc::c_int) {
                reg2 = 4 as libc::c_int;
            }
            g(
                (((*op).shift as libc::c_int) << 6 as libc::c_int)
                    + (reg2 << 3 as libc::c_int) + sib_reg1,
            );
        }
        if mod_0 == 0x40 as libc::c_int {
            g((*op).e.v as libc::c_int);
        } else if mod_0 == 0x80 as libc::c_int
            || (*op).reg as libc::c_int == -(1 as libc::c_int)
        {
            gen_expr32(&mut (*op).e);
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn asm_rex(
    mut width64: libc::c_int,
    mut ops: *mut Operand,
    mut nb_ops: libc::c_int,
    mut op_type: *mut libc::c_int,
    mut regi: libc::c_int,
    mut rmi: libc::c_int,
) {
    let mut rex: libc::c_uchar = (if width64 != 0 {
        0x48 as libc::c_int
    } else {
        0 as libc::c_int
    }) as libc::c_uchar;
    let mut saw_high_8bit: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    if rmi == -(1 as libc::c_int) {
        i = 0 as libc::c_int;
        while i < nb_ops {
            if *op_type.offset(i as isize)
                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG64 as libc::c_int
                    | (1 as libc::c_int) << OPT_ST as libc::c_int) != 0
            {
                if (*ops.offset(i as isize)).reg as libc::c_int >= 8 as libc::c_int {
                    rex = (rex as libc::c_int | 0x41 as libc::c_int) as libc::c_uchar;
                    let ref mut fresh169 = (*ops.offset(i as isize)).reg;
                    *fresh169 = (*fresh169 as libc::c_int - 8 as libc::c_int) as int8_t;
                } else if (*ops.offset(i as isize)).type_0
                    & ((1 as libc::c_int) << OPT_REG8_LOW as libc::c_int) as uint32_t
                    != 0
                {
                    rex = (rex as libc::c_int | 0x40 as libc::c_int) as libc::c_uchar;
                } else if (*ops.offset(i as isize)).type_0
                    & ((1 as libc::c_int) << OPT_REG8 as libc::c_int) as uint32_t != 0
                    && (*ops.offset(i as isize)).reg as libc::c_int >= 4 as libc::c_int
                {
                    saw_high_8bit = (*ops.offset(i as isize)).reg as libc::c_int;
                }
                break;
            } else {
                i += 1;
                i;
            }
        }
    } else {
        if regi != -(1 as libc::c_int) {
            if (*ops.offset(regi as isize)).reg as libc::c_int >= 8 as libc::c_int {
                rex = (rex as libc::c_int | 0x44 as libc::c_int) as libc::c_uchar;
                let ref mut fresh170 = (*ops.offset(regi as isize)).reg;
                *fresh170 = (*fresh170 as libc::c_int - 8 as libc::c_int) as int8_t;
            } else if (*ops.offset(regi as isize)).type_0
                & ((1 as libc::c_int) << OPT_REG8_LOW as libc::c_int) as uint32_t != 0
            {
                rex = (rex as libc::c_int | 0x40 as libc::c_int) as libc::c_uchar;
            } else if (*ops.offset(regi as isize)).type_0
                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int) as uint32_t != 0
                && (*ops.offset(regi as isize)).reg as libc::c_int >= 4 as libc::c_int
            {
                saw_high_8bit = (*ops.offset(regi as isize)).reg as libc::c_int;
            }
        }
        if (*ops.offset(rmi as isize)).type_0
            & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                | (1 as libc::c_int) << OPT_REG64 as libc::c_int
                | (1 as libc::c_int) << OPT_MMX as libc::c_int
                | (1 as libc::c_int) << OPT_SSE as libc::c_int
                | (1 as libc::c_int) << OPT_CR as libc::c_int
                | 0x40000000 as libc::c_int) as uint32_t != 0
        {
            if (*ops.offset(rmi as isize)).reg as libc::c_int >= 8 as libc::c_int {
                rex = (rex as libc::c_int | 0x41 as libc::c_int) as libc::c_uchar;
                let ref mut fresh171 = (*ops.offset(rmi as isize)).reg;
                *fresh171 = (*fresh171 as libc::c_int - 8 as libc::c_int) as int8_t;
            } else if (*ops.offset(rmi as isize)).type_0
                & ((1 as libc::c_int) << OPT_REG8_LOW as libc::c_int) as uint32_t != 0
            {
                rex = (rex as libc::c_int | 0x40 as libc::c_int) as libc::c_uchar;
            } else if (*ops.offset(rmi as isize)).type_0
                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int) as uint32_t != 0
                && (*ops.offset(rmi as isize)).reg as libc::c_int >= 4 as libc::c_int
            {
                saw_high_8bit = (*ops.offset(rmi as isize)).reg as libc::c_int;
            }
        }
        if (*ops.offset(rmi as isize)).type_0 & 0x40000000 as libc::c_int as uint32_t
            != 0 && (*ops.offset(rmi as isize)).reg2 as libc::c_int >= 8 as libc::c_int
        {
            rex = (rex as libc::c_int | 0x42 as libc::c_int) as libc::c_uchar;
            let ref mut fresh172 = (*ops.offset(rmi as isize)).reg2;
            *fresh172 = (*fresh172 as libc::c_int - 8 as libc::c_int) as int8_t;
        }
    }
    if rex != 0 {
        if saw_high_8bit != 0 {
            _tcc_error(
                b"can't encode register %%%ch when REX prefix is required\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 5],
                    &[libc::c_char; 5],
                >(b"acdb\0"))[(saw_high_8bit - 4 as libc::c_int) as usize] as libc::c_int,
            );
        }
        g(rex as libc::c_int);
    }
}
unsafe extern "C" fn maybe_print_stats() {
    static mut already: libc::c_int = 0;
    if 0 as libc::c_int != 0 && already == 0 {
        let mut pa: *const ASMInstr = 0 as *const ASMInstr;
        let mut freq: [libc::c_int; 4] = [0; 4];
        let mut op_vals: [libc::c_int; 500] = [0; 500];
        let mut nb_op_vals: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        already = 1 as libc::c_int;
        nb_op_vals = 0 as libc::c_int;
        memset(
            freq.as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<[libc::c_int; 4]>() as libc::c_ulong,
        );
        pa = asm_instrs.as_ptr();
        while (*pa).sym as libc::c_int != 0 as libc::c_int {
            let mut current_block_7: u64;
            freq[(*pa).nb_ops as usize] += 1;
            freq[(*pa).nb_ops as usize];
            j = 0 as libc::c_int;
            loop {
                if !(j < nb_op_vals) {
                    current_block_7 = 1917311967535052937;
                    break;
                }
                if (*pa).instr_type as libc::c_int == op_vals[j as usize] {
                    current_block_7 = 7651349459974463963;
                    break;
                }
                j += 1;
                j;
            }
            match current_block_7 {
                1917311967535052937 => {
                    let fresh173 = nb_op_vals;
                    nb_op_vals = nb_op_vals + 1;
                    op_vals[fresh173 as usize] = (*pa).instr_type as libc::c_int;
                }
                _ => {}
            }
            pa = pa.offset(1);
            pa;
        }
        i = 0 as libc::c_int;
        while i < nb_op_vals {
            let mut v: libc::c_int = op_vals[i as usize];
            printf(b"%3d: %08x\n\0" as *const u8 as *const libc::c_char, i, v);
            i += 1;
            i;
        }
        printf(
            b"size=%d nb=%d f0=%d f1=%d f2=%d f3=%d\n\0" as *const u8
                as *const libc::c_char,
            ::core::mem::size_of::<[ASMInstr; 347]>() as libc::c_ulong as libc::c_int,
            ::core::mem::size_of::<[ASMInstr; 347]>() as libc::c_ulong as libc::c_int
                / ::core::mem::size_of::<ASMInstr>() as libc::c_ulong as libc::c_int,
            freq[0 as libc::c_int as usize],
            freq[1 as libc::c_int as usize],
            freq[2 as libc::c_int as usize],
            freq[3 as libc::c_int as usize],
        );
    }
}
unsafe extern "C" fn asm_opcode(mut s1: *mut TCCState, mut opcode: libc::c_int) {
    let mut current_block: u64;
    let mut pa: *const ASMInstr = 0 as *const ASMInstr;
    let mut i: libc::c_int = 0;
    let mut modrm_index: libc::c_int = 0;
    let mut modreg_index: libc::c_int = 0;
    let mut reg: libc::c_int = 0;
    let mut v: libc::c_int = 0;
    let mut op1: libc::c_int = 0;
    let mut seg_prefix: libc::c_int = 0;
    let mut pc: libc::c_int = 0;
    let mut p: libc::c_int = 0;
    let mut nb_ops: libc::c_int = 0;
    let mut s: libc::c_int = 0;
    let mut ops: [Operand; 3] = [Operand {
        type_0: 0,
        reg: 0,
        reg2: 0,
        shift: 0,
        e: ExprValue {
            v: 0,
            sym: 0 as *mut Sym,
            pcrel: 0,
        },
    }; 3];
    let mut pop: *mut Operand = 0 as *mut Operand;
    let mut op_type: [libc::c_int; 3] = [0; 3];
    let mut alltypes: libc::c_int = 0;
    let mut autosize: libc::c_int = 0;
    let mut p66: libc::c_int = 0;
    let mut rex64: libc::c_int = 0;
    maybe_print_stats();
    if opcode >= TOK_ASM_wait as libc::c_int && opcode <= TOK_ASM_repnz as libc::c_int {
        unget_tok(';' as i32);
    }
    pop = ops.as_mut_ptr();
    nb_ops = 0 as libc::c_int;
    seg_prefix = 0 as libc::c_int;
    alltypes = 0 as libc::c_int;
    while !(tok == ';' as i32 || tok == 10 as libc::c_int) {
        if nb_ops >= 3 as libc::c_int {
            _tcc_error(
                b"incorrect number of operands\0" as *const u8 as *const libc::c_char,
            );
        }
        parse_operand(s1, pop);
        if tok == ':' as i32 {
            if (*pop).type_0
                != ((1 as libc::c_int) << OPT_SEG as libc::c_int) as uint32_t
                || seg_prefix != 0
            {
                _tcc_error(b"incorrect prefix\0" as *const u8 as *const libc::c_char);
            }
            seg_prefix = segment_prefixes[(*pop).reg as usize] as libc::c_int;
            next();
            parse_operand(s1, pop);
            if (*pop).type_0 & 0x40000000 as libc::c_int as uint32_t == 0 {
                _tcc_error(
                    b"segment prefix must be followed by memory reference\0" as *const u8
                        as *const libc::c_char,
                );
            }
        }
        pop = pop.offset(1);
        pop;
        nb_ops += 1;
        nb_ops;
        if tok != ',' as i32 {
            break;
        }
        next();
    }
    s = 0 as libc::c_int;
    loop {
        let mut current_block_53: u64;
        pa = asm_instrs.as_ptr();
        's_124: while (*pa).sym as libc::c_int != 0 as libc::c_int {
            let mut it: libc::c_int = (*pa).instr_type as libc::c_int
                & 0x70 as libc::c_int;
            s = 0 as libc::c_int;
            if it == 0x40 as libc::c_int {
                v = opcode - (*pa).sym as libc::c_int;
                if !((v as libc::c_uint)
                    < (8 as libc::c_int * 6 as libc::c_int) as libc::c_uint
                    && v % 6 as libc::c_int == 0 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else {
                    current_block_53 = 13321564401369230990;
                }
            } else if it == 0x30 as libc::c_int {
                if !(opcode >= (*pa).sym as libc::c_int
                    && opcode
                        < (*pa).sym as libc::c_int + 8 as libc::c_int * 5 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else {
                    s = (opcode - (*pa).sym as libc::c_int) % 5 as libc::c_int;
                    if (*pa).instr_type as libc::c_int
                        & (0x1 as libc::c_int | 0x1000 as libc::c_int)
                        == 0x1000 as libc::c_int
                    {
                        if (opcode - (*pa).sym as libc::c_int + 1 as libc::c_int)
                            % 5 as libc::c_int == 0 as libc::c_int
                        {
                            current_block_53 = 15768484401365413375;
                        } else {
                            s += 1;
                            s;
                            current_block_53 = 13321564401369230990;
                        }
                    } else {
                        current_block_53 = 13321564401369230990;
                    }
                }
            } else if it == 0x20 as libc::c_int {
                if !(opcode >= (*pa).sym as libc::c_int
                    && opcode
                        < (*pa).sym as libc::c_int + 7 as libc::c_int * 5 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else {
                    s = (opcode - (*pa).sym as libc::c_int) % 5 as libc::c_int;
                    current_block_53 = 13321564401369230990;
                }
            } else if it == 0x50 as libc::c_int {
                if !(opcode >= (*pa).sym as libc::c_int
                    && opcode < (*pa).sym as libc::c_int + 30 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else {
                    if (*pa).instr_type as libc::c_int & 0x1000 as libc::c_int != 0 {
                        s = 5 as libc::c_int - 1 as libc::c_int;
                    }
                    current_block_53 = 13321564401369230990;
                }
            } else if (*pa).instr_type as libc::c_int & 0x1 as libc::c_int != 0 {
                if (*pa).instr_type as libc::c_int & 0x1000 as libc::c_int
                    != 0x1000 as libc::c_int
                    && !(opcode >= (*pa).sym as libc::c_int
                        && opcode
                            < (*pa).sym as libc::c_int + 5 as libc::c_int
                                - 1 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else if !(opcode >= (*pa).sym as libc::c_int
                    && opcode < (*pa).sym as libc::c_int + 5 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else {
                    s = opcode - (*pa).sym as libc::c_int;
                    current_block_53 = 13321564401369230990;
                }
            } else if (*pa).instr_type as libc::c_int & 0x1000 as libc::c_int != 0 {
                if !(opcode >= (*pa).sym as libc::c_int
                    && opcode
                        < (*pa).sym as libc::c_int + 5 as libc::c_int - 1 as libc::c_int)
                {
                    current_block_53 = 15768484401365413375;
                } else {
                    s = opcode - (*pa).sym as libc::c_int + 1 as libc::c_int;
                    current_block_53 = 13321564401369230990;
                }
            } else if (*pa).sym as libc::c_int != opcode {
                current_block_53 = 15768484401365413375;
            } else {
                current_block_53 = 13321564401369230990;
            }
            match current_block_53 {
                13321564401369230990 => {
                    if !((*pa).nb_ops as libc::c_int != nb_ops) {
                        if !((*pa).opcode as libc::c_int == 0xb0 as libc::c_int
                            && ops[0 as libc::c_int as usize].type_0
                                != ((1 as libc::c_int) << OPT_IM64 as libc::c_int)
                                    as uint32_t
                            && ops[1 as libc::c_int as usize].type_0
                                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                                    | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                                    | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                                    | (1 as libc::c_int) << OPT_REG64 as libc::c_int)
                                    as uint32_t
                                == ((1 as libc::c_int) << OPT_REG64 as libc::c_int)
                                    as uint32_t
                            && (*pa).instr_type as libc::c_int & 0x100 as libc::c_int
                                == 0)
                        {
                            alltypes = 0 as libc::c_int;
                            i = 0 as libc::c_int;
                            loop {
                                if !(i < nb_ops) {
                                    break 's_124;
                                }
                                let mut op1_0: libc::c_int = 0;
                                let mut op2: libc::c_int = 0;
                                op1_0 = (*pa).op_type[i as usize] as libc::c_int;
                                op2 = op1_0 & 0x1f as libc::c_int;
                                match op2 {
                                    24 => {
                                        v = (1 as libc::c_int) << OPT_IM8 as libc::c_int
                                            | (1 as libc::c_int) << OPT_IM16 as libc::c_int
                                            | (1 as libc::c_int) << OPT_IM32 as libc::c_int;
                                    }
                                    25 => {
                                        v = (1 as libc::c_int) << OPT_REG8 as libc::c_int
                                            | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                                            | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                                            | (1 as libc::c_int) << OPT_REG64 as libc::c_int;
                                    }
                                    26 => {
                                        v = (1 as libc::c_int) << OPT_REG16 as libc::c_int
                                            | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                                            | (1 as libc::c_int) << OPT_REG64 as libc::c_int;
                                    }
                                    27 => {
                                        v = (1 as libc::c_int) << OPT_IM16 as libc::c_int
                                            | (1 as libc::c_int) << OPT_IM32 as libc::c_int;
                                    }
                                    28 => {
                                        v = (1 as libc::c_int) << OPT_MMX as libc::c_int
                                            | (1 as libc::c_int) << OPT_SSE as libc::c_int;
                                    }
                                    29 | 30 => {
                                        v = (1 as libc::c_int) << OPT_ADDR as libc::c_int;
                                    }
                                    _ => {
                                        v = (1 as libc::c_int) << op2;
                                    }
                                }
                                if op1_0 & OPT_EA as libc::c_int != 0 {
                                    v |= 0x40000000 as libc::c_int;
                                }
                                op_type[i as usize] = v;
                                if ops[i as usize].type_0 & v as uint32_t
                                    == 0 as libc::c_int as uint32_t
                                {
                                    break;
                                }
                                alltypes = (alltypes as uint32_t | ops[i as usize].type_0)
                                    as libc::c_int;
                                i += 1;
                                i;
                            }
                        }
                    }
                }
                _ => {}
            }
            pa = pa.offset(1);
            pa;
        }
        if (*pa).sym as libc::c_int == 0 as libc::c_int {
            if opcode >= TOK_ASM_clc as libc::c_int
                && opcode <= TOK_ASM_emms as libc::c_int
            {
                let mut b: libc::c_int = 0;
                b = op0_codes[(opcode - TOK_ASM_clc as libc::c_int) as usize]
                    as libc::c_int;
                if b & 0xff00 as libc::c_int != 0 {
                    g(b >> 8 as libc::c_int);
                }
                g(b);
                return;
            } else if opcode <= TOK_ASM_subps as libc::c_int {
                _tcc_error(
                    b"bad operand with opcode '%s'\0" as *const u8
                        as *const libc::c_char,
                    get_tok_str(opcode, 0 as *mut CValue),
                );
            } else {
                let mut ts: *mut TokenSym = *table_ident
                    .offset((opcode - 256 as libc::c_int) as isize);
                if (*ts).len >= 6 as libc::c_int
                    && !(strchr(
                        b"wlq\0" as *const u8 as *const libc::c_char,
                        *((*ts).str_0)
                            .as_mut_ptr()
                            .offset(((*ts).len - 1 as libc::c_int) as isize)
                            as libc::c_int,
                    ))
                        .is_null()
                    && memcmp(
                        ((*ts).str_0).as_mut_ptr() as *const libc::c_void,
                        b"cmov\0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        4 as libc::c_int as libc::c_ulong,
                    ) == 0
                {
                    opcode = (*tok_alloc(
                        ((*ts).str_0).as_mut_ptr(),
                        (*ts).len - 1 as libc::c_int,
                    ))
                        .tok;
                } else {
                    _tcc_error(
                        b"unknown opcode '%s'\0" as *const u8 as *const libc::c_char,
                        ((*ts).str_0).as_mut_ptr(),
                    );
                }
            }
        } else {
            autosize = 5 as libc::c_int - 1 as libc::c_int;
            if (*pa).instr_type as libc::c_int
                & (0x1 as libc::c_int | 0x1000 as libc::c_int) == 0x1 as libc::c_int
            {
                autosize = 5 as libc::c_int - 2 as libc::c_int;
            }
            if s == autosize {
                i = nb_ops - 1 as libc::c_int;
                while s == autosize && i >= 0 as libc::c_int {
                    if ops[i as usize].type_0
                        & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                            | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                            | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                            | (1 as libc::c_int) << OPT_REG64 as libc::c_int) as uint32_t
                        != 0
                        && op_type[i as usize]
                            & ((1 as libc::c_int) << OPT_CL as libc::c_int
                                | (1 as libc::c_int) << OPT_DX as libc::c_int) == 0
                    {
                        s = reg_to_size[(ops[i as usize].type_0
                            & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                                | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                                | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                                | (1 as libc::c_int) << OPT_REG64 as libc::c_int)
                                as uint32_t) as usize] as libc::c_int;
                    }
                    i -= 1;
                    i;
                }
                if s == autosize {
                    if (opcode == TOK_ASM_push as libc::c_int
                        || opcode == TOK_ASM_pop as libc::c_int)
                        && ops[0 as libc::c_int as usize].type_0
                            & ((1 as libc::c_int) << OPT_SEG as libc::c_int
                                | (1 as libc::c_int) << OPT_IM8S as libc::c_int
                                | (1 as libc::c_int) << OPT_IM32 as libc::c_int) as uint32_t
                            != 0
                    {
                        s = 2 as libc::c_int;
                    } else if (opcode == TOK_ASM_push as libc::c_int
                        || opcode == TOK_ASM_pop as libc::c_int)
                        && ops[0 as libc::c_int as usize].type_0
                            & 0x40000000 as libc::c_int as uint32_t != 0
                    {
                        s = 5 as libc::c_int - 2 as libc::c_int;
                    } else {
                        _tcc_error(
                            b"cannot infer opcode suffix\0" as *const u8
                                as *const libc::c_char,
                        );
                    }
                }
            }
            rex64 = 0 as libc::c_int;
            if (*pa).instr_type as libc::c_int & 0x200 as libc::c_int != 0 {
                rex64 = 1 as libc::c_int;
            } else if s == 3 as libc::c_int
                || alltypes & (1 as libc::c_int) << OPT_REG64 as libc::c_int != 0
            {
                let mut default64: libc::c_int = 0 as libc::c_int;
                i = 0 as libc::c_int;
                while i < nb_ops {
                    if op_type[i as usize]
                        == (1 as libc::c_int) << OPT_REG64 as libc::c_int
                        && (*pa).opcode as libc::c_int != 0xb8 as libc::c_int
                    {
                        default64 = 1 as libc::c_int;
                        break;
                    } else {
                        i += 1;
                        i;
                    }
                }
                if opcode != TOK_ASM_push as libc::c_int
                    && opcode != TOK_ASM_pop as libc::c_int
                    && opcode != TOK_ASM_pushw as libc::c_int
                    && opcode != TOK_ASM_pushl as libc::c_int
                    && opcode != TOK_ASM_pushq as libc::c_int
                    && opcode != TOK_ASM_popw as libc::c_int
                    && opcode != TOK_ASM_popl as libc::c_int
                    && opcode != TOK_ASM_popq as libc::c_int
                    && opcode != TOK_ASM_call as libc::c_int
                    && opcode != TOK_ASM_jmp as libc::c_int && default64 == 0
                {
                    rex64 = 1 as libc::c_int;
                }
            }
            if (*pa).instr_type as libc::c_int & 0x70 as libc::c_int
                == 0x10 as libc::c_int
            {
                g(0x9b as libc::c_int);
            }
            if seg_prefix != 0 {
                g(seg_prefix);
            }
            i = 0 as libc::c_int;
            while i < nb_ops {
                if ops[i as usize].type_0
                    & ((0x40000000 as libc::c_int) << 1 as libc::c_int) as uint32_t != 0
                {
                    g(0x67 as libc::c_int);
                    break;
                } else {
                    i += 1;
                    i;
                }
            }
            p66 = 0 as libc::c_int;
            if s == 1 as libc::c_int {
                p66 = 1 as libc::c_int;
            } else {
                i = 0 as libc::c_int;
                while i < nb_ops {
                    if op_type[i as usize]
                        & ((1 as libc::c_int) << OPT_MMX as libc::c_int
                            | (1 as libc::c_int) << OPT_SSE as libc::c_int)
                        == (1 as libc::c_int) << OPT_MMX as libc::c_int
                            | (1 as libc::c_int) << OPT_SSE as libc::c_int
                        && ops[i as usize].type_0
                            & ((1 as libc::c_int) << OPT_SSE as libc::c_int) as uint32_t
                            != 0
                    {
                        p66 = 1 as libc::c_int;
                    }
                    i += 1;
                    i;
                }
            }
            if p66 != 0 {
                g(0x66 as libc::c_int);
            }
            v = (*pa).opcode as libc::c_int;
            p = v >> 8 as libc::c_int;
            match p {
                102 | 103 | 242 | 243 => {
                    v = v & 0xff as libc::c_int;
                    g(p);
                }
                0 | 72 | 212 | 213 | 216 | 217 | 218 | 219 | 220 | 221 | 222 | 223 => {}
                _ => {
                    _tcc_error(
                        b"bad prefix 0x%2x in opcode table\0" as *const u8
                            as *const libc::c_char,
                        p,
                    );
                }
            }
            if (*pa).instr_type as libc::c_int & 0x100 as libc::c_int != 0 {
                v = (v & !(0xff as libc::c_int)) << 8 as libc::c_int
                    | 0xf00 as libc::c_int | v & 0xff as libc::c_int;
            }
            if (v == 0x69 as libc::c_int || v == 0x6b as libc::c_int)
                && nb_ops == 2 as libc::c_int
            {
                nb_ops = 3 as libc::c_int;
                ops[2 as libc::c_int as usize] = ops[1 as libc::c_int as usize];
                op_type[2 as libc::c_int as usize] = op_type[1 as libc::c_int as usize];
            } else if v == 0xcd as libc::c_int
                && ops[0 as libc::c_int as usize].e.v == 3 as libc::c_int as uint64_t
                && (ops[0 as libc::c_int as usize].e.sym).is_null()
            {
                v -= 1;
                v;
                nb_ops = 0 as libc::c_int;
            } else if v == 0x6 as libc::c_int || v == 0x7 as libc::c_int {
                if ops[0 as libc::c_int as usize].reg as libc::c_int >= 4 as libc::c_int
                {
                    v = 0xfa0 as libc::c_int + (v - 0x6 as libc::c_int)
                        + ((ops[0 as libc::c_int as usize].reg as libc::c_int
                            - 4 as libc::c_int) << 3 as libc::c_int);
                } else {
                    v
                        += (ops[0 as libc::c_int as usize].reg as libc::c_int)
                            << 3 as libc::c_int;
                }
                nb_ops = 0 as libc::c_int;
            } else if v <= 0x5 as libc::c_int {
                v
                    += ((opcode - TOK_ASM_addb as libc::c_int) / 5 as libc::c_int)
                        << 3 as libc::c_int;
            } else if (*pa).instr_type as libc::c_int
                & (0x70 as libc::c_int | 0x8 as libc::c_int) == 0x40 as libc::c_int
            {
                v
                    += ((opcode - (*pa).sym as libc::c_int) / 6 as libc::c_int)
                        << 3 as libc::c_int;
            }
            modrm_index = -(1 as libc::c_int);
            modreg_index = -(1 as libc::c_int);
            if (*pa).instr_type as libc::c_int & 0x8 as libc::c_int != 0 {
                current_block = 7371321987304394147;
                break;
            } else {
                current_block = 17322559809113443968;
                break;
            }
        }
    }
    match current_block {
        7371321987304394147 => {
            if nb_ops == 0 {
                i = 0 as libc::c_int;
                ops[i as usize]
                    .type_0 = ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG64 as libc::c_int) as uint32_t;
                if (*pa).sym as libc::c_int == TOK_ASM_endbr64 as libc::c_int {
                    ops[i as usize].reg = 2 as libc::c_int as int8_t;
                } else if (*pa).sym as libc::c_int >= TOK_ASM_lfence as libc::c_int
                    && (*pa).sym as libc::c_int <= TOK_ASM_sfence as libc::c_int
                {
                    ops[i as usize].reg = 0 as libc::c_int as int8_t;
                } else {
                    _tcc_error(
                        b"bad MODR/M opcode without operands\0" as *const u8
                            as *const libc::c_char,
                    );
                }
            } else {
                i = 0 as libc::c_int;
                loop {
                    if !(i < nb_ops) {
                        current_block = 4127803603908737533;
                        break;
                    }
                    if op_type[i as usize] & 0x40000000 as libc::c_int != 0 {
                        current_block = 3553852088750651373;
                        break;
                    }
                    i += 1;
                    i;
                }
                match current_block {
                    3553852088750651373 => {}
                    _ => {
                        i = 0 as libc::c_int;
                        while i < nb_ops {
                            if op_type[i as usize]
                                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                                    | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                                    | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                                    | (1 as libc::c_int) << OPT_REG64 as libc::c_int
                                    | (1 as libc::c_int) << OPT_MMX as libc::c_int
                                    | (1 as libc::c_int) << OPT_SSE as libc::c_int
                                    | (1 as libc::c_int) << OPT_INDIR as libc::c_int) != 0
                            {
                                break;
                            }
                            i += 1;
                            i;
                        }
                    }
                }
            }
            modrm_index = i;
            i = 0 as libc::c_int;
            while i < nb_ops {
                let mut t: libc::c_int = op_type[i as usize];
                if i != modrm_index
                    && t
                        & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                            | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                            | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                            | (1 as libc::c_int) << OPT_REG64 as libc::c_int
                            | (1 as libc::c_int) << OPT_MMX as libc::c_int
                            | (1 as libc::c_int) << OPT_SSE as libc::c_int
                            | (1 as libc::c_int) << OPT_CR as libc::c_int
                            | (1 as libc::c_int) << OPT_TR as libc::c_int
                            | (1 as libc::c_int) << OPT_DB as libc::c_int
                            | (1 as libc::c_int) << OPT_SEG as libc::c_int) != 0
                {
                    modreg_index = i;
                    break;
                } else {
                    i += 1;
                    i;
                }
            }
        }
        _ => {}
    }
    asm_rex(
        rex64,
        ops.as_mut_ptr(),
        nb_ops,
        op_type.as_mut_ptr(),
        modreg_index,
        modrm_index,
    );
    if (*pa).instr_type as libc::c_int & 0x4 as libc::c_int != 0 {
        if v == 0xb0 as libc::c_int && s >= 1 as libc::c_int {
            v += 7 as libc::c_int;
        }
        i = 0 as libc::c_int;
        while i < nb_ops {
            if op_type[i as usize]
                & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG16 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG32 as libc::c_int
                    | (1 as libc::c_int) << OPT_REG64 as libc::c_int
                    | (1 as libc::c_int) << OPT_ST as libc::c_int) != 0
            {
                v += ops[i as usize].reg as libc::c_int;
                break;
            } else {
                i += 1;
                i;
            }
        }
    }
    if (*pa).instr_type as libc::c_int & 0x1 as libc::c_int != 0 {
        v += (s >= 1 as libc::c_int) as libc::c_int;
    }
    if nb_ops == 1 as libc::c_int
        && (*pa).op_type[0 as libc::c_int as usize] as libc::c_int
            == OPT_DISP8 as libc::c_int
    {
        let mut current_block_175: u64;
        let mut esym: *mut Elf64_Sym = 0 as *mut Elf64_Sym;
        let mut jmp_disp: libc::c_int = 0;
        esym = elfsym(ops[0 as libc::c_int as usize].e.sym);
        if esym.is_null()
            || (*esym).st_shndx as libc::c_int != (*(*tcc_state).cur_text_section).sh_num
        {
            current_block_175 = 4543157123257471980;
        } else {
            jmp_disp = (ops[0 as libc::c_int as usize].e.v)
                .wrapping_add((*esym).st_value)
                .wrapping_sub(ind as uint64_t)
                .wrapping_sub(2 as libc::c_int as uint64_t)
                .wrapping_sub((v >= 0xff as libc::c_int) as libc::c_int as uint64_t)
                as libc::c_int;
            if jmp_disp == jmp_disp as int8_t as libc::c_int {
                ops[0 as libc::c_int as usize].e.sym = 0 as *mut Sym;
                ops[0 as libc::c_int as usize].e.v = jmp_disp as uint64_t;
                op_type[0 as libc::c_int
                    as usize] = (1 as libc::c_int) << OPT_IM8S as libc::c_int;
                current_block_175 = 12343738388509029619;
            } else {
                current_block_175 = 4543157123257471980;
            }
        }
        match current_block_175 {
            4543157123257471980 => {
                if v == 0xeb as libc::c_int {
                    v = 0xe9 as libc::c_int;
                } else if v == 0x70 as libc::c_int {
                    v += 0xf10 as libc::c_int;
                } else {
                    _tcc_error(
                        b"invalid displacement\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            _ => {}
        }
    }
    if (*pa).instr_type as libc::c_int & 0x70 as libc::c_int == 0x50 as libc::c_int {
        v += test_bits[(opcode - (*pa).sym as libc::c_int) as usize] as libc::c_int;
    } else if (*pa).instr_type as libc::c_int & 0x70 as libc::c_int
        == 0x60 as libc::c_int
    {
        v |= 0xf0100 as libc::c_int;
    }
    op1 = v >> 16 as libc::c_int;
    if op1 != 0 {
        g(op1);
    }
    op1 = v >> 8 as libc::c_int & 0xff as libc::c_int;
    if op1 != 0 {
        g(op1);
    }
    g(v);
    if (*pa).instr_type as libc::c_int & 0x70 as libc::c_int == 0x20 as libc::c_int {
        reg = (opcode - (*pa).sym as libc::c_int) / 5 as libc::c_int;
        if reg == 6 as libc::c_int {
            reg = 7 as libc::c_int;
        }
    } else if (*pa).instr_type as libc::c_int & 0x70 as libc::c_int
        == 0x30 as libc::c_int
    {
        reg = (opcode - (*pa).sym as libc::c_int) / 5 as libc::c_int;
    } else if (*pa).instr_type as libc::c_int & 0x70 as libc::c_int
        == 0x40 as libc::c_int
    {
        reg = (opcode - (*pa).sym as libc::c_int) / 6 as libc::c_int;
    } else {
        reg = (*pa).instr_type as libc::c_int >> 13 as libc::c_int & 7 as libc::c_int;
    }
    pc = 0 as libc::c_int;
    if (*pa).instr_type as libc::c_int & 0x8 as libc::c_int != 0 {
        if modreg_index >= 0 as libc::c_int {
            reg = ops[modreg_index as usize].reg as libc::c_int;
        }
        pc = asm_modrm(reg, &mut *ops.as_mut_ptr().offset(modrm_index as isize));
    }
    i = 0 as libc::c_int;
    while i < nb_ops {
        v = op_type[i as usize];
        if v
            & ((1 as libc::c_int) << OPT_IM8 as libc::c_int
                | (1 as libc::c_int) << OPT_IM16 as libc::c_int
                | (1 as libc::c_int) << OPT_IM32 as libc::c_int
                | (1 as libc::c_int) << OPT_IM64 as libc::c_int
                | (1 as libc::c_int) << OPT_IM8S as libc::c_int
                | (1 as libc::c_int) << OPT_ADDR as libc::c_int) != 0
        {
            if v | (1 as libc::c_int) << OPT_IM8 as libc::c_int
                | (1 as libc::c_int) << OPT_IM64 as libc::c_int
                == (1 as libc::c_int) << OPT_IM8 as libc::c_int
                    | (1 as libc::c_int) << OPT_IM16 as libc::c_int
                    | (1 as libc::c_int) << OPT_IM32 as libc::c_int
                    | (1 as libc::c_int) << OPT_IM64 as libc::c_int
            {
                if s == 0 as libc::c_int {
                    v = (1 as libc::c_int) << OPT_IM8 as libc::c_int;
                } else if s == 1 as libc::c_int {
                    v = (1 as libc::c_int) << OPT_IM16 as libc::c_int;
                } else if s == 2 as libc::c_int
                    || v & (1 as libc::c_int) << OPT_IM64 as libc::c_int
                        == 0 as libc::c_int
                {
                    v = (1 as libc::c_int) << OPT_IM32 as libc::c_int;
                } else {
                    v = (1 as libc::c_int) << OPT_IM64 as libc::c_int;
                }
            }
            if v
                & ((1 as libc::c_int) << OPT_IM8 as libc::c_int
                    | (1 as libc::c_int) << OPT_IM8S as libc::c_int
                    | (1 as libc::c_int) << OPT_IM16 as libc::c_int) != 0
                && !(ops[i as usize].e.sym).is_null()
            {
                _tcc_error(b"cannot relocate\0" as *const u8 as *const libc::c_char);
            }
            if v
                & ((1 as libc::c_int) << OPT_IM8 as libc::c_int
                    | (1 as libc::c_int) << OPT_IM8S as libc::c_int) != 0
            {
                g(ops[i as usize].e.v as libc::c_int);
            } else if v & (1 as libc::c_int) << OPT_IM16 as libc::c_int != 0 {
                gen_le16(ops[i as usize].e.v as libc::c_int);
            } else if v & (1 as libc::c_int) << OPT_IM64 as libc::c_int != 0 {
                gen_expr64(&mut (*ops.as_mut_ptr().offset(i as isize)).e);
            } else if (*pa).op_type[i as usize] as libc::c_int == OPT_DISP as libc::c_int
                || (*pa).op_type[i as usize] as libc::c_int == OPT_DISP8 as libc::c_int
            {
                gen_disp32(&mut (*ops.as_mut_ptr().offset(i as isize)).e);
            } else {
                gen_expr32(&mut (*ops.as_mut_ptr().offset(i as isize)).e);
            }
        }
        i += 1;
        i;
    }
    if pc != 0 {
        add32le(
            ((*(*tcc_state).cur_text_section).data)
                .offset(pc as isize)
                .offset(-(4 as libc::c_int as isize)),
            pc - ind,
        );
    }
}
#[inline]
unsafe extern "C" fn constraint_priority(mut str: *const libc::c_char) -> libc::c_int {
    let mut priority: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut pr: libc::c_int = 0;
    priority = 0 as libc::c_int;
    loop {
        c = *str as libc::c_int;
        if c == '\0' as i32 {
            break;
        }
        str = str.offset(1);
        str;
        match c {
            65 => {
                pr = 0 as libc::c_int;
            }
            97 | 98 | 99 | 100 | 83 | 68 => {
                pr = 1 as libc::c_int;
            }
            113 => {
                pr = 2 as libc::c_int;
            }
            114 | 82 | 112 => {
                pr = 3 as libc::c_int;
            }
            78 | 77 | 73 | 101 | 105 | 109 | 103 => {
                pr = 4 as libc::c_int;
            }
            _ => {
                _tcc_error(
                    b"unknown constraint '%c'\0" as *const u8 as *const libc::c_char,
                    c,
                );
            }
        }
        if pr > priority {
            priority = pr;
        }
    }
    return priority;
}
unsafe extern "C" fn skip_constraint_modifiers(
    mut p: *const libc::c_char,
) -> *const libc::c_char {
    while *p as libc::c_int == '=' as i32 || *p as libc::c_int == '&' as i32
        || *p as libc::c_int == '+' as i32 || *p as libc::c_int == '%' as i32
    {
        p = p.offset(1);
        p;
    }
    return p;
}
unsafe extern "C" fn asm_parse_regvar(mut t: libc::c_int) -> libc::c_int {
    let mut s: *const libc::c_char = 0 as *const libc::c_char;
    let mut op: Operand = Operand {
        type_0: 0,
        reg: 0,
        reg2: 0,
        shift: 0,
        e: ExprValue {
            v: 0,
            sym: 0 as *mut Sym,
            pcrel: 0,
        },
    };
    if t < 256 as libc::c_int || t & 0x20000000 as libc::c_int != 0 {
        return -(1 as libc::c_int);
    }
    s = ((**table_ident.offset((t - 256 as libc::c_int) as isize)).str_0).as_mut_ptr();
    if *s.offset(0 as libc::c_int as isize) as libc::c_int != '%' as i32 {
        return -(1 as libc::c_int);
    }
    t = tok_alloc_const(s.offset(1 as libc::c_int as isize));
    unget_tok(t);
    unget_tok('%' as i32);
    parse_operand(tcc_state, &mut op);
    if op.type_0
        & ((1 as libc::c_int) << OPT_REG8 as libc::c_int
            | (1 as libc::c_int) << OPT_REG16 as libc::c_int
            | (1 as libc::c_int) << OPT_REG32 as libc::c_int
            | (1 as libc::c_int) << OPT_REG64 as libc::c_int) as uint32_t != 0
    {
        return op.reg as libc::c_int
    } else {
        return -(1 as libc::c_int)
    };
}
unsafe extern "C" fn asm_compute_constraints(
    mut operands: *mut ASMOperand,
    mut nb_operands: libc::c_int,
    mut nb_outputs: libc::c_int,
    mut clobber_regs: *const uint8_t,
    mut pout_reg: *mut libc::c_int,
) {
    let mut current_block: u64;
    let mut op: *mut ASMOperand = 0 as *mut ASMOperand;
    let mut sorted_op: [libc::c_int; 30] = [0; 30];
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut p1: libc::c_int = 0;
    let mut p2: libc::c_int = 0;
    let mut tmp: libc::c_int = 0;
    let mut reg: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut reg_mask: libc::c_int = 0;
    let mut str: *const libc::c_char = 0 as *const libc::c_char;
    let mut regs_allocated: [uint8_t; 16] = [0; 16];
    i = 0 as libc::c_int;
    while i < nb_operands {
        op = &mut *operands.offset(i as isize) as *mut ASMOperand;
        (*op).input_index = -(1 as libc::c_int);
        (*op).ref_index = -(1 as libc::c_int);
        (*op).reg = -(1 as libc::c_int);
        (*op).is_memory = 0 as libc::c_int;
        (*op).is_rw = 0 as libc::c_int;
        i += 1;
        i;
    }
    i = 0 as libc::c_int;
    while i < nb_operands {
        op = &mut *operands.offset(i as isize) as *mut ASMOperand;
        str = ((*op).constraint).as_mut_ptr();
        str = skip_constraint_modifiers(str);
        if isnum(*str as libc::c_int) != 0 || *str as libc::c_int == '[' as i32 {
            k = find_constraint(
                operands,
                nb_operands,
                str,
                0 as *mut *const libc::c_char,
            );
            if k as libc::c_uint >= i as libc::c_uint || i < nb_outputs {
                _tcc_error(
                    b"invalid reference in constraint %d ('%s')\0" as *const u8
                        as *const libc::c_char,
                    i,
                    str,
                );
            }
            (*op).ref_index = k;
            if (*operands.offset(k as isize)).input_index >= 0 as libc::c_int {
                _tcc_error(
                    b"cannot reference twice the same operand\0" as *const u8
                        as *const libc::c_char,
                );
            }
            (*operands.offset(k as isize)).input_index = i;
            (*op).priority = 5 as libc::c_int;
        } else if (*(*op).vt).r as libc::c_int & 0x3f as libc::c_int
            == 0x32 as libc::c_int && !((*(*op).vt).c2rust_unnamed_0.sym).is_null()
            && {
                reg = (*(*(*op).vt).c2rust_unnamed_0.sym).r as libc::c_int
                    & 0x3f as libc::c_int;
                reg < 0x30 as libc::c_int
            }
        {
            (*op).priority = 1 as libc::c_int;
            (*op).reg = reg;
        } else {
            (*op).priority = constraint_priority(str);
        }
        i += 1;
        i;
    }
    i = 0 as libc::c_int;
    while i < nb_operands {
        sorted_op[i as usize] = i;
        i += 1;
        i;
    }
    i = 0 as libc::c_int;
    while i < nb_operands - 1 as libc::c_int {
        j = i + 1 as libc::c_int;
        while j < nb_operands {
            p1 = (*operands.offset(sorted_op[i as usize] as isize)).priority;
            p2 = (*operands.offset(sorted_op[j as usize] as isize)).priority;
            if p2 < p1 {
                tmp = sorted_op[i as usize];
                sorted_op[i as usize] = sorted_op[j as usize];
                sorted_op[j as usize] = tmp;
            }
            j += 1;
            j;
        }
        i += 1;
        i;
    }
    i = 0 as libc::c_int;
    while i < 16 as libc::c_int {
        if *clobber_regs.offset(i as isize) != 0 {
            regs_allocated[i
                as usize] = (0x2 as libc::c_int | 0x1 as libc::c_int) as uint8_t;
        } else {
            regs_allocated[i as usize] = 0 as libc::c_int as uint8_t;
        }
        i += 1;
        i;
    }
    regs_allocated[4 as libc::c_int
        as usize] = (0x2 as libc::c_int | 0x1 as libc::c_int) as uint8_t;
    regs_allocated[5 as libc::c_int
        as usize] = (0x2 as libc::c_int | 0x1 as libc::c_int) as uint8_t;
    i = 0 as libc::c_int;
    while i < nb_operands {
        j = sorted_op[i as usize];
        op = &mut *operands.offset(j as isize) as *mut ASMOperand;
        str = ((*op).constraint).as_mut_ptr();
        if !((*op).ref_index >= 0 as libc::c_int) {
            if (*op).input_index >= 0 as libc::c_int {
                reg_mask = 0x2 as libc::c_int | 0x1 as libc::c_int;
            } else if j < nb_outputs {
                reg_mask = 0x1 as libc::c_int;
            } else {
                reg_mask = 0x2 as libc::c_int;
            }
            if (*op).reg >= 0 as libc::c_int {
                if regs_allocated[(*op).reg as usize] as libc::c_int & reg_mask != 0 {
                    _tcc_error(
                        b"asm regvar requests register that's taken already\0"
                            as *const u8 as *const libc::c_char,
                    );
                }
                reg = (*op).reg;
            }
            '_try_next: loop {
                let fresh174 = str;
                str = str.offset(1);
                c = *fresh174 as libc::c_int;
                match c {
                    61 => {
                        continue;
                    }
                    43 => {
                        (*op).is_rw = 1 as libc::c_int;
                        current_block = 13520057744281397368;
                    }
                    38 => {
                        current_block = 13520057744281397368;
                    }
                    65 => {
                        if regs_allocated[TREG_RAX as libc::c_int as usize]
                            as libc::c_int & reg_mask != 0
                            || regs_allocated[TREG_RDX as libc::c_int as usize]
                                as libc::c_int & reg_mask != 0
                        {
                            continue;
                        }
                        (*op).is_llong = 1 as libc::c_int;
                        (*op).reg = TREG_RAX as libc::c_int;
                        regs_allocated[TREG_RAX as libc::c_int
                            as usize] = (regs_allocated[TREG_RAX as libc::c_int as usize]
                            as libc::c_int | reg_mask) as uint8_t;
                        regs_allocated[TREG_RDX as libc::c_int
                            as usize] = (regs_allocated[TREG_RDX as libc::c_int as usize]
                            as libc::c_int | reg_mask) as uint8_t;
                        current_block = 12079920068676227593;
                        break;
                    }
                    97 => {
                        reg = TREG_RAX as libc::c_int;
                        current_block = 12752463292213782080;
                    }
                    98 => {
                        reg = 3 as libc::c_int;
                        current_block = 12752463292213782080;
                    }
                    99 => {
                        reg = TREG_RCX as libc::c_int;
                        current_block = 12752463292213782080;
                    }
                    100 => {
                        reg = TREG_RDX as libc::c_int;
                        current_block = 12752463292213782080;
                    }
                    83 => {
                        reg = 6 as libc::c_int;
                        current_block = 12752463292213782080;
                    }
                    68 => {
                        reg = 7 as libc::c_int;
                        current_block = 12752463292213782080;
                    }
                    113 => {
                        if (*op).reg >= 0 as libc::c_int {
                            reg = (*op).reg;
                            if reg < 4 as libc::c_int {
                                current_block = 11643976609625572206;
                                break;
                            } else {
                                continue;
                            }
                        } else {
                            reg = 0 as libc::c_int;
                            loop {
                                if !(reg < 4 as libc::c_int) {
                                    continue '_try_next;
                                }
                                if regs_allocated[reg as usize] as libc::c_int & reg_mask
                                    == 0
                                {
                                    current_block = 11643976609625572206;
                                    break '_try_next;
                                }
                                reg += 1;
                                reg;
                            }
                        }
                    }
                    114 | 82 | 112 => {
                        reg = (*op).reg;
                        if reg >= 0 as libc::c_int {
                            current_block = 11643976609625572206;
                            break;
                        }
                        reg = 0 as libc::c_int;
                        loop {
                            if !(reg < 8 as libc::c_int) {
                                continue '_try_next;
                            }
                            if regs_allocated[reg as usize] as libc::c_int & reg_mask
                                == 0
                            {
                                current_block = 11643976609625572206;
                                break '_try_next;
                            }
                            reg += 1;
                            reg;
                        }
                    }
                    101 | 105 => {
                        if !((*(*op).vt).r as libc::c_int
                            & (0x3f as libc::c_int | 0x100 as libc::c_int)
                            == 0x30 as libc::c_int)
                        {
                            continue;
                        } else {
                            current_block = 12079920068676227593;
                            break;
                        }
                    }
                    73 | 78 | 77 => {
                        if !((*(*op).vt).r as libc::c_int
                            & (0x3f as libc::c_int | 0x100 as libc::c_int
                                | 0x200 as libc::c_int) == 0x30 as libc::c_int)
                        {
                            continue;
                        } else {
                            current_block = 12079920068676227593;
                            break;
                        }
                    }
                    109 | 103 => {
                        if !(j < nb_outputs || c == 'm' as i32) {
                            current_block = 12079920068676227593;
                            break;
                        }
                        if !((*(*op).vt).r as libc::c_int & 0x3f as libc::c_int
                            == 0x31 as libc::c_int)
                        {
                            current_block = 12079920068676227593;
                            break;
                        }
                        reg = 0 as libc::c_int;
                        loop {
                            if !(reg < 8 as libc::c_int) {
                                continue '_try_next;
                            }
                            if regs_allocated[reg as usize] as libc::c_int
                                & 0x2 as libc::c_int == 0
                            {
                                break;
                            }
                            reg += 1;
                            reg;
                        }
                        regs_allocated[reg
                            as usize] = (regs_allocated[reg as usize] as libc::c_int
                            | 0x2 as libc::c_int) as uint8_t;
                        (*op).reg = reg;
                        (*op).is_memory = 1 as libc::c_int;
                        current_block = 12079920068676227593;
                        break;
                    }
                    _ => {
                        _tcc_error(
                            b"asm constraint %d ('%s') could not be satisfied\0"
                                as *const u8 as *const libc::c_char,
                            j,
                            ((*op).constraint).as_mut_ptr(),
                        );
                    }
                }
                match current_block {
                    13520057744281397368 => {
                        if j >= nb_outputs {
                            _tcc_error(
                                b"'%c' modifier can only be applied to outputs\0"
                                    as *const u8 as *const libc::c_char,
                                c,
                            );
                        }
                        reg_mask = 0x2 as libc::c_int | 0x1 as libc::c_int;
                    }
                    _ => {
                        if (*op).reg >= 0 as libc::c_int && reg != (*op).reg {
                            continue;
                        }
                        if !(regs_allocated[reg as usize] as libc::c_int & reg_mask != 0)
                        {
                            current_block = 11643976609625572206;
                            break;
                        }
                    }
                }
            }
            match current_block {
                11643976609625572206 => {
                    (*op).is_llong = 0 as libc::c_int;
                    (*op).reg = reg;
                    regs_allocated[reg
                        as usize] = (regs_allocated[reg as usize] as libc::c_int
                        | reg_mask) as uint8_t;
                }
                _ => {}
            }
            if (*op).input_index >= 0 as libc::c_int {
                (*operands.offset((*op).input_index as isize)).reg = (*op).reg;
                (*operands.offset((*op).input_index as isize)).is_llong = (*op).is_llong;
            }
        }
        i += 1;
        i;
    }
    *pout_reg = -(1 as libc::c_int);
    let mut current_block_106: u64;
    i = 0 as libc::c_int;
    while i < nb_operands {
        op = &mut *operands.offset(i as isize) as *mut ASMOperand;
        if (*op).reg >= 0 as libc::c_int
            && (*(*op).vt).r as libc::c_int & 0x3f as libc::c_int == 0x31 as libc::c_int
            && (*op).is_memory == 0
        {
            reg = 0 as libc::c_int;
            loop {
                if !(reg < 8 as libc::c_int) {
                    current_block_106 = 6407515180622463684;
                    break;
                }
                if regs_allocated[reg as usize] as libc::c_int & 0x1 as libc::c_int == 0
                {
                    current_block_106 = 8536890617228332037;
                    break;
                }
                reg += 1;
                reg;
            }
            match current_block_106 {
                6407515180622463684 => {
                    _tcc_error(
                        b"could not find free output register for reloading\0"
                            as *const u8 as *const libc::c_char,
                    );
                }
                _ => {
                    *pout_reg = reg;
                    break;
                }
            }
        } else {
            i += 1;
            i;
        }
    }
}
unsafe extern "C" fn subst_asm_operand(
    mut add_str: *mut CString,
    mut sv: *mut SValue,
    mut modifier: libc::c_int,
) {
    let mut r: libc::c_int = 0;
    let mut reg: libc::c_int = 0;
    let mut size: libc::c_int = 0;
    let mut val: libc::c_int = 0;
    r = (*sv).r as libc::c_int;
    if r & 0x3f as libc::c_int == 0x30 as libc::c_int {
        let mut current_block_16: u64;
        if r & 0x100 as libc::c_int == 0 && modifier != 'c' as i32
            && modifier != 'n' as i32 && modifier != 'P' as i32
        {
            cstr_ccat(add_str, '$' as i32);
        }
        if r & 0x200 as libc::c_int != 0 {
            let mut name: *const libc::c_char = get_tok_str(
                (*(*sv).c2rust_unnamed_0.sym).v,
                0 as *mut CValue,
            );
            if (*(*sv).c2rust_unnamed_0.sym).v >= 0x10000000 as libc::c_int {
                get_asm_sym(tok_alloc_const(name), (*sv).c2rust_unnamed_0.sym);
            }
            if (*tcc_state).leading_underscore != 0 {
                cstr_ccat(add_str, '_' as i32);
            }
            cstr_cat(add_str, name, -(1 as libc::c_int));
            if (*sv).c2rust_unnamed.c.i as uint32_t == 0 as libc::c_int as uint32_t {
                current_block_16 = 17860125682698302841;
            } else {
                cstr_ccat(add_str, '+' as i32);
                current_block_16 = 17965632435239708295;
            }
        } else {
            current_block_16 = 17965632435239708295;
        }
        match current_block_16 {
            17965632435239708295 => {
                val = (*sv).c2rust_unnamed.c.i as libc::c_int;
                if modifier == 'n' as i32 {
                    val = -val;
                }
                cstr_printf(
                    add_str,
                    b"%d\0" as *const u8 as *const libc::c_char,
                    (*sv).c2rust_unnamed.c.i as libc::c_int,
                );
            }
            _ => {}
        }
        if r & 0x100 as libc::c_int != 0 {
            cstr_cat(
                add_str,
                b"(%rip)\0" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
        }
    } else if r & 0x3f as libc::c_int == 0x32 as libc::c_int {
        cstr_printf(
            add_str,
            b"%d(%%%s)\0" as *const u8 as *const libc::c_char,
            (*sv).c2rust_unnamed.c.i as libc::c_int,
            get_tok_str(TOK_ASM_rax as libc::c_int + 5 as libc::c_int, 0 as *mut CValue),
        );
    } else if r & 0x100 as libc::c_int != 0 {
        reg = r & 0x3f as libc::c_int;
        if reg >= 0x30 as libc::c_int {
            _tcc_error(
                b"internal compiler error in %s:%d: %s\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"subst_asm_operand\0"))
                    .as_ptr(),
                1553 as libc::c_int,
                b"\0" as *const u8 as *const libc::c_char,
            );
        }
        cstr_printf(
            add_str,
            b"(%%%s)\0" as *const u8 as *const libc::c_char,
            get_tok_str(TOK_ASM_rax as libc::c_int + reg, 0 as *mut CValue),
        );
    } else {
        reg = r & 0x3f as libc::c_int;
        if reg >= 0x30 as libc::c_int {
            _tcc_error(
                b"internal compiler error in %s:%d: %s\0" as *const u8
                    as *const libc::c_char,
                (*::core::mem::transmute::<
                    &[u8; 18],
                    &[libc::c_char; 18],
                >(b"subst_asm_operand\0"))
                    .as_ptr(),
                1559 as libc::c_int,
                b"\0" as *const u8 as *const libc::c_char,
            );
        }
        if (*sv).type_0.t & 0xf as libc::c_int == 1 as libc::c_int
            || (*sv).type_0.t & 0xf as libc::c_int == 11 as libc::c_int
        {
            size = 1 as libc::c_int;
        } else if (*sv).type_0.t & 0xf as libc::c_int == 2 as libc::c_int {
            size = 2 as libc::c_int;
        } else if (*sv).type_0.t & 0xf as libc::c_int == 4 as libc::c_int
            || (*sv).type_0.t & 0xf as libc::c_int == 5 as libc::c_int
        {
            size = 8 as libc::c_int;
        } else {
            size = 4 as libc::c_int;
        }
        if size == 1 as libc::c_int && reg >= 4 as libc::c_int {
            size = 4 as libc::c_int;
        }
        if modifier == 'b' as i32 {
            if reg >= 4 as libc::c_int {
                _tcc_error(
                    b"cannot use byte register\0" as *const u8 as *const libc::c_char,
                );
            }
            size = 1 as libc::c_int;
        } else if modifier == 'h' as i32 {
            if reg >= 4 as libc::c_int {
                _tcc_error(
                    b"cannot use byte register\0" as *const u8 as *const libc::c_char,
                );
            }
            size = -(1 as libc::c_int);
        } else if modifier == 'w' as i32 {
            size = 2 as libc::c_int;
        } else if modifier == 'k' as i32 {
            size = 4 as libc::c_int;
        } else if modifier == 'q' as i32 {
            size = 8 as libc::c_int;
        }
        match size {
            -1 => {
                reg = TOK_ASM_ah as libc::c_int + reg;
            }
            1 => {
                reg = TOK_ASM_al as libc::c_int + reg;
            }
            2 => {
                reg = TOK_ASM_ax as libc::c_int + reg;
            }
            8 => {
                reg = TOK_ASM_rax as libc::c_int + reg;
            }
            _ => {
                reg = TOK_ASM_eax as libc::c_int + reg;
            }
        }
        cstr_printf(
            add_str,
            b"%%%s\0" as *const u8 as *const libc::c_char,
            get_tok_str(reg, 0 as *mut CValue),
        );
    };
}
unsafe extern "C" fn asm_gen_code(
    mut operands: *mut ASMOperand,
    mut nb_operands: libc::c_int,
    mut nb_outputs: libc::c_int,
    mut is_output: libc::c_int,
    mut clobber_regs: *mut uint8_t,
    mut out_reg: libc::c_int,
) {
    let mut regs_allocated: [uint8_t; 16] = [0; 16];
    let mut op: *mut ASMOperand = 0 as *mut ASMOperand;
    let mut i: libc::c_int = 0;
    let mut reg: libc::c_int = 0;
    static mut reg_saved: [uint8_t; 5] = [
        3 as libc::c_int as uint8_t,
        12 as libc::c_int as uint8_t,
        13 as libc::c_int as uint8_t,
        14 as libc::c_int as uint8_t,
        15 as libc::c_int as uint8_t,
    ];
    memcpy(
        regs_allocated.as_mut_ptr() as *mut libc::c_void,
        clobber_regs as *const libc::c_void,
        ::core::mem::size_of::<[uint8_t; 16]>() as libc::c_ulong,
    );
    i = 0 as libc::c_int;
    while i < nb_operands {
        op = &mut *operands.offset(i as isize) as *mut ASMOperand;
        if (*op).reg >= 0 as libc::c_int {
            regs_allocated[(*op).reg as usize] = 1 as libc::c_int as uint8_t;
        }
        i += 1;
        i;
    }
    if is_output == 0 {
        i = 0 as libc::c_int;
        while (i as libc::c_ulong)
            < (::core::mem::size_of::<[uint8_t; 5]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<uint8_t>() as libc::c_ulong)
        {
            reg = reg_saved[i as usize] as libc::c_int;
            if regs_allocated[reg as usize] != 0 {
                if reg >= 8 as libc::c_int {
                    g(0x41 as libc::c_int);
                    reg -= 8 as libc::c_int;
                }
                g(0x50 as libc::c_int + reg);
            }
            i += 1;
            i;
        }
        i = 0 as libc::c_int;
        while i < nb_operands {
            op = &mut *operands.offset(i as isize) as *mut ASMOperand;
            if (*op).reg >= 0 as libc::c_int {
                if (*(*op).vt).r as libc::c_int & 0x3f as libc::c_int
                    == 0x31 as libc::c_int && (*op).is_memory != 0
                {
                    let mut sv: SValue = SValue {
                        type_0: CType {
                            t: 0,
                            ref_0: 0 as *mut Sym,
                        },
                        r: 0,
                        r2: 0,
                        c2rust_unnamed: C2RustUnnamed_15 {
                            c2rust_unnamed: C2RustUnnamed_16 {
                                jtrue: 0,
                                jfalse: 0,
                            },
                        },
                        c2rust_unnamed_0: C2RustUnnamed_13 {
                            c2rust_unnamed: C2RustUnnamed_14 {
                                cmp_op: 0,
                                cmp_r: 0,
                            },
                        },
                    };
                    sv = *(*op).vt;
                    sv
                        .r = (sv.r as libc::c_int & !(0x3f as libc::c_int)
                        | 0x32 as libc::c_int | 0x100 as libc::c_int) as libc::c_ushort;
                    sv.type_0.t = 5 as libc::c_int;
                    load((*op).reg, &mut sv);
                } else if i >= nb_outputs || (*op).is_rw != 0 {
                    load((*op).reg, (*op).vt);
                    if (*op).is_llong != 0 {
                        let mut sv_0: SValue = SValue {
                            type_0: CType {
                                t: 0,
                                ref_0: 0 as *mut Sym,
                            },
                            r: 0,
                            r2: 0,
                            c2rust_unnamed: C2RustUnnamed_15 {
                                c2rust_unnamed: C2RustUnnamed_16 {
                                    jtrue: 0,
                                    jfalse: 0,
                                },
                            },
                            c2rust_unnamed_0: C2RustUnnamed_13 {
                                c2rust_unnamed: C2RustUnnamed_14 {
                                    cmp_op: 0,
                                    cmp_r: 0,
                                },
                            },
                        };
                        sv_0 = *(*op).vt;
                        sv_0
                            .c2rust_unnamed
                            .c
                            .i = (sv_0.c2rust_unnamed.c.i)
                            .wrapping_add(4 as libc::c_int as uint64_t);
                        load(TREG_RDX as libc::c_int, &mut sv_0);
                    }
                }
            }
            i += 1;
            i;
        }
    } else {
        i = 0 as libc::c_int;
        while i < nb_outputs {
            op = &mut *operands.offset(i as isize) as *mut ASMOperand;
            if (*op).reg >= 0 as libc::c_int {
                if (*(*op).vt).r as libc::c_int & 0x3f as libc::c_int
                    == 0x31 as libc::c_int
                {
                    if (*op).is_memory == 0 {
                        let mut sv_1: SValue = SValue {
                            type_0: CType {
                                t: 0,
                                ref_0: 0 as *mut Sym,
                            },
                            r: 0,
                            r2: 0,
                            c2rust_unnamed: C2RustUnnamed_15 {
                                c2rust_unnamed: C2RustUnnamed_16 {
                                    jtrue: 0,
                                    jfalse: 0,
                                },
                            },
                            c2rust_unnamed_0: C2RustUnnamed_13 {
                                c2rust_unnamed: C2RustUnnamed_14 {
                                    cmp_op: 0,
                                    cmp_r: 0,
                                },
                            },
                        };
                        sv_1 = *(*op).vt;
                        sv_1
                            .r = (sv_1.r as libc::c_int & !(0x3f as libc::c_int)
                            | 0x32 as libc::c_int) as libc::c_ushort;
                        sv_1.type_0.t = 5 as libc::c_int;
                        load(out_reg, &mut sv_1);
                        sv_1 = *(*op).vt;
                        sv_1
                            .r = (sv_1.r as libc::c_int & !(0x3f as libc::c_int)
                            | out_reg) as libc::c_ushort;
                        store((*op).reg, &mut sv_1);
                    }
                } else {
                    store((*op).reg, (*op).vt);
                    if (*op).is_llong != 0 {
                        let mut sv_2: SValue = SValue {
                            type_0: CType {
                                t: 0,
                                ref_0: 0 as *mut Sym,
                            },
                            r: 0,
                            r2: 0,
                            c2rust_unnamed: C2RustUnnamed_15 {
                                c2rust_unnamed: C2RustUnnamed_16 {
                                    jtrue: 0,
                                    jfalse: 0,
                                },
                            },
                            c2rust_unnamed_0: C2RustUnnamed_13 {
                                c2rust_unnamed: C2RustUnnamed_14 {
                                    cmp_op: 0,
                                    cmp_r: 0,
                                },
                            },
                        };
                        sv_2 = *(*op).vt;
                        sv_2
                            .c2rust_unnamed
                            .c
                            .i = (sv_2.c2rust_unnamed.c.i)
                            .wrapping_add(4 as libc::c_int as uint64_t);
                        store(TREG_RDX as libc::c_int, &mut sv_2);
                    }
                }
            }
            i += 1;
            i;
        }
        i = (::core::mem::size_of::<[uint8_t; 5]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint8_t>() as libc::c_ulong)
            .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
        while i >= 0 as libc::c_int {
            reg = reg_saved[i as usize] as libc::c_int;
            if regs_allocated[reg as usize] != 0 {
                if reg >= 8 as libc::c_int {
                    g(0x41 as libc::c_int);
                    reg -= 8 as libc::c_int;
                }
                g(0x58 as libc::c_int + reg);
            }
            i -= 1;
            i;
        }
    };
}
unsafe extern "C" fn asm_clobber(
    mut clobber_regs: *mut uint8_t,
    mut str: *const libc::c_char,
) {
    let mut reg: libc::c_int = 0;
    let mut type_0: libc::c_uint = 0;
    if strcmp(str, b"memory\0" as *const u8 as *const libc::c_char) == 0
        || strcmp(str, b"cc\0" as *const u8 as *const libc::c_char) == 0
        || strcmp(str, b"flags\0" as *const u8 as *const libc::c_char) == 0
    {
        return;
    }
    reg = tok_alloc_const(str);
    if reg >= TOK_ASM_eax as libc::c_int && reg <= TOK_ASM_edi as libc::c_int {
        reg -= TOK_ASM_eax as libc::c_int;
    } else if reg >= TOK_ASM_ax as libc::c_int && reg <= TOK_ASM_di as libc::c_int {
        reg -= TOK_ASM_ax as libc::c_int;
    } else if reg >= TOK_ASM_rax as libc::c_int && reg <= TOK_ASM_rdi as libc::c_int {
        reg -= TOK_ASM_rax as libc::c_int;
    } else {
        reg = asm_parse_numeric_reg(reg, &mut type_0);
        if reg >= 0 as libc::c_int {} else {
            _tcc_error(
                b"invalid clobber register '%s'\0" as *const u8 as *const libc::c_char,
                str,
            );
        }
    }
    *clobber_regs.offset(reg as isize) = 1 as libc::c_int as uint8_t;
}
static mut tcc_state: *mut TCCState = 0 as *const TCCState as *mut TCCState;
static mut tcc_compile_sem: TCCSem = TCCSem {
    init: 0,
    sem: sem_t { __size: [0; 32] },
};
static mut stk_data: *mut *mut libc::c_void = 0 as *const *mut libc::c_void
    as *mut *mut libc::c_void;
static mut nb_stk_data: libc::c_int = 0;
static mut g_debug: libc::c_int = 0;
#[no_mangle]
pub unsafe extern "C" fn tcc_enter_state(mut s1: *mut TCCState) {
    if (*s1).error_set_jmp_enabled != 0 {
        return;
    }
    wait_sem(&mut tcc_compile_sem);
    tcc_state = s1;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_exit_state(mut s1: *mut TCCState) {
    if (*s1).error_set_jmp_enabled != 0 {
        return;
    }
    tcc_state = 0 as *mut TCCState;
    post_sem(&mut tcc_compile_sem);
}
unsafe extern "C" fn pstrcpy(
    mut buf: *mut libc::c_char,
    mut buf_size: size_t,
    mut s: *const libc::c_char,
) -> *mut libc::c_char {
    let mut q: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut q_end: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut c: libc::c_int = 0;
    if buf_size > 0 as libc::c_int as size_t {
        q = buf;
        q_end = buf.offset(buf_size as isize).offset(-(1 as libc::c_int as isize));
        while q < q_end {
            let fresh175 = s;
            s = s.offset(1);
            c = *fresh175 as libc::c_int;
            if c == '\0' as i32 {
                break;
            }
            let fresh176 = q;
            q = q.offset(1);
            *fresh176 = c as libc::c_char;
        }
        *q = '\0' as i32 as libc::c_char;
    }
    return buf;
}
unsafe extern "C" fn pstrcat(
    mut buf: *mut libc::c_char,
    mut buf_size: size_t,
    mut s: *const libc::c_char,
) -> *mut libc::c_char {
    let mut len: size_t = 0;
    len = strlen(buf);
    if len < buf_size {
        pstrcpy(buf.offset(len as isize), buf_size.wrapping_sub(len), s);
    }
    return buf;
}
unsafe extern "C" fn pstrncpy(
    mut out: *mut libc::c_char,
    mut buf_size: size_t,
    mut s: *const libc::c_char,
    mut num: size_t,
) -> *mut libc::c_char {
    if num >= buf_size {
        num = buf_size.wrapping_sub(1 as libc::c_int as size_t);
    }
    memcpy(out as *mut libc::c_void, s as *const libc::c_void, num);
    *out.offset(num as isize) = '\0' as i32 as libc::c_char;
    return out;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_basename(
    mut name: *const libc::c_char,
) -> *mut libc::c_char {
    let mut p: *mut libc::c_char = strchr(name, 0 as libc::c_int);
    while p > name as *mut libc::c_char
        && !(*p.offset(-(1 as libc::c_int) as isize) as libc::c_int == '/' as i32)
    {
        p = p.offset(-1);
        p;
    }
    return p;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_fileextension(
    mut name: *const libc::c_char,
) -> *mut libc::c_char {
    let mut b: *mut libc::c_char = tcc_basename(name);
    let mut e: *mut libc::c_char = strrchr(b, '.' as i32);
    return if !e.is_null() { e } else { strchr(b, 0 as libc::c_int) };
}
unsafe extern "C" fn tcc_load_text(mut fd: libc::c_int) -> *mut libc::c_char {
    let mut len: libc::c_int = lseek(fd, 0 as libc::c_int as __off_t, 2 as libc::c_int)
        as libc::c_int;
    let mut buf: *mut libc::c_char = load_data(
        fd,
        0 as libc::c_int as libc::c_ulong,
        (len + 1 as libc::c_int) as libc::c_ulong,
    ) as *mut libc::c_char;
    *buf.offset(len as isize) = 0 as libc::c_int as libc::c_char;
    return buf;
}
unsafe extern "C" fn tcc_set_str(
    mut pp: *mut *mut libc::c_char,
    mut str: *const libc::c_char,
) {
    tcc_free(*pp as *mut libc::c_void);
    *pp = if !str.is_null() { tcc_strdup(str) } else { 0 as *mut libc::c_char };
}
unsafe extern "C" fn tcc_concat_str(
    mut pp: *mut *mut libc::c_char,
    mut str: *const libc::c_char,
    mut sep: libc::c_int,
) {
    let mut l: libc::c_int = (if !(*pp).is_null() {
        (strlen(*pp)).wrapping_add((sep != 0) as libc::c_int as libc::c_ulong)
    } else {
        0 as libc::c_int as libc::c_ulong
    }) as libc::c_int;
    *pp = tcc_realloc(
        *pp as *mut libc::c_void,
        (l as libc::c_ulong)
            .wrapping_add(strlen(str))
            .wrapping_add(1 as libc::c_int as libc::c_ulong),
    ) as *mut libc::c_char;
    if l != 0 && sep != 0 {
        *(*pp).offset((l - 1 as libc::c_int) as isize) = sep as libc::c_char;
    }
    strcpy((*pp).offset(l as isize), str);
}
unsafe extern "C" fn default_reallocator(
    mut ptr: *mut libc::c_void,
    mut size: libc::c_ulong,
) -> *mut libc::c_void {
    let mut ptr1: *mut libc::c_void = 0 as *mut libc::c_void;
    if size == 0 as libc::c_int as libc::c_ulong {
        free(ptr);
        ptr1 = 0 as *mut libc::c_void;
    } else {
        ptr1 = realloc(ptr, size);
        if ptr1.is_null() {
            fprintf(stderr, b"memory full\n\0" as *const u8 as *const libc::c_char);
            exit(1 as libc::c_int);
        }
    }
    return ptr1;
}
unsafe extern "C" fn libc_free(mut ptr: *mut libc::c_void) {
    free(ptr);
}
static mut reallocator: Option::<
    unsafe extern "C" fn(*mut libc::c_void, libc::c_ulong) -> *mut libc::c_void,
> = unsafe {
    Some(
        default_reallocator
            as unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_ulong,
            ) -> *mut libc::c_void,
    )
};
#[no_mangle]
pub unsafe extern "C" fn tcc_set_realloc(mut realloc_0: Option::<TCCReallocFunc>) {
    reallocator = if realloc_0.is_some() {
        realloc_0
    } else {
        Some(
            default_reallocator
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_ulong,
                ) -> *mut libc::c_void,
        )
    };
}
#[no_mangle]
pub unsafe extern "C" fn tcc_free(mut ptr: *mut libc::c_void) {
    reallocator
        .expect("non-null function pointer")(ptr, 0 as libc::c_int as libc::c_ulong);
}
#[no_mangle]
pub unsafe extern "C" fn tcc_malloc(mut size: libc::c_ulong) -> *mut libc::c_void {
    return reallocator.expect("non-null function pointer")(0 as *mut libc::c_void, size);
}
#[no_mangle]
pub unsafe extern "C" fn tcc_realloc(
    mut ptr: *mut libc::c_void,
    mut size: libc::c_ulong,
) -> *mut libc::c_void {
    return reallocator.expect("non-null function pointer")(ptr, size);
}
#[no_mangle]
pub unsafe extern "C" fn tcc_mallocz(mut size: libc::c_ulong) -> *mut libc::c_void {
    let mut ptr: *mut libc::c_void = 0 as *mut libc::c_void;
    ptr = tcc_malloc(size);
    if size != 0 {
        memset(ptr, 0 as libc::c_int, size);
    }
    return ptr;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_strdup(mut str: *const libc::c_char) -> *mut libc::c_char {
    let mut ptr: *mut libc::c_char = 0 as *mut libc::c_char;
    ptr = tcc_malloc((strlen(str)).wrapping_add(1 as libc::c_int as libc::c_ulong))
        as *mut libc::c_char;
    strcpy(ptr, str);
    return ptr;
}
unsafe extern "C" fn normalized_PATHCMP(
    mut f1: *const libc::c_char,
    mut f2: *const libc::c_char,
) -> libc::c_int {
    let mut p1: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut p2: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ret: libc::c_int = 1 as libc::c_int;
    p1 = realpath(f1, 0 as *mut libc::c_char);
    if !p1.is_null() {
        p2 = realpath(f2, 0 as *mut libc::c_char);
        if !p2.is_null() {
            ret = strcmp(p1, p2);
            libc_free(p2 as *mut libc::c_void);
        }
        libc_free(p1 as *mut libc::c_void);
    }
    return ret;
}
unsafe extern "C" fn dynarray_add(
    mut ptab: *mut libc::c_void,
    mut nb_ptr: *mut libc::c_int,
    mut data: *mut libc::c_void,
) {
    let mut nb: libc::c_int = 0;
    let mut nb_alloc: libc::c_int = 0;
    let mut pp: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
    nb = *nb_ptr;
    pp = *(ptab as *mut *mut *mut libc::c_void);
    if nb & nb - 1 as libc::c_int == 0 as libc::c_int {
        if nb == 0 {
            nb_alloc = 1 as libc::c_int;
        } else {
            nb_alloc = nb * 2 as libc::c_int;
        }
        pp = tcc_realloc(
            pp as *mut libc::c_void,
            (nb_alloc as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_void>() as libc::c_ulong,
                ),
        ) as *mut *mut libc::c_void;
        let ref mut fresh177 = *(ptab as *mut *mut *mut libc::c_void);
        *fresh177 = pp;
    }
    let fresh178 = nb;
    nb = nb + 1;
    let ref mut fresh179 = *pp.offset(fresh178 as isize);
    *fresh179 = data;
    *nb_ptr = nb;
}
unsafe extern "C" fn dynarray_reset(mut pp: *mut libc::c_void, mut n: *mut libc::c_int) {
    let mut p: *mut *mut libc::c_void = 0 as *mut *mut libc::c_void;
    p = *(pp as *mut *mut *mut libc::c_void);
    while *n != 0 {
        if !(*p).is_null() {
            tcc_free(*p);
        }
        p = p.offset(1);
        p;
        *n -= 1;
        *n;
    }
    tcc_free(*(pp as *mut *mut libc::c_void));
    let ref mut fresh180 = *(pp as *mut *mut libc::c_void);
    *fresh180 = 0 as *mut libc::c_void;
}
unsafe extern "C" fn dynarray_split(
    mut argv: *mut *mut *mut libc::c_char,
    mut argc: *mut libc::c_int,
    mut p: *const libc::c_char,
    mut sep: libc::c_int,
) {
    let mut qot: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut str: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    loop {
        loop {
            c = *p as libc::c_uchar as libc::c_int;
            if !(c <= ' ' as i32 && c != '\0' as i32) {
                break;
            }
            p = p.offset(1);
            p;
        }
        if c == '\0' as i32 {
            break;
        }
        cstr_new(&mut str);
        qot = 0 as libc::c_int;
        let mut current_block_8: u64;
        loop {
            p = p.offset(1);
            p;
            if sep != 0 {
                if c == sep {
                    break;
                }
                current_block_8 = 12039483399334584727;
            } else if c == '\\' as i32
                && (*p as libc::c_int == '"' as i32 || *p as libc::c_int == '\\' as i32)
            {
                let fresh181 = p;
                p = p.offset(1);
                c = *fresh181 as libc::c_int;
                current_block_8 = 12039483399334584727;
            } else if c == '"' as i32 {
                qot ^= 1 as libc::c_int;
                current_block_8 = 15619007995458559411;
            } else {
                if c <= ' ' as i32 && qot == 0 {
                    break;
                }
                current_block_8 = 12039483399334584727;
            }
            match current_block_8 {
                12039483399334584727 => {
                    cstr_ccat(&mut str, c);
                }
                _ => {}
            }
            c = *p as libc::c_uchar as libc::c_int;
            if !(c != '\0' as i32) {
                break;
            }
        }
        cstr_ccat(&mut str, '\0' as i32);
        dynarray_add(argv as *mut libc::c_void, argc, str.data as *mut libc::c_void);
    };
}
unsafe extern "C" fn tcc_split_path(
    mut s: *mut TCCState,
    mut p_ary: *mut libc::c_void,
    mut p_nb_ary: *mut libc::c_int,
    mut in_0: *const libc::c_char,
) {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        let mut c: libc::c_int = 0;
        let mut str: CString = CString {
            size: 0,
            size_allocated: 0,
            data: 0 as *mut libc::c_char,
        };
        cstr_new(&mut str);
        p = in_0;
        loop {
            c = *p as libc::c_int;
            if !(c != '\0' as i32
                && c
                    != (*::core::mem::transmute::<
                        &[u8; 2],
                        &[libc::c_char; 2],
                    >(b":\0"))[0 as libc::c_int as usize] as libc::c_int)
            {
                break;
            }
            if c == '{' as i32
                && *p.offset(1 as libc::c_int as isize) as libc::c_int != 0
                && *p.offset(2 as libc::c_int as isize) as libc::c_int == '}' as i32
            {
                c = *p.offset(1 as libc::c_int as isize) as libc::c_int;
                p = p.offset(2 as libc::c_int as isize);
                if c == 'B' as i32 {
                    cstr_cat(&mut str, (*s).tcc_lib_path, -(1 as libc::c_int));
                }
                if c == 'R' as i32 {
                    cstr_cat(
                        &mut str,
                        b"\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                    );
                }
                if c == 'f' as i32 && !file.is_null() {
                    let mut f: *const libc::c_char = (*file).true_filename;
                    let mut b: *const libc::c_char = tcc_basename(f);
                    if b > f {
                        cstr_cat(
                            &mut str,
                            f,
                            (b.offset_from(f) as libc::c_long
                                - 1 as libc::c_int as libc::c_long) as libc::c_int,
                        );
                    } else {
                        cstr_cat(
                            &mut str,
                            b".\0" as *const u8 as *const libc::c_char,
                            1 as libc::c_int,
                        );
                    }
                }
            } else {
                cstr_ccat(&mut str, c);
            }
            p = p.offset(1);
            p;
        }
        if str.size != 0 {
            cstr_ccat(&mut str, '\0' as i32);
            dynarray_add(p_ary, p_nb_ary, str.data as *mut libc::c_void);
        }
        in_0 = p.offset(1 as libc::c_int as isize);
        if !(*p != 0) {
            break;
        }
    };
}
unsafe extern "C" fn error1(
    mut mode: libc::c_int,
    mut fmt: *const libc::c_char,
    mut ap: ::core::ffi::VaList,
) {
    let mut pf: *mut *mut BufferedFile = 0 as *mut *mut BufferedFile;
    let mut f: *mut BufferedFile = 0 as *mut BufferedFile;
    let mut s1: *mut TCCState = tcc_state;
    let mut cs: CString = CString {
        size: 0,
        size_allocated: 0,
        data: 0 as *mut libc::c_char,
    };
    let mut line: libc::c_int = 0 as libc::c_int;
    tcc_exit_state(s1);
    if mode == ERROR_WARN as libc::c_int {
        if (*s1).warn_error != 0 {
            mode = ERROR_ERROR as libc::c_int;
        }
        if (*s1).warn_num != 0 {
            let mut wopt: libc::c_int = *(&mut (*s1).warn_none as *mut libc::c_uchar)
                .offset((*s1).warn_num as libc::c_int as isize) as libc::c_int;
            (*s1).warn_num = 0 as libc::c_int as libc::c_uchar;
            if 0 as libc::c_int == wopt & 1 as libc::c_int {
                return;
            }
            if wopt & 2 as libc::c_int != 0 {
                mode = ERROR_ERROR as libc::c_int;
            }
            if wopt & 4 as libc::c_int != 0 {
                mode = ERROR_WARN as libc::c_int;
            }
        }
        if (*s1).warn_none != 0 {
            return;
        }
    }
    cstr_new(&mut cs);
    if *fmt.offset(0 as libc::c_int as isize) as libc::c_int == '%' as i32
        && *fmt.offset(1 as libc::c_int as isize) as libc::c_int == 'i' as i32
        && *fmt.offset(2 as libc::c_int as isize) as libc::c_int == ':' as i32
    {
        line = ap.arg::<libc::c_int>();
        fmt = fmt.offset(3 as libc::c_int as isize);
    }
    f = 0 as *mut BufferedFile;
    if (*s1).error_set_jmp_enabled != 0 {
        f = file;
        while !f.is_null()
            && (*f).filename[0 as libc::c_int as usize] as libc::c_int == ':' as i32
        {
            f = (*f).prev;
        }
    }
    if !f.is_null() {
        pf = ((*s1).include_stack).as_mut_ptr();
        while pf < (*s1).include_stack_ptr {
            cstr_printf(
                &mut cs as *mut CString,
                b"In file included from %s:%d:\n\0" as *const u8 as *const libc::c_char,
                ((**pf).filename).as_mut_ptr(),
                (**pf).line_num - 1 as libc::c_int,
            );
            pf = pf.offset(1);
            pf;
        }
        if 0 as libc::c_int == line {
            line = (*f).line_num
                - (tok_flags & 0x1 as libc::c_int != 0 && macro_ptr.is_null())
                    as libc::c_int;
        }
        cstr_printf(
            &mut cs as *mut CString,
            b"%s:%d: \0" as *const u8 as *const libc::c_char,
            ((*f).filename).as_mut_ptr(),
            line,
        );
    } else if !((*s1).current_filename).is_null() {
        cstr_printf(
            &mut cs as *mut CString,
            b"%s: \0" as *const u8 as *const libc::c_char,
            (*s1).current_filename,
        );
    } else {
        cstr_printf(
            &mut cs as *mut CString,
            b"tcc: \0" as *const u8 as *const libc::c_char,
        );
    }
    cstr_printf(
        &mut cs as *mut CString,
        if mode == ERROR_WARN as libc::c_int {
            b"warning: \0" as *const u8 as *const libc::c_char
        } else {
            b"error: \0" as *const u8 as *const libc::c_char
        },
    );
    if pp_expr > 1 as libc::c_int {
        pp_error(&mut cs);
    } else {
        cstr_vprintf(&mut cs, fmt, ap.as_va_list());
    }
    if ((*s1).error_func).is_none() {
        if !s1.is_null() && (*s1).output_type == 5 as libc::c_int && (*s1).ppfp == stdout
        {
            printf(b"\n\0" as *const u8 as *const libc::c_char);
        }
        fflush(stdout);
        fprintf(stderr, b"%s\n\0" as *const u8 as *const libc::c_char, cs.data);
        fflush(stderr);
    } else {
        ((*s1).error_func)
            .expect("non-null function pointer")((*s1).error_opaque, cs.data);
    }
    cstr_free(&mut cs);
    if mode != ERROR_WARN as libc::c_int {
        (*s1).nb_errors += 1;
        (*s1).nb_errors;
    }
    if mode == ERROR_ERROR as libc::c_int && (*s1).error_set_jmp_enabled != 0 {
        while nb_stk_data != 0 {
            nb_stk_data -= 1;
            tcc_free(
                *(*stk_data.offset(nb_stk_data as isize) as *mut *mut libc::c_void),
            );
        }
        longjmp(((*s1).error_jmp_buf).as_mut_ptr(), 1 as libc::c_int);
    }
}
#[no_mangle]
pub unsafe extern "C" fn tcc_set_error_func(
    mut s: *mut TCCState,
    mut error_opaque: *mut libc::c_void,
    mut error_func: Option::<TCCErrorFunc>,
) {
    (*s).error_opaque = error_opaque;
    (*s).error_func = error_func;
}
#[no_mangle]
pub unsafe extern "C" fn _tcc_error_noabort(
    mut fmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    error1(ERROR_NOABORT as libc::c_int, fmt, ap.as_va_list());
    return -(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn _tcc_error(mut fmt: *const libc::c_char, mut args: ...) -> ! {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    error1(ERROR_ERROR as libc::c_int, fmt, ap.as_va_list());
    exit(1 as libc::c_int);
}
#[no_mangle]
pub unsafe extern "C" fn _tcc_warning(mut fmt: *const libc::c_char, mut args: ...) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    error1(ERROR_WARN as libc::c_int, fmt, ap.as_va_list());
}
unsafe extern "C" fn tcc_open_bf(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
    mut initlen: libc::c_int,
) {
    let mut bf: *mut BufferedFile = 0 as *mut BufferedFile;
    let mut buflen: libc::c_int = if initlen != 0 {
        initlen
    } else {
        8192 as libc::c_int
    };
    bf = tcc_mallocz(
        (::core::mem::size_of::<BufferedFile>() as libc::c_ulong)
            .wrapping_add(buflen as libc::c_ulong),
    ) as *mut BufferedFile;
    (*bf).buf_ptr = ((*bf).buffer).as_mut_ptr();
    (*bf).buf_end = ((*bf).buffer).as_mut_ptr().offset(initlen as isize);
    *((*bf).buf_end).offset(0 as libc::c_int as isize) = '\\' as i32 as uint8_t;
    pstrcpy(
        ((*bf).filename).as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
        filename,
    );
    (*bf).true_filename = ((*bf).filename).as_mut_ptr();
    (*bf).line_num = 1 as libc::c_int;
    (*bf).ifdef_stack_ptr = (*s1).ifdef_stack_ptr;
    (*bf).fd = -(1 as libc::c_int);
    (*bf).prev = file;
    (*bf).prev_tok_flags = tok_flags;
    file = bf;
    tok_flags = 0x1 as libc::c_int | 0x2 as libc::c_int;
}
unsafe extern "C" fn tcc_close() {
    let mut s1: *mut TCCState = tcc_state;
    let mut bf: *mut BufferedFile = file;
    if (*bf).fd > 0 as libc::c_int {
        close((*bf).fd);
        (*s1).total_lines += (*bf).line_num - 1 as libc::c_int;
    }
    if (*bf).true_filename != ((*bf).filename).as_mut_ptr() {
        tcc_free((*bf).true_filename as *mut libc::c_void);
    }
    file = (*bf).prev;
    tok_flags = (*bf).prev_tok_flags;
    tcc_free(bf as *mut libc::c_void);
}
unsafe extern "C" fn _tcc_open(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    if strcmp(filename, b"-\0" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
        fd = 0 as libc::c_int;
        filename = b"<stdin>\0" as *const u8 as *const libc::c_char;
    } else {
        fd = open(filename, 0 as libc::c_int | 0 as libc::c_int);
    }
    if (*s1).verbose as libc::c_int == 2 as libc::c_int && fd >= 0 as libc::c_int
        || (*s1).verbose as libc::c_int == 3 as libc::c_int
    {
        printf(
            b"%s %*s%s\n\0" as *const u8 as *const libc::c_char,
            if fd < 0 as libc::c_int {
                b"nf\0" as *const u8 as *const libc::c_char
            } else {
                b"->\0" as *const u8 as *const libc::c_char
            },
            ((*s1).include_stack_ptr).offset_from(((*s1).include_stack).as_mut_ptr())
                as libc::c_long as libc::c_int,
            b"\0" as *const u8 as *const libc::c_char,
            filename,
        );
    }
    return fd;
}
unsafe extern "C" fn tcc_open(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    let mut fd: libc::c_int = _tcc_open(s1, filename);
    if fd < 0 as libc::c_int {
        return -(1 as libc::c_int);
    }
    tcc_open_bf(s1, filename, 0 as libc::c_int);
    (*file).fd = fd;
    return 0 as libc::c_int;
}
unsafe extern "C" fn tcc_compile(
    mut s1: *mut TCCState,
    mut filetype: libc::c_int,
    mut str: *const libc::c_char,
    mut fd: libc::c_int,
) -> libc::c_int {
    tcc_enter_state(s1);
    (*s1).error_set_jmp_enabled = 1 as libc::c_int;
    if _setjmp(((*s1).error_jmp_buf).as_mut_ptr()) == 0 as libc::c_int {
        (*s1).nb_errors = 0 as libc::c_int;
        if fd == -(1 as libc::c_int) {
            let mut len: libc::c_int = strlen(str) as libc::c_int;
            tcc_open_bf(s1, b"<string>\0" as *const u8 as *const libc::c_char, len);
            memcpy(
                ((*file).buffer).as_mut_ptr() as *mut libc::c_void,
                str as *const libc::c_void,
                len as libc::c_ulong,
            );
        } else {
            tcc_open_bf(s1, str, 0 as libc::c_int);
            (*file).fd = fd;
        }
        preprocess_start(s1, filetype);
        tccgen_init(s1);
        if (*s1).output_type == 5 as libc::c_int {
            tcc_preprocess(s1);
        } else {
            tccelf_begin_file(s1);
            if filetype & (2 as libc::c_int | 4 as libc::c_int) != 0 {
                tcc_assemble(s1, (filetype & 4 as libc::c_int != 0) as libc::c_int);
            } else {
                tccgen_compile(s1);
            }
            tccelf_end_file(s1);
        }
    }
    tccgen_finish(s1);
    preprocess_end(s1);
    (*s1).error_set_jmp_enabled = 0 as libc::c_int;
    tcc_exit_state(s1);
    return if (*s1).nb_errors != 0 as libc::c_int {
        -(1 as libc::c_int)
    } else {
        0 as libc::c_int
    };
}
#[no_mangle]
pub unsafe extern "C" fn tcc_compile_string(
    mut s: *mut TCCState,
    mut str: *const libc::c_char,
) -> libc::c_int {
    return tcc_compile(s, (*s).filetype as libc::c_int, str, -(1 as libc::c_int));
}
#[no_mangle]
pub unsafe extern "C" fn tcc_define_symbol(
    mut s1: *mut TCCState,
    mut sym: *const libc::c_char,
    mut value: *const libc::c_char,
) {
    let mut eq: *const libc::c_char = 0 as *const libc::c_char;
    eq = strchr(sym, '=' as i32);
    if eq.is_null() {
        eq = strchr(sym, 0 as libc::c_int);
    }
    if value.is_null() {
        value = if *eq as libc::c_int != 0 {
            eq.offset(1 as libc::c_int as isize)
        } else {
            b"1\0" as *const u8 as *const libc::c_char
        };
    }
    cstr_printf(
        &mut (*s1).cmdline_defs as *mut CString,
        b"#define %.*s %s\n\0" as *const u8 as *const libc::c_char,
        eq.offset_from(sym) as libc::c_long as libc::c_int,
        sym,
        value,
    );
}
#[no_mangle]
pub unsafe extern "C" fn tcc_undefine_symbol(
    mut s1: *mut TCCState,
    mut sym: *const libc::c_char,
) {
    cstr_printf(
        &mut (*s1).cmdline_defs as *mut CString,
        b"#undef %s\n\0" as *const u8 as *const libc::c_char,
        sym,
    );
}
#[no_mangle]
pub unsafe extern "C" fn tcc_new() -> *mut TCCState {
    let mut s: *mut TCCState = 0 as *mut TCCState;
    s = tcc_mallocz(::core::mem::size_of::<TCCState>() as libc::c_ulong)
        as *mut TCCState;
    (*s).gnu_ext = 1 as libc::c_int as libc::c_uchar;
    (*s).tcc_ext = 1 as libc::c_int as libc::c_uchar;
    (*s).nocommon = 1 as libc::c_int as libc::c_uchar;
    (*s).dollars_in_identifiers = 1 as libc::c_int as libc::c_uchar;
    (*s).cversion = 199901 as libc::c_int as libc::c_uint;
    (*s).warn_implicit_function_declaration = 1 as libc::c_int as libc::c_uchar;
    (*s).warn_discarded_qualifiers = 1 as libc::c_int as libc::c_uchar;
    (*s).ms_extensions = 1 as libc::c_int as libc::c_uchar;
    (*s).unwind_tables = 1 as libc::c_int as libc::c_uchar;
    (*s).ppfp = stdout;
    (*s).include_stack_ptr = ((*s).include_stack).as_mut_ptr();
    tcc_set_lib_path(s, b"/usr/local/lib/tcc\0" as *const u8 as *const libc::c_char);
    return s;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_delete(mut s1: *mut TCCState) {
    tccelf_delete(s1);
    dynarray_reset(
        &mut (*s1).library_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_library_paths,
    );
    dynarray_reset(
        &mut (*s1).crt_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_crt_paths,
    );
    dynarray_reset(
        &mut (*s1).include_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_include_paths,
    );
    dynarray_reset(
        &mut (*s1).sysinclude_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_sysinclude_paths,
    );
    tcc_free((*s1).tcc_lib_path as *mut libc::c_void);
    tcc_free((*s1).soname as *mut libc::c_void);
    tcc_free((*s1).rpath as *mut libc::c_void);
    tcc_free((*s1).elfint as *mut libc::c_void);
    tcc_free((*s1).elf_entryname as *mut libc::c_void);
    tcc_free((*s1).init_symbol as *mut libc::c_void);
    tcc_free((*s1).fini_symbol as *mut libc::c_void);
    tcc_free((*s1).mapfile as *mut libc::c_void);
    tcc_free((*s1).outfile as *mut libc::c_void);
    tcc_free((*s1).deps_outfile as *mut libc::c_void);
    dynarray_reset(
        &mut (*s1).files as *mut *mut *mut filespec as *mut libc::c_void,
        &mut (*s1).nb_files,
    );
    dynarray_reset(
        &mut (*s1).target_deps as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_target_deps,
    );
    dynarray_reset(
        &mut (*s1).pragma_libs as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_pragma_libs,
    );
    dynarray_reset(
        &mut (*s1).argv as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).argc,
    );
    dynarray_reset(
        &mut (*s1).link_argv as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).link_argc,
    );
    cstr_free(&mut (*s1).cmdline_defs);
    cstr_free(&mut (*s1).cmdline_incl);
    tcc_free((*s1).dState as *mut libc::c_void);
    tcc_run_free(s1);
    dynarray_reset(
        &mut (*s1).loaded_dlls as *mut *mut *mut DLLReference as *mut libc::c_void,
        &mut (*s1).nb_loaded_dlls,
    );
    tcc_free(s1 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn tcc_set_output_type(
    mut s: *mut TCCState,
    mut output_type: libc::c_int,
) -> libc::c_int {
    (*s).output_type = output_type;
    if (*s).nostdinc == 0 {
        tcc_add_sysinclude_path(
            s,
            b"{B}/include:/usr/local/include/x86_64-linux-gnu:/usr/local/include:/usr/include/x86_64-linux-gnu:/usr/include\0"
                as *const u8 as *const libc::c_char,
        );
    }
    if output_type == 5 as libc::c_int {
        (*s).do_debug = 0 as libc::c_int as libc::c_uchar;
        return 0 as libc::c_int;
    }
    tccelf_new(s);
    if output_type == 3 as libc::c_int {
        (*s).output_format = 0 as libc::c_int;
        return 0 as libc::c_int;
    }
    if (*s).nostdlib_paths == 0 {
        tcc_add_library_path(
            s,
            b"{B}:/usr/lib/x86_64-linux-gnu:/usr/lib:/lib/x86_64-linux-gnu:/lib:/usr/local/lib/x86_64-linux-gnu:/usr/local/lib\0"
                as *const u8 as *const libc::c_char,
        );
    }
    tcc_split_path(
        s,
        &mut (*s).crt_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s).nb_crt_paths,
        b"/usr/lib/x86_64-linux-gnu\0" as *const u8 as *const libc::c_char,
    );
    if output_type != 1 as libc::c_int && (*s).nostdlib == 0 {
        tccelf_add_crtbegin(s);
    }
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_add_include_path(
    mut s: *mut TCCState,
    mut pathname: *const libc::c_char,
) -> libc::c_int {
    tcc_split_path(
        s,
        &mut (*s).include_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s).nb_include_paths,
        pathname,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_add_sysinclude_path(
    mut s: *mut TCCState,
    mut pathname: *const libc::c_char,
) -> libc::c_int {
    tcc_split_path(
        s,
        &mut (*s).sysinclude_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s).nb_sysinclude_paths,
        pathname,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_add_library_path(
    mut s: *mut TCCState,
    mut pathname: *const libc::c_char,
) -> libc::c_int {
    tcc_split_path(
        s,
        &mut (*s).library_paths as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s).nb_library_paths,
        pathname,
    );
    return 0 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_set_lib_path(
    mut s: *mut TCCState,
    mut path: *const libc::c_char,
) {
    tcc_set_str(&mut (*s).tcc_lib_path, path);
}
unsafe extern "C" fn tcc_add_dllref(
    mut s1: *mut TCCState,
    mut dllname: *const libc::c_char,
    mut level: libc::c_int,
) -> *mut DLLReference {
    let mut ref_0: *mut DLLReference = 0 as *mut DLLReference;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s1).nb_loaded_dlls {
        if 0 as libc::c_int
            == strcmp(
                ((**((*s1).loaded_dlls).offset(i as isize)).name).as_mut_ptr(),
                dllname,
            )
        {
            ref_0 = *((*s1).loaded_dlls).offset(i as isize);
            break;
        } else {
            i += 1;
            i;
        }
    }
    if level == -(1 as libc::c_int) {
        return ref_0;
    }
    if !ref_0.is_null() {
        if level < (*ref_0).level {
            (*ref_0).level = level;
        }
        (*ref_0).found = 1 as libc::c_int as libc::c_uchar;
        return ref_0;
    }
    ref_0 = tcc_mallocz(
        (::core::mem::size_of::<DLLReference>() as libc::c_ulong)
            .wrapping_add(strlen(dllname)),
    ) as *mut DLLReference;
    strcpy(((*ref_0).name).as_mut_ptr(), dllname);
    dynarray_add(
        &mut (*s1).loaded_dlls as *mut *mut *mut DLLReference as *mut libc::c_void,
        &mut (*s1).nb_loaded_dlls,
        ref_0 as *mut libc::c_void,
    );
    (*ref_0).level = level;
    (*ref_0).index = (*s1).nb_loaded_dlls as libc::c_uchar;
    return ref_0;
}
unsafe extern "C" fn tcc_add_binary(
    mut s1: *mut TCCState,
    mut flags: libc::c_int,
    mut filename: *const libc::c_char,
    mut fd: libc::c_int,
) -> libc::c_int {
    let mut ehdr: Elf64_Ehdr = Elf64_Ehdr {
        e_ident: [0; 16],
        e_type: 0,
        e_machine: 0,
        e_version: 0,
        e_entry: 0,
        e_phoff: 0,
        e_shoff: 0,
        e_flags: 0,
        e_ehsize: 0,
        e_phentsize: 0,
        e_phnum: 0,
        e_shentsize: 0,
        e_shnum: 0,
        e_shstrndx: 0,
    };
    let mut obj_type: libc::c_int = 0;
    let mut saved_filename: *const libc::c_char = (*s1).current_filename;
    let mut ret: libc::c_int = 0 as libc::c_int;
    (*s1).current_filename = filename;
    obj_type = tcc_object_type(fd, &mut ehdr);
    lseek(fd, 0 as libc::c_int as __off_t, 0 as libc::c_int);
    match obj_type {
        1 => {
            ret = tcc_load_object_file(s1, fd, 0 as libc::c_int as libc::c_ulong);
        }
        3 => {
            ret = tcc_load_archive(
                s1,
                fd,
                (flags & 0x80 as libc::c_int == 0) as libc::c_int,
            );
        }
        2 => {
            if (*s1).output_type == 1 as libc::c_int {
                let mut dl: *mut libc::c_void = dlopen(
                    filename,
                    0x100 as libc::c_int | 0x1 as libc::c_int,
                );
                if !dl.is_null() {
                    let ref mut fresh182 = (*tcc_add_dllref(
                        s1,
                        filename,
                        0 as libc::c_int,
                    ))
                        .handle;
                    *fresh182 = dl;
                } else {
                    ret = -(3 as libc::c_int);
                }
            } else {
                ret = tcc_load_dll(
                    s1,
                    fd,
                    filename,
                    (flags & 0x20 as libc::c_int != 0 as libc::c_int) as libc::c_int,
                );
            }
        }
        _ => {
            ret = tcc_load_ldscript(s1, fd);
        }
    }
    close(fd);
    (*s1).current_filename = saved_filename;
    if ret == -(3 as libc::c_int) {
        tcc_enter_state(s1);
        return (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(
            b"%s: unrecognized file type\0" as *const u8 as *const libc::c_char,
            filename,
        );
    }
    return ret;
}
unsafe extern "C" fn guess_filetype(mut filename: *const libc::c_char) -> libc::c_int {
    let mut filetype: libc::c_int = 0 as libc::c_int;
    let mut ext: *const libc::c_char = tcc_fileextension(filename);
    if *ext.offset(0 as libc::c_int as isize) != 0 {
        ext = ext.offset(1);
        ext;
        if strcmp(ext, b"S\0" as *const u8 as *const libc::c_char) == 0 {
            filetype = 4 as libc::c_int;
        } else if strcmp(ext, b"s\0" as *const u8 as *const libc::c_char) == 0 {
            filetype = 2 as libc::c_int;
        } else if strcmp(ext, b"c\0" as *const u8 as *const libc::c_char) == 0
            || strcmp(ext, b"h\0" as *const u8 as *const libc::c_char) == 0
            || strcmp(ext, b"i\0" as *const u8 as *const libc::c_char) == 0
        {
            filetype = 1 as libc::c_int;
        } else {
            filetype |= 0x40 as libc::c_int;
        }
    } else {
        filetype = 1 as libc::c_int;
    }
    return filetype;
}
unsafe extern "C" fn tcc_add_file_internal(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
    mut flags: libc::c_int,
) -> libc::c_int {
    let mut fd: libc::c_int = 0;
    if 0 as libc::c_int == flags & (7 as libc::c_int | 0x40 as libc::c_int) {
        flags |= guess_filetype(filename);
    }
    if (*s1).output_type == 5 as libc::c_int && flags & 0x40 as libc::c_int != 0 {
        return 0 as libc::c_int;
    }
    fd = _tcc_open(s1, filename);
    if fd < 0 as libc::c_int {
        if flags & 0x10 as libc::c_int != 0 {
            tcc_enter_state(s1);
            (Some(
                _tcc_error_noabort
                    as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
            ))
                .expect(
                    "non-null function pointer",
                )(
                b"file '%s' not found\0" as *const u8 as *const libc::c_char,
                filename,
            );
        }
        return -(2 as libc::c_int);
    }
    if flags & 0x40 as libc::c_int != 0 {
        return tcc_add_binary(s1, flags, filename, fd);
    }
    dynarray_add(
        &mut (*s1).target_deps as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).nb_target_deps,
        tcc_strdup(filename) as *mut libc::c_void,
    );
    return tcc_compile(s1, flags, filename, fd);
}
#[no_mangle]
pub unsafe extern "C" fn tcc_add_file(
    mut s: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    return tcc_add_file_internal(
        s,
        filename,
        (*s).filetype as libc::c_int | 0x10 as libc::c_int,
    );
}
unsafe extern "C" fn tcc_add_library_internal(
    mut s1: *mut TCCState,
    mut fmt: *const libc::c_char,
    mut filename: *const libc::c_char,
    mut flags: libc::c_int,
    mut paths: *mut *mut libc::c_char,
    mut nb_paths: libc::c_int,
) -> libc::c_int {
    let mut buf: [libc::c_char; 1024] = [0; 1024];
    let mut i: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < nb_paths {
        snprintf(
            buf.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1024]>() as libc::c_ulong,
            fmt,
            *paths.offset(i as isize),
            filename,
        );
        ret = tcc_add_file_internal(
            s1,
            buf.as_mut_ptr(),
            flags & !(0x10 as libc::c_int),
        );
        if ret != -(2 as libc::c_int) {
            return ret;
        }
        i += 1;
        i;
    }
    if flags & 0x10 as libc::c_int != 0 {
        tcc_enter_state(s1);
        (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(
            b"%s '%s' not found\0" as *const u8 as *const libc::c_char,
            if flags & 8 as libc::c_int != 0 {
                b"library\0" as *const u8 as *const libc::c_char
            } else {
                b"file\0" as *const u8 as *const libc::c_char
            },
            filename,
        );
    }
    return -(2 as libc::c_int);
}
unsafe extern "C" fn tcc_add_dll(
    mut s: *mut TCCState,
    mut filename: *const libc::c_char,
    mut flags: libc::c_int,
) -> libc::c_int {
    return tcc_add_library_internal(
        s,
        b"%s/%s\0" as *const u8 as *const libc::c_char,
        filename,
        flags,
        (*s).library_paths,
        (*s).nb_library_paths,
    );
}
unsafe extern "C" fn tcc_add_support(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    let mut buf: [libc::c_char; 100] = [0; 100];
    if (*::core::mem::transmute::<
        &[u8; 1],
        &[libc::c_char; 1],
    >(b"\0"))[0 as libc::c_int as usize] != 0
    {
        filename = strcat(
            strcpy(buf.as_mut_ptr(), b"\0" as *const u8 as *const libc::c_char),
            filename,
        );
    }
    return tcc_add_dll(s1, filename, 0x10 as libc::c_int);
}
unsafe extern "C" fn tcc_add_crt(
    mut s1: *mut TCCState,
    mut filename: *const libc::c_char,
) -> libc::c_int {
    return tcc_add_library_internal(
        s1,
        b"%s/%s\0" as *const u8 as *const libc::c_char,
        filename,
        0x10 as libc::c_int,
        (*s1).crt_paths,
        (*s1).nb_crt_paths,
    );
}
#[no_mangle]
pub unsafe extern "C" fn tcc_add_library(
    mut s: *mut TCCState,
    mut libraryname: *const libc::c_char,
) -> libc::c_int {
    static mut libs: [*const libc::c_char; 3] = [
        b"%s/lib%s.so\0" as *const u8 as *const libc::c_char,
        b"%s/lib%s.a\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut flags: libc::c_int = 8 as libc::c_int
        | (*s).filetype as libc::c_int & 0x80 as libc::c_int;
    if *libraryname as libc::c_int == ':' as i32 {
        libraryname = libraryname.offset(1);
        libraryname;
    } else {
        let mut pp: *const *const libc::c_char = libs.as_ptr();
        if (*s).static_link != 0 {
            pp = pp
                .offset(
                    (::core::mem::size_of::<[*const libc::c_char; 3]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        )
                        .wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize,
                );
        }
        while !(*pp).is_null() {
            let mut ret: libc::c_int = tcc_add_library_internal(
                s,
                *pp,
                libraryname,
                flags,
                (*s).library_paths,
                (*s).nb_library_paths,
            );
            if ret != -(2 as libc::c_int) {
                return ret;
            }
            pp = pp.offset(1);
            pp;
        }
    }
    return tcc_add_dll(s, libraryname, flags | 0x10 as libc::c_int);
}
unsafe extern "C" fn tcc_add_pragma_libs(mut s1: *mut TCCState) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < (*s1).nb_pragma_libs {
        tcc_add_library(s1, *((*s1).pragma_libs).offset(i as isize));
        i += 1;
        i;
    }
}
unsafe extern "C" fn strstart(
    mut val: *const libc::c_char,
    mut str: *mut *const libc::c_char,
) -> libc::c_int {
    let mut p: *const libc::c_char = 0 as *const libc::c_char;
    let mut q: *const libc::c_char = 0 as *const libc::c_char;
    p = *str;
    q = val;
    while *q != 0 {
        if *p as libc::c_int != *q as libc::c_int {
            return 0 as libc::c_int;
        }
        p = p.offset(1);
        p;
        q = q.offset(1);
        q;
    }
    *str = p;
    return 1 as libc::c_int;
}
unsafe extern "C" fn link_option(
    mut o_0: *mut lopt,
    mut q: *const libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut p: *const libc::c_char = (*o_0).opt;
    let mut c: libc::c_int = 0;
    let fresh183 = p;
    p = p.offset(1);
    if *fresh183 as libc::c_int != '-' as i32 {
        return 0 as libc::c_int;
    }
    if *p as libc::c_int == '-' as i32 {
        p = p.offset(1);
        p;
    }
    loop {
        c = *q as libc::c_int;
        if !(c == *p as libc::c_int) {
            current_block = 17216689946888361452;
            break;
        }
        if c == '\0' as i32 {
            current_block = 11087450290713198429;
            break;
        }
        p = p.offset(1);
        p;
        if c == '=' as i32 {
            current_block = 11087450290713198429;
            break;
        }
        q = q.offset(1);
        q;
    }
    match current_block {
        17216689946888361452 => {
            if c == '=' as i32 || c == ':' as i32 {
                if *p as libc::c_int == '\0' as i32 {
                    if ((*(*o_0).s).link_optind + 1 as libc::c_int)
                        < (*(*o_0).s).link_argc
                    {
                        (*(*o_0).s).link_optind += 1;
                        p = *((*(*o_0).s).link_argv)
                            .offset((*(*o_0).s).link_optind as isize);
                        current_block = 11087450290713198429;
                    } else {
                        (*o_0).match_0 = 1 as libc::c_int;
                        current_block = 17860125682698302841;
                    }
                } else if c == ':' as i32 {
                    current_block = 11087450290713198429;
                } else {
                    current_block = 17860125682698302841;
                }
            } else {
                current_block = 17860125682698302841;
            }
            match current_block {
                11087450290713198429 => {}
                _ => return 0 as libc::c_int,
            }
        }
        _ => {}
    }
    (*o_0).arg = p;
    return 1 as libc::c_int;
}
unsafe extern "C" fn tcc_set_linker(
    mut s: *mut TCCState,
    mut optarg: *const libc::c_char,
) -> libc::c_int {
    let mut s1: *mut TCCState = s;
    dynarray_split(&mut (*s1).link_argv, &mut (*s1).link_argc, optarg, ',' as i32);
    while (*s).link_optind < (*s).link_argc {
        let mut end: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut ignoring: libc::c_int = 0 as libc::c_int;
        let mut o_0: lopt = {
            let mut init = lopt {
                s: 0 as *mut TCCState,
                opt: 0 as *const libc::c_char,
                arg: 0 as *const libc::c_char,
                match_0: 0,
            };
            init
        };
        o_0.s = s;
        o_0.opt = *((*s).link_argv).offset((*s).link_optind as isize);
        if link_option(&mut o_0, b"Bsymbolic\0" as *const u8 as *const libc::c_char) != 0
        {
            (*s).symbolic = 1 as libc::c_int as libc::c_uchar;
        } else if link_option(
            &mut o_0,
            b"nostdlib\0" as *const u8 as *const libc::c_char,
        ) != 0
        {
            (*s).nostdlib_paths = 1 as libc::c_int as libc::c_uchar;
        } else if link_option(&mut o_0, b"e=\0" as *const u8 as *const libc::c_char) != 0
            || link_option(&mut o_0, b"entry=\0" as *const u8 as *const libc::c_char)
                != 0
        {
            tcc_set_str(&mut (*s).elf_entryname, o_0.arg);
        } else if link_option(
            &mut o_0,
            b"image-base=\0" as *const u8 as *const libc::c_char,
        ) != 0
            || link_option(&mut o_0, b"Ttext=\0" as *const u8 as *const libc::c_char)
                != 0
        {
            (*s)
                .text_addr = strtoull(o_0.arg, &mut end, 16 as libc::c_int)
                as Elf64_Addr;
            (*s).has_text_addr = 1 as libc::c_int as libc::c_uchar;
        } else if link_option(&mut o_0, b"init=\0" as *const u8 as *const libc::c_char)
            != 0
        {
            tcc_set_str(&mut (*s).init_symbol, o_0.arg);
            ignoring = 1 as libc::c_int;
        } else if link_option(&mut o_0, b"fini=\0" as *const u8 as *const libc::c_char)
            != 0
        {
            tcc_set_str(&mut (*s).fini_symbol, o_0.arg);
            ignoring = 1 as libc::c_int;
        } else if link_option(&mut o_0, b"Map=\0" as *const u8 as *const libc::c_char)
            != 0
        {
            tcc_set_str(&mut (*s).mapfile, o_0.arg);
            ignoring = 1 as libc::c_int;
        } else {
            let mut current_block_51: u64;
            if link_option(&mut o_0, b"oformat=\0" as *const u8 as *const libc::c_char)
                != 0
            {
                if 0 as libc::c_int
                    == strncmp(
                        b"elf64-\0" as *const u8 as *const libc::c_char,
                        o_0.arg,
                        6 as libc::c_int as libc::c_ulong,
                    )
                {
                    (*s).output_format = 0 as libc::c_int;
                    current_block_51 = 17728966195399430138;
                } else if 0 as libc::c_int
                    == strcmp(b"binary\0" as *const u8 as *const libc::c_char, o_0.arg)
                {
                    (*s).output_format = 1 as libc::c_int;
                    current_block_51 = 17728966195399430138;
                } else {
                    current_block_51 = 14949136498596856099;
                }
            } else if link_option(
                &mut o_0,
                b"export-all-symbols\0" as *const u8 as *const libc::c_char,
            ) != 0
                || link_option(
                    &mut o_0,
                    b"export-dynamic\0" as *const u8 as *const libc::c_char,
                ) != 0
            {
                (*s).rdynamic = 1 as libc::c_int as libc::c_uchar;
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"rpath=\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                tcc_concat_str(&mut (*s).rpath, o_0.arg, ':' as i32);
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"dynamic-linker=\0" as *const u8 as *const libc::c_char,
            ) != 0
                || link_option(&mut o_0, b"I:\0" as *const u8 as *const libc::c_char)
                    != 0
            {
                tcc_set_str(&mut (*s).elfint, o_0.arg);
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"enable-new-dtags\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                (*s).enable_new_dtags = 1 as libc::c_int as libc::c_uchar;
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"section-alignment=\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                (*s)
                    .section_align = strtoul(o_0.arg, &mut end, 16 as libc::c_int)
                    as libc::c_uint;
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"soname=\0" as *const u8 as *const libc::c_char,
            ) != 0
                || link_option(
                    &mut o_0,
                    b"install_name=\0" as *const u8 as *const libc::c_char,
                ) != 0
            {
                tcc_set_str(&mut (*s).soname, o_0.arg);
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"whole-archive\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                (*s)
                    .filetype = ((*s).filetype as libc::c_int | 0x80 as libc::c_int)
                    as libc::c_uchar;
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"no-whole-archive\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                (*s)
                    .filetype = ((*s).filetype as libc::c_int & !(0x80 as libc::c_int))
                    as libc::c_uchar;
                current_block_51 = 17728966195399430138;
            } else if link_option(
                &mut o_0,
                b"as-needed\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                ignoring = 1 as libc::c_int;
                current_block_51 = 17728966195399430138;
            } else if link_option(&mut o_0, b"O\0" as *const u8 as *const libc::c_char)
                != 0
            {
                ignoring = 1 as libc::c_int;
                current_block_51 = 17728966195399430138;
            } else if link_option(&mut o_0, b"z=\0" as *const u8 as *const libc::c_char)
                != 0
            {
                ignoring = 1 as libc::c_int;
                current_block_51 = 17728966195399430138;
            } else if link_option(&mut o_0, b"L:\0" as *const u8 as *const libc::c_char)
                != 0
            {
                tcc_add_library_path(s, o_0.arg);
                current_block_51 = 17728966195399430138;
            } else if link_option(&mut o_0, b"l:\0" as *const u8 as *const libc::c_char)
                != 0
            {
                args_parser_add_file(
                    s,
                    o_0.arg,
                    8 as libc::c_int
                        | (*s).filetype as libc::c_int
                            & !(7 as libc::c_int | 0x40 as libc::c_int),
                );
                current_block_51 = 17728966195399430138;
            } else if o_0.match_0 != 0 {
                return 0 as libc::c_int
            } else {
                current_block_51 = 14949136498596856099;
            }
            match current_block_51 {
                14949136498596856099 => {
                    tcc_enter_state(s1);
                    return (Some(
                        _tcc_error_noabort
                            as unsafe extern "C" fn(
                                *const libc::c_char,
                                ...
                            ) -> libc::c_int,
                    ))
                        .expect(
                            "non-null function pointer",
                        )(
                        b"unsupported linker option '%s'\0" as *const u8
                            as *const libc::c_char,
                        o_0.opt,
                    );
                }
                _ => {}
            }
        }
        if ignoring != 0 {
            tcc_enter_state(s1);
            (*tcc_state)
                .warn_num = (&mut (*(0 as *mut TCCState)).warn_unsupported
                as *mut libc::c_uchar as size_t)
                .wrapping_sub(
                    &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                        as size_t,
                ) as libc::c_uchar;
            (Some(_tcc_warning as unsafe extern "C" fn(*const libc::c_char, ...) -> ()))
                .expect(
                    "non-null function pointer",
                )(
                b"unsupported linker option '%s'\0" as *const u8 as *const libc::c_char,
                o_0.opt,
            );
        }
        (*s).link_optind += 1;
        (*s).link_optind;
    }
    return 0 as libc::c_int;
}
static mut tcc_options: [TCCOption; 59] = [
    {
        let mut init = TCCOption {
            name: b"h\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_HELP as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"-help\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_HELP as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"?\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_HELP as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"hh\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_HELP2 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"v\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_v as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"-version\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_v as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"I\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_I as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"D\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_D as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"U\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_U as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"P\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_P as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"L\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_L as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"B\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_B as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"l\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_l as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"bench\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_bench as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"bt\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_bt as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"b\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_b as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"g\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_g as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"c\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_c as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"dumpmachine\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_dumpmachine as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"dumpversion\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_dumpversion as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"d\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_d as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"static\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_static as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"std\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_std as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"shared\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_shared as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"soname\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_soname as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"o\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_o as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"pthread\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_pthread as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"run\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_run as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"rdynamic\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_rdynamic as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"r\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_r as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"Wl,\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_Wl as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"Wp,\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_Wp as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"W\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_W as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"O\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_O as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"m\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_m as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"f\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_f as libc::c_int as uint16_t,
            flags: (0x1 as libc::c_int | 0x2 as libc::c_int) as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"isystem\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_isystem as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"include\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_include as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"nostdinc\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_nostdinc as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"nostdlib\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_nostdlib as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"print-search-dirs\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_print_search_dirs as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"w\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_w as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"E\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_E as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"M\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_M as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"MD\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_MD as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"MF\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_MF as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"MM\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_MM as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"MMD\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_MMD as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"MP\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_MP as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"x\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_x as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"ar\0" as *const u8 as *const libc::c_char,
            index: TCC_OPTION_ar as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"arch\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"C\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"-param\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0x1 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"pedantic\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"pipe\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"s\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: b"traditional\0" as *const u8 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
    {
        let mut init = TCCOption {
            name: 0 as *const libc::c_char,
            index: 0 as libc::c_int as uint16_t,
            flags: 0 as libc::c_int as uint16_t,
        };
        init
    },
];
static mut options_W: [FlagDef; 7] = [FlagDef {
    offset: 0,
    flags: 0,
    name: 0 as *const libc::c_char,
}; 7];
static mut options_f: [FlagDef; 11] = [FlagDef {
    offset: 0,
    flags: 0,
    name: 0 as *const libc::c_char,
}; 11];
static mut options_m: [FlagDef; 3] = [FlagDef {
    offset: 0,
    flags: 0,
    name: 0 as *const libc::c_char,
}; 3];
unsafe extern "C" fn set_flag(
    mut s: *mut TCCState,
    mut flags: *const FlagDef,
    mut name: *const libc::c_char,
) -> libc::c_int {
    let mut value: libc::c_int = 0;
    let mut mask: libc::c_int = 0;
    let mut ret: libc::c_int = 0;
    let mut p: *const FlagDef = 0 as *const FlagDef;
    let mut r: *const libc::c_char = 0 as *const libc::c_char;
    let mut f: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    r = name;
    value = (strstart(b"no-\0" as *const u8 as *const libc::c_char, &mut r) == 0)
        as libc::c_int;
    mask = 0 as libc::c_int;
    if (*flags).flags as libc::c_int & 0x1 as libc::c_int != 0
        && strstart(b"error=\0" as *const u8 as *const libc::c_char, &mut r) != 0
    {
        value = (if value != 0 {
            1 as libc::c_int | 2 as libc::c_int
        } else {
            4 as libc::c_int
        });
        mask = 1 as libc::c_int;
    }
    let mut current_block_6: u64;
    ret = -(1 as libc::c_int);
    p = flags;
    while !((*p).name).is_null() {
        if ret != 0 {
            if strcmp(r, (*p).name) != 0 {
                current_block_6 = 715039052867723359;
            } else {
                current_block_6 = 1394248824506584008;
            }
        } else if 0 as libc::c_int == (*p).flags as libc::c_int & 0x1 as libc::c_int {
            current_block_6 = 715039052867723359;
        } else {
            current_block_6 = 1394248824506584008;
        }
        match current_block_6 {
            1394248824506584008 => {
                f = (s as *mut libc::c_uchar)
                    .offset((*p).offset as libc::c_int as isize);
                *f = (*f as libc::c_int & mask
                    | value
                        ^ ((*p).flags as libc::c_int & 0x2 as libc::c_int != 0)
                            as libc::c_int) as libc::c_uchar;
                if ret != 0 {
                    ret = 0 as libc::c_int;
                    if strcmp(r, b"all\0" as *const u8 as *const libc::c_char) != 0 {
                        break;
                    }
                }
            }
            _ => {}
        }
        p = p.offset(1);
        p;
    }
    return ret;
}
static mut dumpmachine_str: [libc::c_char; 20] = unsafe {
    *::core::mem::transmute::<&[u8; 20], &[libc::c_char; 20]>(b"x86_64-pc-linux-gnu\0")
};
unsafe extern "C" fn insert_args(
    mut s1: *mut TCCState,
    mut pargv: *mut *mut *mut libc::c_char,
    mut pargc: *mut libc::c_int,
    mut optind: libc::c_int,
    mut p: *const libc::c_char,
    mut sep: libc::c_int,
) {
    let mut argc: libc::c_int = 0 as libc::c_int;
    let mut argv: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < *pargc {
        if i == optind {
            dynarray_split(&mut argv, &mut argc, p, sep);
        } else {
            dynarray_add(
                &mut argv as *mut *mut *mut libc::c_char as *mut libc::c_void,
                &mut argc,
                tcc_strdup(*(*pargv).offset(i as isize)) as *mut libc::c_void,
            );
        }
        i += 1;
        i;
    }
    dynarray_reset(
        &mut (*s1).argv as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut (*s1).argc,
    );
    (*s1).argc = argc;
    *pargc = (*s1).argc;
    (*s1).argv = argv;
    *pargv = (*s1).argv;
}
unsafe extern "C" fn args_parser_add_file(
    mut s: *mut TCCState,
    mut filename: *const libc::c_char,
    mut filetype: libc::c_int,
) {
    let mut f: *mut filespec = tcc_malloc(
        (::core::mem::size_of::<filespec>() as libc::c_ulong)
            .wrapping_add(strlen(filename)),
    ) as *mut filespec;
    (*f).type_0 = filetype as libc::c_char;
    strcpy(((*f).name).as_mut_ptr(), filename);
    dynarray_add(
        &mut (*s).files as *mut *mut *mut filespec as *mut libc::c_void,
        &mut (*s).nb_files,
        f as *mut libc::c_void,
    );
    if filetype & 8 as libc::c_int != 0 {
        (*s).nb_libraries += 1;
        (*s).nb_libraries;
    }
}
#[no_mangle]
pub unsafe extern "C" fn tcc_parse_args(
    mut s: *mut TCCState,
    mut pargc: *mut libc::c_int,
    mut pargv: *mut *mut *mut libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let mut s1: *mut TCCState = s;
    let mut popt: *const TCCOption = 0 as *const TCCOption;
    let mut optarg: *const libc::c_char = 0 as *const libc::c_char;
    let mut r: *const libc::c_char = 0 as *const libc::c_char;
    let mut run: *const libc::c_char = 0 as *const libc::c_char;
    let mut x: libc::c_int = 0;
    let mut tool: libc::c_int = 0 as libc::c_int;
    let mut arg_start: libc::c_int = 0 as libc::c_int;
    let mut not_empty: libc::c_int = 0 as libc::c_int;
    let mut optind: libc::c_int = 1 as libc::c_int;
    let mut argv: *mut *mut libc::c_char = *pargv;
    let mut argc: libc::c_int = *pargc;
    (*s).link_optind = (*s).link_argc;
    while optind < argc {
        r = *argv.offset(optind as isize);
        if *r.offset(0 as libc::c_int as isize) as libc::c_int == '@' as i32
            && *r.offset(1 as libc::c_int as isize) as libc::c_int != '\0' as i32
        {
            let mut fd: libc::c_int = 0;
            let mut p: *mut libc::c_char = 0 as *mut libc::c_char;
            r = r.offset(1);
            fd = open(r, 0 as libc::c_int | 0 as libc::c_int);
            if fd < 0 as libc::c_int {
                tcc_enter_state(s1);
                return (Some(
                    _tcc_error_noabort
                        as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
                ))
                    .expect(
                        "non-null function pointer",
                    )(
                    b"listfile '%s' not found\0" as *const u8 as *const libc::c_char,
                    r,
                );
            }
            p = tcc_load_text(fd);
            insert_args(s1, &mut argv, &mut argc, optind, p, 0 as libc::c_int);
            close(fd);
            tcc_free(p as *mut libc::c_void);
        } else {
            optind += 1;
            optind;
            if tool != 0 {
                (*s)
                    .verbose = ((*s).verbose as libc::c_int
                    + (strcmp(r, b"-v\0" as *const u8 as *const libc::c_char) == 0)
                        as libc::c_int) as libc::c_uchar;
            } else {
                if *r.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
                    || *r.offset(1 as libc::c_int as isize) as libc::c_int == '\0' as i32
                {
                    args_parser_add_file(s, r, (*s).filetype as libc::c_int);
                    not_empty = 1 as libc::c_int;
                } else if !(*r.offset(1 as libc::c_int as isize) as libc::c_int
                    == '-' as i32
                    && *r.offset(2 as libc::c_int as isize) as libc::c_int
                        == '\0' as i32)
                {
                    popt = tcc_options.as_ptr();
                    loop {
                        let mut p1: *const libc::c_char = (*popt).name;
                        let mut r1: *const libc::c_char = r
                            .offset(1 as libc::c_int as isize);
                        if p1.is_null() {
                            tcc_enter_state(s1);
                            return (Some(
                                _tcc_error_noabort
                                    as unsafe extern "C" fn(
                                        *const libc::c_char,
                                        ...
                                    ) -> libc::c_int,
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                b"invalid option -- '%s'\0" as *const u8
                                    as *const libc::c_char,
                                r,
                            );
                        }
                        if !(strstart(p1, &mut r1) == 0) {
                            optarg = r1;
                            if (*popt).flags as libc::c_int & 0x1 as libc::c_int != 0 {
                                if *r1 as libc::c_int == '\0' as i32
                                    && (*popt).flags as libc::c_int & 0x2 as libc::c_int == 0
                                {
                                    if optind >= argc {
                                        tcc_enter_state(s1);
                                        return (Some(
                                            _tcc_error_noabort
                                                as unsafe extern "C" fn(
                                                    *const libc::c_char,
                                                    ...
                                                ) -> libc::c_int,
                                        ))
                                            .expect(
                                                "non-null function pointer",
                                            )(
                                            b"argument to '%s' is missing\0" as *const u8
                                                as *const libc::c_char,
                                            r,
                                        );
                                    }
                                    let fresh184 = optind;
                                    optind = optind + 1;
                                    optarg = *argv.offset(fresh184 as isize);
                                }
                                break;
                            } else if !(*r1 as libc::c_int != '\0' as i32) {
                                break;
                            }
                        }
                        popt = popt.offset(1);
                        popt;
                    }
                    match (*popt).index as libc::c_int {
                        4 => {
                            tcc_add_include_path(s, optarg);
                            current_block = 433373112845341403;
                        }
                        5 => {
                            tcc_define_symbol(s, optarg, 0 as *const libc::c_char);
                            current_block = 433373112845341403;
                        }
                        6 => {
                            tcc_undefine_symbol(s, optarg);
                            current_block = 433373112845341403;
                        }
                        8 => {
                            tcc_add_library_path(s, optarg);
                            current_block = 433373112845341403;
                        }
                        9 => {
                            tcc_set_lib_path(s, optarg);
                            continue;
                        }
                        10 => {
                            args_parser_add_file(
                                s,
                                optarg,
                                8 as libc::c_int
                                    | (*s).filetype as libc::c_int
                                        & !(7 as libc::c_int | 0x40 as libc::c_int),
                            );
                            current_block = 433373112845341403;
                        }
                        39 => {
                            (*s).option_pthread = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        11 => {
                            (*s).do_bench = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        12 => {
                            (*s).rt_num_callers = atoi(optarg);
                            current_block = 2315900458826720866;
                        }
                        13 => {
                            (*s).do_bounds_check = 1 as libc::c_int as libc::c_uchar;
                            current_block = 2315900458826720866;
                        }
                        14 => {
                            (*s).do_debug = 2 as libc::c_int as libc::c_uchar;
                            (*s).dwarf = 0 as libc::c_int as libc::c_uchar;
                            if strstart(
                                b"dwarf\0" as *const u8 as *const libc::c_char,
                                &mut optarg,
                            ) != 0
                            {
                                (*s)
                                    .dwarf = (if *optarg as libc::c_int != 0 {
                                    0 as libc::c_int - atoi(optarg)
                                } else {
                                    5 as libc::c_int
                                }) as libc::c_uchar;
                            } else if 0 as libc::c_int
                                == strcmp(
                                    b"stabs\0" as *const u8 as *const libc::c_char,
                                    optarg,
                                )
                            {
                                (*s).dwarf = 0 as libc::c_int as libc::c_uchar;
                            } else if isnum(*optarg as libc::c_int) != 0 {
                                x = *optarg as libc::c_int - '0' as i32;
                                (*s)
                                    .do_debug = (if x > 2 as libc::c_int {
                                    2 as libc::c_int
                                } else if x == 0 as libc::c_int
                                    && (*s).do_backtrace as libc::c_int != 0
                                {
                                    1 as libc::c_int
                                } else {
                                    x
                                }) as libc::c_uchar;
                            }
                            current_block = 433373112845341403;
                        }
                        15 => {
                            x = 3 as libc::c_int;
                            current_block = 1605789560870616463;
                        }
                        18 => {
                            if *optarg as libc::c_int == 'D' as i32 {
                                (*s).dflag = 3 as libc::c_int as libc::c_uchar;
                                current_block = 433373112845341403;
                            } else if *optarg as libc::c_int == 'M' as i32 {
                                (*s).dflag = 7 as libc::c_int as libc::c_uchar;
                                current_block = 433373112845341403;
                            } else if *optarg as libc::c_int == 't' as i32 {
                                (*s).dflag = 16 as libc::c_int as libc::c_uchar;
                                current_block = 433373112845341403;
                            } else if isnum(*optarg as libc::c_int) != 0 {
                                g_debug |= atoi(optarg);
                                current_block = 433373112845341403;
                            } else {
                                current_block = 10069833867076306609;
                            }
                        }
                        19 => {
                            (*s).static_link = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        20 => {
                            if strcmp(
                                optarg,
                                b"=c11\0" as *const u8 as *const libc::c_char,
                            ) == 0 as libc::c_int
                                || strcmp(
                                    optarg,
                                    b"=gnu11\0" as *const u8 as *const libc::c_char,
                                ) == 0 as libc::c_int
                            {
                                (*s).cversion = 201112 as libc::c_int as libc::c_uint;
                            }
                            current_block = 433373112845341403;
                        }
                        21 => {
                            x = 4 as libc::c_int;
                            current_block = 1605789560870616463;
                        }
                        22 => {
                            tcc_set_str(&mut (*s).soname, optarg);
                            current_block = 433373112845341403;
                        }
                        23 => {
                            if !((*s).outfile).is_null() {
                                tcc_enter_state(s1);
                                (Some(
                                    _tcc_warning
                                        as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    b"multiple -o option\0" as *const u8 as *const libc::c_char,
                                );
                                tcc_free((*s).outfile as *mut libc::c_void);
                            }
                            tcc_set_str(&mut (*s).outfile, optarg);
                            current_block = 433373112845341403;
                        }
                        24 => {
                            (*s).option_r = 1 as libc::c_int as libc::c_uchar;
                            x = 3 as libc::c_int;
                            current_block = 1605789560870616463;
                        }
                        32 => {
                            tcc_add_sysinclude_path(s, optarg);
                            current_block = 433373112845341403;
                        }
                        34 => {
                            cstr_printf(
                                &mut (*s).cmdline_incl as *mut CString,
                                b"#include \"%s\"\n\0" as *const u8 as *const libc::c_char,
                                optarg,
                            );
                            current_block = 433373112845341403;
                        }
                        35 => {
                            (*s).nostdinc = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        36 => {
                            (*s).nostdlib = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        40 => {
                            run = optarg;
                            x = 1 as libc::c_int;
                            current_block = 1605789560870616463;
                        }
                        3 => {
                            loop {
                                (*s).verbose = ((*s).verbose).wrapping_add(1);
                                (*s).verbose;
                                let fresh185 = optarg;
                                optarg = optarg.offset(1);
                                if !(*fresh185 as libc::c_int == 'v' as i32) {
                                    break;
                                }
                            }
                            continue;
                        }
                        31 => {
                            if set_flag(s, options_f.as_ptr(), optarg) < 0 as libc::c_int
                            {
                                current_block = 10069833867076306609;
                            } else {
                                current_block = 433373112845341403;
                            }
                        }
                        30 => {
                            if set_flag(s, options_m.as_ptr(), optarg) < 0 as libc::c_int
                            {
                                x = atoi(optarg);
                                if x != 32 as libc::c_int && x != 64 as libc::c_int {
                                    current_block = 10069833867076306609;
                                } else {
                                    if 8 as libc::c_int != x / 8 as libc::c_int {
                                        return x;
                                    }
                                    continue;
                                }
                            } else {
                                current_block = 433373112845341403;
                            }
                        }
                        27 => {
                            (*s).warn_none = 0 as libc::c_int as libc::c_uchar;
                            if *optarg.offset(0 as libc::c_int as isize) as libc::c_int
                                != 0
                                && set_flag(s, options_W.as_ptr(), optarg)
                                    < 0 as libc::c_int
                            {
                                current_block = 10069833867076306609;
                            } else {
                                current_block = 433373112845341403;
                            }
                        }
                        41 => {
                            (*s).warn_none = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        38 => {
                            (*s).rdynamic = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        25 => {
                            if tcc_set_linker(s, optarg) < 0 as libc::c_int {
                                return -(1 as libc::c_int);
                            }
                            current_block = 433373112845341403;
                        }
                        26 => {
                            if !(*argv.offset(0 as libc::c_int as isize)).is_null() {
                                optind -= 1;
                                insert_args(
                                    s,
                                    &mut argv,
                                    &mut argc,
                                    optind,
                                    optarg,
                                    ',' as i32,
                                );
                            }
                            current_block = 433373112845341403;
                        }
                        42 => {
                            x = 5 as libc::c_int;
                            current_block = 1605789560870616463;
                        }
                        7 => {
                            (*s)
                                .Pflag = (atoi(optarg) + 1 as libc::c_int) as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        43 => {
                            (*s).include_sys_deps = 1 as libc::c_int as libc::c_uchar;
                            current_block = 4605011386847538253;
                        }
                        46 => {
                            current_block = 4605011386847538253;
                        }
                        47 => {
                            current_block = 5224583933058991945;
                        }
                        44 => {
                            (*s).gen_deps = 1 as libc::c_int as libc::c_uchar;
                            (*s).include_sys_deps = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        45 => {
                            tcc_set_str(&mut (*s).deps_outfile, optarg);
                            current_block = 433373112845341403;
                        }
                        48 => {
                            (*s).gen_phony_deps = 1 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        16 => {
                            printf(
                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                dumpmachine_str.as_ptr(),
                            );
                            exit(0 as libc::c_int);
                        }
                        17 => {
                            printf(
                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                b"0.9.28rc\0" as *const u8 as *const libc::c_char,
                            );
                            exit(0 as libc::c_int);
                        }
                        49 => {
                            x = 0 as libc::c_int;
                            if *optarg as libc::c_int == 'c' as i32 {
                                x = 1 as libc::c_int;
                            } else if *optarg as libc::c_int == 'a' as i32 {
                                x = 4 as libc::c_int;
                            } else if *optarg as libc::c_int == 'b' as i32 {
                                x = 0x40 as libc::c_int;
                            } else if *optarg as libc::c_int == 'n' as i32 {
                                x = 0 as libc::c_int;
                            } else {
                                tcc_enter_state(s1);
                                (Some(
                                    _tcc_warning
                                        as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    b"unsupported language '%s'\0" as *const u8
                                        as *const libc::c_char,
                                    optarg,
                                );
                            }
                            (*s)
                                .filetype = (x
                                | (*s).filetype as libc::c_int
                                    & !(7 as libc::c_int | 0x40 as libc::c_int))
                                as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        28 => {
                            (*s)
                                .optimize = (if isnum(
                                *optarg.offset(0 as libc::c_int as isize) as libc::c_int,
                            ) != 0
                            {
                                *optarg.offset(0 as libc::c_int as isize) as libc::c_int
                                    - '0' as i32
                            } else {
                                1 as libc::c_int
                            }) as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        1 => {
                            x = 1 as libc::c_int;
                            current_block = 6445002142072119214;
                        }
                        2 => {
                            x = 2 as libc::c_int;
                            current_block = 6445002142072119214;
                        }
                        37 => {
                            x = 4 as libc::c_int;
                            current_block = 6445002142072119214;
                        }
                        51 => {
                            x = 6 as libc::c_int;
                            current_block = 6445002142072119214;
                        }
                        50 => {
                            x = 5 as libc::c_int;
                            current_block = 6445002142072119214;
                        }
                        _ => {
                            current_block = 10069833867076306609;
                        }
                    }
                    match current_block {
                        4605011386847538253 => {
                            (*s).just_deps = 1 as libc::c_int as libc::c_uchar;
                            if ((*s).deps_outfile).is_null() {
                                tcc_set_str(
                                    &mut (*s).deps_outfile,
                                    b"-\0" as *const u8 as *const libc::c_char,
                                );
                            }
                            current_block = 5224583933058991945;
                        }
                        1605789560870616463 => {
                            if (*s).output_type != 0 {
                                tcc_enter_state(s1);
                                (Some(
                                    _tcc_warning
                                        as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    b"-%s: overriding compiler action already specified\0"
                                        as *const u8 as *const libc::c_char,
                                    (*popt).name,
                                );
                            }
                            (*s).output_type = x;
                            current_block = 433373112845341403;
                        }
                        2315900458826720866 => {
                            (*s).do_backtrace = 1 as libc::c_int as libc::c_uchar;
                            if 0 as libc::c_int == (*s).do_debug as libc::c_int {
                                (*s).do_debug = 1 as libc::c_int as libc::c_uchar;
                            }
                            (*s).dwarf = 0 as libc::c_int as libc::c_uchar;
                            current_block = 433373112845341403;
                        }
                        6445002142072119214 => {
                            arg_start = optind - 1 as libc::c_int;
                            if not_empty != 0 {
                                tcc_enter_state(s1);
                                return (Some(
                                    _tcc_error_noabort
                                        as unsafe extern "C" fn(
                                            *const libc::c_char,
                                            ...
                                        ) -> libc::c_int,
                                ))
                                    .expect(
                                        "non-null function pointer",
                                    )(
                                    b"cannot parse %s here\0" as *const u8
                                        as *const libc::c_char,
                                    r,
                                );
                            }
                            tool = x;
                            current_block = 433373112845341403;
                        }
                        10069833867076306609 => {
                            tcc_enter_state(s1);
                            (*tcc_state)
                                .warn_num = (&mut (*(0 as *mut TCCState)).warn_unsupported
                                as *mut libc::c_uchar as size_t)
                                .wrapping_sub(
                                    &mut (*(0 as *mut TCCState)).warn_none as *mut libc::c_uchar
                                        as size_t,
                                ) as libc::c_uchar;
                            (Some(
                                _tcc_warning
                                    as unsafe extern "C" fn(*const libc::c_char, ...) -> (),
                            ))
                                .expect(
                                    "non-null function pointer",
                                )(
                                b"unsupported option '%s'\0" as *const u8
                                    as *const libc::c_char,
                                r,
                            );
                            current_block = 433373112845341403;
                        }
                        _ => {}
                    }
                    match current_block {
                        5224583933058991945 => {
                            (*s).gen_deps = 1 as libc::c_int as libc::c_uchar;
                        }
                        _ => {}
                    }
                    not_empty = 1 as libc::c_int;
                    continue;
                }
                if run.is_null() {
                    continue;
                }
                if tcc_set_options(s, run) != 0 {
                    return -(1 as libc::c_int);
                }
                arg_start = optind - 1 as libc::c_int;
                break;
            }
        }
    }
    if (*s).link_optind < (*s).link_argc {
        tcc_enter_state(s1);
        return (Some(
            _tcc_error_noabort
                as unsafe extern "C" fn(*const libc::c_char, ...) -> libc::c_int,
        ))
            .expect(
                "non-null function pointer",
            )(
            b"argument to '-Wl,%s' is missing\0" as *const u8 as *const libc::c_char,
            *((*s).link_argv).offset((*s).link_optind as isize),
        );
    }
    if (*argv.offset(0 as libc::c_int as isize)).is_null() {
        return 0 as libc::c_int;
    }
    if arg_start != 0 {
        *pargc = argc - arg_start;
        *pargv = argv.offset(arg_start as isize);
        return tool;
    }
    if not_empty != 0 {
        return 0 as libc::c_int;
    }
    if (*s).verbose as libc::c_int == 2 as libc::c_int {
        return 4 as libc::c_int;
    }
    if (*s).verbose != 0 {
        return 3 as libc::c_int;
    }
    return 1 as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_set_options(
    mut s: *mut TCCState,
    mut r: *const libc::c_char,
) -> libc::c_int {
    let mut argv: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut argc: libc::c_int = 0 as libc::c_int;
    let mut ret: libc::c_int = 0;
    dynarray_add(
        &mut argv as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut argc,
        0 as *mut libc::c_void,
    );
    dynarray_split(&mut argv, &mut argc, r, 0 as libc::c_int);
    ret = tcc_parse_args(s, &mut argc, &mut argv);
    dynarray_reset(
        &mut argv as *mut *mut *mut libc::c_char as *mut libc::c_void,
        &mut argc,
    );
    return ret;
}
#[no_mangle]
pub unsafe extern "C" fn tcc_print_stats(
    mut s1: *mut TCCState,
    mut total_time: libc::c_uint,
) {
    if total_time == 0 {
        total_time = 1 as libc::c_int as libc::c_uint;
    }
    fprintf(
        stderr,
        b"# %d idents, %d lines, %u bytes\n# %0.3f s, %u lines/s, %0.1f MB/s\n\0"
            as *const u8 as *const libc::c_char,
        (*s1).total_idents,
        (*s1).total_lines,
        (*s1).total_bytes,
        total_time as libc::c_double / 1000 as libc::c_int as libc::c_double,
        ((*s1).total_lines as libc::c_uint)
            .wrapping_mul(1000 as libc::c_int as libc::c_uint)
            .wrapping_div(total_time),
        (*s1).total_bytes as libc::c_double / 1000 as libc::c_int as libc::c_double
            / total_time as libc::c_double,
    );
    fprintf(
        stderr,
        b"# text %u, data.rw %u, data.ro %u, bss %u bytes\n\0" as *const u8
            as *const libc::c_char,
        (*s1).total_output[0 as libc::c_int as usize],
        (*s1).total_output[1 as libc::c_int as usize],
        (*s1).total_output[2 as libc::c_int as usize],
        (*s1).total_output[3 as libc::c_int as usize],
    );
}
unsafe extern "C" fn run_static_initializers() {
    asm_instrs = [
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_vmcall as libc::c_int as uint16_t,
                opcode: (if 0xc1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x60 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_vmlaunch as libc::c_int as uint16_t,
                opcode: (if 0xc2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x60 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_vmresume as libc::c_int as uint16_t,
                opcode: (if 0xc3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x60 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_vmxoff as libc::c_int as uint16_t,
                opcode: (if 0xc4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x60 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cmpsb as libc::c_int as uint16_t,
                opcode: (if 0xa6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xa6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xa6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xa6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xa6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_scmpb as libc::c_int as uint16_t,
                opcode: (if 0xa6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xa6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xa6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xa6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xa6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_insb as libc::c_int as uint16_t,
                opcode: (if 0x6c as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6c as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6c as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6c as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6c as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_outsb as libc::c_int as uint16_t,
                opcode: (if 0x6e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6e as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lodsb as libc::c_int as uint16_t,
                opcode: (if 0xac as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xac as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xac as libc::c_int & 0xff as libc::c_int
                } else {
                    0xac as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xac as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_slodb as libc::c_int as uint16_t,
                opcode: (if 0xac as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xac as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xac as libc::c_int & 0xff as libc::c_int
                } else {
                    0xac as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xac as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movsb as libc::c_int as uint16_t,
                opcode: (if 0xa4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xa4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xa4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xa4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xa4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_smovb as libc::c_int as uint16_t,
                opcode: (if 0xa4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xa4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xa4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xa4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xa4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_scasb as libc::c_int as uint16_t,
                opcode: (if 0xae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sscab as libc::c_int as uint16_t,
                opcode: (if 0xae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_stosb as libc::c_int as uint16_t,
                opcode: (if 0xaa as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xaa as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xaa as libc::c_int & 0xff as libc::c_int
                } else {
                    0xaa as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xaa as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sstob as libc::c_int as uint16_t,
                opcode: (if 0xaa as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xaa as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xaa as libc::c_int & 0xff as libc::c_int
                } else {
                    0xaa as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xaa as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_bsfw as libc::c_int as uint16_t,
                opcode: (if 0xfbc as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbc as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbc as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbc as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbc as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_bsrw as libc::c_int as uint16_t,
                opcode: (if 0xfbd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btw as libc::c_int as uint16_t,
                opcode: (if 0xfa3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfa3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfa3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfa3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfa3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btw as libc::c_int as uint16_t,
                opcode: (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfba as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfba as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfba as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btsw as libc::c_int as uint16_t,
                opcode: (if 0xfab as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfab as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfab as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfab as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfab as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btsw as libc::c_int as uint16_t,
                opcode: (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfba as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfba as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfba as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btrw as libc::c_int as uint16_t,
                opcode: (if 0xfb3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btrw as libc::c_int as uint16_t,
                opcode: (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfba as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfba as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfba as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btcw as libc::c_int as uint16_t,
                opcode: (if 0xfbb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_btcw as libc::c_int as uint16_t,
                opcode: (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfba as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfba as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfba as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfba as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_popcntw as libc::c_int as uint16_t,
                opcode: (if 0xf30fb8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf30fb8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf30fb8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf30fb8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf30fb8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_tzcntw as libc::c_int as uint16_t,
                opcode: (if 0xf30fbc as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf30fbc as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf30fbc as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf30fbc as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf30fbc as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lzcntw as libc::c_int as uint16_t,
                opcode: (if 0xf30fbd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf30fbd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf30fbd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf30fbd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf30fbd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sysretq as libc::c_int as uint16_t,
                opcode: (if 0x480f07 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x480f07 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x480f07 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x480f07 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x480f07 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movb as libc::c_int as uint16_t,
                opcode: (if 0x88 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x88 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x88 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x88 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x88 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movb as libc::c_int as uint16_t,
                opcode: (if 0x8a as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x8a as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x8a as libc::c_int & 0xff as libc::c_int
                } else {
                    0x8a as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x8a as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movb as libc::c_int as uint16_t,
                opcode: (if 0xb0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xb0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xb0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xb0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xb0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM as libc::c_int as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_mov as libc::c_int as uint16_t,
                opcode: (if 0xb8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xb8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xb8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xb8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xb8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM64 as libc::c_int as uint8_t,
                    OPT_REG64 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0xb8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xb8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xb8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xb8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xb8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM64 as libc::c_int as uint8_t,
                    OPT_REG64 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movb as libc::c_int as uint16_t,
                opcode: (if 0xc6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM as libc::c_int as uint8_t,
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movw as libc::c_int as uint16_t,
                opcode: (if 0x8c as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x8c as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x8c as libc::c_int & 0xff as libc::c_int
                } else {
                    0x8c as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x8c as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_SEG as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movw as libc::c_int as uint16_t,
                opcode: (if 0x8e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x8e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x8e as libc::c_int & 0xff as libc::c_int
                } else {
                    0x8e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x8e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    OPT_SEG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movw as libc::c_int as uint16_t,
                opcode: (if 0xf20 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf20 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf20 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf20 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf20 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_CR as libc::c_int as uint8_t,
                    OPT_REG64 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movw as libc::c_int as uint16_t,
                opcode: (if 0xf21 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf21 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf21 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf21 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf21 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_DB as libc::c_int as uint8_t,
                    OPT_REG64 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movw as libc::c_int as uint16_t,
                opcode: (if 0xf22 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf22 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf22 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf22 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf22 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG64 as libc::c_int as uint8_t,
                    OPT_CR as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movw as libc::c_int as uint16_t,
                opcode: (if 0xf23 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf23 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf23 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf23 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf23 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG64 as libc::c_int as uint8_t,
                    OPT_DB as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movsbw as libc::c_int as uint16_t,
                opcode: (if 0x660fbe as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x660fbe as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x660fbe as libc::c_int & 0xff as libc::c_int
                } else {
                    0x660fbe as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x660fbe as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG8 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG16 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movsbl as libc::c_int as uint16_t,
                opcode: (if 0xfbe as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbe as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbe as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbe as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbe as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG8 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movsbq as libc::c_int as uint16_t,
                opcode: (if 0xfbe as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbe as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbe as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbe as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbe as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG8 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movswl as libc::c_int as uint16_t,
                opcode: (if 0xfbf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG16 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movswq as libc::c_int as uint16_t,
                opcode: (if 0xfbf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfbf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfbf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfbf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfbf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG16 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movslq as libc::c_int as uint16_t,
                opcode: (if 0x63 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x63 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x63 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x63 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x63 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG32 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movzbw as libc::c_int as uint16_t,
                opcode: (if 0xfb6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG8 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movzwl as libc::c_int as uint16_t,
                opcode: (if 0xfb7 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb7 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb7 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb7 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb7 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG16 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movzwq as libc::c_int as uint16_t,
                opcode: (if 0xfb7 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb7 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb7 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb7 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb7 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG16 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushq as libc::c_int as uint16_t,
                opcode: (if 0x6a as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6a as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6a as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6a as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6a as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM8S as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_push as libc::c_int as uint16_t,
                opcode: (if 0x6a as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6a as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6a as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6a as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6a as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM8S as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0x666a as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x666a as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x666a as libc::c_int & 0xff as libc::c_int
                } else {
                    0x666a as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x666a as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM8S as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0x50 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x50 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x50 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x50 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x50 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG64 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0x50 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x50 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x50 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x50 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x50 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG64 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0x6668 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6668 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6668 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6668 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6668 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0x68 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x68 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x68 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x68 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x68 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM32 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pushw as libc::c_int as uint16_t,
                opcode: (if 0x6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_SEG as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_popw as libc::c_int as uint16_t,
                opcode: (if 0x58 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x58 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x58 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x58 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x58 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG64 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_popw as libc::c_int as uint16_t,
                opcode: (if 0x58 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x58 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x58 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x58 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x58 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_popw as libc::c_int as uint16_t,
                opcode: (if 0x8f as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x8f as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x8f as libc::c_int & 0xff as libc::c_int
                } else {
                    0x8f as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x8f as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_popw as libc::c_int as uint16_t,
                opcode: (if 0x7 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x7 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x7 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x7 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x7 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_SEG as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_xchgw as libc::c_int as uint16_t,
                opcode: (if 0x90 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x90 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x90 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x90 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x90 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_xchgw as libc::c_int as uint16_t,
                opcode: (if 0x90 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x90 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x90 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x90 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x90 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EAX as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_xchgb as libc::c_int as uint16_t,
                opcode: (if 0x86 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x86 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x86 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x86 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x86 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_xchgb as libc::c_int as uint16_t,
                opcode: (if 0x86 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x86 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x86 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x86 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x86 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_inb as libc::c_int as uint16_t,
                opcode: (if 0xe4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_inb as libc::c_int as uint16_t,
                opcode: (if 0xe4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_inb as libc::c_int as uint16_t,
                opcode: (if 0xec as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xec as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xec as libc::c_int & 0xff as libc::c_int
                } else {
                    0xec as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xec as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_DX as libc::c_int as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_inb as libc::c_int as uint16_t,
                opcode: (if 0xec as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xec as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xec as libc::c_int & 0xff as libc::c_int
                } else {
                    0xec as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xec as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DX as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_outb as libc::c_int as uint16_t,
                opcode: (if 0xe6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EAX as libc::c_int as uint8_t,
                    OPT_IM8 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_outb as libc::c_int as uint16_t,
                opcode: (if 0xe6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_outb as libc::c_int as uint16_t,
                opcode: (if 0xee as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xee as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xee as libc::c_int & 0xff as libc::c_int
                } else {
                    0xee as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xee as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EAX as libc::c_int as uint8_t,
                    OPT_DX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_outb as libc::c_int as uint16_t,
                opcode: (if 0xee as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xee as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xee as libc::c_int & 0xff as libc::c_int
                } else {
                    0xee as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x2 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xee as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DX as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_leaw as libc::c_int as uint16_t,
                opcode: (if 0x8d as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x8d as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x8d as libc::c_int & 0xff as libc::c_int
                } else {
                    0x8d as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x8d as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EA as libc::c_int as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_les as libc::c_int as uint16_t,
                opcode: (if 0xc4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EA as libc::c_int as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lds as libc::c_int as uint16_t,
                opcode: (if 0xc5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EA as libc::c_int as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lss as libc::c_int as uint16_t,
                opcode: (if 0xfb2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EA as libc::c_int as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lfs as libc::c_int as uint16_t,
                opcode: (if 0xfb4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EA as libc::c_int as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lgs as libc::c_int as uint16_t,
                opcode: (if 0xfb5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_EA as libc::c_int as uint8_t,
                    OPT_REG32 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_addb as libc::c_int as uint16_t,
                opcode: (if 0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x30 as libc::c_int | 0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_addb as libc::c_int as uint16_t,
                opcode: (if 0x2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x30 as libc::c_int | 0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_addb as libc::c_int as uint16_t,
                opcode: (if 0x4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x30 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM as libc::c_int as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_addw as libc::c_int as uint16_t,
                opcode: (if 0x83 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x83 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x83 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x83 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x30 as libc::c_int | 0x8 as libc::c_int
                    | 0x1000 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x83 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8S as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_addb as libc::c_int as uint16_t,
                opcode: (if 0x80 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x80 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x80 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x80 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x30 as libc::c_int | 0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x80 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_testb as libc::c_int as uint16_t,
                opcode: (if 0x84 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x84 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x84 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x84 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x84 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_testb as libc::c_int as uint16_t,
                opcode: (if 0x84 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x84 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x84 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x84 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x84 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_testb as libc::c_int as uint16_t,
                opcode: (if 0xa8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xa8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xa8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xa8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x1 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xa8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM as libc::c_int as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_testb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_incb as libc::c_int as uint16_t,
                opcode: (if 0xfe as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_decb as libc::c_int as uint16_t,
                opcode: (if 0xfe as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_notb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_negb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_mulb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_imulb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_imulw as libc::c_int as uint16_t,
                opcode: (if 0xfaf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfaf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfaf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfaf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfaf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_imulw as libc::c_int as uint16_t,
                opcode: (if 0x6b as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6b as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6b as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6b as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6b as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 3 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8S as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_imulw as libc::c_int as uint16_t,
                opcode: (if 0x6b as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x6b as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x6b as libc::c_int & 0xff as libc::c_int
                } else {
                    0x6b as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x6b as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8S as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_imulw as libc::c_int as uint16_t,
                opcode: (if 0x69 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x69 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x69 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x69 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x69 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 3 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IMW as libc::c_int as uint8_t,
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_imulw as libc::c_int as uint16_t,
                opcode: (if 0x69 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x69 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x69 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x69 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x69 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IMW as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_divb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_divb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_idivb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_idivb as libc::c_int as uint16_t,
                opcode: (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_EAX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_rolb as libc::c_int as uint16_t,
                opcode: (if 0xc0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int) | 0x20 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_rolb as libc::c_int as uint16_t,
                opcode: (if 0xd2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int) | 0x20 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_CL as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_rolb as libc::c_int as uint16_t,
                opcode: (if 0xd0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int) | 0x20 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_shldw as libc::c_int as uint16_t,
                opcode: (if 0xfa4 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfa4 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfa4 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfa4 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfa4 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 3 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_shldw as libc::c_int as uint16_t,
                opcode: (if 0xfa5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfa5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfa5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfa5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfa5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 3 as libc::c_int as uint8_t,
                op_type: [
                    OPT_CL as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_shldw as libc::c_int as uint16_t,
                opcode: (if 0xfa5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfa5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfa5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfa5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfa5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_shrdw as libc::c_int as uint16_t,
                opcode: (if 0xfac as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfac as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfac as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfac as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfac as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 3 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_shrdw as libc::c_int as uint16_t,
                opcode: (if 0xfad as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfad as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfad as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfad as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfad as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 3 as libc::c_int as uint8_t,
                op_type: [
                    OPT_CL as libc::c_int as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_shrdw as libc::c_int as uint16_t,
                opcode: (if 0xfad as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfad as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfad as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfad as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfad as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REGW as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REGW as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_call as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_INDIR as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_call as libc::c_int as uint16_t,
                opcode: (if 0xe8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_callq as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_INDIR as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_callq as libc::c_int as uint16_t,
                opcode: (if 0xe8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_jmp as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_INDIR as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_jmp as libc::c_int as uint16_t,
                opcode: (if 0xeb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xeb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xeb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xeb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xeb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lcall as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ljmp as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ljmpw as libc::c_int as uint16_t,
                opcode: (if 0x66ff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x66ff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x66ff as libc::c_int & 0xff as libc::c_int
                } else {
                    0x66ff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0x66ff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ljmpl as libc::c_int as uint16_t,
                opcode: (if 0xff as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_INT as libc::c_int as uint16_t,
                opcode: (if 0xcd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xcd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xcd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xcd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xcd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_seto as libc::c_int as uint16_t,
                opcode: (if 0xf90 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf90 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf90 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf90 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x50 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf90 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG8 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_setob as libc::c_int as uint16_t,
                opcode: (if 0xf90 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf90 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf90 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf90 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x50 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf90 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG8 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_enter as libc::c_int as uint16_t,
                opcode: (if 0xc8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM16 as libc::c_int as uint8_t,
                    OPT_IM8 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_retq as libc::c_int as uint16_t,
                opcode: (if 0xc2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ret as libc::c_int as uint16_t,
                opcode: (if 0xc2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xc2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xc2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xc2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xc2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lret as libc::c_int as uint16_t,
                opcode: (if 0xca as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xca as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xca as libc::c_int & 0xff as libc::c_int
                } else {
                    0xca as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xca as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_IM16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_jo as libc::c_int as uint16_t,
                opcode: (if 0x70 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x70 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x70 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x70 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x50 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x70 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_loopne as libc::c_int as uint16_t,
                opcode: (if 0xe0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_loopnz as libc::c_int as uint16_t,
                opcode: (if 0xe0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_loope as libc::c_int as uint16_t,
                opcode: (if 0xe1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_loopz as libc::c_int as uint16_t,
                opcode: (if 0xe1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_loop as libc::c_int as uint16_t,
                opcode: (if 0xe2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xe2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xe2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xe2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xe2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_jecxz as libc::c_int as uint16_t,
                opcode: (if 0x67e3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x67e3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x67e3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x67e3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x67e3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_DISP8 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcomp as libc::c_int as uint16_t,
                opcode: (if 0xd8d9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd8d9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd8d9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd8d9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd8d9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fadd as libc::c_int as uint16_t,
                opcode: (if 0xd8c0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd8c0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd8c0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd8c0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd8c0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fadd as libc::c_int as uint16_t,
                opcode: (if 0xd8c0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd8c0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd8c0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd8c0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd8c0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fadd as libc::c_int as uint16_t,
                opcode: (if 0xdcc0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdcc0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdcc0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdcc0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdcc0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST0 as libc::c_int as uint8_t,
                    OPT_ST as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fmul as libc::c_int as uint16_t,
                opcode: (if 0xdcc8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdcc8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdcc8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdcc8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdcc8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST0 as libc::c_int as uint8_t,
                    OPT_ST as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fadd as libc::c_int as uint16_t,
                opcode: (if 0xdec1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdec1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdec1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdec1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdec1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_faddp as libc::c_int as uint16_t,
                opcode: (if 0xdec0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdec0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdec0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdec0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdec0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_faddp as libc::c_int as uint16_t,
                opcode: (if 0xdec0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdec0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdec0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdec0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdec0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_faddp as libc::c_int as uint16_t,
                opcode: (if 0xdec0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdec0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdec0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdec0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x4 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdec0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST0 as libc::c_int as uint8_t,
                    OPT_ST as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_faddp as libc::c_int as uint16_t,
                opcode: (if 0xdec1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdec1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdec1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdec1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdec1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fadds as libc::c_int as uint16_t,
                opcode: (if 0xd8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x8 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fiaddl as libc::c_int as uint16_t,
                opcode: (if 0xda as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xda as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xda as libc::c_int & 0xff as libc::c_int
                } else {
                    0xda as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x8 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xda as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_faddl as libc::c_int as uint16_t,
                opcode: (if 0xdc as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdc as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdc as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdc as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x8 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdc as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fiadds as libc::c_int as uint16_t,
                opcode: (if 0xde as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xde as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xde as libc::c_int & 0xff as libc::c_int
                } else {
                    0xde as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x40 as libc::c_int | 0x8 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xde as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fld as libc::c_int as uint16_t,
                opcode: (if 0xd9c0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9c0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9c0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9c0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9c0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fldl as libc::c_int as uint16_t,
                opcode: (if 0xd9c0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9c0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9c0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9c0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9c0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_flds as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fldl as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fildl as libc::c_int as uint16_t,
                opcode: (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fildq as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fildll as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fldt as libc::c_int as uint16_t,
                opcode: (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fbld as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fst as libc::c_int as uint16_t,
                opcode: (if 0xddd0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xddd0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xddd0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xddd0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xddd0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstl as libc::c_int as uint16_t,
                opcode: (if 0xddd0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xddd0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xddd0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xddd0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xddd0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fsts as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstps as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstl as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstpl as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fist as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fistp as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fistl as libc::c_int as uint16_t,
                opcode: (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fistpl as libc::c_int as uint16_t,
                opcode: (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstp as libc::c_int as uint16_t,
                opcode: (if 0xddd8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xddd8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xddd8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xddd8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xddd8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fistpq as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fistpll as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstpt as libc::c_int as uint16_t,
                opcode: (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fbstp as libc::c_int as uint16_t,
                opcode: (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fxch as libc::c_int as uint16_t,
                opcode: (if 0xd9c8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9c8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9c8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9c8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9c8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fucom as libc::c_int as uint16_t,
                opcode: (if 0xdde0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdde0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdde0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdde0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdde0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fucomp as libc::c_int as uint16_t,
                opcode: (if 0xdde8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdde8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdde8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdde8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdde8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_finit as libc::c_int as uint16_t,
                opcode: (if 0xdbe3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbe3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbe3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbe3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x10 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbe3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fldcw as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fnstcw as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstcw as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x10 as libc::c_int
                    | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fnstsw as libc::c_int as uint16_t,
                opcode: (if 0xdfe0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdfe0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdfe0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdfe0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdfe0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EAX as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fnstsw as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstsw as libc::c_int as uint16_t,
                opcode: (if 0xdfe0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdfe0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdfe0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdfe0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x10 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdfe0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EAX as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstsw as libc::c_int as uint16_t,
                opcode: (if 0xdfe0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdfe0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdfe0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdfe0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x10 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdfe0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstsw as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x10 as libc::c_int
                    | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fclex as libc::c_int as uint16_t,
                opcode: (if 0xdbe2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbe2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbe2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbe2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x10 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbe2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fnstenv as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fstenv as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x10 as libc::c_int
                    | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fldenv as libc::c_int as uint16_t,
                opcode: (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fnsave as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fsave as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x10 as libc::c_int
                    | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_frstor as libc::c_int as uint16_t,
                opcode: (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ffree as libc::c_int as uint16_t,
                opcode: (if 0xddc0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xddc0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xddc0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xddc0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xddc0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ffreep as libc::c_int as uint16_t,
                opcode: (if 0xdfc0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdfc0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdfc0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdfc0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdfc0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_ST as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fxsave as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fxrstor as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fxsaveq as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x200 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fxrstorq as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x200 as libc::c_int
                    | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_arpl as libc::c_int as uint16_t,
                opcode: (if 0x63 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x63 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x63 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x63 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x63 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG16 as libc::c_int as uint8_t,
                    (OPT_REG16 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_larw as libc::c_int as uint16_t,
                opcode: (if 0xf02 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf02 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf02 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf02 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf02 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lgdt as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lgdtq as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lidt as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lidtq as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lldt as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lmsw as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lslw as libc::c_int as uint16_t,
                opcode: (if 0xf03 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf03 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf03 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf03 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x1000 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf03 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG as libc::c_int) as uint8_t,
                    OPT_REG as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ltr as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG16 as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sgdt as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sgdtq as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sidt as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sidtq as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sldt as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_smsw as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_str as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG32 as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_str as libc::c_int as uint16_t,
                opcode: (if 0x660f00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x660f00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x660f00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x660f00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0x660f00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG16 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_str as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x200 as libc::c_int
                    | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG64 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_verr as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_verw as libc::c_int as uint16_t,
                opcode: (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf00 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf00 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf00 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf00 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_swapgs as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_bswap as libc::c_int as uint16_t,
                opcode: (if 0xfc8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG32 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_bswapl as libc::c_int as uint16_t,
                opcode: (if 0xfc8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG32 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_bswapq as libc::c_int as uint16_t,
                opcode: (if 0xfc8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | 0x200 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_REG64 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_xaddb as libc::c_int as uint16_t,
                opcode: (if 0xfc0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cmpxchgb as libc::c_int as uint16_t,
                opcode: (if 0xfb0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfb0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfb0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfb0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int
                    | (0x1 as libc::c_int | 0x1000 as libc::c_int)
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfb0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    (OPT_REG as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_invlpg as libc::c_int as uint16_t,
                opcode: (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf01 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf01 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf01 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf01 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cmpxchg8b as libc::c_int as uint16_t,
                opcode: (if 0xfc7 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc7 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc7 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc7 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc7 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cmpxchg16b as libc::c_int as uint16_t,
                opcode: (if 0xfc7 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc7 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc7 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc7 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x200 as libc::c_int
                    | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc7 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cmovo as libc::c_int as uint16_t,
                opcode: (if 0xf40 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf40 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf40 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf40 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x50 as libc::c_int
                    | 0x1000 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf40 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_REGW as libc::c_int | OPT_EA as libc::c_int) as uint8_t,
                    OPT_REGW as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovb as libc::c_int as uint16_t,
                opcode: (if 0xdac0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdac0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdac0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdac0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdac0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmove as libc::c_int as uint16_t,
                opcode: (if 0xdac8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdac8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdac8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdac8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdac8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovbe as libc::c_int as uint16_t,
                opcode: (if 0xdad0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdad0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdad0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdad0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdad0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovu as libc::c_int as uint16_t,
                opcode: (if 0xdad8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdad8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdad8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdad8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdad8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovnb as libc::c_int as uint16_t,
                opcode: (if 0xdbc0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbc0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbc0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbc0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbc0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovne as libc::c_int as uint16_t,
                opcode: (if 0xdbc8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbc8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbc8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbc8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbc8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovnbe as libc::c_int as uint16_t,
                opcode: (if 0xdbd0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbd0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbd0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbd0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbd0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcmovnu as libc::c_int as uint16_t,
                opcode: (if 0xdbd8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbd8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbd8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbd8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbd8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fucomi as libc::c_int as uint16_t,
                opcode: (if 0xdbe8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbe8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbe8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbe8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbe8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcomi as libc::c_int as uint16_t,
                opcode: (if 0xdbf0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdbf0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdbf0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdbf0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdbf0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fucomip as libc::c_int as uint16_t,
                opcode: (if 0xdfe8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdfe8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdfe8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdfe8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdfe8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_fcomip as libc::c_int as uint16_t,
                opcode: (if 0xdff0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xdff0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xdff0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xdff0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x4 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xdff0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_ST as libc::c_int as uint8_t,
                    OPT_ST0 as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movd as libc::c_int as uint16_t,
                opcode: (if 0xf6e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movd as libc::c_int as uint16_t,
                opcode: (if 0xf6e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG64 as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0xf6e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x200 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG64 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0xf6f as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6f as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6f as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6f as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6f as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMX as libc::c_int) as uint8_t,
                    OPT_MMX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movd as libc::c_int as uint16_t,
                opcode: (if 0xf7e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf7e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf7e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf7e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf7e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movd as libc::c_int as uint16_t,
                opcode: (if 0xf7e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf7e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf7e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf7e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf7e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG64 as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0xf7f as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf7f as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf7f as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf7f as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf7f as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_MMX as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_MMX as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0x660fd6 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0x660fd6 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0x660fd6 as libc::c_int & 0xff as libc::c_int
                } else {
                    0x660fd6 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0x660fd6 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_SSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0xf30f7e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf30f7e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf30f7e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf30f7e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf30f7e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movq as libc::c_int as uint16_t,
                opcode: (if 0xf7e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf7e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf7e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf7e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf7e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG64 as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_packssdw as libc::c_int as uint16_t,
                opcode: (if 0xf6b as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6b as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6b as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6b as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6b as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_packsswb as libc::c_int as uint16_t,
                opcode: (if 0xf63 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf63 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf63 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf63 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf63 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_packuswb as libc::c_int as uint16_t,
                opcode: (if 0xf67 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf67 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf67 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf67 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf67 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddb as libc::c_int as uint16_t,
                opcode: (if 0xffc as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xffc as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xffc as libc::c_int & 0xff as libc::c_int
                } else {
                    0xffc as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xffc as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddw as libc::c_int as uint16_t,
                opcode: (if 0xffd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xffd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xffd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xffd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xffd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddd as libc::c_int as uint16_t,
                opcode: (if 0xffe as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xffe as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xffe as libc::c_int & 0xff as libc::c_int
                } else {
                    0xffe as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xffe as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddsb as libc::c_int as uint16_t,
                opcode: (if 0xfec as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfec as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfec as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfec as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfec as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddsw as libc::c_int as uint16_t,
                opcode: (if 0xfed as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfed as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfed as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfed as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfed as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddusb as libc::c_int as uint16_t,
                opcode: (if 0xfdc as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfdc as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfdc as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfdc as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfdc as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_paddusw as libc::c_int as uint16_t,
                opcode: (if 0xfdd as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfdd as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfdd as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfdd as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfdd as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pand as libc::c_int as uint16_t,
                opcode: (if 0xfdb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfdb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfdb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfdb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfdb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pandn as libc::c_int as uint16_t,
                opcode: (if 0xfdf as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfdf as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfdf as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfdf as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfdf as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pcmpeqb as libc::c_int as uint16_t,
                opcode: (if 0xf74 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf74 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf74 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf74 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf74 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pcmpeqw as libc::c_int as uint16_t,
                opcode: (if 0xf75 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf75 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf75 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf75 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf75 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pcmpeqd as libc::c_int as uint16_t,
                opcode: (if 0xf76 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf76 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf76 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf76 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf76 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pcmpgtb as libc::c_int as uint16_t,
                opcode: (if 0xf64 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf64 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf64 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf64 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf64 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pcmpgtw as libc::c_int as uint16_t,
                opcode: (if 0xf65 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf65 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf65 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf65 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf65 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pcmpgtd as libc::c_int as uint16_t,
                opcode: (if 0xf66 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf66 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf66 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf66 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf66 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pmaddwd as libc::c_int as uint16_t,
                opcode: (if 0xff5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pmulhw as libc::c_int as uint16_t,
                opcode: (if 0xfe5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pmullw as libc::c_int as uint16_t,
                opcode: (if 0xfd5 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfd5 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfd5 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfd5 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfd5 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_por as libc::c_int as uint16_t,
                opcode: (if 0xfeb as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfeb as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfeb as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfeb as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfeb as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psllw as libc::c_int as uint16_t,
                opcode: (if 0xff1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psllw as libc::c_int as uint16_t,
                opcode: (if 0xf71 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf71 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf71 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf71 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf71 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pslld as libc::c_int as uint16_t,
                opcode: (if 0xff2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pslld as libc::c_int as uint16_t,
                opcode: (if 0xf72 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf72 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf72 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf72 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf72 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psllq as libc::c_int as uint16_t,
                opcode: (if 0xff3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psllq as libc::c_int as uint16_t,
                opcode: (if 0xf73 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf73 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf73 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf73 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf73 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psraw as libc::c_int as uint16_t,
                opcode: (if 0xfe1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psraw as libc::c_int as uint16_t,
                opcode: (if 0xf71 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf71 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf71 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf71 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf71 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrad as libc::c_int as uint16_t,
                opcode: (if 0xfe2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrad as libc::c_int as uint16_t,
                opcode: (if 0xf72 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf72 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf72 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf72 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (4 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf72 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrlw as libc::c_int as uint16_t,
                opcode: (if 0xfd1 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfd1 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfd1 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfd1 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfd1 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrlw as libc::c_int as uint16_t,
                opcode: (if 0xf71 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf71 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf71 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf71 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf71 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrld as libc::c_int as uint16_t,
                opcode: (if 0xfd2 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfd2 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfd2 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfd2 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfd2 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrld as libc::c_int as uint16_t,
                opcode: (if 0xf72 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf72 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf72 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf72 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf72 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrlq as libc::c_int as uint16_t,
                opcode: (if 0xfd3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfd3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfd3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfd3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfd3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psrlq as libc::c_int as uint16_t,
                opcode: (if 0xf73 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf73 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf73 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf73 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf73 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_IM8 as libc::c_int as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubb as libc::c_int as uint16_t,
                opcode: (if 0xff8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubw as libc::c_int as uint16_t,
                opcode: (if 0xff9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xff9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xff9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xff9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xff9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubd as libc::c_int as uint16_t,
                opcode: (if 0xffa as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xffa as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xffa as libc::c_int & 0xff as libc::c_int
                } else {
                    0xffa as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xffa as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubsb as libc::c_int as uint16_t,
                opcode: (if 0xfe8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubsw as libc::c_int as uint16_t,
                opcode: (if 0xfe9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubusb as libc::c_int as uint16_t,
                opcode: (if 0xfd8 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfd8 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfd8 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfd8 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfd8 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_psubusw as libc::c_int as uint16_t,
                opcode: (if 0xfd9 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfd9 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfd9 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfd9 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfd9 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_punpckhbw as libc::c_int as uint16_t,
                opcode: (if 0xf68 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf68 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf68 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf68 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf68 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_punpckhwd as libc::c_int as uint16_t,
                opcode: (if 0xf69 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf69 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf69 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf69 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf69 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_punpckhdq as libc::c_int as uint16_t,
                opcode: (if 0xf6a as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf6a as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf6a as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf6a as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf6a as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_punpcklbw as libc::c_int as uint16_t,
                opcode: (if 0xf60 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf60 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf60 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf60 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf60 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_punpcklwd as libc::c_int as uint16_t,
                opcode: (if 0xf61 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf61 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf61 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf61 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf61 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_punpckldq as libc::c_int as uint16_t,
                opcode: (if 0xf62 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf62 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf62 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf62 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf62 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pxor as libc::c_int as uint16_t,
                opcode: (if 0xfef as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfef as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfef as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfef as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfef as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_ldmxcsr as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_stmxcsr as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movups as libc::c_int as uint16_t,
                opcode: (if 0xf10 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf10 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf10 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf10 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf10 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movups as libc::c_int as uint16_t,
                opcode: (if 0xf11 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf11 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf11 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf11 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf11 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_SSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movaps as libc::c_int as uint16_t,
                opcode: (if 0xf28 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf28 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf28 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf28 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf28 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movaps as libc::c_int as uint16_t,
                opcode: (if 0xf29 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf29 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf29 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf29 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf29 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_SSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movhps as libc::c_int as uint16_t,
                opcode: (if 0xf16 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf16 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf16 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf16 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf16 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movhps as libc::c_int as uint16_t,
                opcode: (if 0xf17 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf17 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf17 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf17 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf17 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_SSE as libc::c_int as uint8_t,
                    (OPT_EA as libc::c_int | OPT_REG32 as libc::c_int) as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_addps as libc::c_int as uint16_t,
                opcode: (if 0xf58 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf58 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf58 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf58 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf58 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cvtpi2ps as libc::c_int as uint16_t,
                opcode: (if 0xf2a as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf2a as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf2a as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf2a as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf2a as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMX as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cvtps2pi as libc::c_int as uint16_t,
                opcode: (if 0xf2d as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf2d as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf2d as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf2d as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf2d as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_MMX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_cvttps2pi as libc::c_int as uint16_t,
                opcode: (if 0xf2c as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf2c as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf2c as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf2c as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf2c as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_MMX as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_divps as libc::c_int as uint16_t,
                opcode: (if 0xf5e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf5e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf5e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf5e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf5e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_maxps as libc::c_int as uint16_t,
                opcode: (if 0xf5f as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf5f as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf5f as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf5f as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf5f as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_minps as libc::c_int as uint16_t,
                opcode: (if 0xf5d as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf5d as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf5d as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf5d as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf5d as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_mulps as libc::c_int as uint16_t,
                opcode: (if 0xf59 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf59 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf59 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf59 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf59 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pavgb as libc::c_int as uint16_t,
                opcode: (if 0xfe0 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe0 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe0 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe0 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe0 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pavgw as libc::c_int as uint16_t,
                opcode: (if 0xfe3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfe3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfe3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfe3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfe3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pmaxsw as libc::c_int as uint16_t,
                opcode: (if 0xfee as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfee as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfee as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfee as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfee as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pmaxub as libc::c_int as uint16_t,
                opcode: (if 0xfde as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfde as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfde as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfde as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfde as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pminsw as libc::c_int as uint16_t,
                opcode: (if 0xfea as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfea as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfea as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfea as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfea as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_pminub as libc::c_int as uint16_t,
                opcode: (if 0xfda as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfda as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfda as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfda as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfda as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_MMXSSE as libc::c_int) as uint8_t,
                    OPT_MMXSSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_rcpss as libc::c_int as uint16_t,
                opcode: (if 0xf53 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf53 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf53 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf53 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf53 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_rsqrtps as libc::c_int as uint16_t,
                opcode: (if 0xf52 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf52 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf52 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf52 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf52 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sqrtps as libc::c_int as uint16_t,
                opcode: (if 0xf51 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf51 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf51 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf51 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf51 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_subps as libc::c_int as uint16_t,
                opcode: (if 0xf5c as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf5c as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf5c as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf5c as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf5c as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    (OPT_EA as libc::c_int | OPT_SSE as libc::c_int) as uint8_t,
                    OPT_SSE as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movnti as libc::c_int as uint16_t,
                opcode: (if 0xfc3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG as libc::c_int as uint8_t,
                    OPT_EA as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movntil as libc::c_int as uint16_t,
                opcode: (if 0xfc3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG32 as libc::c_int as uint8_t,
                    OPT_EA as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_movntiq as libc::c_int as uint16_t,
                opcode: (if 0xfc3 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfc3 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfc3 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfc3 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | 0x200 as libc::c_int
                    | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfc3 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 2 as libc::c_int as uint8_t,
                op_type: [
                    OPT_REG64 as libc::c_int as uint8_t,
                    OPT_EA as libc::c_int as uint8_t,
                    0,
                ],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_prefetchnta as libc::c_int as uint16_t,
                opcode: (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf18 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf18 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf18 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (0 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_prefetcht0 as libc::c_int as uint16_t,
                opcode: (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf18 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf18 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf18 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_prefetcht1 as libc::c_int as uint16_t,
                opcode: (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf18 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf18 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf18 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (2 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_prefetcht2 as libc::c_int as uint16_t,
                opcode: (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf18 as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf18 as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf18 as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (3 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf18 as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_prefetchw as libc::c_int as uint16_t,
                opcode: (if 0xf0d as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf0d as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf0d as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf0d as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (1 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf0d as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_lfence as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (5 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_mfence as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (6 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_sfence as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_clflush as libc::c_int as uint16_t,
                opcode: (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xfae as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xfae as libc::c_int & 0xff as libc::c_int
                } else {
                    0xfae as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xfae as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 1 as libc::c_int as uint8_t,
                op_type: [OPT_EA as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: TOK_ASM_endbr64 as libc::c_int as uint16_t,
                opcode: (if 0xf30f1e as libc::c_int & 0xff00 as libc::c_int
                    == 0xf00 as libc::c_int
                {
                    0xf30f1e as libc::c_int >> 8 as libc::c_int & !(0xff as libc::c_int)
                        | 0xf30f1e as libc::c_int & 0xff as libc::c_int
                } else {
                    0xf30f1e as libc::c_int
                }) as uint64_t as uint16_t,
                instr_type: (0x8 as libc::c_int | (7 as libc::c_int) << 13 as libc::c_int
                    | (if 0xf30f1e as libc::c_int & 0xff00 as libc::c_int
                        == 0xf00 as libc::c_int
                    {
                        0x100 as libc::c_int
                    } else {
                        0 as libc::c_int
                    })) as uint16_t,
                nb_ops: 0 as libc::c_int as uint8_t,
                op_type: [0 as libc::c_int as uint8_t, 0, 0],
            };
            init
        },
        {
            let mut init = ASMInstr {
                sym: 0 as libc::c_int as uint16_t,
                opcode: 0,
                instr_type: 0,
                nb_ops: 0,
                op_type: [0; 3],
            };
            init
        },
    ];
    options_W = [
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).warn_all as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0x1 as libc::c_int as uint16_t,
                name: b"all\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).warn_error as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"error\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).warn_write_strings
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"write-strings\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).warn_unsupported
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"unsupported\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).warn_implicit_function_declaration
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0x1 as libc::c_int as uint16_t,
                name: b"implicit-function-declaration\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).warn_discarded_qualifiers
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0x1 as libc::c_int as uint16_t,
                name: b"discarded-qualifiers\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: 0 as libc::c_int as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: 0 as *const libc::c_char,
            };
            init
        },
    ];
    options_f = [
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).char_is_unsigned
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"unsigned-char\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).char_is_unsigned
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0x2 as libc::c_int as uint16_t,
                name: b"signed-char\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).nocommon as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0x2 as libc::c_int as uint16_t,
                name: b"common\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).leading_underscore
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"leading-underscore\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).ms_extensions as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"ms-extensions\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).dollars_in_identifiers
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"dollars-in-identifiers\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).test_coverage as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"test-coverage\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).reverse_funcargs
                    as *mut libc::c_uchar as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"reverse-funcargs\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).gnu89_inline as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"gnu89-inline\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).unwind_tables as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"asynchronous-unwind-tables\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: 0 as libc::c_int as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: 0 as *const libc::c_char,
            };
            init
        },
    ];
    options_m = [
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).ms_bitfields as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: b"ms-bitfields\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: &mut (*(0 as *mut TCCState)).nosse as *mut libc::c_uchar
                    as size_t as uint16_t,
                flags: 0x2 as libc::c_int as uint16_t,
                name: b"sse\0" as *const u8 as *const libc::c_char,
            };
            init
        },
        {
            let mut init = FlagDef {
                offset: 0 as libc::c_int as uint16_t,
                flags: 0 as libc::c_int as uint16_t,
                name: 0 as *const libc::c_char,
            };
            init
        },
    ];
}
#[used]
#[cfg_attr(target_os = "linux", link_section = ".init_array")]
#[cfg_attr(target_os = "windows", link_section = ".CRT$XIB")]
#[cfg_attr(target_os = "macos", link_section = "__DATA,__mod_init_func")]
static INIT_ARRAY: [unsafe extern "C" fn(); 1] = [run_static_initializers];
